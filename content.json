[{"title":"Java浮点数装箱不相等问题","date":"2021-10-26T01:33:00.000Z","path":"2021/10/26/Java浮点数装箱不相等问题/","text":"1234567891011System.out.println(0.0 == -0.0); // trueSystem.out.println(Double.compare(0.0, -0.0)); // 1System.out.println(new Double(0.0).equals(new Double(-0.0))); // falseMap&lt;Double, Integer&gt; map = new HashMap&lt;&gt;();map.put(0.0, 1);map.put(-0.0, 2);System.out.println(map.size()); // 2System.out.println((double)(2-2)/(1-2)); // -0.0System.out.println((double)(3-3)/(2-1)); // 0.0 在集合中遇见0.0和-0.0时，由于自动装箱，导致两个在绝对数值上相等的数据，放入集合时表现出不相等。 解决办法： 对获得的double类型数据加上一个0.0 1234Map&lt;Double, Integer&gt; map = new HashMap&lt;&gt;();map.put(0.0, 1);map.put(-0.0+0.0, 2);System.out.println(map.size()); // 1 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Java","slug":"Java","permalink":"http://blog.iwxyi.com/tags/Java/"}]},{"title":"Flutter切换页面保留状态","date":"2021-10-14T09:40:00.000Z","path":"2021/10/14/Flutter切换页面保留状态/","text":"State 混入 AutomaticKeepAliveClientMixin，同时 wantKeepAlive 返回 true。 这样使用 TabView 或者 PageView 切换页面时，ListView 等 Stateful 控件的状态（如滚动位置）都会保留下来。 123456789101112131415161718192021class _PageListView extends State&lt;PageListView&gt; with AutomaticKeepAliveClientMixin { @override Widget build(BuildContext context) { super.build(context); return ListView.builder( padding: EdgeInsets.only(bottom: 10), itemCount: 100, itemExtent: 40, shrinkWrap: true, itemBuilder: (BuildContext context, int index) { return Container( color: Colors.black12, child: Text(' 这是第 $index 行'), ); }); } @override // TODO: implement wantKeepAlive bool get wantKeepAlive =&gt; true; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://blog.iwxyi.com/tags/Flutter/"}]},{"title":"Flutter在ListView创建时滚动到底部","date":"2021-10-13T09:39:00.000Z","path":"2021/10/13/Flutter在ListView创建时滚动到底部/","text":"12345678910111213141516171819202122Widget build(BuildContext context) { final items = List&lt;String&gt;.generate(50, (i) =&gt; \"Item $i\"); ScrollController _controller = ScrollController(); SchedulerBinding.instance.addPostFrameCallback((_) { _controller.jumpTo(_controller.position.maxScrollExtent); }); return Scaffold( body: SafeArea( child: ListView.builder( controller: _controller, itemCount: items.length, itemBuilder: (context, index) { return ListTile( title: Text('${items[index]}'), ); }, ), ));} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://blog.iwxyi.com/tags/Flutter/"}]},{"title":"约瑟夫环问题：一行代码递归","date":"2021-09-14T01:53:00.000Z","path":"2021/09/14/约瑟夫环问题：一行代码递归/","text":"问题描述：编号为 1-N 的 N 个士兵围坐在一起形成一个圆圈，从编号为 1 的士兵开始依次报数（1，2，3…这样依次报），数到 m 的 士兵会被杀死出列，之后的士兵再从 1 开始报数。直到最后剩下一士兵，求这个士兵的编号。 解决方法：最暴力的就是用环形链表，被选中就移除，时间复杂度为 O(n * m)，空间复杂度是 O(n)。 递归是思路是每次我们删除了某一个士兵之后，我们就对这些士兵重新编号，然后我们的难点就是找出删除前和删除后士兵编号的映射关系。 我们定义递归函数 f(n，m) 的返回结果是存活士兵的编号，显然当 n = 1 时，f(n, m) = 1。假如我们能够找出 f(n，m) 和 f(n-1，m) 之间的关系的话，我们就可以用递归的方式来解决了。我们假设人员数为 n, 报数到 m 的人就自杀。则刚开始的编号为 1234567891011…1...m - 2m - 1mm + 1m + 2...n… 进行了一次删除之后，删除了编号为 m 的节点。删除之后，就只剩下 n - 1 个节点了，删除前和删除之后的编号转换关系为： 12345678删除前 --- 删除后… --- …m - 2 --- n - 2m - 1 --- n - 1m --- 无(因为编号被删除了)m + 1 --- 1(因为下次就从这里报数了)m + 2 --- 2… --- … 新的环中只有 n - 1 个节点。且删除前编号为 m + 1, m + 2, m + 3 的节点成了删除后编号为 1， 2， 3 的节点。 假设 old 为删除之前的节点编号， new 为删除了一个节点之后的编号，则 old 与 new 之间的关系为： 1old = (new + m - 1) % n + 1 注：有些人可能会疑惑为什么不是 old = (new + m ) % n 呢？主要是因为编号是从 1 开始的，而不是从 0 开始的。如果 new + m == n的话，会导致最后的计算结果为 old = 0。所以 old = (new + m - 1) % n + 1.这样，我们就得出 f(n, m) 与 f(n - 1, m)之间的关系了，而 f(1, m) = 1.所以我们可以采用递归的方式来做。代码如下： 1234int f(int n, int m){ return n == 1 ? n : (f(n - 1, m) + m - 1) % n + 1;} 参考：https://www.iamshuaidi.com/145.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"算法","slug":"算法","permalink":"http://blog.iwxyi.com/tags/算法/"}]},{"title":"链表翻转之K个一组：双递归","date":"2021-09-13T01:52:00.000Z","path":"2021/09/13/链表翻转之K个一组：双递归/","text":"例如：链表:1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8-&gt;null, K = 3。调整后：3-&gt;2-&gt;1-&gt;6-&gt;5-&gt;4-&gt;7-&gt;8-&gt;null。 其中 7，8不调整，因为不够一组。 LeetCode25，这里用的是分别递归的思想： 12345678910111213141516171819202122232425262728293031323334// k个为一组逆序public ListNode reverseKGroup(ListNode head, int k) { ListNode tail = head; // 遍历K-1次，直到当前组的tail(newHead) for (int i = 1; i &lt; k &amp;&amp; tail != null; i++) { tail = tail.next; } if(tail == null) // 判断节点的数量是否能够凑成一组 return head; ListNode t2 = tail.next; tail.next = null; // 把当前的组进行逆序 ListNode newHead = reverseList(head); // 把之后的节点进行分组逆序，返回新的Head ListNode nextNewHead = reverseKGroup(t2, k); // 把两部分连接起来 ListNode newTail = head; newTail.next = nextNewHead; return newHead;}// 逆序单链表// 返回新的头节点private static ListNode reverseList(ListNode head) { if(head == null || head.next == null) return head; ListNode result = reverseList(head.next); head.next.next = head; head.next = null; return result;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"算法","slug":"算法","permalink":"http://blog.iwxyi.com/tags/算法/"}]},{"title":"C++使用std::conditional定义类型","date":"2021-09-10T01:42:00.000Z","path":"2021/09/10/使用std-conditional定义类型/","text":"有时候需要根据条件进行类型定义，比如下面这种情况： 123456789101112131415161718struct test_struct{ char c; int i;};struct test_struct_2{ char c; double d;};if (flag) typedef bb::test_struct AAA;else typedef bb::test_struct_2 AAA;AAA a; 编译会报错 error: ‘AAA’ was not declared in this scope。 这个时候就可以用std::conditional来做， 有两种方式： 123456#include &lt;type_traits&gt;using AAA = typename std::conditional&lt; flag == true, bb::test_struct, bb::test_struct_2 &gt;::type; or 1234typedef std::conditional&lt; flag, bb::test_struct, bb::test_struct_2 &gt;::type AAA; 获取变量的类型用tpyeid, 123#include &lt;typeinfo&gt;std::cout &lt;&lt; typeid(a).name() &lt;&lt; std::endl; 参考：https://blog.csdn.net/photon222/article/details/99327989 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"}]},{"title":"Java并发：volatile关键字解析","date":"2021-09-10T01:33:00.000Z","path":"2021/09/10/Java并发：volatile关键字解析/","text":"volatile这个关键字可能很多朋友都听说过，或许也都用过。在Java 5之前，它是一个备受争议的关键字，因为在程序中使用它往往会导致出人意料的结果。在Java 5之后，volatile关键字才得以重获生机。 volatile关键字虽然从字面上理解起来比较简单，但是要用好不是一件容易的事情。由于volatile关键字是与Java的内存模型有关的，因此在讲述volatile关键之前，我们先来了解一下与内存模型相关的概念和知识，然后分析了volatile关键字的实现原理，最后给出了几个使用volatile关键字的场景。 一.内存模型的相关概念 大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。 也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码： 1i = i + 1; 当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。 这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。 比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？ 可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。 最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。 也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。 为了解决缓存不一致性问题，通常来说有以下2种解决方法： 1）通过在总线加LOCK#锁的方式 2）通过缓存一致性协议 这2种方式都是硬件层面上提供的方式。 在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。 但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。 所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。 img 二.并发编程中的三个概念 在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。我们先看具体看一下这三个概念： 1.原子性 原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。 一个很经典的例子就是银行账户转账问题： 比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。 试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。 所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。 同样地反映到并发编程中会出现什么结果呢？ 举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？ 1i = 9; 假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。 那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。 2.可见性 可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 举个简单的例子，看下面这段代码： 123456//线程1执行的代码int i = 0;i = 10; //线程2执行的代码j = i; 假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。 此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10. 这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。 3.有序性 有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码： 1234int i = 0; boolean flag = false;i = 1; //语句1 flag = true; //语句2 上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。 下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。 比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。 但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子： 1234int a = 10; //语句1int r = 2; //语句2a = a + 3; //语句3r = a*a; //语句4 这段代码有4个语句，那么可能的一个执行顺序是： 那么可不可能是这个执行顺序呢： 语句2 语句1 语句4 语句3 不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。 虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子： 123456789//线程1:context = loadContext(); //语句1inited = true; //语句2 //线程2:while(!inited ){ sleep()}doSomethingwithconfig(context); 上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。 从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。 也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。 三.Java内存模型 在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。 在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。 Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。 举个简单的例子：在java中，执行下面这个语句： 1i = 10; 执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。 那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？ 1.原子性 在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。 上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i： 请分析以下哪些操作是原子性操作： 1234x = 10; //语句1y = x; //语句2x++; //语句3x = x + 1; //语句4 咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。 语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。 语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。 同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。 所以上面4个语句只有语句1的操作具备原子性。 也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。 不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。 从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。 2.可见性 对于可见性，Java提供了volatile关键字来保证可见性。 当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。 而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。 另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。 3.有序性 在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。 在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。 另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。 下面就来具体介绍下happens-before原则（先行发生原则）： 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作 锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作 volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始 这8条原则摘自《深入理解Java虚拟机》。 这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。 下面我们来解释一下前4条规则： 对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。 第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。 第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。 第四条规则实际上就是体现happens-before原则具备传递性。 四.深入剖析volatile关键字 在前面讲述了很多东西，其实都是为讲述volatile关键字作铺垫，那么接下来我们就进入主题。 1.volatile关键字的两层语义 一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义： 1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 2）禁止进行指令重排序。 先看一段代码，假如线程1先执行，线程2后执行： 12345678//线程1boolean stop = false;while(!stop){ doSomething();} //线程2stop = true; 这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。 下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。 那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。 但是用volatile修饰之后就变得不一样了： 第一：使用volatile关键字会强制将修改的值立即写入主存； 第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）； 第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。 那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。 那么线程1读取到的就是最新的正确的值。 2.volatile保证原子性吗？ 从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？ 下面看一个例子： 1234567891011121314151617181920212223public class Test { public volatile int inc = 0; public void increase() { inc++; } public static void main(String[] args) { final Test test = new Test(); for(int i=0;i&lt;10;i++){ new Thread(){ public void run() { for(int j=0;j&lt;1000;j++) test.increase(); }; }.start(); } while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); }} 大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。 可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。 这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。 在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现： 假如某个时刻变量inc的值为10， 线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了； 然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。 然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。 那么两个线程分别进行了一次自增操作后，inc只增加了1。 解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。 根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。 把上面的代码改成以下任何一种都可以达到效果： 采用synchronized： 1234567891011121314151617181920212223public class Test { public int inc = 0; public synchronized void increase() { inc++; } public static void main(String[] args) { final Test test = new Test(); for(int i=0;i&lt;10;i++){ new Thread(){ public void run() { for(int j=0;j&lt;1000;j++) test.increase(); }; }.start(); } while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); }} 采用Lock： 1234567891011121314151617181920212223242526272829public class Test { public int inc = 0; Lock lock = new ReentrantLock(); public void increase() { lock.lock(); try { inc++; } finally{ lock.unlock(); } } public static void main(String[] args) { final Test test = new Test(); for(int i=0;i&lt;10;i++){ new Thread(){ public void run() { for(int j=0;j&lt;1000;j++) test.increase(); }; }.start(); } while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); }} 采用AtomicInteger： 1234567891011121314151617181920212223public class Test { public AtomicInteger inc = new AtomicInteger(); public void increase() { inc.getAndIncrement(); } public static void main(String[] args) { final Test test = new Test(); for(int i=0;i&lt;10;i++){ new Thread(){ public void run() { for(int j=0;j&lt;1000;j++) test.increase(); }; }.start(); } while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); }} 在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。 3.volatile能保证有序性吗？ 在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。 volatile关键字禁止指令重排序有两层意思： 1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行； 2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。 可能上面说的比较绕，举个简单的例子： 12345678//x、y为非volatile变量//flag为volatile变量 x = 2; //语句1y = 0; //语句2flag = true; //语句3x = 4; //语句4y = -1; //语句5 由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。 并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。 那么我们回到前面举的一个例子： 123456789//线程1:context = loadContext(); //语句1inited = true; //语句2 //线程2:while(!inited ){ sleep()}doSomethingwithconfig(context); 前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。 这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。 4.volatile的原理和实现机制 前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。 下面这段话摘自《深入理解Java虚拟机》： “观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令” lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能： 1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成； 2）它会强制将对缓存的修改操作立即写入主存； 3）如果是写操作，它会导致其他CPU中对应的缓存行无效。 五.使用volatile关键字的场景 synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件： 1）对变量的写操作不依赖于当前值 2）该变量没有包含在具有其他变量的不变式中 实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。 事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。 下面列举几个Java中使用volatile的几个场景。 1.状态标记量 123456789volatile boolean flag = false; while(!flag){ doSomething();} public void setFlag() { flag = true;} 12345678910volatile boolean inited = false;//线程1:context = loadContext(); inited = true; //线程2:while(!inited ){sleep()}doSomethingwithconfig(context); 2.double check 1234567891011121314151617class Singleton{ private volatile static Singleton instance = null; private Singleton() { } public static Singleton getInstance() { if(instance==null) { synchronized (Singleton.class) { if(instance==null) instance = new Singleton(); } } return instance; }} 至于为何需要这么写请参考： 《Java 中的双重检查（Double-Check）》http://blog.csdn.net/dl88250/article/details/5439024 和http://www.iteye.com/topic/652440 参考资料： 《Java编程思想》 《深入理解Java虚拟机》 http://jiangzhengjun.iteye.com/blog/652532 http://blog.sina.com.cn/s/blog_7bee8dd50101fu8n.html http://ifeve.com/volatile/ http://blog.csdn.net/ccit0519/article/details/11241403 http://blog.csdn.net/ns_code/article/details/17101369 http://www.cnblogs.com/kevinwu/archive/2012/05/02/2479464.html http://www.cppblog.com/elva/archive/2011/01/21/139019.html http://ifeve.com/volatile-array-visiblity/ http://www.bdqn.cn/news/201312/12579.shtml http://exploer.blog.51cto.com/7123589/1193399 http://www.cnblogs.com/Mainz/p/3556430.html 作者：Matrix海子 出处：https://www.cnblogs.com/dolphin0520/p/3920373.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"多线程","slug":"多线程","permalink":"http://blog.iwxyi.com/tags/多线程/"},{"name":"Java","slug":"Java","permalink":"http://blog.iwxyi.com/tags/Java/"}]},{"title":"十大排序算法","date":"2021-09-07T01:49:00.000Z","path":"2021/09/07/十大排序算法/","text":"0、算法概述0.1 算法分类** **十种常见排序算法可以分为两大类： 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 0.2 算法复杂度 img 0.3 相关概念 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。 不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。 时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。 空间复杂度：是指算法在计算机 内执行时所需存储空间的度量，它也是数据规模n的函数。 1、冒泡排序（Bubble Sort）冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 1.1 算法描述 比较相邻的元素。如果第一个比第二个大，就交换它们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 重复步骤1~3，直到排序完成。 1.2 动图演示 img 1.3 代码实现12345678910111213function bubbleSort(arr) { var len = arr.length; for(var i = 0; i &lt; len - 1; i++) { for(var j = 0; j &lt; len - 1 - i; j++) { if(arr[j] &gt; arr[j+1]) { // 相邻元素两两对比 var temp = arr[j+1]; // 元素交换 arr[j+1] = arr[j]; arr[j] = temp; } } } return arr;} 2、选择排序（Selection Sort）选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 2.1 算法描述n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下： 初始状态：无序区为R[1..n]，有序区为空； 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区； n-1趟结束，数组有序化了。 2.2 动图演示 img 2.3 代码实现12345678910111213141516function selectionSort(arr) { var len = arr.length; var minIndex, temp; for(var i = 0; i &lt; len - 1; i++) { minIndex = i; for(var j = i + 1; j &lt; len; j++) { if(arr[j] &lt; arr[minIndex]) { // 寻找最小的数 minIndex = j; // 将最小数的索引保存 } } temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; } return arr;} 2.4 算法分析表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。 3、插入排序（Insertion Sort）插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 3.1 算法描述一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。 3.2 动图演示 img 3.2 代码实现1234567891011121314function insertionSort(arr) { var len = arr.length; var preIndex, current; for(var i = 1; i &lt; len; i++) { preIndex = i - 1; current = arr[i]; while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) { arr[preIndex + 1] = arr[preIndex]; preIndex--; } arr[preIndex + 1] = current; } return arr;} 3.4 算法分析插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 4、希尔排序（Shell Sort）1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。 4.1 算法描述先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述： 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； 按增量序列个数k，对序列进行k 趟排序； 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 4.2 动图演示 img 4.3 代码实现12345678910111213141516function shellSort(arr) { var len = arr.length; for(var gap = Math.floor(len / 2); gap &gt; 0; gap = Math.floor(gap / 2)) { // 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行 for(var i = gap; i &lt; len; i++) { var j = i; var current = arr[i]; while(j - gap &gt;= 0 &amp;&amp; current &lt; arr[j - gap]) { arr[j] = arr[j - gap]; j = j - gap; } arr[j] = current; } } return arr;} 4.4 算法分析希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。 5、归并排序（Merge Sort）归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 5.1 算法描述 把长度为n的输入序列分成两个长度为n/2的子序列； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列。 5.2 动图演示 img 5.3 代码实现123456789101112131415161718192021222324252627282930function mergeSort(arr) { var len = arr.length; if(len &lt; 2) { return arr; } var middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right));} function merge(left, right) { var result = []; while(left.length&gt;0 &amp;&amp; right.length&gt;0) { if(left[0] &lt;= right[0]) { result.push(left.shift()); }else{ result.push(right.shift()); } } while(left.length) result.push(left.shift()); while(right.length) result.push(right.shift()); return result;} 5.4 算法分析归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。 6、快速排序（Quick Sort）快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 6.1 算法描述快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下： 从数列中挑出一个元素，称为 “基准”（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 6.2 动图演示 img 6.3 代码实现1234567891011121314151617181920212223242526272829303132function quickSort(arr, left, right) { var len = arr.length, partitionIndex, left = typeofleft !='number'? 0 : left, right = typeofright !='number'? len - 1 : right; if(left &lt; right) { partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex-1); quickSort(arr, partitionIndex+1, right); } return arr;} function partition(arr, left ,right) { // 分区操作 var pivot = left, // 设定基准值（pivot） index = pivot + 1; for(var i = index; i &lt;= right; i++) { if(arr[i] &lt; arr[pivot]) { swap(arr, i, index); index++; } } swap(arr, pivot, index - 1); return index-1;} function swap(arr, i, j) { var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;} 7、堆排序（Heap Sort）堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 7.1 算法描述 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区； 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]； 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。 7.2 动图演示 img 7.3 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344var len; // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量 function buildMaxHeap(arr) { // 建立大顶堆 len = arr.length; for(var i = Math.floor(len/2); i &gt;= 0; i--) { heapify(arr, i); }} function heapify(arr, i) { // 堆调整 var left = 2 * i + 1, right = 2 * i + 2, largest = i; if(left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) { largest = left; } if(right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) { largest = right; } if(largest != i) { swap(arr, i, largest); heapify(arr, largest); }} function swap(arr, i, j) { var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;} function heapSort(arr) { buildMaxHeap(arr); for(var i = arr.length - 1; i &gt; 0; i--) { swap(arr, 0, i); len--; heapify(arr, 0); } return arr;} 8、计数排序（Counting Sort）计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 8.1 算法描述 找出待排序的数组中最大和最小的元素； 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。 8.2 动图演示 img 8.3 代码实现12345678910111213141516171819202122function countingSort(arr, maxValue) { var bucket =newArray(maxValue + 1), sortedIndex = 0; arrLen = arr.length, bucketLen = maxValue + 1; for(var i = 0; i &lt; arrLen; i++) { if(!bucket[arr[i]]) { bucket[arr[i]] = 0; } bucket[arr[i]]++; } for(var j = 0; j &lt; bucketLen; j++) { while(bucket[j] &gt; 0) { arr[sortedIndex++] = j; bucket[j]--; } } return arr;} 8.4 算法分析计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。 9、桶排序（Bucket Sort）桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。 9.1 算法描述 设置一个定量的数组当作空桶； 遍历输入数据，并且把数据一个一个放到对应的桶里去； 对每个不是空的桶进行排序； 从不是空的桶里把排好序的数据拼接起来。 9.2 图片演示 img 9.3 代码实现12345678910111213141516171819202122232425262728293031323334353637383940function bucketSort(arr, bucketSize) { if(arr.length === 0) { return arr; } var i; var minValue = arr[0]; var maxValue = arr[0]; for(i = 1; i &lt; arr.length; i++) { if(arr[i] &lt; minValue) { minValue = arr[i]; // 输入数据的最小值 }else if(arr[i] &gt; maxValue) { maxValue = arr[i]; // 输入数据的最大值 } } // 桶的初始化 var DEFAULT_BUCKET_SIZE = 5; // 设置桶的默认数量为5 bucketSize = bucketSize || DEFAULT_BUCKET_SIZE; var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1; var buckets = newArray(bucketCount); for(i = 0; i &lt; buckets.length; i++) { buckets[i] = []; } // 利用映射函数将数据分配到各个桶中 for(i = 0; i &lt; arr.length; i++) { buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]); } arr.length = 0; for(i = 0; i &lt; buckets.length; i++) { insertionSort(buckets[i]); // 对每个桶进行排序，这里使用了插入排序 for(var j = 0; j &lt; buckets[i].length; j++) { arr.push(buckets[i][j]); } } return arr;} 9.4 算法分析桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 10、基数排序（Radix Sort）基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。 10.1 算法描述 取得数组中的最大数，并取得位数； arr为原始数组，从最低位开始取每个位组成radix数组； 对radix进行计数排序（利用计数排序适用于小范围数的特点）； 10.2 动图演示 img 10.3 代码实现123456789101112131415161718192021222324var counter = [];function radixSort(arr, maxDigit) { var mod = 10; var dev = 1; for(var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) { for(var j = 0; j &lt; arr.length; j++) { var bucket = parseInt((arr[j] % mod) / dev); if(counter[bucket]==null) { counter[bucket] = []; } counter[bucket].push(arr[j]); } varpos = 0; for(var j = 0; j &lt; counter.length; j++) { var value =null; if(counter[j]!=null) { while((value = counter[j].shift()) !=null) { arr[pos++] = value; } } } } return arr;} 10.4 算法分析基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。 基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。 转载：https://www.cnblogs.com/onepixel/articles/7674659.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"算法","slug":"算法","permalink":"http://blog.iwxyi.com/tags/算法/"}]},{"title":"Qt解压缩文件","date":"2021-09-06T01:35:00.000Z","path":"2021/09/06/Qt解压缩文件/","text":"这里使用的是 QuaZip 方案。它调用了 zlib1.dll，如果是32位，直接编译 QuaZip 即可，默认就是32位。 如果是64位，不兼容的 zlib1.dll 会导致编译失败，需要自己编译 zlib。 一、编译Zlib 转自：https://blog.csdn.net/yxy244/article/details/105024989 编译环境：VS2017 1. 官网下载zlib库http://www.zlib.net/ img 解压到一个好找的位置，这里是直接放D盘。 2.命令行编译32位dll img 1.最常见的方式，开始菜单找到VS命令提示符工具，输入cd 复制粘贴zlib库的路径（你下载解压的zlib文件路径），回车切换到zlib目录下 img 2.输入nmake -f win32/Makefile.msc 回车开始编译 img 3.简单两步，在zlib目录下就生成了静态库和动态库了，生成的是x86版本。 img 3.命令行编译64位dll img 1.编译32位用的是x86的命令提示工具，编译64位需要在开始菜单找到x64的命令提示工具，输入cd zlib库的路径，回车切换到zlib目录下 img 2.输入 nmake -f win32/Makefile.msc AS=ml64 LOC=”-DASMV -DASMINF -I.” OBJA=”inffasx64.obj gvmat64.obj inffas8664.obj” 执行编译 img 3.如果遇到错误提示 inffasx64.obj:fatal error LNK1112:模块计算机类型“x64”与目标计算机类型“x86”冲突， img 先删除之前编译x86生成的obj文件，输入 del *.obj 执行删除目录下的所有obj文件 img \\4. 再次执行 nmake -f win32/Makefile.msc AS=ml64 LOC=”-DASMV -DASMINF -I.” OBJA=”inffasx64.obj gvmat64.obj inffas8664.obj” ，顺利的话就能得到64位的静态库、动态库和导入库了。 img 成功的 zlib1.dll，替换到 quazip 中的 lib/zlib1.dll。 二、编译QuaZip 转自：https://blog.csdn.net/xiaopei_yan/article/details/90267714 zlib编译详见https://blog.csdn.net/zhangxuechao_/article/details/85049711 下载quaziphttps://github.com/stachenov/quazip 也可直接下载我配置好的quaziphttps://github.com/zwx230741/quazip.git 加入头文件在quazip中创建include文件夹 1 将zlib头文件拷贝到include文件夹下 2 加入动态库文件在quazip中创建lib文件夹 1 将zlib编译好的动态库拷贝到lib文件夹下 2 quazip工程配置修改quazip.pro工程文件。添加头文件路径和动态库路径 123INCLUDEPATH += $$PWD/includeLIBS += -L$$PWD/lib -lzlib112 3 编译动态库 3 不加入头文件，报以下错误 4 创建测试工程quazipTest同理，创建include和lib目录。分别放头文件和动态库文件 5 拷贝头文件从quazip拷贝所有头文件 2 拷贝库文件拷贝刚刚生成的动态库文件。quazipd.dll是Debug生成的，quazipd.dll是Release生成的，zlib1.dll是zlib动态库 3 quazipTest工程配置修改quazipTest.pro工程文件。添加头文件路径和动态库路径 1234567INCLUDEPATH += $$PWD/includeCONFIG(debug, debug|release) { LIBS += -L$$PWD/lib -lquazipd} else { LIBS += -L$$PWD/lib -lquazip} 添加压缩解压代码 123456789101112131415#include \"mainwindow.h\"#include &lt;QApplication&gt;#include &lt;JlCompress.h&gt;int main(int argc, char *argv[]){ QApplication a(argc, argv); MainWindow w; w.show(); JlCompress::compressDir(\"D:/testzip/a.zip\", \"D:/testzipdir1\"); JlCompress::extractDir(\"D:/testzip/a.zip\", \"D:/testzipdir2\"); return a.exec();} 测试好的工程：https://github.com/zwx230741/quazipTest.git document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"文件","slug":"文件","permalink":"http://blog.iwxyi.com/tags/文件/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"CentOS创建桌面快捷方式","date":"2021-09-01T01:31:00.000Z","path":"2021/09/01/CentOS创建桌面快捷方式/","text":"一，在桌面新建一个文件 文件名随意，但必须带有.desktop的后缀名。 12cd 桌面/gedit app.desktop 二，在文件中写入如下内容 12345678910[Desktop Entry]Encoding=UTF-8 #编码格式Exec=/home/software/app/app.sh #要执行程序的命令路径Icon=/home/software/app/app.ico #应用程序的图标，会显示在桌面上Name=MyApp #应用程序在桌面显示的名字Name[en]=MyApp #英文名Path=/home/software/app #应用程序的安装路径Type=Application #快捷方式的类型X-KDE-SubstituteUID=false X-KDE-Username=root 三，给文件赋予可执行权限 11 chmod a+x /home/username/Desktop/app.desktop document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.iwxyi.com/tags/Linux/"}]},{"title":"永劫无间技巧整理","date":"2021-08-29T01:48:00.000Z","path":"2021/08/29/永劫无间技巧整理/","text":"基础跳跃：短按小跳（一般用于连招），长按大跳 切换武器：被振刀后按住1或2（振落的槽位），滚动鼠标滚轮选择新武器（个人感觉还是Tab顺手） 加速下落：在空中按住C加速下落，防止被射 喝药蹲伏：修武器时不可移动，嗑药不断按C蹲伏，避免远程爆头；或者在树干上静止喝药 炮台箭头：小地图上若看见炮台箭头在动，说明有人 紫色草丛：蹲下隐身后别人看不见，但是喝药会发光和有声音 刷新二段跳：空中振刀、钩锁都可以刷新二段跳 替换装备：捡东西按3替换装备（如高级甲换低级甲），不会被其他E给挡住 绝大多数情况下优先打药，其次拉人，最后追人 攻击普攻连招：左键+左键+下蹲/跳跃/闪避+左键+左键 升龙斩：左键蓄力/平A蓝霸体前按C+右键升龙，避免被振刀。敌人若较远则全称按W 平A两下后的蓄力都比直接蓄力要快；对手未到斩杀线不建议第三下跳A，破绽很大，会被蓄力反打 蓄力壁击：挂在树上或者墙上左键蓄力壁击，伤害非常高；也可用来位移一段距离（类似飞索） 平A转蓄力：平A两下结束后必定蓝霸体，本来的单击左/右变成长按，先骗敌人的振刀再攻击。也可以蓄力（C）转平A再打他一套 平A二段：可蓄一会儿，对面若蓄力准备蓄转振 蓄力压平A：承受第一下A后平A；或承受第二下A后放蓄力 蓝升龙：C+右键蓄力，未蓄满一段时释放 敌人蓄力：1 随时准备振刀（如蓄转振），2 跑远用弓箭射 空中蓄力：shift后右键蓄力，落地释放，很难防 滑铲升龙：跑步滑铲过程中右键升龙，尤其适合长枪追击对手，范围很大。伤害更低，但是升龙高度更高 屋顶蓄力：落地时突然释放，对手很难反应；尤其适合阔刀左蓄 突然切换武器：长剑升龙空中换阔刀下劈 地堂霸脚：接滑铲连招或空中连招，踢到瞬间阔刀跑左、阔刀空中下劈（伤害低）、太刀升龙连招 壁击连招：壁击后接升龙，真连 勾人对方蓄力：少振刀，中间跳取消再勾 追人若精力不够了，等等再追 振刀振刀时间：并不是红光出现就振刀，作用区间只有释放后的 250~450 毫秒 立刻振刀： 飞行或者蓄力时，按住C/跳跃中断操作，可马上振刀。（建议用跳跃，即使不振刀，也可以在空中完成2下左键1下右键的攻击） 平A转振刀：平A中疯狂按C+振刀（比只按振刀快很多） 蓄力转振刀：左/右键蓄力时，马上按C或空格，再按右/左键（或松开左/右键再振刀） 蓄力直接转振刀：左/右键蓄力不足1段时，再按下右/左键的一瞬间松开左/右键（但太容易误操作） 蓄力转平A：蓄力不足一段时松开，还会按照平A的方式打出；有迷惑性且蓄力时不会被僵直 跑步时： 立刻松开W，C+振刀（若按住W会变攻击） W+跳跃+振刀 触发敌人阔刀磐石：敌人若没有动，立刻跳起来振刀（但高端局不一定会反击） 升龙转振刀：C+右键升龙 对面被升龙：继续打 对面在蓄力：直接振刀 平A转振刀：平A后，立刻先按下快捷振刀，再立刻按下C键。（快捷振刀唯一的用处，实测不行） 第一下A可以转，第二下有后摇 闪振：很容易振到刀，不像蓄转振红光出了也不一定振到。后闪距离远，闪振使用左右闪 A闪振：平A时发现对方蓄力，立刻闪避转振刀 跳A振刀：跳A可以直接振刀，平A需要取消后摇才能振刀 钩锁飞索升龙：空中左键，落地后接C+右键。阔刀升龙落地后按下W+空格跳会跟很远，否则对方打飞了 飞索延长：飞索末端左键攻击，可增大飞行距离（逃跑也适用） 飞索找人：在树上可将挡视角的树叶变透明，有人的话准星会变红 刷新后摇：钩锁可以取消蓄力攻击后的后摇（例如阔刀左键蓄力的超大后摇），对面闪开也能抓上去 被飞索勾住： shift找掩体，壁击向下攻击、向远处逃跑； 拼刀：普攻/蓄力（不建议，一般不止一个追杀） 身法滑步攻击：跑步时小按一会儿左/右键（蓄力闪光前松手）滑步一段距离，可增加攻击距离 蓄力滑步：跑步时蓄力蓝霸体半秒，马上按住Shift滑步（不按住会变成闪避后走路），轮流切换，近战使用可避免普攻和飞梭硬直。注意时机和精力，不然会变成攻击。 避免钩锁：跑路时一定要蓄力滑步或者阔刀跑路（至少要有其他动作，不能纯跑），不然被勾到了就是一阵毒打；胡桃务必放光伞连偏僻处或者队友 快速移动：跑步滑铲快结束的一瞬间跳跃，取消滑铲的后摇，跑路最快（只按C+空格，不滑铲也一样） 快速上树：按住W，左键挥完后跳（取消后摇+爬树）循环（墙壁不行）。 到顶端后可接左键蓄力壁击逃跑（同时利用树挡住对面的钩锁），飞到顶接钩锁 无敌帧：短按shift、长按shift 短按闪：无敌时间长，但后续出招/振刀慢，用于残血求稳、躲剑气。 短闪振是闪避且后摇结束后振刀，有一瞬间会挨打 长按闪：无敌时间短，但后续出招/振刀快，用于连招。 长闪振是振刀打断闪避，无敌帧结束后立刻振刀 长按是指：在后续操作（攻击/振刀）按下后再松开Shift 压无敌帧：若发现敌人喜欢用无敌帧，则用蓝A顶 闪避滑步：按住S+Shift之后准星调转180°（向身后）滑步蓄力；否则滑步蓄力还会凑到敌人身前。距离比单次闪避，不容易被打，打到也可以反打 遮影步：在对方即将放蓄力时，按住W+A+按住Shift滑到对方身后，视角旋转180°回到对方身上。难点在于对对方蓄力时机的把握（通常只算一段），然后用钩锁或平A抓对方蓄力攻击的后摇 克制遮影步：攻击时视角旋转180度再出刀，例如敌人was就左旋 壁击奔跑：壁击落地之后按住shift，可以进入奔跑状态（其实就是普通的奔跑）。壁击到其他树/墙壁，可反复壁击位移。 空中飞行：钩锁飞到高点，按住W，循环按 Shift（短按）+空格+左键（跳A）；远程武器的蓄力也可以。 连续后闪：点按S+Shift，结束瞬间按W取消后摇，身体向前探瞬间再按S+Shift 回首掏：长按闪后退，等人物完全转过身后，再短按闪进攻 跑路不要径直往前，一定向后看看对手和队友 下落进房子：屋顶边缘滑步蓄力下落，然后用平A+长按闪控制方向 近战武器阔刀磐石架势：与其他武器同时攻击时非但不会被弹开还会立马释放蓝色霸体反击；左右蓄力受到平A或者右蓄力受到蓝霸体也会触发磐石，受伤害次数越多反击等级越高；且右键反击很难被振掉。 注意：每次触发磐石时必须松开鼠标按键（包括多段磐石的前面段），否则会自动释放不是拼刀的情况下触发磐石，就是自己被打中扣血了（减伤77%左右），敌人是没有任何负面效果的。 磐石硬直：进入磐石会有433毫秒的硬直，且每次触发都会重置硬直，且反击等级+1；因此会被太刀打到死。硬直时间内点左/右键会相应的反击，也可最多延迟到硬直结束后的625毫秒（实测500毫秒）内点左/右键释放（放之前能且只能按方向键）；跳蹲闪可取消。（但是要注意，硬直结束后没有减伤，相当于只是站着，直到进入霸体） 磐石反击时间（右键反击有两段攻击）： 左键反击伤害判定点 右键反击伤害判定点1 右键反击伤害判定点2 一段 575毫秒 325毫秒 875毫秒 二段 575毫秒 325毫秒 875毫秒 三段 616毫秒 325毫秒 875毫秒 因此右键反击被振刀的区间只有250~325这75毫秒内，再加上反应延迟+设备延迟+网络延迟，很难被振刀 取消磐石反击：听到“当”的一声，立刻松开左/右键，同时按下方向键+Shift取消磐石并进入奔跑状态。绝大多数情况都不直接放反击，或者趁敌人后摇时延迟反击 普通磐石：平A打阔刀直接蓄力 无敌磐石：阔刀AB蓄，平A不会磐石，蓄力会磐石 阔刀振刀：振刀反击落地瞬间，按住W+空格跳+右键下劈，对方躲不掉（但是按太快会导致砍不出来）。身旁若有另外的敌人，别接下劈连招，后摇很大。 阔刀赶路：有个前冲攻击，跑+蹲+跳+左键+跑 循环；慢一点点但更简单：跑+左键+跑循环。阔刀的跑+蹲+跳+左键攻击范围比纯左键更大，并且可结合拜年刀法补残血。此方法可挡背后的钩锁。 拜年刀法：连续小跳+右键（衔接得快）下劈，自动吸附到敌人位置，可劈到死。 建议阔刀，距离长；长枪不适合，大后摇结束才能跳跃。 应对方法：向砍的人的方向闪 取消后摇：结束后立刻接钩锁再取消 蓄力迷惑：阔刀左键蓄力可缓慢移动，不断按方向键进行鬼畜，让别人不知道你在干啥 阔刀起手： 钩锁起手：钩锁飞过去点击左键砍中一刀或两刀之后，点击空格跳A+下劈。注意点击空格左键时是不按方向键的，按了可能会打空 左键起手 AB蓄：A后立刻B蓄力进入二段防御姿态，可磐蓄力击；左键起手的右键蓄力是崩山斩，伤害更高 若A在蓝霸体上： 直接打出平A二段蓝霸体，可能先打中，可能拼刀进入磐石，也可能被振刀 右蓄磐石格挡（阔刀后摇太大，可能来不及闪） 若对手蓄力：等他反应 若对手振刀：释放蓄力，或转平A 若对手平A：释放蓄力 若对手闪避：长闪过去继续AB蓄 跑+右键滑铲升龙：攻击范围大，且自动贴靠敌人 对面若蓄力： 按住右键第二下站立下劈抵挡磐石（右键蓄力时不需要松开打出也可以磐石，所以不着急放出） 空中振刀 对面若不蓄力： 空中左键+右键下劈 右键蓄力起手：右键滑步蓄力 声东击西：多个敌人的话，可以向一个敌人滑步蓄力，然后准心调转到另一个敌人身上 左键一段蓄力起手：攻击距离较大（比百裂斩远） 左键三段蓄力起手：混战时从刁钻的位置出去，最常用的是高处（如屋顶）蓄力 阔刀连招 左键+闪+左键 左键（平A） + C+右键（升龙） + 左键（空中砍） + 落地后跳+右键（下劈） 阔刀钩锁起手： 打磐石反击：别老想着振刀（可能延迟反击，或右键反击来不及振），先闪；对面若反击再振刀或者抓后摇 振阔刀左蓄：等大风车到自己面前再振刀 振阔刀右蓄：两次振刀判定，第一次闪光时振刀、挑飞动作结束前振刀（稍远距离） 阔刀打阔刀： 左键拼刀时，先出手的人会挨揍（因为左键反击慢，对方一直磐石，自己后摇时被反击） 右键拼刀时，后出手的会挨揍（因为右键反击快，对方立刻磐石反击到自己磐石—自己立刻磐石反击） 左键与右键拼刀时会一直弹刀 左键+右键 打不过 右键+左键（因为第二下右键的触发了左键的磐石，被反击了） 磐石对拼：俩阔刀互相磐石时，反击用右键 磐石左键反击打不到蹲下的人，俩阔刀打出对方一段磐石后延迟放右键反击 克制磐石反击：触发对方磐石立刻后退，对面若反击再振刀 左键反击来得慢，右键反击快但是能振第二段 对方变蓝后，若横挥则立刻振刀，跳起则延迟振第二段 背身蓄力：阔刀一直被打得磐石时，旋转180度背向对手，不会触发磐石。躲法：跑就行了 阔刀振刀连招：反击+W跳A+下劈，跳A容易挥空；如果地形不好直接下劈，稳定推荐；若距离过远，放弃终结技，直接跳AB 阔刀防止振刀：要按住W，AA第一下如果没打中，马上切视角（比如右转90°），防止被振刀 拆哪吒闹海：阔刀左蓄逼近，等对方金霸体结束瞬间释放 阔刀追残血：跑步过程中右键滑步蓝A，攻击距离很远 钩锁取消蓄力：只有右键二段防御姿态所有时间、左键蓄力未满第一个点时 阔刀右键蓄力一定要贴脸，否则第二下的下劈很容易被振。多蓄几段，对手若敢振刀就抓后摇阔刀滑铲空A距离远，滑铲平A范围大 不放磐石：磐石不反击就接蹲A 阔刀磐石龙王破这种后摇很大的招式，可以直接右键反击 阔刀起身：被打倒地，可以直接右键蓄力起身；若被平A压起身，则会进入磐石 雷刀： 雷刀的旋风斩可以随时起跳 持续按左键可以多转几圈 最后是个下劈动作，一般打不到，可尝试跳B或跳AB 夺魂阔刀：可转两圈，但第一圈就会把人打飞，要是有两个敌人就能打飞两个；终结技后不能跳AB，只能跳B 崩山斩打飞敌人，通过影子判断人落点 阔刀魂玉： 巺风震雷刀：左键三段从4圈变成好多圈，三排必带 夺魂·阔刀：振刀后攻击回血回甲，必带 裂空：右键蓄力击增加振荡，必带 霸主：磐石反击都变成三段，反击必带 烈火斩：左键一段、二段蓄力带灼烧 破风：右键二段蓄力产生类似剑气的攻击 长剑长剑起手：长剑左键平A速度快、距离远，打到后 Shift+右键 打出僵直，接升龙 白嫖剑法：先用~锁定敌人，按住A/S/D，循环接shift+右键。这里每次只砍一下，因为第二下僵直短，不好连。 两次内可趁机接升龙+空中左键+右键，落地后A+右键蓄力 进入强博弈（僵直存在递减机制，A出第三次时对方可直接躲掉；能不能躲和延迟有关） 长剑升龙： 升龙后稍等片刻再左键攻击；若是马上空A，第二击会无法命中、或把敌人击飞。 升龙后等对方快落地再按住W 长剑A闪A升龙：是伪连，有很小的间隙，但只有磐石和大招（例如胡桃加血）能解；A升龙是真连 长剑连招：右键+shift+右键+升龙，即将落地时（太早/太晚都不行）左键跳A，落地后再接空格跳A，再右键下劈 长剑振刀连招： 振刀后接升龙连招 处决一段shift取消掉，接双跳A 长剑蓄力：对于有逃跑意志的敌人（尤其是地上绕圈的），用横向蓄力，纵向打不到人 克制白嫖剑法：阔刀正面磐石（猛按左键或右键）或奥义V可挡长剑的A闪A升龙（伪连），侧面背面不行，A闪的升龙也不行 剑气闪避：放出剑气后立刻闪避，远距离被振了没事，近距离尽量两段或者不放或者闪开，场面乱起来很难振刀 横剑气近距离蹲下可躲过，但远距离蹲下不行 阔刀打长剑： 磐石起手：时刻面对对手并保持蓄力，或AB蓄，防止长剑BSB升龙 A蓄：长剑和阔刀同时蓄力则释放蓄力磐掉剑气，并拉近距离 AB保持蓄力：A若没打到人，立刻按方向键并转移镜头出B，防止被振刀 长剑BSB后B蓄：或许能磐到长剑升龙，尽量不要反击 近距离前闪穿剑气：靠近对手并抓住其剑气后摇出A 振到剑气：距离过远则放弃处决，跑过去B 长枪龙王破+哪吒闹海：左键/右键二段蓄力完成的一瞬间松手，使出龙王破，紧接左/右键使出哪吒闹海，再接左键蓝霸体攻击（可躲/可振），接右键普通攻击。振刀后紧接左键也可使出哪吒闹海。 长枪蓝A：又蓄滑步转平A，攻击距离比直接平A长。平A抢先手，蓝A打反手 长枪连招： 右键起手：右键攻击距离大于左键 右键+左键 +左键蓝（萌新三连1）：对手必须第一时间振刀 +右键蓝（萌新三连2）：对手第一时间振刀又振早了 +跳A：记得按方向键，否则会有落地下蹲的破绽（只有长枪有）（建议三种连招混着来） +左键蓄力：后续看情况 +C+左键+左键 +方向键+Shift+左键+左键 对付短闪：方向键+Shift 改为 W+Shift 右键+跳A+下劈 升龙+双跳A：升龙后一直按住W。是伪连，但是各种延迟下对手很难反应过来 不推荐：右键+右键，因为后摇实在太长了 左键起手：比右键起手的攻击范围广、出手快、攻击呈两段；但僵直短，攻击距离短 连招同右键，但是接不了升龙 使用情况： 钩锁攻击 左键蓄力骗出对方振刀后，左键起手 压对手倒地起身：按住W+Shift奔跑，左键蓄力，看到敌人翻滚的瞬间打出蓝A 准备龙王破/左蓄转平A 哪吒闹海连招：第二下（即只点一下左键）或者第四下（两下左键）的时候，按C打断（第一圈时预输入）并用出升龙+双跳A+下劈。打断后可考虑先用右键蓝B再加升龙，对手看见你变蓝会考虑振刀 长枪长闪：闪避距离最长，长闪也有两个无敌帧 长枪追人：不用蓄力滑步，使用滑铲升龙 长枪打太刀：控制距离，抓后摇 长枪打阔刀：打出磐石直接闪走，长枪位移长，反击打不到 太刀太刀左A比右B僵直长，可接升龙；但是右B攻击范围大，容易命中 太刀左键时机： 预判对面振刀 预判压闪避 压起身 太刀连招： 右键+跳A +左键蓄力（跳A落地蓄力比直接A的蓄力优点：可以转振、转平A） +落地后右键蓄力（不落地会变成下劈） 左键+升龙+落地后右键+右键（不是跳A） 双升龙：左键+升龙+落地后再升龙+右键（较高风险，适用于补残血） 双跳A：左键+升龙+跳A（不用空格）（第一刀命中后立刻按住W）+（落地后按空格+左键）跳A 升龙钩锁：左键+钩锁（钩敌人/落地地面）+空中钩锁踢（空格）+落地后右蓄百裂斩 闪百裂斩：太刀的横向百裂斩，左/右短闪在距离上躲不掉，只能前/后闪 快速百裂斩：普攻第三下的蓄力，蓄出百裂斩的耗时很短 太刀惊雷：几乎不用，对面无僵直，不是跑就是振刀，高风险 太刀振刀连招：第二下金霸体出来时按空格，后续接跳A 太刀八连：升龙（如妖刀姬F1）后连续多次双跳A 阔刀A蓄会前冲，在中距离可打百裂斩后摇 原地滑铲升龙：按住方向键+Shift，立刻C+右键，速度要快 百裂斩出手瞬间，可冲到边缘闪振碰瓷（无需太近） 匕首豫让三伏连招：戳两下时后闪（预输入）打断，接C右升龙+双跳A+下劈；可以不接下劈，使用C左打闪避的敌人 鬼反断升龙：鬼反断打到人的瞬间，Shift打断后摇，C右升龙（即 Shift+C+右） 闪步后接： 左键：鬼反断（对面不处于后摇状态千万别用） 接右键：最稳定 闪步，立刻C打断闪步，接右键升龙双跳A 左键蓄力击 + 升龙连招 右键蓄力击， 打完立刻接右键，回到起手 第二刀时闪步打断，C打断闪步，接升龙连招 宁红夜F + 升龙连招 按住左键，蓄一段前松开：鬼反断，防止振刀 左键蓄力：亢龙卷破 右键：平A 按住右键，蓄一段前松开蓝A 右键蓄力：豫让三伏 跳A：按W，自动吸附敌人 C左 + 升龙 C右：升龙 振刀 蓄力转振刀 短闪/翻滚 蹲左：接蹲右升龙是必中的；平时少用，后摇比较长 右键起手：判定范围比左键大 打出僵直： A第二段 + 闪步 C左 + C右升龙连招：伪连，但C左刚好能打到一个闪避的距离 打在蓝霸体上：立刻闪步拉开 拼刀：用不了闪步，可接蓝A，回到起手 被躲掉：闪步 匕首钩锁起手：命中后在空中立刻空格打断，接跳A 匕首压起身：直接蹲左（可打到闪出的敌人），打到则蹲右+升龙连招 匕首无限升龙：左蓄/C右升龙起手，两下空A，落地小跳A一下，无限C右升龙 故意右键蓄空：骗对手过来，Shift打断豫让三伏并闪步，鬼反断反击 匕首振刀连招：处决后接升龙+双跳A+下劈 金闪步：对手出招瞬间闪步冲上去，鬼反断攻击 匕首蓝升龙：距离远（长闪短闪都躲不掉）、顶白A、秒振刀，很无赖 阔刀对战匕首： 蓄力释放起手：与蓄力的匕首形成拼刀，防止对手使用闪步近身 打到对手闪步则必吃鬼反断 不要在远距离振匕首B蓄：B蓄的蓝霸体突进太短，容易被插 阔刀B蓄磐不了匕首B，会吃后面的金霸体 不要尝试振匕首的A3或B3：应连续两次短闪，匕首会打出鬼反断A2闪步的循环 A1蓄若与鬼反断同时出手，则不会磐石而是直接命中对手 空精力或残血，切勿使用大后摇的方式追击匕首 对手残血拼刀抓闪步结束瞬间出刀会比鬼反断快（没死则会吃鬼反断） 若使用最快的B蓄磐鬼反断则需要在其闪步之前就开始蓄力 匕首的鬼反断可以延时释放，不是轻易能振到的 拼刀磐石后可尝试闪振鬼反断 匕首的金闪振能把磐1段的B蓄秒放大概率振刀 鬼反断可以躲过并打断A蓄旋风斩 若被匕首打倒地起身接2段短闪规避鬼反断 短闪可以躲避鬼反断（极难） 磐石以后立马镜头追踪敌人调整面向（极难） 振刀磐石可以同时应对匕首闪步后的AB择（终极难） 振B蓄得贴脸，否则会吃到后面的金霸体 远程武器落地射击：下落时瞄准敌人正上方，对上头时射出 钩锁射击：钩锁硬直，飞过去空格取消，滚轮切换武器，射击。等飞行时再跳，太快导致取消不了 弓箭鸟铳快速射击：射一下按S+shift取消后摇 鸟铳起手贼快，打倒地后接鸟铳A闪A，对手若起身蓄力则遭一顿毒打 火炮连弩左键按一下就能射三发，比按住射伤害高 治疗箭隐藏功能会把三发改成四发，升级版的速射且不会降低伤害 五眼铳御地雷：延迟炸裂会触发阔刀的多段磐石 闪避无敌帧可以躲御地雷的爆炸 英雄胡桃集火胡桃：大家都先集火胡桃，千万别冲，跟着队友冲或者远攻 胡桃定位：要打，要挨打，要奶，要拆火，要断后，还要一边挨打一边扶队友 胡桃光伞：长按选位置，左键金霸体瞬移 会被平A打断，金霸体不能打断哪吒闹海 瞬移有后摇，可用蹲跳闪取消后摇 抵挡远程子弹（也会挡自己的），有血条 Q可以取消伞，没必要不用左右键放，有后摇 抢落物堆时振飞敌人 逃跑时找偏僻位置放光伞、或者和队友连线后反向逃跑，分散敌人 避免和尚大佛远抓（ 往后靠用伞顶挡，伞下不行 ）；但是近距离会被一下子抓破 往沙男风暴外面出光伞逃出 宁红夜大招结束的一瞬间（会有光照下来）瞬移躲避；或者瞬移到远处 按F及其右键，一定要大跳/二连跳、或者钩锁快结束的空中，否则就是活靶子 超出距离，不管超出多少3秒内都可以瞬移 极度适合地堂霸脚 跑步的时候开伞，移动放技能；伞还能阻挡后面的远程攻击 拯救宁红夜眩晕/风暴困住的队友（要等时机，别立刻莽进），击飞蓄力的敌人 救援时长按F把伞放到魂冢上，再F连接魂冢，可阻挡远程攻击，扶起来后立刻回血 扶队友挨打时远离魂冢，在复杂地形上躲避，结束后瞬移逃走 带队友跑毒：先连队友A，自己&amp;队友B扣一半血时，再连到队友B，右键加血，三人都是满状态 胡桃大招： 大招和光伞瞬移都是金霸体，减伤一大半，可以用来防御，或者原地硬吃伤害加血 有延迟，即将扶起人前预判性的V，再右键奶一口，可瞬间恢复1500血甲 别瞬移拆火：队友被集火，不要F瞬移过去！没有把握好时机，就是羊入虎口。应该是被集火的先蓄力滑步离开，队友旁边蓄力援救。（除了保护被眩晕的队友） 要注意队友血量，有阵则喊住离太远的队友 迦南迦南F瞬移： 进攻：向天上F，S+shift贴脸，右键蓄力，落地发出攻击 追击：F可以接空A追击敌人（相当于跳跃） 多段位移：F瞬移上天后方向键+shift形成短时间内的多段位移 跳出沙男风暴 卡时机躲阴神之眼 迦南V隐身： 可完全躲过阴神之眼 钩锁不能自瞄，但还是可以被勾到 宁红夜宁红夜F： 经典连招QF：不按方向键时自动锁敌（近战修正），比如钩锁时用F攻击 自己被钩锁了直接F（能打到后面），反手一套连招 能打僵直用于连招（如白嫖剑法），也能让倒地的人再倒一会儿，再接普攻连招 被普攻连能狂按F，对手稍慢就能反打 能沉默连线的胡桃，后者只能挨打不能奶也不能瞬移 能沉默大佛，后者抓了也不能摔 踢开大的大佛更容易，等和尚开大佛再踢，还能刷伤害 勾宁红夜时远距离钩锁中间断一下再勾，否则容易被其F反击 宁红夜V： 对手迦南若隐身，最后四秒开大，对手可能会仗着隐身不躲 极限开V：远处/高处开V，最后两秒冲进战场；例如树顶壁击上天开大，落地已过三秒 若被对方宁红夜踢了（语音要说），己方宁红夜应立刻开大，因为对方宁红夜可能会连着开大 宁红夜大招结束瞬间前，滑铲（跑步中长按C）可躲（bug） 特木尔先手开大：双方都有宁红夜或者特木尔等控制英雄，一定要先手开大 特木尔风球： 经典连招：QFQ，落地蓄力 六段跳：跳跳F跳跳F跳跳 追踪：靠近敌人一段距离才会追踪 输出：控制后蓄力（如长剑右蓄）；远程攻击（弓箭：空中两箭，落地一箭，不要蓄力会打飞） 现在可以挡三次远程攻击（现在可以挡爆炸），可以挡弩炮 挡特木尔的沙球，只需要一直蓄力顶着吹风，伤害极低；但精力会被清空，可能会被原地射，阔刀左蓄可移动 对手沙男F上天，立刻钩锁留人 开F后，钩锁过去中间跳回来，用来拆火和吓唬人；也可以F控制一个，钩锁骚扰另一个人 穿不过沙暴风墙下半部分，会被反弹 特木尔V： 和敌人一个身位距离，向左或向右转向按V沙暴，刚好让敌人进沙暴 能震荡敌人，并能造成一丝伤害；可紧接平A+升龙把人打入沙暴中 在空中或前面有遮挡物时是原地释放，前摇很长，很不建议，还会被大佛抓 能打断哪吒闹海，可闷掉和尚的大招的前摇（但是和尚出了沙暴还能重开） 用自己身体挡住沙暴中想要移动的敌人，一直太刀一段百裂斩（二段会把人打飞），使用右键修正敌人的位置 被剑气克制，能透过沙暴 风之牢笼不是圆柱形，是正反两个圆锥，V3边缘高跳也可以刷新风之精灵，不需要来回穿越；配合F3可一直束缚敌人 沙暴空中游泳时可以靠Q飞锁瞄准滞空来拖延时间 天海金刚秒杀：同时抓到两个人砸落几乎秒杀；砸向另一个金刚落点处秒杀金刚 天海V： 满金甲开大更亏，还不能振刀 敌人大佛面前可以用短闪躲避，等出手后再闪 躲避大佛：一定要面向大佛，背着或侧着跑，保证能看到动作和及时躲避；钩锁时会稳定被大佛抓中 季苍海火男F火球： 升龙后的火球必中 敌人若在蓄力，放火球 火球速度慢，稍微预判敌人的走位 弓箭补伤害：先切换弓箭跳跃，再释放火球，命中后，直接点左键射箭。火球有浮空再倒地的效果，第一箭击空中，第二箭击落地 火男F格挡： 混战建议带F2 克制F格挡：贴脸蓄力，他若敢反击/平A就打出去，若闪走则只能放弃蓝霸体（怕被闪振） 火男V： 被振刀可强制取消僵直 无法击退金霸体，被振刀可闪走（但不能反击） 冲拳： 跑步中 shift 冲拳，可使敌人僵直，包括蓝霸体 战力时双击 Shift 冲拳 冲拳距离很短，比不过刀 无限升龙（颠勺） 确保设置里的“近战招式修正”是开启的 起手： 跑到敌人面前Shift冲拳，左键平A，接 C+右键升龙； 平A/平B后两下Shift冲拳（纯右键僵直不够），再接升龙 跑过去滑铲升龙 升龙后立刻调整视角对准敌人或者其稍右，并按住 A+Shift 落地奔跑半秒后（不要太急）按C+右键进行滑铲升龙 有升龙的动作后（不要等上升）立刻按 A+Shift，否则会跳很高 每次视角右转一点即可 可以按“~”锁定视角，但会失效 点按 A+Shift 是瞬步升龙 若不等奔跑而提前升龙，会出现把人击飞的情况 第4/7/10下不按A和Shift，原地升龙，因为要恢复精力 颠勺过程中不用按W靠近，本质上相当于对着敌人绕一圈 重点在视角和滑步上 若三下之后不想升龙了，落地百裂斩 滑步升龙：无限下，难度高，闪避后奔跑，敌人飞起来高能等精力恢复 瞬步升龙：三四下，难度低，瞬间闪避，且对地形要求低，单次伤害高，结束后直接接百裂斩 妖刀姬妖刀姬F飞盘： 在角落放，敌人相当于一直被平A，会被打断振刀，此时可大胆蓄力攻击 F1跳出沙男的沙暴 F3： 能挡蓄力攻击，但不会中断蓄力，因此可滑步蓄力进去，等结束一瞬间出手 风球、喷火筒、其他妖刀姬的飞盘等非直接物理攻击能透过飞盘 火炮和一窝蜂可以往边上打，有概率溅射到里面 抢空投：F3飞盘有高度的，应该向着敌人竖直着放，或者背对着敌人斜着放，高的方向挡头 视角朝下（准星瞄准魂冢底部）斜着插到底地面，适合救队友时近处有敌人骚扰（注意地面释放会金霸体前冲） 二段跳竖直插到地面，能挡一面的攻击适合救队友时远处有敌人骚扰骚扰 在狭小的地形（角落）压缩敌人的操作空间 妖刀姬V：杀人就放，不要用来保命 最好平面，有点高低差（除非对准）就不行 会被大佛抓、宁红夜大招眩晕，目前已不会被沙暴中断 左键丢飞盘会从金霸体变蓝霸体，两妖刀姬开大千万别丢，不然会被打断 砍出去会偏右一点，准星要移到敌人左边 护甲没了就放大，不然可能中途或结束后打死 V3回复量只有V2旳一半，切后面三刀不回复 大招逃跑：一边正面砍，一边旋转视角反向丢飞盘 躲宁红夜大招：“阴神之眼”的“眼”瞬间立刻按V开大，砍一刀后丢盘子瞬移可躲过 躲和尚大招：他开你也开（反应要快）可先一步砍中 躲沙男大招：两次位移出沙暴 躲妖刀姬V：拉出一段距离后使用短闪 飞盘连招 平A接升龙 对准人物空中F2飞盘（不用按方向键），放出来后立刻W+Shift（此时冲过前面的飞盘） 落地升龙 小顿一下，再升龙 镜头往飞盘方向拉过来 空中左键 落地二段F 蓄力百裂斩 崔三娘崔三娘V： 戳矛之前释放敌人前，队友在下面蓄力，集火先秒一人 团队意识观察对手阵容，确定优先集火目标 资源合理分配很重要 队友好操作多夸一夸，氛围舒服 被追击了逃不掉，找适合拉人的地方死，比如小房子里 多打一：有人平A，有人蓄力，注意队友交流，不要放松 队友交流：询问要上吗、要上了、振刀了、被振刀了、龙王破了、报药数、打药了（让队友拉扯一下）、被碎甲了、碎甲了赶紧集火（队友迦南F上天钩锁赶过来）、被集火了、开大了（让队友帮忙留人）、对面开沙暴了、我没有大赶紧躲一下、杀了一个xx、又来一队赶紧走等等等等等 振刀反击的金霸体没有伤害减免，一样会被远程打。被残血敌人振刀了身边队友赶紧长剑蓄力；哪吒闹海也可能会控住自己导致被剑气刮死 决赛圈注意其他队伍的位置，不要被其余队伍形成夹击之势 金刚伏魔：队友要看着自家的大佛，帮忙平A留人；抓到人赶紧用远程补伤害 允许单挑的情况下，5~8秒内解决不了对手就立刻去帮队友 站位： 1号位开团（可能会吃到大量伤害） 2号位开火、拆火 3号位队伍容错/自由人，拆伙、补残血、放符等 拆火站位：敌人背后、侧身 其他听声振刀：听到“叮”的声音习惯性振刀，尤其是隐身的敌人 任务奖励：铜钟 &gt; 宝箱 &gt; 追击 &gt; 祭拜 祭拜：可以用打招呼等动作代替，速度更快 舔包时视野往宽阔的地方看；黑皮肤蹲魂冢里就行 滑铲时翻滚，别人视角就是瞬移 追人可以先不用管有大的迦南 常见语音： 《先秒大佛》《我这可以救》《和尚一丝》《早知道直接开大了》《谁的风谁的风 我操 对面的风》《我刀呢》《别被双抓别被双抓》《俩残你们人呢》《又来一队他妈的》《哪个xx在射我》《我没近战》《前面打起来了快去劝》《走走走消费一波》《我操金甲》《我被龙王破了》《都走了能救》《让他们先打》《我上了》《三个人》《我被振了》《我没了》 大多是参考B站各大佬教程、实战视频整理总结的因为出处太多，就不挨个标明了 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"游戏","slug":"游戏","permalink":"http://blog.iwxyi.com/tags/游戏/"}]},{"title":"Qt无窗口状态下对键盘事件的监听","date":"2021-08-26T01:39:00.000Z","path":"2021/08/26/Qt无窗口状态下对键盘事件的监听/","text":"需要接收键盘事件，但是又不能有界面 1234567891011121314151617181920int main(int argc, char *argv[]){ QApplication a(argc, argv); Test *p = new Test; a.installEventFilter(p); return a.exec();}bool Test::eventFilter(QObject *obj, QEvent *event){ if(event-&gt;type() == QEvent::KeyPress) { static int index = 0; QKeyEvent *key=static_cast&lt;QKeyEvent *&gt;(event); ......... } return QObject::eventFilter(obj,event);} 1、首先需要在main方法中注册，使用installEventFilter方法把这个类的指针传进去 2、在Test类中重写eventFilter方法，这样就可以进行监听了 3、在eventFilter中进行自己的逻辑处理 摘录自：https://www.cnblogs.com/xupeidong/p/11152998.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"Qt应用单例运行模式（文件锁方式）","date":"2021-08-26T01:38:00.000Z","path":"2021/08/26/Qt应用单例运行模式（文件锁方式）/","text":"123456QLockFile *lockFile = new QLockFile(\"temp/appName.app.lock\");if (!lockFile -&gt;tryLock(2000)) { //上锁失败，不能启动 qDebug() &lt;&lt; \"app is running\";} else { qDebug() &lt;&lt; \"app is not running\";} 1、QLockFile的构造函数的参数就是指定一个锁文件的地址 2、tryLock的参数为等待时间 3、如果程序没有启动则对文件上锁，如果启动则退出 还有通过本地 Socket 的方式，可使用 QSingleApplication。 摘录自：https://www.cnblogs.com/xupeidong/p/11152920.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"Qt将unicode字符串转换成中文","date":"2021-08-10T01:41:00.000Z","path":"2021/08/10/Qt将unicode字符串转换成中文/","text":"外部输入的 \\u1234 在代码里相当于 \\\\u1234，只是普通的字符串，而不是 Unicode，需要单独替换一遍： 12345678QString filename = \"\\\\u6211\\\\u662f\\\\u4e2d\\\\u6587\";do { int idx = filename.indexOf(\"\\\\u\"); QString strHex = filename.mid(idx, 6); strHex = strHex.replace(\"\\\\u\", QString()); int nHex = strHex.toInt(0, 16); filename.replace(idx, 6, QChar(nHex));} while (filename.indexOf(\"\\\\u\") != -1); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"MySQL设置表名不分大小写","date":"2021-08-04T01:28:00.000Z","path":"2021/08/04/MySQL设置表名不分大小写/","text":"linuxMySQL 默认区分大小写 设置为不区分:在 /etc/my.cnf 中 [mysqld] 下加入 lower_case_table_names=1 （1 不区分大小写；0 区分大小写）重启数据库 windowsMySQL不区分大小写 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"SQL","slug":"SQL","permalink":"http://blog.iwxyi.com/tags/SQL/"}]},{"title":"SystemC-学习笔记","date":"2021-08-02T02:24:00.000Z","path":"2021/08/02/SystemC-学习笔记/","text":"系统级设计描述语言语言架构SystemC本质上是在C++的基础上添加的硬件扩展库和仿真核。 1234567graph LRA[C++语言标准]--&gt;B[SystemC核心]A--&gt;C[数据类型]B--&gt;D[基本通道]C--&gt;DD--&gt;E[方法学库]D--&gt;F[层次Layered库] 方法学库 Master Lib Slave Lib 层次（Layered）库 Verification Lib Static Data Flow 基本通道 信号 互斥 信号量 FIFO SystemC 核心 模块（Module） 端口（Port） 进程（Process） 接口（Interface） 通道（Channel） 事件（Event） 基于事件的仿真核 数据类型 4值逻辑数据类型 4值逻辑向量类型 比特和比特向量 任意精度整数型 定点数据类型 C++用户自定义数据类型 C++语言标准 描述层次SystemC 不仅仅是一种新的硬件描述语言，更是一种系统描述语言。 寄存器传输级（RTL） 时钟周期精确级 带时间信息的编程级（PVT） 编程级（PV） 算法级 高层 底层 基本语法 缺省时间单位为 ns，缺省时间分辨率为 1ps 模块用 SC_MODULE(module_name){...} 来声明 一个模块实际上是一个类，拥有构造函数和析构函数 最顶层的函数是 sc_main 全局函数 sc_version() sc_copyright() T sc_abs(const T&amp; val) T sc_max(const T&amp; a, const T&amp; b) sc_start()：开始运行仿真核 sc_top()：停止运行 示例：与非门 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include \"systemc.h\"// 声明一个模块SC_MODULE(nand2){ sc_in&lt;bool&gt; A, B; // 输入端口 sc_out&lt;bool&gt; F; // 输出端口 void do_nand() // 与非门 { F = !(A &amp; B); } SC_CTOR(nand2) // 模块的构造函数 { SC_METHOD(do_nand); sensitive &lt;&lt; A &lt;&lt; B; }};SC_MODULE(tb){ sc_out&lt;bool&gt; a, b; sc_in&lt;bool&gt; f; sc_in_clk clk; void gen_input() { auto setAB = [&amp;](int a, int b) { wait(); this-&gt;a = a; this-&gt;b = b; }; setAB(0, 0); setAB(0, 1); setAB(1, 0); setAB(1, 1); setAB(0, 0); setAB(0, 0); } void display_variable() { cout &lt;&lt; \"a=\" &lt;&lt; a &lt;&lt; \", b=\" &lt;&lt; b &lt;&lt; \", f=\" &lt;&lt; f &lt;&lt; endl; } SC_CTOR(tb) { SC_CTHREAD(gen_input, clk.pos()); SC_METHOD(display_variable); sensitive &lt;&lt; f &lt;&lt; a &lt;&lt; b; dont_initialize(); }};// 主函数入口int sc_main(int argc, char *argv[]){ sc_signal&lt;bool&gt; a, b, f; sc_clock clk(\"Clk\", 20, SC_NS); // 模块实例的初始化 nand2 N2(\"Nand2\"); N2.A(a); N2.B(b); N2.F(f); tb tb1(\"tb\"); tb1.clk(clk); tb1.a(a); tb1.b(b); tb1.f(f); // 连接模块的通道的初始化 sc_trace_file *tf = sc_create_vcd_trace_file(\"Nand2\"); sc_trace(tf, N2.A, \"A\"); sc_trace(tf, N2.B, \"B\"); sc_trace(tf, N2.F, \"F\"); // 设置缺省时间单位 sc_start(); sc_close_vcd_trace_file(tf); // 别忘了关闭 return 0;} 仿真过程仿真过程是基于事件的，时间只前进，不后退。前进的尺度与仿真时间分辨率和时间单位有关。 执行过程分三个阶段： 目标描述 模块实例和连接模块的通道的初始化 设置缺省时间单位和仿真分辨率 sc_clock 的初始化 sc_time 类型数据的初始化 初始化 整个 SystemC 仿真的执行过程由 SystemC 调度器控制，初始化是其执行的第一步 SystemC 核心语言库定义了三种进程： SC_METHOD SC_THREAD SC_CTHREAD 在初始化阶段，缺省情况下每一个进程都被执行一次，THREAD 进程被执行到第一个 wait*() 语句 通过 don't_initialize() 函数可以关闭对进程的初始化 在初始化阶段，进程的初始化顺序是不确定的；但不同次执行中进程的初始化顺序是确定的。因此用不同编译器可能产生不同的运行结果。 仿真 从第一次遇到 sc_start() 开始到预先设定的仿真时间结束或者遇到 sc_stop() 预先设定的仿真时间由 sc_start() 确定，如： 12345SC_MODULE(Example) { /* ... */ sc_start(500); /* ... */} 如果缺省的时间单位为 ns 且代码中没有使用 sc_stop()，则仿真进行 500ns 如果 sc_start() 的参数为空，则仿真进行到遇到 sc_stop() SystemC 调度器sc_start() 函数激活调度器，第一个工作是对进程的初始化。 调度器控制： 仿真时序 进程的执行顺序 处理仿真过程中的事件 更新信号的值 SystemC 调度器也是基于 Delta 周期的，一个 Delta 周期包括求值和更新两个阶段。 SystemC 模块模块是最基本的单位，包含一些其他元素如：端口、内部信号、内部数据、子模块、进程、构造函数和析构函数等。这些元素共同定义模块所表达的功能。 使用关键字 SC_MODULE 来声明一个模块，也可以用 C++ 的类来定义模块。 模块的端口模块间的端口使数据能够在模块间通过，模块之间通过信号将端口连接起来。 端口分为三种类型： in out inout 如果需要将某一端口的数据赋给模块自身的其他型号，那么该端口就应该是 inout 类型。 你也可以指定端口的数据类型，允许的数据类型包括C++基本数据类型如 bool、int、short、char 等或者是 SystemC 专有数据类型如 sc_int、sc_unit、sc_logic 等或用户定义的任何数据类型。 下面是定义端口的示例： 123sc_in&lt;packet&gt; pkt_in; // 一个输入端口sc_int&lt;sc_logic&gt; a[32]; // 端口向量（如计算机的数据和地址总线）sc_signal&lt;sc_logic&gt; abus[16]; // 信号向量 抽象端口SystemC 为了支持交易级建模，还支持抽象端口，示例： 123456class direct_if : public virtual sc_interface{public: virtual bool direct_read(int* data, unsigned int address) = 0; virutal bool direct_write(int* data, unsigned int address) = 0;} 1sc_port&lt;direct_if&gt; arbiter_port; // 定义类一个抽象端口 端口的读写12345678// 定义输入端口sc_in&lt;bool&gt; data_in;// 可以进行下面的读操作if (data_in == TRUE) { ... }if (data_in.read() == 1) { ... }bool flag = data_in;bool flag = data_in.read(); 123456789// 定义输出端口sc_out&lt;int&gt; data_out;// 可以进行下面的写操作data_out.write(10);data_out.write(data_in.read());// 非法的data_out = data_in; // 直接赋值是不行的，因为两者类型不同。 端口和信号的多驱动处理 0 1 Z X 0 0 X 0 X 1 X 1 1 X Z 0 1 Z X X X X X X 普通的信号是不允许多驱动的。SystemC 中引入了解析逻辑向量信号（Resolved LogicalVector signal）来解决多驱动的问题。可以使用下面的方法定义解析型端口： 1234sc_in_rv&lt;n&gt; x; // n 比特宽的解析逻辑向量型输入端口sc_out_rv&lt;n&gt; y;sc_inout_rv&lt;n&gt; z;sc_signal_rv_&lt;n&gt; x; // 宽度为 n 比特的解析型向量信号 信号和变量 信号不能用 in、out 或 inout 来声明，信号的传输方向取决于连接部分的端口状态。 信号常常被用来连接模块和用于进程间通信，变量则用于进程和模块的本地存储。 变量仿真的赋值是立刻发生的，没有 delta 延时；而信号和端口的值刷新要经过一个 delta 延时。 信号应常被综合为逻辑块间的连线；变量常被综合为逻辑块，可以是组合或者时序逻辑。 信号和端口的关联 关联（Association）基本等于连接（Connect），也成为了绑定（Bind）- 关联分为位置关联和名字关联。 12sc_signal&lt;bool&gt; a, b, f;sc_clock clk(\"Clk\", 20, SC_NS); 位置关联：按照端口定义的顺序一一对应适合少量端口的模块，但在大量端口的模块中非常危险，因为可能不经意间修改了端口顺序 12345678910nand2 N2(\"Nand2\");N2.A(a);N2.B(b);N2.F(f);tb tb1(\"tb\");tb1.clk(clk);tb1.a(a);tb1.b(b);tb1.f(f); 1 名字关联：按照名字一一对应对于大的 SystemC 项目，一般建议统一使用名字关联 12345nand2 N2(\"Nand2\");N2(a, b, f);tb tb1(\"tb\");tb1(clk, a, b, f); 构造函数使用 SC_CTOR 标识，构造函数的名字必须与模块的名字相同，用于初始化进程的类型并创建进程的敏感表。 12345678910111213141516171819202122SC_MODULE(Tb){ sc_out&lt;bool&gt; data_source; bool value; void GenInput() { data_source.write(value); value = !value; } SC_CTOR(Tb) { SC_METHOD(GenInput); sensitive_pos &lt;&lt; clk; data_source.initialize(true); // OK value = TRUE; // OK data_source.write(TRUE); // Wrong! data_source = TRUE; // Wrong! }}; 时钟模型在 SystemC 中，时钟被作为一个特殊的对象处理，它就是 sc_clock 类。 时钟端口作为一个特殊的端口，如： 12sc_in_clk clk1;sc_in&lt;bool&gt; clk1; // 两种方式等价 在 SystemC2.0.1 中，sc_clock 一共有 6 个重载的构造函数，如： 12sc_clock(sc_module_name name, const sc_time&amp; period, double duty_cycle = 0.5, const sc_time&amp; start_time = SC_ZERO_TIME, bool posedge_first = true); 定义实例： 1sc_clock clk1(\"clk1\", 20, 0.5 5, true); upload successful 1sc_clock clk2(\"clk2\", 20, 0.5, 0, true); upload successful 另一种定义时钟的办法： 123456789sc_signal&lt;bool&gt; clock;sc_initialize();for (int i = 0; i &lt; 1000; i++){ clock = 1; sc_cycle(5); clock = 0; sc_cycle(5);} 采用这种方法初始化时钟的好处是可以同时插入对其他信号的初始化： 12345678910111213141516clock = 1;sc_cycle(2.5);rst = 1;sc_cycle(2.5);clock = 0;sc_cycle(5);clock = 1;sc_cycle(2.5);rst = 0;sc_cycle(2.5);clock = 0;sc_cycle(5);...... 等价于： 12sc_clock clk(\"main clock\", 10, 0.5);sc_start(10000); 时间单位 时间单位 英文 时间长度（秒） SC_SEC Second 1 SC_MS Millisecond 10-3 SC_US Microsecond 10-6 SC_NS Nanosecond 10-9 SC_PS Picosecond 10-12 SC_FS Femtosecond 10-15 时间模型SystemC 采用基于整数的时间模型，系统时间采用一个 64 位无符号整数来表示。 时间分辨率是仿真系统能够处理的时间的最小精度，比时间分辨率更惊喜的时间将被四舍五入。 假设系统的时间分辨率为 10ps，则 wait(33.667, SC_NS) 实际上等效于 wait(33.67, SC_NS)。 SystemC 缺省时间分辨率为 1ps，同时提供了 sc_set_time_resolution(double, sc_time_unit) 函数来修改系统的时间分辨率。如下面的代码将系统的时间分辨率设置为 10ps： 1sc_set_time_resolution(10, SC_PS); SystemC 缺省时间单位是 SC_NS，同时允许通过 sc_set_default_time_unit(double, sc_time_unit) 来修改缺省的时间单位。如下面的代码将时间单位设置为 100ps： 1sc_set_default_time_unit(100, SC_PS); SystemC 对时间分辨率和时间单位的设置有以下的要求： 必须是 10 的幂 只能在仿真开始之前设置 只能设置一次 时间单位必须大于等于时间分辨率 时间分辨率必须在任何的非零的 sc_time 声明之前设置 在时间单位设置为 100ps 的情况下，下面的 clk1 的周期为 100*100ps=1ns： 1sc_clock clk1(\"clk1\", 10); 数据类型基本数据类型 类型名 类型说明 sc_bit 2 值比特数据类型 sc_logic 4 值比特数据类型 sc_int 1 到 64 比特有符号整型数据类型 sc_uint 1 到 64 比特无符号整型数据类型 sc_bigint 任意宽度的有符号整型数据类型 sc_biguint 任意宽度的无符号整型数据类型 sc_bv 任意宽度的 2 值比特向量数据类型 sc_lv 任意宽度的 4 值比特向量数据类型 sc_fixed 模板类有符号定点数据类型 sc_ufixed 模板类无符号定点数据类型 sc_fix 非模板类有符号定点数据类型 sc_ufix 非模板类无符号定点数据类型 四值逻辑 sc_logic数字系统中最常见的四个逻辑为： 值 表示 描述 0 SC_LOGIC_0 逻辑低电平 1 SC_LOGIC_1 逻辑高电平 Z SC_LOGIC_Z 高阻态 X SC_LOGIC_X 不定值 可以对 sc_bit / sc_logic 类型进行赋值。 在进行代数操作时 sc_bit 可与 C++ 的 bool 类型混合使用，但推荐的做法是多使用 bool 型。 sc_bit 只有 0 和 1 两个值。 sc_logic 数据类型比 sc_bit 多两个值 X 和 Z，它所支持的运算与 sc_bit 一样，如下： 位操作 与 &amp; 或 | 异或 ^ 取反 ~ （没有取反赋值） 赋值操作 与赋值 &amp;= 或赋值 |= 异或赋值 ^= 直接赋值 = 逻辑操作 等于 == 不等于 != 任意宽度整型 sc_intSystemC 中引入了 sc_int&lt;W&gt; 和 sc_uint&lt;W&gt; 来实现 1 到 64 比特中任意宽度的整型数据类型，W&lt;=64。以及 sc_bigint 和 sc_biguint 来实现任意宽度的整型操作。 12sc_int&lt;34&gt; a; // 34 位有符号整数型sc_uint&lt;60&gt; b; // 60 位无符号整型 除最基本操作外，还支持以下操作： 操作 语法 说明 串联 (, ) (a,b) 将 a 和 b 串联起来构造更大的数 范围选择 range(left, right) a,range(x, y) 选择了 a 的右数第 y+1 到第 x+1 位。Y 可以是 0 位选择 [x] a[x] 选择了 a 的右数第 x+1 位 自动增加 ++ 自动减少 -- 位减操作 如下表 位减操作： 语法 说明 a.and_reduce() 返回 a 的所有位相与后得到的 bool 型数 a.nand_reduce() 返回 a 的所有位相与后取反得到的 bool 型数 a.or_reduce() 返回 a 的所有位相或后得到的 bool 型数 a.nor_reduce() 返回 a 的所有位相或后取反得到的 bool 型数 a.xor_reduce() 返回 a 的所有位相异或后得到的 bool 型数 12345sc_int&lt;4&gt; x, y;sc_int&lt;8&gt; z;z = (x, y); // 串联x = z.range(7, 4); // z的高4位bool temp = x.or_reduce(); // 所有位异或 1234sc_biguint&lt;128&gt; b1;sc_biguint&lt;64&gt; b2;sc_biguint&lt;152&gt; b3;b3 = b1 * b2; // 结果有192位，只有低152位被赋值给b3 当一个无符号整数 sc_uint&lt;M&gt; 被赋值给有符号整数 sc_int&lt;N&gt; 时，uint 首先被扩展为 64 位（高位直接填零），然后从低位开始取 N 位赋值给 sc_int。 当 sc_int 被赋值给 sc_uint 时，系统首先将它按符号（负数高位填 1，正数填 0）扩展为 64 位，然后从低位开始取 M 位赋值给 sc_uint。 用户自定义类型1234567891011121314#define MAX_LENGTH 1504struct packet{ sc_uint&lt;16&gt; length; char[MAX_LENGTH] info; sc_int&lt;32&gt; fcs; inline bool operator == (const packet&amp; rhs) const { return rhs.info == info &amp;&amp; rhs.length == length &amp;&amp; rhs.fcs == fcs; }}; 定点数据类型四种基本定点数据类型： sc_fixed sc_ufixed sc_fix sc_ufix sc_fixed 和 sc_ufixed 的参数是静态的，在程序中设定后不能再修改，而 sc_fix 和 sc_ufix 的参数是非静态的，其字长和整数部分长度可以是变量。 定点数据类型的定义方法如下： 1234sc_fixed&lt;wl, iwl, q_mode, o_mode, n_bits&gt; x;sc_ufixed&lt;wl, iwl, q_mode, o_mode, n_bits&gt; y;sc_fix x(list of option);sc_ufix y(list of option); wl：字长，总比特数，必须大于 0 iwl：整数部分字长，可以是正数、负数，也可以大于总字长 q_mode：量化模式。超出精度时根据量化模式对尾数进行取舍 o_mode：溢出模式。超出范围时根据溢出模式对数据进行处理 n_bits：饱和比特的尾数。仅用于具有饱和行为的溢出模式下饱和比特的位数 量化模式： 量化模式 含义 SC_RND 向正无穷舍入 SC_RND_ZERO 向 0 舍入 SC_RND_MIN_INF 向负无穷舍入 SC_RND_INF 向无穷舍入 SC_RND_CONV 收敛舍入 SC_TRN 删除舍入 SC_TRN_ZERO 向 0 删除舍入 定点数据类型的量化示例： 1234sc_fixed&lt;4, 2&gt; x;sc_fixed&lt;3, 2, SC_RND_ZERO, SC_SAT&gt; y;x = 1.25;y = x; // 这里发生了量化 x 的值：二进制为 01.01，十进制为 1.25 y 的值：二进制为 01.0，十进制为 1.0，q=0.5，x=2.5q 饱和模式： 溢出模式 意义 SC_SAT 饱和为最大最小值 SC_SAT_ZERO 饱和为 0 SC_SAT_SYM 对称饱和 SC_WRAP 循环饱和 SC_WRAP_SM 符号幅度循环饱和 定点数据类型饱和示例： 1234sc_fixed&lt;4, 4&gt; x;sc_fixed&lt;3, 3, SC_TRN, SC_SAT&gt; y;x = 5;y = x; // 这里发生饱和，因为 y 的范围是 -4~3，而 x 为 5 x 的值：二进制为 0101，十进制为 5 y 的值：二进制为 011，十进制为 3，q=1 SystemC 的进程在 SystemC 中，进程是程序在并发环境中的执行过程，也是一个基本执行单位，具有动态性、并发性、独立性、异步性和结构性五大特征。 基本进程有三种： SC_METHOD SC_THREAD SC_CTHREAD SC_SLAVE （在 Master/Slave 库中定义的第四种进程类型） 进程不是层次化的，不能包含或直接调用其它进程，但可以调用非进程的函数和方法。 进程通常会有一个敏感表，当在敏感表中的信号上有事件发生时，进程就会被激活。信号上的事件是指信号的值的变化，如时钟的上升沿就是时钟信号从 0 变为 1。当信号上的事件发生，所有对该事件敏感的进程对会被激活。 进程的敏感表在模块的构造函数内设定。 方法进程 SC_METHOD方法进程 SC_METHOD 是唯一的可以综合的寄存器传输级（RTL）进程。 特点是当敏感表上有事件发生，它就会被调用，调用后应该立刻返回。只有该类进程返回后仿真系统的事件才有可能前进，因此该类进程中不能使用 wait() 这样的语句。 示例：全加器 1234567891011121314151617181920#include &lt;systemc.h&gt;SC_MODULE(FullAAdder){ sc_in&lt;sc_bit&gt; A, B, Ci; sc_out&lt;sc_bit&gt; S, Co; void do_ad() { S = A.read() ^ B.read() ^ Ci.read(); Co = (A.read() &amp; B.read()) | (B.read() &amp; Ci.read()) | (A.read() &amp; Ci.read()); } SC_CTOR(FullAdder) { SC_METHOD(do_add); sensitive &lt;&lt; A &lt;&lt; B &lt;&lt; Ci; }} 线程进程 SC_THREAD特点是它能够被挂起和重新激活。线程进程使用 wait() 挂起，当敏感表中有事件发生，线程进程被重新激活运行到遇到新的 wait() 语句再重新挂起。 线程进程不是寄存器传输级进程，一个方便的用途就是用来描述验证平台的输入激励和输出获取。 显示全加器的输入和输出结果1234567891011121314151617181920SC_MODULE(Monitor){ sc_in&lt;sc_bit&gt; m_a, m_b, m_cin, m_sum, m_cout; void prc_monitor() { while (true) { cout &lt;&lt; m_a.read() &lt;&lt; m_b.read() &lt;&lt; m_cin.read() &lt;&lt; \",\"; cout &lt;&lt; m_sum.read() &lt;&lt; m_cout.read() &lt;&lt; endl; wait(); } } SC_CTOR(Monitor) { SC_THREAD(prc_monitor); sensitive &lt;&lt; m_a, m_b, m_cin, m_sum, m_cout; }} 当敏感表中的信号至少有一个值发生变化时，prc_monitor 就会被激活显示这时全加器的输入和输出结果。 钟控线程进程 SC_CTHREADSC_CTHREAD 继承于 SC_THREAD，只能在时钟的上升沿或者下降沿被触发或者激活，这种行为更加接近实际硬件的行为。 SC_CTHREAD 的敏感表与其他类型的线程不同，它必须在指定线程名字的同时指定时钟和它的边沿。 产生全加器的激励123456789101112131415161718192021222324SC_MODULE(Driver){ sc_in_clk clk; sc_out&lt;sc_bit&gt; d_a, d_b, d_cin; sc_uint&lt;3&gt; pattern; void prc_driver() { pattern = 0; while (true) { d_a.write((sc_bit)pattern[0]); d_b.write((sc_bit)pattern[1]); d_cin.write((sc_bit)pattern[2]); wait(); pattern++; } } SC_CTOR(Driver) { SC_CTHREAD(prc_driver, clk.pos()); }} 有限状态机通常意义上的有限状态机要明确定义系统的状态，一般要使用 case 语句来实现状态转移。 隐式有限状态机指编程中不现实定义状态机的状态，而是通过程序中的 wait() 语句和 wait() 语句中间的赋值语句来完成对状态机的描述。 钟控线程进程最适合来描述隐式有限状态机。 挂起wiat_until()将进程挂起直到指定的表达式的值为真，只能用于线程进程和钟控线程进程。 1wait_until(data.delayed() == true); 该语句中的 delayed() 是必须的！ 参数必须是 bool 型，如： 12wait_untile(clock.delayed()== true &amp;&amp; reset.delayed() == false); wait() wait()：等待敏感表中有事件发生 wait(const sc_event&amp;)：等待事件发生 12sc_event e1;wait(e1); wait(sc_event_or_list&amp;)：等待事件之一发生 12sc_event e1, e2, e3;wait(e1 | e2 | e3); wait(sc_event_and_list&amp;)：等待事件全部发生 next_trigger()只能用于 SC_METHOD 类进程。 参数与 wait() 的参数相同，只是分别用于不同类型的进程。 next_trigger() 调用后进程立即返回。 watching()只能用于 SC_CTHREAD 进程。 SC_CTHREAD 进程中通常有一个死循环，但有时候需要初始化一些变量和信号，或者当某些条件满足的时候能够让进程从循环中跳出来。使用 watching 结构可以跳出循环。 watching 结构会不停地监视某一个条件，一旦该条件发生，则 SC_CTHREAD 进程就会跳出循环从进程的开始处重新执行。 12345678910111213141516171819202122232425262728SC_MODULE(Driver){ sc_in_clk clk; sc_in&lt;bool&gt; rst; sc_out&lt;sc_bit&gt; d_a, d_b, d_cin; sc_uint&lt;3&gt; pattern; void prc_driver() { if (rst.read() == true) pattern = 0; while (true) { d_a.write((sc_bit)pattern[0]); d_b.write((sc_bit)pattern[1]); d_cin.write((sc_bit)pattern[2]); wait(); pattern++; } } SC_CTOR(Driver) { SC_CTHREAD(prc_driver, clk.pos()); // 当 rst 为高，进程将会跳出循环重新执行 watching(rst.delayed() == true); }} 局部 watching()在前面的 watching 中，当 watching 的条件成立的时候，整个进程就会重新开始运行，但有的时候会只需要局部代码重新运行，这时候就需要使用局部 watching。 仿真与波形跟踪支持以下三种标准的波形格式： VCD (Value Change Dump) WIF (Waveform Intermediate Format) ISDB (Integrated Signal Data Base) （可能会被淘汰） 只有在整个仿真期间都存在的信号和变量才能被跟踪，这与多数仿真器是一样的。它能够保证模块中的所有信号和数据成员都被跟踪。函数的本地变量只有在函数被调用期间才存在，所以不能跟踪。 任何类型的信号和变量包括标量、数组和其它聚合类型（如结构 struct 类型）都能被跟踪。 不同格式的波形文件可以在同一次仿真过程中同时产生，任何一个信号和变量都可以在不同格式的波形文件中不限制次数的被跟踪。 创建和关闭波形跟踪文件以创建 vcd 波形文件为例。下面代码生成 Wave.vcd 文件： 12sc_trace_file* my_trace_file;my_trace_file = sc_create_ved_trace_file(\"Wave\"); sc_main() 函数调用 return 之前必须关闭波形文件： 1sc_close_ved_trace_file(my_trace_file); 跟踪标量型变量和信号创建了波形跟踪文件后，还必须告诉 SystemC 调度器到底要跟踪那些信号和变量以及被跟踪的信号和变量在波形文件中保存的名字： 1234sc_in&lt;int&gt;datain;sc_out&lt;int&gt; dataout;sc_trace(my_trace_file, datain, \"DataIn\");sc_trace(my_trace_file, dataout, \"DataOut\"); trace() 函数只能在所有的信号和模块已经例化、波形跟踪文件已经产生后才能调用。 跟踪聚合型变量和信号sc_trace() 函数只能跟踪标量类型的信号和变量，为了跟踪聚合类型的变量和信号，你需要重载 sc_trace 函数。所谓聚合类型可以是数组、向量和结构等。 假设我们在设计中定义了下面的结构： 123456struct packet{ BYTE source_address; BYTE destination_address; WORD payload;}; 为了跟踪 packet，我们要重载 sc_trace()函数。 1234567void sc_trace(sc_trace_file *tf, cont packet&amp; v, const sc_string&amp; name){ int i; sc_trace(tf, v.source_address, name + \".src_addr\"); sc_trace(tf, v.destination_address, name + \".dst_addr\"); sc_trace(tf, v.payload, name + \".payload\");} 行为建模系统抽象的三个关键元素： 行为：算法（运算、控制……） 通信：各个算法模块之间的数据交互，控制配合 时序：行为和通信在时间域上的协调 在 SystemC 中，模块是行为的主要载体，通道是通信的主要载体，时序隐含在模块和通道的描述中。 行为和通信分开 支持接口方法调用 端口端口连接模块内的进程（行为）和通道（通信）。 基本的 SystemC 端口类型： sc_in&lt;T&gt; sc_out&lt;T&gt; sc_inout&lt;T&gt; 为了满足行为建模的需要，允许用户自定义端口类型： 1sc_port&lt;InterfaceType, ChannelNumber = 1&gt; 一些端口定义的示例： 123sc_port&lt;ram_if&gt; ram_port1; // 连接到一个RAM上sc_port&lt;ram_if, N&gt; ram_portN; // 可以连接到N个RAM上sc_port&lt;ram_if, 0&gt; ram_port0; // 不限制所连接的RAM数量 可以通过 ram_port0.size() 得到实际连接到 ram_port0 的通道 RAM 的数量。 端口必须与特定的通道接口相连，或者同父模块的端口相连。一个模块的端口连接到零个、一个或者多个通道，或者零个、一个或者多个父模块的端口，但必须至少连接到1个通道或者父模块的端口上。 类 sc_port&lt;IF，N&gt; 是所有端口的基类，它是一个模板类。IF 是接口类型，N 是所连接的同一类型的通道数目，也就是接口数，它的缺省值是 1。 示例：RAM读写端口12345678910111213141516171819202122232425262728293031323334SC_MODULE(Master){ sc_in_clk clk; sc_port&lt;ram_if&lt;int&gt;&gt; ram_port; // 端口实例 int data; unsigned int address; void main_action() { wait(); int i = 0; address = 0; while (i++ &lt; 100) { if ((status = ram_port-&gt;write(address, data))) { /* ... */ } else cout &lt;&lt; \"RAM write fail\" &lt;&lt;endl; if ((status = ram_port-&gt;read(address, data))) { /* ... */ } else cout &lt;&lt; \"RAM read fail\" &lt;&lt; endl; wait(); address++; } } SC_CTOR() { SC_CTHREAD(main_action, clk.pos()); }} 通道在SystemC中，接口本身只是定义了一组通信方法，而不具体负责这些方法如何实现。通道才是这些接口方法的实现者。 通道可以实现一个或者多个接口，也连接一个或者多个模块。 SystemC中通道分为两种：基本通道和分层通道 基本通道不包含任何进程，也不对外展现出任何可见结构，它们也不能够直接的或者间接的调用其它基本通道。 分层通道本身是一个模块，可以包含进程、子模块，也可以包含和调用其它通道。 12345// 端口与通道的关联source1.write_port(fifo1);source1.clk(clk);sink1.read_port(fifo1);sink1.clk(clk); 基本通道基本通道不包含任何进程，也不对外展现出任何可见结构，它们也不能够直接的或者间接的调用其它基本通道。 SystemC2.01中定义了若干基本通道类型，它们是： sc_signal&lt;T&gt; sc_signal_rv&lt;N&gt; sc_mutex sc_fifo&lt;T&gt; sc_semaphore sc_buffer&lt;T&gt; sc_signal sc_signal&lt;T&gt; 是最基本的通道，它用于连接模块的基本端口 sc_in&lt;T&gt;、sc_out&lt;T&gt; 和 sc_inout&lt;T&gt;。 最多只有一个 sc_out&lt;T&gt; 或者 sc_inout&lt;T&gt; 可以连接到 sc_signal&lt;T&gt;，否则就会产生典型的多驱动情况。 可以有多个 sc_in&lt;T&gt; 同时连接到 sc_signal&lt;T&gt;。 sc_signal&lt;T&gt; 继承于基本通道类，并实现了 sc_signal_inout_if&lt;T&gt; 接口。sc_signal_inout_if&lt;T&gt; 接口的最重要成员函数 read() 和 write()。 sc_signal_rtsc_signal_rv&lt;T&gt; 是所谓“解析的”信号通道，与 sc_signal&lt;T&gt; 的不同之处是它允许同时有多个端口连接到其上并进行写操作。 sc_buffersc_buffer&lt;T&gt; 继承于 sc_signal&lt;T&gt;，并重载了 write() 和 update()函数。 sc_buffer&lt;T&gt; 不管 write() 写的数据是否与原数据相同，都要求进行数据更新；而 sc_signal&lt;T&gt; 首先要检查新数据是否与原数据相同，如果不同才进行更新。 sc_fifo sc_fifo&lt;T&gt; 是SystemC核心语言库中已经实现了的 FIFO 通道 write(&amp;T) 代表写 FIFO 的方法。 read()是读 FIFO 的方法，它返回队头单元的数据。 num_free() 用于查询FIFO还有多少空单元。 num_available() 查询FIFO还有多少个数据可以读。 Size 代表FIFO的总单元数，对于 sc_fifo，Size 的默认值为 16。 12sc_fifo&lt;int&gt; fifo1; // 默认深度为16sc_fifo&lt;packet&gt; fifo2(64); 示例：信源和信宿模块通过FIFO通信123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include \"systemc.h\"// 信源模块class source : public sc_module{public: sc_in_clk clk; sc_port&lt;sc_fifo_out_if&lt;char&gt;&gt; write_port; SC_HAS_PROCESS(source); source(sc_module_name name) : sc_module(name) { SC_CTHREAD(main, clk.neg()); } void main() { int i = 0; const char str[] = \"For any problems, feel free to contact the author via Email: chenxiee@mails.tsinghua.edu.cn\"; wait(); while (true) { if (rand() &amp; 1) { if (str[i]) { write_port-&gt;write(str[i++]); wait(); } } } }};// 信宿模块class sink : public sc_module{public: sc_in_clk clk; sc_port&lt;sc_fifo_in_if&lt;char&gt;&gt; read_port; SC_HAS_PROCESS(sink); sink(sc_module_name name) { SC_CTHREAD(main, clk.neg()); } void main() { char c; while (true) { if (rand() &amp; 1) { read_port-&gt;read(c); cout &lt;&lt; c; } wait(); } }};// Top模块#define PERIOD 20class Top : public sc_module{public: sc_clock clk; sc_fifo&lt;char&gt; fifo1; source source1; sink sink1; Top(sc_module_name name, int size) : sc_module(name), fifo1(\"Fifo1\", size), source1(\"source1\"), sink1(\"sink1\"), clk(\"Clk\", PERIOD, SC_NS) { source1.write_port(fifo1); source1.clk(clk); sink1.read_port(fifo1); sink1.clk(clk); }};int sc_main(int, char **){ unsigned size = 16; Top top(\"Top\", size); cout &lt;&lt; \"Testbench started, the simulation result is:\" &lt;&lt; endl; sc_start(100000, SC_NS); cout &lt;&lt; \"\\n\" &lt;&lt; endl; return 0;} 从本例看模块、接口、端口、通道之间的关系： 接口是一个C++抽象类，它定义了一组抽象方法，但不定义这些方法的具体实现。 通道实现一个或者多个接口。也就是说，通道必须继承一个或者多个接口，这些接口中定义的抽象方法必须在通道中实现。 端口总是与一定的接口类型相关联的，端口只能连接到实现了该类接口的通道上。 通过端口，模块中的进程可以连接到通道并使用通道提供的方法 sc_semaphore通常翻译为信号量。 信号量代表可用资源实体的数量，所以可以认为信号量就是一个资源计数器，它限制的是同时使用某共享资源（也称为临界资源）的进程的数量。信号量计数的值代表的就是当前仍然可用的共享资源的数量。 sc_semaphore 实现的是 sc_semaphore_if 接口。 其中，wait() 方法获得一个信号量，其作用效果是获得一份资源的使用权，使信号量计数减一，如下面的实现代码。 sc_mutex具有锁定和非锁定两种状态。当互斥（器）已经由另外的进程锁定，这时申请互斥的进程就会被阻塞，直到锁定互斥的进程将互斥解锁。 直接通道调用在同一模块内，各个进程之间也需要通信。它们可以通过共享变量、握手信号、模块内通道等方式通信。如果它们之间的通信是通过模块内通道，则此时需要进行直接通道调用。 使用 sc_mutex 的直接通道调用的实例： 123456789101112131415sc_in_clk clk;sc_out&lt;int&gt; data;sc_mutex protect;void writer1(){ wait(); while (true) { protect.lock(); data.write(rand()); protect.unlock(); wait(); }} 另一种形式：不通过端口直接调用通道实现： 123456789101112131415161718ram&lt;int&gt;* ram0; // 通道实例的指针void main_action(){ ...; while (address &lt;= end_address) { ram0-&gt;write(address, data); // 不通过端口直接调用通道实现 wait(); } ...;}SC_CTOR(PortLess){ SC_CTHREAD(main_action, clk.pos()); ram0 = new ram&lt;int&gt;(\"RAM\", 0, 255);} 分层通道分层通道具有可见结构，可以包含进程，可以直接调用其它通道，它是一个实现了一个或者多个接口的模块。 常见的分层通道有两种： 一是在一个通道中直接例化并使用其它通道，被例化的通道可以是分层通道，也可以是基本通道。这种类型的通道比较常见，被称为一般分层通道； 二是一个通道利用端口进行间接通道调用，调用穿越了一个以上的通道。被穿过的通道似乎被“合成”到了一起，这种通道是一种特殊的分层通道，称作合成通道（compositechannel）。合成通道间接的体现了通道的层次性。 一般分层通道凡是例化了其它通道的通道都可以归入一般分层通道之列。如下例： 合成通道一个模块可以利用端口穿越了一个以上的通道进行间接通道调用。被穿过的通道似乎被“合成“到了一起。 我们假定设计好了一个接口类 GetFIFO_if，它的一个成员函数 getWriteFIFO() 返回的是一个 FIFO 通道的指针，如返回上节中定义的 tlm_fifo 的指针 tlm_fifo，再假设又我们实现了一个 GetFIFO 通道，data 是一个初始化了的 char 型数据。那么在 Source 模块中就可以通过下面的方式来写 FIFO： 1read_port-&gt;getWriteFIFO()-&gt;write(data); 交易级建模SoC设计中的通信体系结构的抽象层次图： 屏蔽的细节 L3 消息层 资源共享，时序 L2 交易层 时钟，协议 L1 传输层 连线，寄存器 L0 寄存器传输层 门，门/连线延时 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.iwxyi.com/tags/学习笔记/"},{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"SystemC","slug":"SystemC","permalink":"http://blog.iwxyi.com/tags/SystemC/"}]},{"title":"C++使用async将参数传递给函数","date":"2021-06-17T02:47:00.000Z","path":"2021/06/17/C-使用async将参数传递给函数/","text":"async如果第一个参数是指向成员函数的指针，第二个参数则提供了用来应用该成员函数的对象（直接地，或通过指针，或封装在 std::ref 中），其余的参数则作为参数传递给该成员函数。否则，第二个及后续的参数将作为参数，传递给第一个参数是所指定的函数或可调用对象。和 std::thread 一样，如果参数是右值，则通过移动原来的参数来创建副本。这就允许使用只可移动的类型同时作为函数对象和参数。 12345678910111213141516171819202122232425262728293031323334#include &lt;string&gt;#include &lt;future&gt;struct X{ void foo(int, std::string const&amp;); std::string bar(string const&amp;);}X x;auto f1 = std::async(&amp;X::foo, &amp;x, 42, \"hello\"); // x.foo(42, \"hello\");auto f2 = std::async(&amp;X::bar, x, \"goodbye\"); // tempx.bar(\"goodbye\") 副本Xstruct Y{ double operator()(double);}Y y;auto f3 = std::async(Y(), 3.141); // tempy(2.14)，从Y()移动构造auto f4 = std::async(std::ref(y), 2.718); // y(2.714)X baz(X&amp;);std::async(baz, std::ref(x)); // baz(x)class move_only{public: move_only(); move_only(move_only&amp;&amp;); move_only(move_only const&amp;) = delete; move_only&amp; operator=(move_only&amp;&amp;); move_only&amp; operator=(move_only const&amp;) = delete; void operator()();}auto f5 = std::async(move_only()); // tmp()，从std::move(move_only())移动构造 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"多线程","slug":"多线程","permalink":"http://blog.iwxyi.com/tags/多线程/"},{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"}]},{"title":"C++多线程使用condition_cariable等待线程和休眠唤醒","date":"2021-06-17T02:46:00.000Z","path":"2021/06/17/C-多线程使用condition-cariable等待线程和休眠唤醒/","text":"C++提供了两个条件变量的实现：std::condition_variable 和 std::condition_variable_any，这两个都在 &lt;condition_variable&gt; 库的头文件中声明。两者都需要和互斥元一起工作，前者仅限于 std::mutex，后者可以与符合称为类似互斥元的最低标准的任何东西一起工作，因此跟普遍，所以会有大小、性能或者操作系统资源方面的形式的额外代价的可能。 12345678910111213141516171819202122232425262728293031323334std::mutex mut;std::queue&lt;data_chunk&gt; data_queue; // 两个线程直接传递数据的队列std::condition_variable data_cond;void data_preparetion_thread(){ while (more_data_to_prepare()) { data_chunk const data = prepare_data(); std::lock_guard&lt;std::mutex&gt; lk(mut); // 锁定保护队列的互斥元 { data_queue.push(data); } data_cond.notify_one(); // 通知等待中的线程（如果有） }}void data_processing_thread(){ while (true) { std::unique_lock&lt;std::mutex&gt; lk(mut); // 锁定 data_cond.wait(lk, []{ return !data_queue.empty(); }); // 等待 { data_chunk data = data_queue.front(); data_queue.pop(); } lk.unlock(); // 解锁 process(data); if (is_last_chunk(data)) break; }} 当来自数据准备线程中对 notify_one() 的调用通知条件变量时，线程从睡眠状态中苏醒（解除其阻塞），重新获得互斥元上的锁，并再次检查条件，如果条件已经满足，就从 wait() 返回值，互斥元仍被锁定；如果条件不满足，该线程解锁互斥元，并恢复等待。 这就是为什么需要 std::unique_lock 而不是 std::lock_guard ——等待中的线程在等待期间必须解锁互斥元，并在这之后重新将其锁定，而 std::guard_lock 没有提供这样的灵活性。 在对 wait() 的调用中，条件变量可能会对所提供的条件检查任意多次。然而，它总是在互斥元被锁定的情况下这样做，并且当（且仅当）用来测试条件的函数返回 true，它就会立即返回。 当等待线程重新获取互斥元并检查条件时，如果它并非直接响应另一个线程的通知，这就是所谓的伪唤醒。由于所有的这种伪唤醒的次数和频率根据根据定义是不确定的，所以使用对于条件检查具有副作用的函数是不可取的。如果你这样做，就必须做好多次产生副作用的准备。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"多线程","slug":"多线程","permalink":"http://blog.iwxyi.com/tags/多线程/"},{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"}]},{"title":"Vue.js-学习笔记","date":"2021-05-26T02:31:00.000Z","path":"2021/05/26/Vue-js-学习笔记/","text":"基础官方教程：https://cn.vuejs.org/v2/guide/ 示例12345&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt; 12345678910var vue = new Vue({ el: '#app', // 选择器 data: { // 渲染的数据 str: ' ', arr: [' ', ' ', ' '], arr2: [{ }, { }, { }] }, computed: {}, methods: {}}) 1234&lt;div id=\"app\"&gt; {{str}} &lt;br/&gt; &lt;input type=\"text\" v-model=\"str\"/&gt;&lt;/div&gt; 标签语法数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值： 1&lt;span&gt;Message: {{ msg }}&lt;/span&gt; v-if与v-else12&lt;div v-if=\"boolVar\"&gt; true的内容 &lt;/div&gt;&lt;div v-else=\"boolVar\"&gt; false的内容 &lt;/div&gt; 可以把一个 &lt;template&gt; 元素当做不可见的包裹元素，并在上面使用 v-if。最终的渲染结果将不包含 &lt;template&gt; 元素（v-for也可）： 1&lt;template v-if=\"ok\"&gt;...&lt;/template&gt; v-else-if1234&lt;div v-if=\"type === 'A'\"&gt; A &lt;/div&gt;&lt;div v-else-if=\"type === 'B'\"&gt; B &lt;/div&gt;&lt;div v-else-if=\"type === 'C'\"&gt; C &lt;/div&gt;&lt;div v-else&gt; Not A/B/C &lt;/div&gt; 用key管理可复用的元素Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换： 12345678&lt;template v-if=\"loginType === 'username'\"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder=\"Enter your username\"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder=\"Enter your email address\"&gt;&lt;/template&gt; 那么在上面的代码中切换 loginType 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，&lt;input&gt; 不会被替换掉——仅仅是替换了它的 placeholder。 这样也不总是符合实际需求，所以 Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 key attribute 即可： 12345678&lt;template v-if=\"loginType === 'username'\"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder=\"Enter your username\" key=\"username-input\"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder=\"Enter your email address\" key=\"email-input\"&gt;&lt;/template&gt; 现在，每次切换时，输入框都将被重新渲染。 注意，&lt;label&gt; 元素仍然会被高效地复用，因为它们没有添加 key attribute。 v-show另一个用于根据条件展示元素的选项是 v-show 指令。用法大致一样： 1&lt;h1 v-show=\"ok\"&gt;Hello!&lt;/h1&gt; 不同的是带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS property display。 注意，v-show 不支持 &lt;template&gt; 元素，也不支持 v-else。 v-if vs v-show v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 v-for在 v-for 块中，可以访问所有父作用域的 property。 遍历数组123456789101112131415161718192021222324252627282930313233343536&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;!-- 未排序 --&gt; &lt;li v-for=\"val in ss\"&gt; {{val}} &lt;/li&gt; &lt;!-- 使用 computed 排序 --&gt; &lt;li v-for=\"val in newSs\"&gt; {{val}} &lt;/li&gt; &lt;!-- 带索引 --&gt; &lt;li v-for=\"(val, index) in ss\"&gt; {{index}}-&gt;{{val}} &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; var name = new Vue({ el: '#app', // 选择器 data: { // 渲染的数据 ss: ['s1', 's3', 'S2'] }, computed: { // 运算 // 可指定排序算法（其实是个新的数组了） newSs: function() { // 如果不指定排序方法，默认首字母排序 return this.ss.sort(sortNum); } } }) // 值从小到大排序 function sortNum(a, b) { return a - b; }&lt;/script&gt; 其中in可以替换为of： 1&lt;div v-for=\"item of items\"&gt;&lt;/div&gt; 遍历对象 在遍历对象时，会按 Object.keys() 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下都一致。 123&lt;li v-for=\"value in object\"&gt; {{ value }}&lt;/li&gt; 也可以提供第二个的参数为 property 名称 (也就是键名)： 123&lt;div v-for=\"(value, name) in object\"&gt; {{ name }}: {{ value }}&lt;/div&gt; 还可以用第三个参数作为索引： 123&lt;div v-for=\"(value, name, index) in object\"&gt; {{ index }}. {{ name }}: {{ value }}&lt;/div&gt; 维护状态它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key attribute。 123&lt;div v-for=\"item in items\" v-bind:key=\"item.id\"&gt; &lt;!-- 内容 --&gt;&lt;/div&gt; 不要使用对象或数组之类的非基本类型值作为 v-for 的 key。请用字符串或数值类型的值。 数组更新检测注意：由于 JavaScript 的限制，Vue 不能检测数组和对象的变化，只是侦听一些方法的调用。 变更方法Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括： push() pop() shift() unshift() splice() sort() reverse() 你可以打开控制台，然后对前面例子的 items 数组尝试调用变更方法。比如 vm.items.push({ message: 'Baz' })。 替换数组filter()、concat() 和 slice()等，不会变更原始数组，而总是返回一个新数组。 123vm.items = vm.items.filter(function (item) { return item.message.match(/Foo/)}) Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的启发式方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。 数值循环123&lt;div&gt; &lt;span v-for=\"n in 10\"&gt;{{ n }} &lt;/span&gt;&lt;/div&gt; 会重复 1 ~ 10。 v-for 与 v-if 一同使用不推荐在同一元素上使用 v-if 和 v-for。 当它们处于同一节点，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。当你只想为部分项渲染节点时，这种优先级的机制会十分有用，如下： 123&lt;li v-for=\"todo in todos\" v-if=\"!todo.isComplete\"&gt; {{ todo }}&lt;/li&gt; 上面的代码将只渲染未完成的 todo。 而如果你的目的是有条件地跳过循环的执行，那么可以将 v-if 置于外层元素 (或 template) 上。如： 123456&lt;ul v-if=\"todos.length\"&gt; &lt;li v-for=\"todo in todos\"&gt; {{ todo }} &lt;/li&gt;&lt;/ul&gt;&lt;p v-else&gt;No todos left!&lt;/p&gt; 在组件上使用v-for123456&lt;my-component v-for=\"(item, index) in items\" v-bind:item=\"item\" v-bind:index=\"index\" v-bind:key=\"item.id\"&gt;&lt;/my-component&gt; 组件中的 :key 是必需的。 简单的 todo 列表例子123456789101112131415161718&lt;div id=\"todo-list-example\"&gt; &lt;form v-on:submit.prevent=\"addNewTodo\"&gt; &lt;label for=\"new-todo\"&gt;Add a todo&lt;/label&gt; &lt;input v-model=\"newTodoText\" id=\"new-todo\" placeholder=\"E.g. Feed the cat\" &gt; &lt;button&gt;Add&lt;/button&gt; &lt;/form&gt; &lt;ul&gt; &lt;li is=\"todo-item\" v-for=\"(todo, index) in todos\" v-bind:key=\"todo.id\" v-bind:title=\"todo.title\" v-on:remove=\"todos.splice(index, 1)\" &gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 注意这里的 is=\"todo-item\" attribute。这种做法在使用 DOM 模板时是十分必要的，因为在 &lt;ul&gt; 元素内只有 &lt;li&gt; 元素会被看作有效内容。这样做实现的效果与 &lt;todo-item&gt; 相同，但是可以避开一些潜在的浏览器解析错误。 12345678910111213141516171819202122232425262728293031323334Vue.component('todo-item', { template: '&lt;li&gt;\\ {{ title }}\\ &lt;button v-on:click=\"$emit(\\'remove\\')\"&gt;Remove&lt;/button&gt;\\ &lt;/li&gt;', props: ['title']});new Vue({ el: '#todo-list-example', data: { newTodoText: '', todos: [ { id: 1, title: 'Do the dishes', }, { id: 2, title: 'Take out the trash', } ], nextTodoId: 3 }, methods: { addNewTodo: function () { this.todos.push({ id: this.nextTodoId++, title: this.newTodoText }) this.newTodoText = '' } }}) v-text / v-html1234&lt;!-- 会输出标签 --&gt;&lt;span v-text=\"msg\"&gt;&lt;/span&gt;&lt;!-- 原模原样输出 --&gt;&lt;span v-html=\"msg\"&gt;&lt;/span&gt; v-on 事件绑定简写示例：&lt;a @click=\"doSomething\"&gt;...&lt;/a&gt;、&lt;a @[event]=\"doSomething\"&gt; ... &lt;/a&gt; 可以是直接运行JS语句、调用vue的method（无参、有参皆可）。 123456789101112131415161718var vm = new Vue({ el: '#app', data: { num: 10, addNum: 0 }, methods: { add: function(){ return this.num++; }, cut: function(){ return this.num--; }, onEnter: function(event){ this.num += parseInt(this.addNum); // event 是原生 DOM 事件，可忽略 if (event) { alert(event.target.tagName) } } }}) 12345&lt;button v-on:click=\"add\"&gt;+1&lt;/button&gt;&lt;button @click=\"cut\"&gt;-1&lt;/button&gt;&lt;!-- 相加；13是enter键 --&gt;&lt;input type=\"text\" v-model=\"addNum\" @keyup.13=\"onEnter\"/&gt; HTML的 onclick=\"func()\" 带有括号，Vue的不带括号 或者带参数的方式： 12&lt;button v-on:click=\"modify(1)\"&gt;+1&lt;/button&gt;&lt;button @click=\"modify(-1)\"&gt;-1&lt;/button&gt; 原生DOM事件有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法： 1&lt;button v-on:click=\"warn('Form cannot be submitted yet.', $event)\"&gt; Submit &lt;/button&gt; 12345678910// ...methods: { warn: function (message, event) { // 现在我们可以访问原生事件对象 if (event) { event.preventDefault() } alert(message) }} 事件修饰符修饰符是由点开头的指令后缀来表示的。 .stop .prevent .capture .self .once .passive 1234567891011121314151617181920212223242526272829&lt;!-- 阻止单击事件继续传播 --&gt;&lt;a v-on:click.stop=\"doThis\"&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=\"doThat\"&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;&lt;div v-on:click.capture=\"doThis\"&gt;...&lt;/div&gt;&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;&lt;!-- 即事件不是从内部元素触发的 --&gt;&lt;div v-on:click.self=\"doThat\"&gt;...&lt;/div&gt;&lt;!-- 2.1.4新增：点击事件将只会触发一次 --&gt;&lt;a v-on:click.once=\"doThis\"&gt;&lt;/a&gt;&lt;!-- 2.3.0新增： 对应 addEventListener 中的 passive 选项--&gt;&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;&lt;!-- 而不会等待 `onScroll` 完成 --&gt;&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;&lt;!-- 这个 .passive 修饰符尤其能够提升移动端的性能 --&gt;&lt;div v-on:scroll.passive=\"onScroll\"&gt;...&lt;/div&gt; 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。 因此，用 v-on:click.prevent.self 会阻止所有的点击， 而 v-on:click.self.prevent 只会阻止对元素自身的点击。 按键修饰符12&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;&lt;input v-on:keyup.enter=\"submit\"&gt; 你可以直接将 KeyboardEvent.key 暴露的任意有效按键名转换为 kebab-case 来作为修饰符。 1&lt;input v-on:keyup.page-down=\"onPageDown\"&gt; 在上述示例中，处理函数只会在 $event.key 等于 PageDown 时被调用。 已经废弃的使用 keyCode attribute 也是允许的，但可能不会被最新的浏览器支持： 1&lt;input v-on:keyup.13=\"submit\"&gt; 有一些按键 (.esc 以及所有的方向键) 在 IE9 中有不同的 key 值, 如果你想支持 IE9，这些内置的别名应该是首选。 你还可以通过全局 config.keyCodes 对象自定义按键修饰符别名： 12// 可以使用 v-on:keyup.f1Vue.config.keyCodes.f1 = 112 系统修饰键可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。 .ctrl .alt .shift .meta 注意：在 Mac 上，meta 对应 command 键 (⌘)。在 Windows 系统键盘 meta 对应 Windows 徽标键 (⊞)。其他系统类似。 12345&lt;!-- Alt + C --&gt;&lt;input v-on:keyup.alt.67=\"clear\"&gt;&lt;!-- Ctrl + Click --&gt;&lt;div v-on:click.ctrl=\"doSomething\"&gt;Do something&lt;/div&gt; 只有在按住 ctrl 的情况下释放其它按键，才能触发 keyup.ctrl。而单单释放 ctrl 也不会触发事件。如果你想要这样的行为，请为 ctrl 换用 keyCode：keyup.17。 .extra修饰符.exact 修饰符允许你控制由精确的系统修饰符组合触发的事件。 12345678&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;&lt;button v-on:click.ctrl=\"onClick\"&gt;A&lt;/button&gt;&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;&lt;button v-on:click.ctrl.exact=\"onCtrlClick\"&gt;A&lt;/button&gt;&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;&lt;button v-on:click.exact=\"onClick\"&gt;A&lt;/button&gt; 鼠标按钮修饰符 .left .right .middle 这些修饰符会限制处理函数仅响应特定的鼠标按钮。 v-model双向绑定，有以下的修饰符： lazy延迟绑定 input框失去焦点之后才会引起改变 1&lt;input type=\"text\" v-model.lazy=\"num\" /&gt; number数据转换 input框转换过来的数值自动变成number（默认是string） 1&lt;input type=\"text\" v-model.number=\"num\" /&gt; 去除空格 1&lt;input type=\"text\" v-model.trim=\"msg\" /&gt; 表单中的v-modelv-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件： text 和 textarea 元素使用 value property 和 input 事件； checkbox 和 radio 使用 checked property 和 change 事件； select 字段将 value 作为 prop 并将 change 作为事件。 单个复选框 checkbox的值会映射到bool中（默认值为bool的默认值） 123&lt;input type=\"checkbox\" id=\"Check1\" value=\"Val1\" v-model=\"checked\" /&gt;&lt;label for=\"Check1\"&gt;{{checked}}&lt;/label&gt;&lt;!-- true/false --&gt; 多个复选框绑定一个数组 123456&lt;input type=\"checkbox\" id=\"Check1\" value=\"Val1\" v-model=\"arr\" /&gt;&lt;input type=\"checkbox\" id=\"Check2\" value=\"Val2\" v-model=\"arr\" /&gt;&lt;input type=\"checkbox\" id=\"Check3\" value=\"Val3\" v-model=\"arr\" /&gt;&lt;!-- [\"Val1\", \"Val3\"] --&gt;{{arr}} 多个单选框 1234567&lt;input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\" /&gt;&lt;label for=\"one\"&gt;one&lt;/label&gt;&lt;input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\" /&gt;&lt;label for=\"two\"&gt;two&lt;/label&gt;&lt;!-- One/Two --&gt;{{picked}} 下拉列表 可以单选也可以多选。单选时是一个字符串，多选时是绑定到一个数组 1234data:{ selected: '', array:[]} 1234567&lt;select v-model=\"array\" multiple&gt; &lt;option disabled value=\"\"&gt;请选择&lt;/option&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt;&lt;/select&gt;{{array}} 如果 v-model 表达式的初始值未能匹配任何选项，&lt;select&gt; 元素将被渲染为“未选中”状态。在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 change 事件。因此，更推荐像上面这样提供一个值为空的禁用选项。 值绑定有时我们可能想把值绑定到 Vue 实例的一个动态 property 上，这时可以用 v-bind 实现，并且这个 property 的值可以不是字符串。 复选框 123456&lt;input type=\"checkbox\" v-model=\"toggle\" true-value=\"yes\" false-value=\"no\"&gt; 1234// 当选中时vm.toggle === 'yes'// 当没有选中时vm.toggle === 'no' 这里的 true-value 和 false-value attribute 并不会影响输入控件的 value attribute，因为浏览器在提交表单时并不会包含未被选中的复选框。如果要确保表单中这两个值中的一个能够被提交，(即“yes”或“no”)，请换用单选按钮。 单选按钮 1&lt;input type=\"radio\" v-model=\"pick\" v-bind:value=\"a\"&gt; 12// 当选中时vm.pick === vm.a 选择框 1234&lt;select v-model=\"selected\"&gt; &lt;!-- 内联对象字面量 --&gt; &lt;option v-bind:value=\"{ number: 123 }\"&gt;123&lt;/option&gt;&lt;/select&gt; 123// 当选中时typeof vm.selected // =&gt; 'object'vm.selected.number // =&gt; 123 修饰符.lazy 在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了输入法组合文字时)。你可以添加 lazy 修饰符，从而转为在 change 事件_之后_进行同步： 12&lt;!-- 在“change”时而非“input”时更新 --&gt;&lt;input v-model.lazy=\"msg\"&gt; .number 如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符： 1&lt;input v-model.number=\"age\" type=\"number\"&gt; 这通常很有用，因为即使在 type=\"number\" 时，HTML 输入元素的值也总会返回字符串。如果这个值无法被 parseFloat() 解析，则会返回原始的值。 .trim 如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符： 1&lt;input v-model.trim=\"msg\"&gt; v-bind 属性绑定能绑定例如 v-bind:id、v-bind:disabled 等。 简写示例：&lt;a :href=\"url\"&gt;...&lt;/a&gt;、&lt;a :[key]=\"url\"&gt; ... &lt;/a&gt; img.src绑定 1&lt;img v-bind:src=\"imageSrc\" :width=\"width\" /&gt; 1234data:{ imageSrc: 'http://xxx', width: '200'} v-bind:class123456789&lt;style&gt; .classA{} .classB{}&lt;/style&gt;&lt;!-- 单个style；与v-bind:class与普通class可共存 --&gt;&lt;div class=\"xxx\" :class=\"style0\"&gt;&lt;/div&gt;&lt;!-- style数组 --&gt;&lt;div :class=\"[style1, style2]\"&gt;&lt;/div&gt; 12345data: { style0: 'classA', style1: 'classA', style2: 'classB'} style判断 12345678&lt;!-- 单个style --&gt;&lt;div :class=\"{style0:false}\"&gt;&lt;/div&gt;&lt;div class=\"style0\" v-bind:class= \"{ style1: isActive1, 'style-name': isActive2 }\" &gt;&lt;/div&gt;&lt;!-- style数组形式 --&gt;&lt;div :class=\"[boolVar ? style1 : style2, style3]\"&gt;&lt;/div&gt; 复杂style对象 1&lt;div v-bind:class=\"classObject\"&gt;&lt;/div&gt; 123456data: { classObject: { style1: true, 'styleb': false }} 也可以是下面的： 123456789101112data: { isActive: true, error: null},computed: { classObject: function () { return { active: this.isActive &amp;&amp; !this.error, 'text-danger': this.error &amp;&amp; this.error.type === 'fatal' } }} 用在组件上 当在一个自定义组件上使用 class property 时，这些 class 将被添加到该组件的根元素上面。这个元素上已经存在的 class 不会被覆盖。 例如，如果你声明了这个组件： 123Vue.component('my-component', { template: '&lt;p class=\"foo bar\"&gt;Hi&lt;/p&gt;'}) 然后在使用它的时候添加一些 class： 1&lt;my-component class=\"baz boo\"&gt;&lt;/my-component&gt; HTML 将被渲染为： 1&lt;p class=\"foo bar baz boo\"&gt;Hi&lt;/p&gt; 对于带数据绑定 class 也同样适用： 1&lt;my-component v-bind:class=\"{ active: isActive }\"&gt;&lt;/my-component&gt; 当 isActive 为 true 时，HTML 将被渲染成为： 1&lt;p class=\"foo bar active\"&gt;Hi&lt;/p&gt; v-bind:style与class的区别是，这是内联样式。 看着非常像 CSS，但其实是一个 JavaScript 对象。CSS property 名可以用驼峰式或短横线分隔 (kebab-case，记得用引号括起来) 来命名： 12345&lt;div v-bind:style=\"{ color: activeColor, fontSize: fontSize + 'px' }\"&gt;&lt;/div&gt;data: { activeColor: 'red', fontSize: 30} 直接绑定到一个样式对象通常更好，这会让模板更清晰： 1234567&lt;div v-bind:style=\"styleObject\"&gt;&lt;/div&gt;data: { styleObject: { color: 'red', fontSize: '13px' }} 同样的，对象语法常常结合返回对象的计算属性使用。 数组语法 将多个样式对象应用到同一个元素上： 1&lt;div v-bind:style=\"[baseStyles, overridingStyles]\"&gt;&lt;/div&gt; 自动添加前缀 当 v-bind:style 使用需要添加浏览器引擎前缀的 CSS property 时，如 transform，Vue.js 会自动侦测并添加相应的前缀。 多重值 从 2.3.0 起你可以为 style 绑定中的 property 提供一个包含多个值的数组，常用于提供多个带前缀的值，例如： 1&lt;div :style=\"{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }\"&gt;&lt;/div&gt; 这样写只会渲染数组中最后一个被浏览器支持的值。在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 display: flex。 使用JS表达式1234{{ number + 1 }}{{ ok ? 'YES' : 'NO' }}{{ message.split('').reverse().join('') }}&lt;div v-bind:id=\"'list-' + id\"&gt;&lt;/div&gt; 有个限制就是，每个绑定都只能包含单个表达式，所以下面的例子都不会生效。 12345&lt;!-- 这是语句，不是表达式 --&gt;{{ var a = 1 }}&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;{{ if (ok) { return message } }} 模板表达式都被放在沙盒中，只能访问全局变量的一个白名单，如 Math 和 Date 。你不应该在模板表达式中试图访问用户定义的全局变量。 绑定动态属性从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数： 12&lt;!-- 注意，参数表达式的写法存在一些约束 --&gt;&lt;a v-bind:[attributeName]=\"url\"&gt; ... &lt;/a&gt; 这里的 attributeName 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。 同样地，你可以使用动态参数为一个动态的事件名绑定处理函数： 1&lt;a v-on:[eventName]=\"doSomething\"&gt; ... &lt;/a&gt; 在这个示例中，当 eventName 的值为 \"focus\" 时，v-on:[eventName] 将等价于 v-on:focus。 对动态参数的值的约束动态参数预期会求出一个字符串，异常情况下值为 null。这个特殊的 null 值可以被显性地用于移除绑定。任何其它非字符串类型的值都将会触发一个警告。 对动态参数表达式的约束动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 HTML attribute 名里是无效的。例如： 12&lt;!-- 这会触发一个编译警告 --&gt;&lt;a v-bind:['foo' + bar]=\"value\"&gt; ... &lt;/a&gt; 变通的办法是使用没有空格或引号的表达式，或用计算属性替代这种复杂表达式。 还需要避免使用大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写。 修饰符以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()： 1&lt;form v-on:submit.prevent=\"onSubmit\"&gt;...&lt;/form&gt; 杂项API 和其余部分有些重复，稍微看看就好 Vue实例当一个 Vue 实例被创建时，它将 data 对象中的所有的 property 加入到 Vue 的响应式系统中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。只有当实例被创建时就已经存在于 data 中的 property 才是响应式的。 12345678910111213141516171819// 我们的数据对象var data = { a: 1 }// 该对象被加入到一个 Vue 实例中var vm = new Vue({ data: data})// 获得这个实例上的 property返回源数据中对应的字段// 但是使用a的话视图不会自动响应（若要使用，可以创建时设置为空或null）vm.a == data.a // =&gt; true// 设置 property 也会影响到原始数据vm.a = 2data.a // =&gt; 2// ……反之亦然data.a = 3vm.a // =&gt; 3 这里唯一的例外是使用 Object.freeze()，这会阻止修改现有的 property，也意味着响应系统无法再追踪变化。 一些有用的实例 property 与方法。它们都有前缀 $，以便与用户定义的 property 区分开来： 123456vm.$data === data // =&gt; truevm.$el === document.getElementById('example') // =&gt; truevm.$watch('a', function (newValue, oldValue) { // 这个回调将在 `vm.a` 改变后调用}) Vue.extend构造一个组件的语法器 1&lt;div id=\"header\"&gt;&lt;/div&gt; 1234567var header = Vue.extend({ template: '&lt;p&gt;{{message}}&lt;/p&gt;', data: function() { return { message: 'This is header'; } }})new header().$mount('#header'); // 挂载 Vue.set设置数据响应 1234567&lt;ul&gt; &lt;li v-for=\"val in goods\"&gt; {{val.name}} - {{val.num}}&lt;/li&gt;&lt;/ul&gt;总计{{count}}件产品&lt;button onclick=\"add()\"&gt;添加&lt;/button&gt;&lt;button @click=\"clear\"&gt;清空&lt;/button&gt; 1234567891011121314151617181920212223242526var sql = { count: 3, goods: [{name: '物品0', num: '2'}, {xxx}, {xxx}]}var vm = new Vue({ el: '#app', data: sql, method: { clear: function(){ this.count = 0; this.goods = []; // 将两个都设置为null，可禁用添加 } }})// 直接使用setfunction testSet() { Vue.set(sql, 'count', '4');}// 挨个添加function add() { sql.goods.push({name:'物品3', num: '1'}); sql.count++;} 生命周期 beforeCreate 初始化之后 created 创建完成 beforeMount 挂载之前 mounted 被创建 — 开始操作的位置 — beforeUpdate 数据更新前 updated 数据更新之后 beforeDestroy 销毁之前（使用 vm.$destroy()） destroyed 销毁之后 组件 component注册一个全局组件，使用： 1Vue.component(tagName, options); 123456789&lt;hello&gt;&lt;/hello&gt;&lt;script&gt;// 可以在不是'#app'的作用域外中使用（但也必须是其他的el，不能是没el的）Vue.component('hello', { template: '&lt;div&gt;全局化注册的组件&lt;/div&gt;'});var vm = new Vue({ /*...*/ })&lt;/script&gt; 局部组件 12345678910111213// 只能应用在对应 'app' 中的组件word = { template: '&lt;div&gt;局部化注册的组件&lt;/div&gt;'}var vm = new Vue({ el: '#app', data: { msg: '' }, // 这里的语法的双引号和全局组件正好相反 components: { // 注意这里多了个s，因为是可以多个的 \"world\": world; }}) 带参数的component123456789&lt;div id=\"app-7\"&gt; &lt;ol&gt; &lt;!-- 为每个 todo-item 提供 todo 对象，其内容可以是动态的 --&gt; &lt;todo-item v-for=\"item in groceryList\" v-bind:todo=\"item\" v-bind:key=\"item.id\" &gt;&lt;/todo-item&gt; &lt;/ol&gt;&lt;/div&gt; 1234567891011121314151617Vue.component('todo-item', { // todo-item 组件现在接受一个 \"prop\"，类似一个自定义 attribute。 // 这个 prop 名为 todo props: ['todo'], template: '&lt;li&gt;{{ todo.text }}&lt;/li&gt;'})var app7 = new Vue({ el: '#app-7', data: { groceryList: [ { id: 0, text: '蔬菜' }, { id: 1, text: '奶酪' }, { id: 2, text: '随便其它什么人吃的东西' } ] }}) Vue选项computed可以在使用时进行函数计算而不是使用computed，两种结果方式完全相同；但计算属性是基于它们的响应式依赖进行缓存的，只要属性值没变，就不必再次执行函数。 示例：计算 fullName 123456789101112var vm = new Vue({ el: '#demo', data: { firstName: 'Foo', lastName: 'Bar' }, computed: { fullName: function () { return this.firstName + ' ' + this.lastName } }}) 计算属性的setter1234567891011121314computed: { fullName: { // getter get: function () { return this.firstName + ' ' + this.lastName }, // setter set: function (newValue) { var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] } }} 运行 vm.fullName = 'John Doe' 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。 methodwatch12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;p&gt;原价：￥{{prevPrice}]&lt;/p&gt;&lt;p&gt;折扣：{{sale}]&lt;/p&gt;&lt;p&gt;现价：￥{{newPrice}]&lt;/p&gt;&lt;button @click=\"add\"&gt;+&lt;/button&gt;&lt;button @click=\"cut\"&gt;+&lt;/button&gt;&lt;script&gt;var vm = new Vue({ el: '#app', data { prevPrice: 10, sale: 0.8 }, computed: { newPrice: function(){ return '￥' + this.prevPrice * this.sale; } }, methods: { add: function() { this.prevPrice++; }, cut: function() { this.prevPrice--; } }, // 写法一：局部 watch: { prevPrice: function(newVal, oldVal) { if (newVal &lt; 1) { // 不允许减到 1 以下 this.prevPrice = 1; } } }});// 写法二：全局（两种方法写一个就够了）vm.$watch('prevPrice', function(newVal, oldVal) { if (newVal &lt; 1) { // 不允许减到 1 以下 this.prevPrice = 1; }});&lt;/script&gt; propsprops 可以是数组或对象，用于接收来自父组件的数据 123Vue.component('simple', { props: ['size', 'myMessage']}) mixin 混入接收一个混合对象的数组。这些混合实例对象可以像正常的示例对象一样包含选项，他们将在 Vue.extend() 里最终选择使用相同的选项合并逻辑合并。 12345678910111213141516171819&lt;script&gt;var mix = { created: function() { // 先执行被混入的生命周期，再执行构造器原装的 this.msg = '被混入的'; // 修改data中的值 }};var vm = new Vue({ el: '#app', data { msg: 'hello world' }, created: function() { // 构造器原装的生命周期 }, mixins: [mix]});&lt;/script&gt; 实例 $mount() 挂载 $destroy() 卸载 $forceUpdate() 更新（迫使Vue实例重新渲染） $nextTick() 回调 $on() 监听当前实例上的自定义事件 $once 监听第一个自定义事件，但是只触发一次；之后移除监听器 $emit() 触发当前实例上的事件 $off() 移除事件监听器 1234567891011121314151617181920212223242526272829303132&lt;div id='header'&gt;&lt;/div&gt;&lt;button onclick=\"destroy()\"&gt;卸载&lt;/button&gt;&lt;script&gt;var header = Vue.extend({ template: '&lt;p&gt;{{message}}&lt;/p&gt;', data: function() { return { message: 'This is header'; } }, destroyed: function() { console.log(\"控制器和视图脱离关系了\"); }})// 绑定 id='header' 的组件var vm = new header().$mount('#header');// 卸载function destroy() { vm.$destroy(); // 卸载之后其实是看不到区别的，因为控制器和视图脱离关系了}// 回调function testTick() { vm.$nextTick(function() { alert('我是回调函数'); })}&lt;/script&gt; 事件123456789101112131415161718// 绑定事件（添加监听器）vm.$on('added', function(num){ this.count += num;});// 和上面的区别就是只触发一次vm.$once('cutted', function(num){ this.count -= num;});function add() { vm.$emit('added', '2');}// 移除监听器function remove() { vm.$off('added');} slot 扩展标签内容的扩展，常与组件component联合使用 1&lt;slot name=''&gt;&lt;/slot&gt; 1234567891011121314151617181920212223242526272829303132&lt;div id='app'&gt; &lt;goods v-for=\"val in good\"&gt; &lt;!-- 注意slot是要双标签，单标签没有任何效果的 --&gt; &lt;span slot=\"name\"&gt;{{val.name}}&lt;/span&gt; &lt;span slot=\"num\"&gt;{{val.num}}&lt;/span&gt; &lt;/goods&gt;&lt;/div&gt;&lt;template id=\"demo\"&gt; &lt;p&gt; 名称：&lt;slot name=\"name\"&gt;&lt;/slot&gt; 数量：&lt;slot name=\"num\"&gt;&lt;/slot&gt; &lt;/p&gt;&lt;/template&gt;&lt;script&gt;goods = { template: '#demo'}var vm= new Vue({ el: '#app', data: { good: [ {name: 'car', num: '1'}, {name: 'house', num: '2'} ] }, components: { \"goods\": goods // 其实就是id=demo }})&lt;/script&gt; Ajax123456beforeMount: function(){ // 数据挂载之前 // 这是 jquery 的 $.get('1.txt', function(result){ $('#app').html(result); })} 组件基础基本示例12345678new Vue({ el: '#components-demo' });// 定义一个名为 button-counter 的新组件Vue.component('button-counter', { data: function () { return { count: 0 } }, template: '&lt;button v-on:click=\"count++\"&gt;You clicked me {{ count }} times.&lt;/button&gt;'}) 组件是可复用的 Vue 实例，且带有一个名字：在这个例子中是 &lt;button-counter&gt;。我们可以在一个通过 new Vue 创建的 Vue 根实例中，把这个组件作为自定义元素来使用： 123&lt;div id=\"components-demo\"&gt; &lt;button-counter&gt;&lt;/button-counter&gt;&lt;/div&gt; 注意当点击按钮时，每个组件都会各自独立维护它的 count。 此处的示例是全局注册，可以用在其被注册之后的任何新创建的 Vue 根实例。 data 必须是一个函数data 并不是直接提供一个对象，而必须是一个函数。因此每个实例可以维护一份被返回对象的独立的拷贝。 如果 Vue 没有这条规则，点击一个按钮就可能会影响到其它所有实例。 Prop 向子组件传递数据Prop 在组件上注册的一些自定义 attribute，包含在该组件可接受的 prop 列表中： 1234Vue.component('blog-post', { props: ['title'], template: '&lt;h3&gt;{{ title }}&lt;/h3&gt;'}) 1&lt;blog-post title=\"My journey with Vue\"&gt;&lt;/blog-post&gt; 然而在一个典型的应用中，你可能在 data 里有一个博文的数组： 12345678910new Vue({ el: '#blog-post-demo', data: { posts: [ { id: 1, title: 'My journey with Vue' }, { id: 2, title: 'Blogging with Vue' }, { id: 3, title: 'Why Vue is so fun' } ] }}) 并想要为每篇博文渲染一个组件： 12345&lt;blog-post v-for=\"post in posts\" v-bind:key=\"post.id\" v-bind:title=\"post.title\" &gt;&lt;/blog-post&gt; 如上所示，你会发现我们可以使用 v-bind 来动态传递 prop。 单个根元素每个组件必须只有一个根元素，可以将模板的内容包裹在一个父元素内，来修复这个问题，例如： 1234&lt;div class=\"blog-post\"&gt; &lt;h3&gt;{{ title }}&lt;/h3&gt; &lt;div v-html=\"content\"&gt;&lt;/div&gt;&lt;/div&gt; 当组件变得越来越复杂的时候，尝试重构一下这个 &lt;blog-post&gt; 组件，让它变成接受一个单独的 post prop： 12345&lt;blog-post v-for=\"post in posts\" v-bind:key=\"post.id\" v-bind:post=\"post\" &gt;&lt;/blog-post&gt; 123456789Vue.component('blog-post', { props: ['post'], template: ` &lt;div class=\"blog-post\"&gt; &lt;h3&gt;{{ post.title }}&lt;/h3&gt; &lt;div v-html=\"post.content\"&gt;&lt;/div&gt; &lt;/div&gt; `}) 上述的这个和一些接下来的示例使用了 JavaScript 的模板字符串来让多行的模板更易读。它们在 IE 下并没有被支持，所以如果你需要在不 (经过 Babel 或 TypeScript 之类的工具) 编译的情况下支持 IE，请使用折行转义字符取而代之。 emit 监听子组件事件子组件： 123&lt;button v-on:click=\"$emit('enlarge-text')\"&gt; Enlarge text&lt;/button&gt; 父组件： 1234&lt;blog-post ... v-on:enlarge-text=\"postFontSize += 0.1\"&gt;&lt;/blog-post&gt;&lt;/blog-post&gt; 带参数的子组件事件例如我们可能想让 &lt;blog-post&gt; 组件决定它的文本要放大多少，这时可以使用 $emit 的第二个参数来提供这个值： 123&lt;button v-on:click=\"$emit('enlarge-text', 0.1)\"&gt; Enlarge text&lt;/button&gt; 然后当在父级组件监听这个事件的时候，我们可以通过 $event 访问到被抛出的这个值： 1234&lt;blog-post ... v-on:enlarge-text=\"postFontSize += $event\"&gt;&lt;/blog-post&gt; 或者，如果这个事件处理函数是一个方法： 1234&lt;blog-post ... v-on:enlarge-text=\"onEnlargeText\"&gt;&lt;/blog-post&gt; 那么这个值将会作为第一个参数传入这个方法： 12345methods: { onEnlargeText: function (enlargeAmount) { this.postFontSize += enlargeAmount }} 在组件上使用 v-model1&lt;input v-model=\"searchText\"&gt; 等价于： 1234&lt;input v-bind:value=\"searchText\" v-on:input=\"searchText = $event.target.value\"&gt; 当用在组件上时，v-model 则会这样： 1234&lt;custom-input v-bind:value=\"searchText\" v-on:input=\"searchText = $event\"&gt;&lt;/custom-input&gt; 为了让它正常工作，这个组件内的 &lt;input&gt; 必须： 将其 value attribute 绑定到一个名叫 value 的 prop 上 在其 input 事件被触发时，将新的值通过自定义的 input 事件抛出 写成代码之后是这样的： 12345678Vue.component('custom-input', { props: ['value'], template: ` &lt;input v-bind:value=\"value\" v-on:input=\"$emit('input', $event.target.value)\" &gt;`}) 现在 v-model 就应该可以在这个组件上完美地工作起来了： 1&lt;custom-input v-model=\"searchText\"&gt;&lt;/custom-input&gt; 通过插槽分发内容12345678Vue.component('alert-box', { template: ` &lt;div class=\"demo-alert-box\"&gt; &lt;strong&gt;Error!&lt;/strong&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; `}) 只要在需要的地方加入插槽就行了。 动态组件有的时候，在不同组件之间进行动态切换是非常有用的，比如多标签的界面。 通过 Vue 的 &lt;component&gt; 元素加一个特殊的 is attribute 来实现： 12&lt;!-- 组件会在 `currentTabComponent` 改变时改变 --&gt;&lt;component v-bind:is=\"currentTabComponent\"&gt;&lt;/component&gt; currentTabComponent 可以包括 已注册组件的名字，或 一个组件的选项对象 DOM注意事项有些 HTML 元素，诸如 &lt;ul&gt;、&lt;ol&gt;、&lt;table&gt; 和 &lt;select&gt;，对于哪些元素可以出现在其内部是有严格限制的。而有些元素，诸如 &lt;li&gt;、&lt;tr&gt; 和 &lt;option&gt;，只能出现在其它某些特定的元素内部。 这会导致我们使用这些有约束条件的元素时遇到一些问题。例如： 123&lt;table&gt; &lt;blog-post-row&gt;&lt;/blog-post-row&gt;&lt;/table&gt; 这个自定义组件 &lt;blog-post-row&gt; 会被作为无效的内容提升到外部，并导致最终渲染结果出错。幸好这个特殊的 is attribute 给了我们一个变通的办法： 123&lt;table&gt; &lt;tr is=\"blog-post-row\"&gt;&lt;/tr&gt;&lt;/table&gt; 需要注意的是如果我们从以下来源使用模板的话，这条限制是*不存在*的： 字符串 (例如：template: '...') 单文件组件 (.vue) &lt;script type=\"text/x-template\"&gt; 深入组件组件注册组件名强烈推荐遵循 W3C 规范中的自定义组件名 (字母全小写且必须包含一个连字符)。这会帮助你避免和当前以及未来的 HTML 元素相冲突。 组件名大小写使用 kebab-case 1Vue.component('my-component-name', { /* ... */ }) 当使用 kebab-case (短横线分隔命名) 定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case，例如 &lt;my-component-name&gt;。 使用 PascalCase 1Vue.component('MyComponentName', { /* ... */ }) 当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。也就是说 &lt;my-component-name&gt; 和 &lt;MyComponentName&gt; 都是可接受的。注意，尽管如此，直接在 DOM (即非字符串的模板) 中使用时只有 kebab-case 是有效的。 全局注册用 Vue.component 来创建组件： 123Vue.component('my-component-name', { // ... 选项 ...}) 局部注册通过一个普通的 JavaScript 对象来定义组件： 12var ComponentA = { /* ... */ }var ComponentB = { /* ... */ } 在 components 选项中定义你想要使用的组件： 1234567new Vue({ el: '#app', components: { 'component-a': ComponentA, 'component-b': ComponentB }}) 注意局部注册的组件在其子组件中*不可用*。例如，如果你希望 ComponentA 在 ComponentB 中可用，则你需要这样写： 12345678var ComponentA = { /* ... */ }var ComponentB = { components: { 'component-a': ComponentA }, // ...} 或者如果你通过 Babel 和 webpack 使用 ES2015 模块，那么代码看起来更像： 1import ComponentA from './ComponentA.vue' 123456export default { components: { ComponentA }, // ...} 模块系统基础组件的自动化全局注册 PropProp的大小写HTML 中的 attribute 名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名： 12345Vue.component('blog-post', { // 在 JavaScript 中是 camelCase 的 props: ['postTitle'], template: '&lt;h3&gt;{{ postTitle }}&lt;/h3&gt;'}) 12&lt;!-- 在 HTML 中是 kebab-case 的 --&gt;&lt;blog-post post-title=\"hello!\"&gt;&lt;/blog-post&gt; 重申一次，如果使用字符串模板，那么这个限制就不存在了。 Prop类型 到这里，我们只看到了以字符串数组形式列出的 prop： 1props: ['title', 'likes', 'isPublished', 'commentIds', 'author'] 通常你希望每个 prop 都有指定的值类型。这时，你可以以对象形式列出 prop，这些 property 的名称和值分别是 prop 各自的名称和类型： 123456789props: { title: String, likes: Number, isPublished: Boolean, commentIds: Array, author: Object, callback: Function, contactsPromise: Promise // or any other constructor} 传递动态Prop数组用法： 12345&lt;blog-post v-for=\"post in posts\" v-bind:key=\"post.id\" v-bind:title=\"post.title\"&gt;&lt;/blog-post&gt; 静态传递： 1&lt;blog-post title=\"My journey with Vue\"&gt;&lt;/blog-post&gt; 通过 v-bind 动态赋值： 1234567891011&lt;!-- 动态赋予一个变量的值 --&gt;&lt;blog-post v-bind:title=\"post.title\"&gt;&lt;/blog-post&gt;&lt;blog-post v-bind:likes=\"42\"&gt;&lt;/blog-post&gt;&lt;blog-post v-bind:comment-ids=\"[234, 266, 273]\"&gt;&lt;/blog-post&gt;&lt;!-- 布尔值：包含该 prop 没有值的情况在内，都意味着 `true`。--&gt;&lt;blog-post is-published&gt;&lt;/blog-post&gt;&lt;!-- 动态赋予一个复杂表达式的值 --&gt;&lt;blog-post v-bind:title=\"post.title + ' by ' + post.author.name\"&gt;&lt;/blog-post&gt; 传入一个对象12345678910&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;&lt;blog-post v-bind:author=\"{ name: 'Veronica', company: 'Veridian Dynamics' }\"&gt;&lt;/blog-post&gt;&lt;!-- 用一个变量进行动态赋值。--&gt;&lt;blog-post v-bind:author=\"post.author\"&gt;&lt;/blog-post&gt; 传入一个对象所有 property如果你想要将一个对象的所有 property 都作为 prop 传入，你可以使用不带参数的 v-bind (取代 v-bind:prop-name)。例如，对于一个给定的对象 post： 1234post: { id: 1, title: 'My Journey with Vue'} 下面的模板： 1&lt;blog-post v-bind=\"post\"&gt;&lt;/blog-post&gt; 等价于： 1234&lt;blog-post v-bind:id=\"post.id\" v-bind:title=\"post.title\"&gt;&lt;/blog-post&gt; 单向数据流所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。 额外的，每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。 这里有两种常见的试图变更一个 prop 的情形： 这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。在这种情况下，最好定义一个本地的 data property 并将这个 prop 用作其初始值： 123456props: ['initialCounter'],data: function () { return { counter: this.initialCounter }} 这个 prop 以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个 prop 的值来定义一个计算属性： 123456props: ['size'],computed: { normalizedSize: function () { return this.size.trim().toLowerCase() }} 注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变变更这个对象或数组本身将会影响到父组件的状态。 Prop验证如果有一个需求没有被满足，则 Vue 会在浏览器控制台中警告你。 为 props 中的值提供一个带有验证需求的对象，而不是一个字符串数组。例如： 123456789101112131415161718192021222324252627282930313233Vue.component('my-component', { props: { // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证) propA: Number, // 多个可能的类型 propB: [String, Number], // 必填的字符串 propC: { type: String, required: true }, // 带有默认值的数字 propD: { type: Number, default: 100 }, // 带有默认值的对象 propE: { type: Object, // 对象或数组默认值必须从一个工厂函数获取 default: function () { return { message: 'hello' } } }, // 自定义验证函数 propF: { validator: function (value) { // 这个值必须匹配下列字符串中的一个 return ['success', 'warning', 'danger'].indexOf(value) !== -1 } } }}) 当 prop 验证失败的时候，(开发环境构建版本的) Vue 将会产生一个控制台的警告。 注意那些 prop 会在一个组件实例创建之前进行验证，所以实例的 property (如 data、computed 等) 在 default 或 validator 函数中是不可用的。 类型检查type 可以是下列原生构造函数中的一个： String Number Boolean Array Object Date Function Symbol 额外的，type 还可以是一个自定义的构造函数，并且通过 instanceof 来进行检查确认。例如，给定下列现成的构造函数： 1234function Person (firstName, lastName) { this.firstName = firstName this.lastName = lastName} 你可以使用： 12345Vue.component('blog-post', { props: { author: Person }}) 来验证 author prop 的值是否是通过 new Person 创建的。 非Prop的Attribute一个非 prop 的 attribute 是指传向一个组件，但是该组件并没有相应 prop 定义的 attribute。 因为显式定义的 prop 适用于向一个子组件传入信息，然而组件库的作者并不总能预见组件会被用于怎样的场景。这也是为什么组件可以接受任意的 attribute，而这些 attribute 会被添加到这个组件的根元素上。 例如，想象一下你通过一个 Bootstrap 插件使用了一个第三方的 &lt;bootstrap-date-input&gt; 组件，这个插件需要在其 &lt;input&gt; 上用到一个 data-date-picker attribute。我们可以将这个 attribute 添加到你的组件实例上： 1&lt;bootstrap-date-input data-date-picker=\"activated\"&gt;&lt;/bootstrap-date-input&gt; 然后这个 data-date-picker=\"activated\" attribute 就会自动添加到 &lt;bootstrap-date-input&gt; 的根元素上。 替换/合并已有的Attribute对于绝大多数 attribute 来说，从外部提供给组件的值会替换掉组件内部设置好的值。如果传入 type=\"text\" 就会替换掉内部的 type=\"date\" 并把它破坏！庆幸的是，class 和 style attribute 会稍微智能一些，即两边的值会被合并起来。 禁用Attribute继承如果你不希望组件的根元素继承 attribute，你可以在组件的选项中设置 inheritAttrs: false。例如： 1234Vue.component('my-component', { inheritAttrs: false, // ...}) 这尤其适合配合实例的 $attrs property 使用，该 property 包含了传递给一个组件的 attribute 名和 attribute 值，例如： 1234{ required: true, placeholder: 'Enter your username'} 有了 inheritAttrs: false 和 $attrs，你就可以手动决定这些 attribute 会被赋予哪个元素。在撰写基础组件的时候是常会用到的： 1234567891011121314Vue.component('base-input', { inheritAttrs: false, props: ['label', 'value'], template: ` &lt;label&gt; {{ label }} &lt;input v-bind=\"$attrs\" v-bind:value=\"value\" v-on:input=\"$emit('input', $event.target.value)\" &gt; &lt;/label&gt; `}) 自定义事件不同于组件和 prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。并且 v-on 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以 v-on:myEvent 将会变成 v-on:myevent——导致 myEvent 不可能被监听到。 因此，推荐始终使用 kebab-case 的事件名。 自定义组件的v-model一个组件上的 v-model 默认会利用名为 value 的 prop 和名为 input 的事件，但是像单选框、复选框等类型的输入控件可能会将 value attribute 用于不同的目的。model 选项可以用来避免这样的冲突： 12345678910111213141516Vue.component('base-checkbox', { model: { prop: 'checked', event: 'change' }, props: { checked: Boolean }, template: ` &lt;input type=\"checkbox\" v-bind:checked=\"checked\" v-on:change=\"$emit('change', $event.target.checked)\" &gt; `}) 现在在这个组件上使用 v-model 的时候： 1&lt;base-checkbox v-model=\"lovingVue\"&gt;&lt;/base-checkbox&gt; 这里的 lovingVue 的值将会传入这个名为 checked 的 prop。同时当 &lt;base-checkbox&gt; 触发一个 change 事件并附带一个新的值的时候，这个 lovingVue 的 property 将会被更新。 注意你仍然需要在组件的 props 选项里声明 checked 这个 prop。 将原生事件绑定到组件你可能有很多次想要在一个组件的根元素上直接监听一个原生事件。这时，你可以使用 v-on 的 .native 修饰符： 1&lt;base-input v-on:focus.native=\"onFocus\"&gt;&lt;/base-input&gt; 在有的时候这是很有用的，不过在你尝试监听一个类似 &lt;input&gt; 的非常特定的元素时，这并不是个好主意。比如上述 &lt;base-input&gt; 组件可能做了如下重构，所以根元素实际上是一个 &lt;label&gt; 元素： 12345678&lt;label&gt; {{ label }} &lt;input v-bind=\"$attrs\" v-bind:value=\"value\" v-on:input=\"$emit('input', $event.target.value)\" &gt;&lt;/label&gt; 这时，父级的 .native 监听器将静默失败。它不会产生任何报错，但是 onFocus 处理函数不会如你预期地被调用。 为了解决这个问题，Vue 提供了一个 $listeners property，它是一个对象，里面包含了作用在这个组件上的所有监听器。例如： 1234{ focus: function (event) { /* ... */ } input: function (value) { /* ... */ },} 有了这个 $listeners property，你就可以配合 v-on=\"$listeners\" 将所有的事件监听器指向这个组件的某个特定的子元素。对于类似 &lt;input&gt; 的你希望它也可以配合 v-model 工作的组件来说，为这些监听器创建一个类似下述 inputListeners 的计算属性通常是非常有用的： 1234567891011121314151617181920212223242526272829303132Vue.component('base-input', { inheritAttrs: false, props: ['label', 'value'], computed: { inputListeners: function () { var vm = this // `Object.assign` 将所有的对象合并为一个新对象 return Object.assign({}, // 我们从父级添加所有的监听器 this.$listeners, // 然后我们添加自定义监听器， // 或覆写一些监听器的行为 { // 这里确保组件配合 `v-model` 的工作 input: function (event) { vm.$emit('input', event.target.value) } } ) } }, template: ` &lt;label&gt; {{ label }} &lt;input v-bind=\"$attrs\" v-bind:value=\"value\" v-on=\"inputListeners\" &gt; &lt;/label&gt; `}) 现在 &lt;base-input&gt; 组件是一个完全透明的包裹器了，也就是说它可以完全像一个普通的 &lt;input&gt; 元素一样使用了：所有跟它相同的 attribute 和监听器都可以工作，不必再使用 .native 监听器。 .sync修饰符在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以变更父组件，且在父组件和子组件两侧都没有明显的变更来源。 这也是为什么我们推荐以 update:myPropName 的模式触发事件取而代之。举个例子，在一个包含 title prop 的假设的组件中，我们可以用以下方法表达对其赋新值的意图： 1this.$emit('update:title', newTitle) 然后父组件可以监听那个事件并根据需要更新一个本地的数据 property。例如： 1234&lt;text-document v-bind:title=\"doc.title\" v-on:update:title=\"doc.title = $event\"&gt;&lt;/text-document&gt; 为了方便起见，我们为这种模式提供一个缩写，即 .sync 修饰符： 1&lt;text-document v-bind:title.sync=\"doc.title\"&gt;&lt;/text-document&gt; 注意带有 .sync 修饰符的 v-bind 不能和表达式一起使用 (例如 v-bind:title.sync=”doc.title + ‘!’” 是无效的)。取而代之的是，你只能提供你想要绑定的 property 名，类似 v-model。 当我们用一个对象同时设置多个 prop 的时候，也可以将这个 .sync 修饰符和 v-bind 配合使用： 1&lt;text-document v-bind.sync=\"doc\"&gt;&lt;/text-document&gt; 这样会把 doc 对象中的每一个 property (如 title) 都作为一个独立的 prop 传进去，然后各自添加用于更新的 v-on 监听器。 将 v-bind.sync 用在一个字面量的对象上，例如 v-bind.sync=”{ title: doc.title }”，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑。 插槽 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.iwxyi.com/tags/学习笔记/"},{"name":"vue","slug":"vue","permalink":"http://blog.iwxyi.com/tags/vue/"}]},{"title":"C++多线程数据共享、互斥锁lock_guard","date":"2021-05-25T02:45:00.000Z","path":"2021/05/25/C-多线程数据共享、互斥锁lock-guard/","text":"从整体上看，所有线程之间共享数据的问题，都是修改数据导致的。在谈到并发时，术语竞争条件通常用来表示有问题的竞争条件，良性的竞争条件没什么意思。C++标准还定义了术语数据竞争，表示因单个对象的并发修改而产生的特定类型的竞争条件，造成可怕的未定义行为。 使用C++中的互斥元通过构造 std::mutex 的实例创建互斥元，调用成员函数 lock() 来锁定它，unlock() 来解锁。然而，直接调用成员函数是不推荐的做法，因为这意味着你必须记住在离开函数的每条代码路径上都调用 unlock，包括异常所导致的在内。作为替代，标准C++库提供了 std::lock_guard 类模板，实现了互斥元的 RAII 管用语法；它在构造时锁定所给的互斥元，在析构时将互斥元解锁。 123456789101112131415161718#include &lt;list&gt;#include &lt;mutex&gt;#include &lt;algorithm&gt;std::list&lt;int&gt; some_list; // 全局变量，被相应的 std::mutex 全局实例保护std::muitext some_mutex;void add_to_list(int val){ std::lock_guard&lt;std::mutex&gt; guard(some_mutex); some_list.push_back(val);}bool list_contains(int val){ std::lock_guard&lt;std::mutex&gt; guard(some_mutex); return std::find(some_list.begin(), some_list.end(), val) != some_list.end();} 这是只是函数级别的保护，但通过能够访问（并可能修改）该指针或引用的任意代码可以访问受保护的数据而无需锁定该互斥元。因此使用互斥元保护数据需要仔细社畜接口，以确保在有任意对受保护的数据进行访问前，互斥元已被锁定，且不留后门。 不要将对受保护的数据的指针和引用传递到锁的范围之外，无论是通过从函数中返回它们、将其存放在外部可见的内存中，还是作为参数传递给用户提供的函数。 发现接口中固有的竞争条件1234567stack&lt;int&gt; s;if (!s.empty()){ int const value = s.top(); // 多线程不安全1：和 s.empty() 之间可能删除了元素 s.pop(); // 多线程不安全2：也可能删除了元素 do_something(value);} 双线程下，它们的运行顺序可能是以下的情况，将看到两个一样的值： 线程A 线程B if (!s.empty()) if (!s.empty()) int const value = s.top(); int const value = s.top(); s.pop(); do_something(value); s.pop(); do_something(value); 在 pop() 的两次调用之间没有对 top() 的调用，这远比 empty() / top() 竞争的未定义行为更糟糕，从来没有任何明显的错误发生，同时错误造成的后果可能和诱因差距甚远，尽管他们明显取决于 so_something() 到底做什么。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"多线程","slug":"多线程","permalink":"http://blog.iwxyi.com/tags/多线程/"},{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"}]},{"title":"C++使用once_flag和call_once来避免数据竞争","date":"2021-05-25T02:44:00.000Z","path":"2021/05/25/C-使用once-flag和call-once来避免数据竞争/","text":"使用互斥元进行线程安全的延迟初始化 像下面这段代码一样的朴素的转换，会引起使用该资源的线程产生不必要的序列化。这是因为每个线程都必须等待互斥元，以检查资源是否已经被初始化。 12345678910111213std::shared_ptr&lt;Resource&gt; resource_ptr;std::mutex m;void foo(){ std::unique_lock&lt;std::mutex&gt; lk(m); if (!source_ptr) { resource_ptr.reset(new Resource); // 多线程唯一需要保护的部分 } lk.unlock(); resource_ptr-&gt;do_something();} 语气锁定互斥元并且显式地检查指针，还不如每个线程都可以用 std::call_once，到 call_once 返回时，指针将会被某个线程初始化（以完全同步的方式），这样就安全了。使用 std::call_once 比显式地使用互斥元通常会有更低的开销，特别是初始化已经完成的时候。 12345678910111213std::sharef_ptr&lt;Resource&gt; resource_ptr;std::once_flag resource_flag;void init_resource(){ resource_ptr.reset(new Resource);}void foo(){ std::call_once(resource_flag, init_resource); resource_ptr-&gt;do_something();} std::call_once() 可以容易地用于类成员的延迟出初始化： 12345void X::call(){ std::call_once(init_flag, &amp;X:init, this); do_something();} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"多线程","slug":"多线程","permalink":"http://blog.iwxyi.com/tags/多线程/"},{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"}]},{"title":"C++使用boost的share_mutex保护多线程读写","date":"2021-05-25T02:44:00.000Z","path":"2021/05/25/C-使用boost的share-mutex保护多线程读写/","text":"假设有用户存储DNS条目缓存的表，支持多线程读取，但在进行更新时独占访问数据结构，直到它完成了操作。使用 std::mutex 来保护数据结构会在其没有修改时消除并发读取数据结构的可能。这种新的互斥元通常称为读写互斥元，因为它考虑了两种不同的用法：由单个“写”线程独占访问或共享，有多个“读”线程并发访问。 对于更新操作，std::lock_guard&lt;boost::shared_mutex&gt; 和 std::unique_lock&lt;boost::shared_mutex&gt; 可用于锁定，以取代相应的 std::mutex 特化，这确保了独占访问。那些不需要更新数据结构的线程能够转而使用 boost::shared_lock&lt;boost::shared_mutex&gt; 来获得共享访问，这与 std::unique_lock 用起来是相同的，除了多个线程在同一时间、统一 boost::share_mutex 上可能会有共享锁。唯一的限制是，如果任一线程拥有一个共享锁，试图独占锁的线程会被阻塞，直到其他线程全都撤回它们的锁；同样的，如果任一线程具有独占锁，其他线程都不能获取共享锁或独占锁，直到第一个线程撤回了它的锁。 1234567891011121314151617181920212223242526272829303132#include &lt;map&gt;#include &lt;string&gt;#include &lt;mutex&gt;#include &lt;boost/thread/shared_mutex.hpp&gt;class dns_entry;class dns_cache{ std::map&lt;std::string, dns_entry&gt; entries; mutable boost::shared_mutex entry_mutex; public: dns_entry entry(std::string const&amp; domain) const { // 共享、只读，多线程同时调用 boost::shared_lock&lt;boost::shared_mutex&gt; lk(entry_mutex); std::map&lt;std::string, dns_entry&gt;::const_iterator const it = entries.find(domain); return (it == entries.end()) ? dns_entry() : it-&gt;second; } void update_or_add_entry(std::string const&amp; domain, dns_entry const&amp; dns_details) { // 独占访问，其余读写线程都会被阻塞 std::lock_guard&lt;boost::shared_mutex&gt; lk(entry_mutex); entries[domain] = dns_details; }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"多线程","slug":"多线程","permalink":"http://blog.iwxyi.com/tags/多线程/"},{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"boost","slug":"boost","permalink":"http://blog.iwxyi.com/tags/boost/"}]},{"title":"C++锁定多个互斥元而没有死锁","date":"2021-05-25T02:43:00.000Z","path":"2021/05/25/C-锁定多个互斥元而没有死锁/","text":"为避免死锁，常用的建议是始终使用相同的顺序锁定两个互斥元，但也有例外情况，如两个线程尝试通过交换参数而在相同的两个实例之间交换数据，将产生死锁。 幸运的是，C++标准库中的 std::lock 可以解决这一问题——std::lock 函数可以同时锁定两个或更多的互斥元，而没有死锁的风险。 123456789101112131415161718192021222324252627282930class BigObject;void swap(BigObject&amp; lhs, BigObject&amp; rhs);class X{private: BigObject detail; std::mutex m;public: X(BigObject const&amp; sd) : detail(sd) {} friend void swap(X&amp; lhs, X&amp; rhs) { if (&amp;lhs == &amp;rhs) // 确保是不同的实例 return ; // 使用 std::lock_guard 的写法 std::lock(lhs.m, rhs.m); // 锁定这两个互斥元 std::lock_guard&lt;std::mutex&gt; lock_a(lhs.m, std::adopt_lock); // 每个lock_guard对应一个互斥元 std::lock_guard&lt;std::mutex&gt; lock_b(rhs.m, std;:adopt_lock); /* // 使用 std::unique_lock 的写法 std::unique_lock&lt;std::mutex&gt; lock_a(lhs.m, std::defer_lock); std::unique_lock&lt;std::mutex&gt; lock_b(rhs.m, std;:defer_lock); std::lock(lhs.m, rhs.m); */ swap(lhs.detail, rhs.detail); }} std::lock_guard 额外提供一个参数 std::adopt_lock 给互斥元，告知 std:lock_guard 对象该互斥元已被锁定，并且它们只应沿用互斥元上已有的锁的所有权，而不是试图在构造函数中锁定互斥元。 std:unique_lock 保留互斥元为未锁定，但占用更多空间并且使用起来比 std::lock_guard 略慢。 这就确保了通常在受保护的操作可能引发异常的情况下，函数退出时正确地解锁互斥元，这也考虑到了简单返回。此外，在对 std::lock 的调用中锁定 lhs.m 抑或是 rhs.m 都可能引发异常，在这种情况下，该异常被传播出 std::lock，如果 std::lock 已经成功地在一个互斥元上获取了锁，当它试图在另一个互斥元上获取锁的时候，就会引发异常，前一个互斥元将会自动释放。std::lock 提供了关于锁定给定的互斥元的全或无的语义。 避免死锁的一些办法： 避免嵌套锁：已经持有一个锁，就别再获取锁 在持有锁时，避免调用用户提供的代码 以固定顺序获取锁 使用锁层次：在高层锁定低层互斥元；如果在较低层已经持有锁定，则不允许锁定该互斥元 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"多线程","slug":"多线程","permalink":"http://blog.iwxyi.com/tags/多线程/"},{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"}]},{"title":"C++在作用域之间转移锁的所有权unique_lock","date":"2021-05-24T02:42:00.000Z","path":"2021/05/24/C-在作用域之间转移锁的所有权unique-lock/","text":"因为 std::unique_lock 实例并没有拥有与其相关的互斥元，所以通过四处移动（moving）实例，互斥元的所有权可以在实例之间进行转移。在某些情况下这种转移是自动的，比如从函数中返回一个实例，而在其他情况下，你必须通过调用 std::move() 来显式实现。从根本上说，这取决于是否为左值（lvalue）——实变量或对实变量的引用——或者是右值（rvalue）——某种临时变量。如果源为右值，则所有权转移是自动的，而对于作者，所有权转移必须显式地完成，以避免从变量中意外地转移了所有权。std::unique_lock 就是可移动的（moveable）但不可复制（copyable）的类型的例子。 一种可能的用法，是允许函数锁定一个互斥元，并将此锁的所有权转移给调用者，于是调用者接下来可以在同一个锁的保护下执行额外的操作。下面的代码片段展示了这样的例子：函数 get_lock()锁定了互斥元，然后再将锁返回给调用者之前准备数据。 12345678910111213std::unique_lock&lt;std::mutex&gt; get_lock(){ extern std::mutex m; std::unqiue_lock&lt;std::mutex&gt; lk(m); prepare_data(); return lk;}void process_data(){ std::unique_lock&lt;std::mutext&gt; lk(get_lock()); do_something();} 因为 lk 是在函数内声明的变量，它可以被直接返回而无需调用 std::move()，编译器负责调用移动构造函数。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"多线程","slug":"多线程","permalink":"http://blog.iwxyi.com/tags/多线程/"},{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"}]},{"title":"QtCreator启动速度慢","date":"2021-05-22T02:35:00.000Z","path":"2021/05/22/QtCreator启动速度慢/","text":"菜单—帮助—关于插件：Device Support 中关闭 Android 和 WinRT 实测关闭 Android 很有效果，WinRT效果感知不大。 另外，据说关闭 Welcome 插件可加快，但我觉得也作用不大。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"C++多线程累加示例","date":"2021-05-19T02:42:00.000Z","path":"2021/05/19/C-多线程累加示例/","text":"在运行时选择线程数量：std::thread:hardware_currency()，这个函数返回一个对于给定程序执行时能够真正并发运行的线程数量的指示，如果该信息不可用则函数会返回0。例如，在多核系统上它可能是CPU核心的数量。 123456789101112131415161718192021222324252627282930313233343536373839template&lt;typename Iterator, typename T&gt;struct accumulate_block{ void operator()(Iterator first, Iterator last, T&amp;result) { result = std::accumulate(first, last, result); }};template&lt;typename Iterator, typename T&gt;T parallel_accumulate(Iterator first, Iterator last, T init){ unsigned long const length = std::distance(first, last); if (!length) // 输入范围为空，无需计算 return init; unsigned long const min_per_thread = 25; unsigned long const max_thread = (length + min_per_thread - 1) / min_per_thread; // 设置线程最大数量，避免5个数创建2个线程 unsigned long const hardware_threads = std::thread:hardware_concurrency(); // 硬件线程数量 unsigned long const num_threads = std::min(hardware_threads != 0 ? hardware_threads : 2, max_threads); // 适合的线程数量 unsigned long const block_size = length / num_threads; // 每个线程处理多少数 std::vector&lt;T&gt; results(num_threads); std::vector&lt;std::thread&gt; threads(num_threads - 1); // 注意-1，因为自己也算一个线程 Iterator block_start = first; for (unsigned long i = 0; i &lt; num_threads - 1; ++i) { Iterator block_end = block_start; std::advance(block_end, block_size); // 迭代到当前块的末尾 threads[i] = std::thread(accumulate_block&lt;Iterator, T&gt;(), block_start, block_end, std::ref(results[i])); // 注意这个std::ref，缺了的话将会引用thread构造函数中的副本，导致实际对象并没有被更改 block_start = block_end; } accumulate_block&lt;Iterator, T&gt;()(start, last, results[num_threads - 1]); // 当前线程结束最后的块，即可能没有被整除的地方 std::for_each(threads.begin(), threads.end(), std::mem_fn(&amp;std::thread::join)); // 等待所有线程 return std::accumulate(results.begin(), results.end(); init); // 累加并返回} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"多线程","slug":"多线程","permalink":"http://blog.iwxyi.com/tags/多线程/"},{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"}]},{"title":"C++线程函数的参数注意点","date":"2021-05-19T02:41:00.000Z","path":"2021/05/19/C-线程函数的参数注意点/","text":"隐式类型转换未定义123456789void f(int i, std::string const&amp; s);void oops(int param){ char buffer[1024]; sprintf(buffer, \"%i\", param); std::thread t(f, 3, buffer); t.detach();} 在这种情况下，正是局部变量 buffer 的指针被传递给新线程，还有一个重要的时机，即函数 oops 会在缓冲在新线程上呗转换为 std::string 之前退出，从而导致未定义的行为。解决之道是在将缓冲传递给 std::thread 的构造函数之前转换为 std::string。 123// 先转换，避免悬浮指针std::thread t(f, 3, std::string(buffer));t.detach(); 引用对象错误也有可能的得到相反的情况，对象被复制，而你想要的是引用。这可能发生在当线程正在更新一个通过引用传递来的数据结构时，例如： 12345678910void updateWidgetData(Widget w, Widget&amp; data); // 引用void oops(Widget w){ WidgetData data; std::thread t(updateWidgetData, w, data); // 不知道需要引用，会先复制参数data，让复制后的变量被引用 displayStatus(); t.join(); processWidgetData(data);} 尽管 updateWidgetData 希望通过引用传递第二个参数，但 std::thread 的构造函数却并不知道；它无视函数所期望的类型，并且盲目地复制了所提供的值。实际修改的是 data 在线程内部的副本的应用，随着线程的销毁，这些改动都将被舍弃。最后调用 processWidgetData，将会传递一个未改变的 data。 对于熟悉 std::bind 的人来说，解决方案也是显而易见的，需要用 std::ref 来包装确实需要被引用的参数。 1std::thread t(updateWidgetData, w, std::ref(data); 新线程调用成员函数你可以传递一个成员函数的指针作为函数，前提是提供一个合适的对象指针作为第一个参数。 12345678class X{public: void doWork();}X x;std::thread t(&amp;X::doWork, &amp;x); 这段代码将在新线程上调用 x.doWork()，因为 x 的地址是作为对象指针提供的。你也可以提供参数给这样的成员函数调用：std::thread 构造函数的第三个参数将作为成员函数的第一个参数等等。 转移std::unique_ptr对象所有权一个有趣的场景是，参数不能被复制但只能被移动：一个对象内保存的数据被转移到另一个对象，使原来的对象变成“空壳”。这种类型的一个例子是 std::unique_ptr。移动构造函数和移动赋值运算符允许一个对象的所有权在 std::unique_ptr 实例之间进行转移，这种转移给源对象留下一个 NULL 指针。 在源对象是临时的场合，这种移动是自动的；但在源是一个命名值的地方，此转移必须直接通过调用 std::move 来请求。 123456void processObject(std::unique_ptr&lt;Object&gt;);std::unique_ptr&lt;Object&gt; p(newObject);p-&gt;prepareData(42);std::thread t(processObject, std::move(p)); 这种所有权可以在实例之间进行转移，因为 std::thread 的实例是可移动的，即使他们不是可复制的。这确保了在允许程序员选择在对象之间转换所有权的时候，在任意时刻只有一个对象与某个特定的执行线程相关联。 笔记摘录自：《C++并发实战》Anthony Williams，章节2.2 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"多线程","slug":"多线程","permalink":"http://blog.iwxyi.com/tags/多线程/"},{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"}]},{"title":"C++使用RALL等待线程完成","date":"2021-05-14T02:41:00.000Z","path":"2021/05/14/C-使用RALL等待线程完成/","text":"在析构函数中将 joinable() 的线程 join() 123456789101112131415161718192021222324252627282930313233343536373839404142class thread_guard{ std::thread&amp; t;public: explicit thread_guard(std::thread&amp; t_) : t(t_) {} ~thread_guard() { if (t.joinable()) // 要先判断能不能join t.join(); } thread_guard(thread_guard const&amp;) = delete; thread_guard&amp; operator=(thread_guard const&amp;) = delete;};struct func{ int&amp; i; func(int&amp; i_) : i(i_) {} void operator()() { for (unsigned j = 0; j &lt; 10000000; ++j) { do_something(i); // 对悬空引用可能的访问 } }};void f(){ int some_local_state = 0; func my_func(some_local_state); std::thread t(my_func); thread_guard g(t); // 最后声明，最先析构 do_something_in_current_thread();} 要点： 局部变量会按照构造函数的逆序被销毁 析构函数在调用 join() 前要首先测试是不是 joinable() 的，因为 join() 只能调用一次。 拷贝构造函数和拷贝赋值运算符被标记 =delete，以确保他们不会由编译器自动提供，任何复制 thread_guard 对象的企图都将产生编译错误。 如果无需等待线程完成，可以通过 detach() 把线程丢在后台运行（被分离的线程通常被称为守护线程）。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"多线程","slug":"多线程","permalink":"http://blog.iwxyi.com/tags/多线程/"},{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"}]},{"title":"Qt5风格Connect重载的信号","date":"2021-05-12T02:36:00.000Z","path":"2021/05/12/Qt5Connect重载的信号/","text":"下面以最常用的QComboBox为例说明。 Qt4风格的connect示例代码： 1connect(ui-&gt;comboBox, SIGNAL(activated(int index)), this, SLOT(onActivated(int nIndex))); 观察Qt4风格，可知第二个参数即使信号重载，也不会出现歧义。 Qt5风格的connect示例代码： 1connect(ui-&gt;comboBox, &amp;QComboBox::activated, this, &amp;MyWidget::onActivated); 但是，针对QComboBox对象，这样的信号槽连接，编译器会报编译错误： 12// error: C2664: “QMetaObject::Connection QObject::connect(const QObject *,const char *,const char *,Qt::ConnectionType) const”:// 无法将参数 2 从“overloaded-function”转换为“const char *”上下文不允许消除重载函数的歧义 经查询分析，原因如下： 123456789Q_SIGNALS: void editTextChanged(const QString &amp;); void activated(int index); void activated(const QString &amp;); void highlighted(int index); void highlighted(const QString &amp;); void currentIndexChanged(int index); void currentIndexChanged(const QString &amp;); void currentTextChanged(const QString &amp;); 可知，因QComboBox的activated信号有重载实现导致。 Qt5风格信号重载的connect方式示例代码： 1234// 两种正确方式：// 方式1：typedef void (QComboBox::*QComboIntSignal)(int);connect(ui-&gt;comboBox, static_cast&lt;QComboIntSignal&gt;(&amp;QComboBox::activated), this, &amp;MyWidget::onActivated); 12// 方式2：connect(ui-&gt;comboBox, static_cast&lt;void (QComboBox::*)(int)&gt;(&amp;QComboBox::activated), this, &amp;MyWidget::onActivated); Qt助手范例： img 转载自：https://blog.csdn.net/weixin_34405354/article/details/85907557 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"Qt控件setFocus失效","date":"2021-05-10T02:34:00.000Z","path":"2021/05/10/Qt控件setFocus失效/","text":"目标效果：弹窗弹出后，弹窗上的输入框获得焦点，以便不必再点击输入框就可以直接输入。但在我通过一些方式为这个弹窗添加了背景遮罩后，发现输入框没有自动获得焦点了。 最终解决方法激活弹窗。添加my_window-&gt;activateWindow()再setFocus()。 尝试方法一：发现失去焦点后，运行了setFocus()函数，但无论加在哪都没有用，怎么加都没有用。 尝试方法二：查阅一些资料，表示只有控件可见后设置setFocus()才有效。于是我运行 12this-&gt;show();ui.lineEdit-&gt;setFocus(); 很显然没有用，我的弹窗已经是可见的了。 尝试方法三（最终解决）：查阅Qt官方文档， 如果此窗口小部件或其父控件之一是活动窗口，则将键盘输入焦点赋予该控件。于是激活窗口activateWindow()，问题迎刃而解。 原文链接：https://blog.csdn.net/qq_36908789/article/details/110825539 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"VSCode配置Electron开发环境","date":"2021-03-20T08:03:00.000Z","path":"2021/03/20/VSCode配置Electron开发环境/","text":"nodejs安装下载地址：https://nodejs.org/zh-cn/download/ 为了稳定性，建议下载node 10.17.0版本。访问https://nodejs.org/en/download/ 进入Previous Releases。 找到v10.17.0版本的，下载完成后， 执行安装程序，根据引导完成安装即可。 安装完成之后查询node和npm的版本，确认安装是否成功。 node -vnpm -v 如果上述命令均打印出一个版本号，就说明Node.js已经安装好了！ 注册npm镜像不建议直接将npm设置为淘宝镜像，而是注册cnpm指令。方便之后有选择性的使用npm或者cnpm npm install -g cnpm –registry=https://registry.npm.taobao.org Electron安装国外站点速度太慢，直接使用cnpm来安装electron。cnpm install -g electron 新建配置Electron项目在相应目录新建项目目录 mkdir eledemo 进入目录 cd eledemo 初始化项目，创建package.json npm init -y 使用VSCode打开项目文件夹 code . VSCode中无法使用cnpm需要使用PowerShell进行授权执行set-ExecutionPolicy RemoteSigned命令，然后选A 添加electron依赖 cnpm install electron -S 修改package.json 123456789101112131415{ \"name\": \"eledemo\", \"version\": \"1.0.0\", \"description\": \"This is an electron demo project.\", \"main\": \"main.js\", \"scripts\": { \"start\": \"electron .\" }, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"dependencies\": { \"electron\": \"^8.2.5\" }} 新建main.js文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const electron = require('electron');const {app, BrowserWindow} = require('electron');const path = require('path');const url = require('url');let mainWindow;function createWindow () { // Create the browser window. mainWindow = new BrowserWindow({ width: 1024, height: 640, transparent: false, frame: true, resizable : true //固定大小 }); const URL = url.format({ pathname: path.join(__dirname, 'index.html'), protocol: 'file:', slashes: true }) mainWindow.loadURL(URL); console.log(URL); mainWindow.openDevTools() mainWindow.on('closed', function () { mainWindow = null; });}app.on('ready', createWindow);// Quit when all windows are closed.app.on('window-all-closed', function () { // On OS X it is common for applications and their menu bar // to stay active until the user quits explicitly with Cmd + Q if (process.platform !== 'darwin') { app.quit(); }});app.on('activate', function () { // On OS X it's common to re-create a window in the app when the // dock icon is clicked and there are no other windows open. if (mainWindow === null) { createWindow(); }}); 新建index.html文件 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; hello! This is an electron project.&lt;/body&gt;&lt;/html&gt; 运行项目 cnpm installnpm start 添加应用图标文件logo.png修改main.js文件 1234567891011function createWindow() { var ico = path.join(__dirname, 'img', 'logo-28.png'); // Create the browser window. mainWindow = new BrowserWindow({ width: 1024, height: 640, transparent: false, frame: true, icon: ico, resizable: true //固定大小 }); 使用VSCODE调试Electron项目打开VSCODE的调试窗口，添加调试配置文件（nodejs） 12345678910111213141516{ // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"node\", \"request\": \"launch\", \"name\": \"Electron Main\", \"runtimeExecutable\": \"${workspaceFolder}/node_modules/.bin/electron\", \"program\": \"${workspaceFolder}/main.js\", \"protocol\": \"inspector\" //添加默认的协议是legacy，这个协议导致不进入断点 } ]} 转载：https://www.cnblogs.com/songhaipeng/p/12857912.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"VSCode","slug":"VSCode","permalink":"http://blog.iwxyi.com/tags/VSCode/"},{"name":"Electron","slug":"Electron","permalink":"http://blog.iwxyi.com/tags/Electron/"}]},{"title":"Qt生成二维码","date":"2021-03-14T08:46:00.000Z","path":"2021/03/14/Qt生成二维码/","text":"下载 qrencode 将qrencode源码中的(*.h *.c)加入到工程中； 将源码中的config.h.in文件修改成config.h并加入工程； 在QT的pro文件中添加DEFINES += HAVE_CONFIG_H 定义全局宏定义； 重新定义 MAJOR_VERSION、MICRO_VERSION、MINOR_VERSION、VERSION，重新定义的方法：找到#undef MAJOR_VERSION位置，在其下面定义#define MAJOR_VERSION 1，其他几个也这么定义。VERSION是字符串\"1\"。 12345678910111213141516171819202122232425262728293031const char* url = \"http://www.baidu.com\";QRcode* qrcode = QRcode_encodeString(url, 2, QR_ECLEVEL_Q, QR_MODE_8, 0);qint32 temp_width = 400; //二维码图片的大小qint32 temp_height = 400;qint32 qrcode_width = qMax(qrcode-&gt;width, 1);double scale_x = (double)temp_width / (double)qrcode_width; //二维码图片的缩放比例double scale_y = (double)temp_height / (double)qrcode_width;QImage img = QImage(temp_width, temp_height, QImage::Format_ARGB32);QPainter painter(&amp;img);painter.setBrush(Qt::white);painter.setPen(Qt::NoPen);painter.drawRect(0, 0, temp_width, temp_height);painter.setBrush(Qt::black);for( qint32 y = 0; y &lt; qrcode_width; y ++){ for(qint32 x = 0; x &lt; qrcode_width; x++) { unsigned char b = qrcode-&gt;data[y * qrcode_width + x]; if(b &amp; 0x01) { QRectF r(x * scale_x, y * scale_y, scale_x, scale_y); painter.drawRects(&amp;r, 1); } }}QPixmap pixmap = QPixmap::fromImage(img);ui-&gt;qrcodeLabel-&gt;setPixmap(pixmap);delete qrcode; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"Qt在pro文件中条件编译","date":"2021-03-14T08:44:00.000Z","path":"2021/03/14/Qt在pro文件中条件编译/","text":"QMake本身就提供了在pro下可判断平台的变量参数，如下： 123456789101112131415macx {# mac only}ios{# ios only}android{# android only}unix:!macx{# linux only}win32 {# windows only} linux(也可以作为android平台)并没有单独的参数判断，但是可以通过是否是unix并且不是mac os x来判断是在linux系统底下。 若根据某些宏是否存在来执行不同的配置则可以： 添加宏定义： DEFINES += TEST 判断宏定义是否存在: 12345contains(DEFINES, TEST) { message('--&gt;&gt;(DEFINES, TEST)')} else { message('--&gt;&gt;not contains (DEFINES, TEST)')} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"Deepin个人配置","date":"2021-03-13T08:17:00.000Z","path":"2021/03/13/Deepin个人配置/","text":"安装Sublime Text https://www.sublimetext.com/docs/3/linux_repositories.html 12345wget -qO - https://download.sublimetext.com/sublimehq-pub.gpg | sudo apt-key add -sudo apt-get install apt-transport-httpsecho \"deb https://download.sublimetext.com/ apt/stable/\" | sudo tee /etc/apt/sources.list.d/sublime-text.listsudo apt-get updatesudo apt-get install sublime-text 修改仓库/商店软件源https://bbs.deepin.org/forum.php?mod=viewthread&amp;tid=179163 无法添加软件源 sudo dedit /etc/lsb-release，保存为下面的内容 123456789#DISTRIB_ID=Deepin#DISTRIB_RELEASE=\"15.10.1\"#DISTRIB_DESCRIPTION=\"Deepin 15.10.1 \"#DISTRIB_CODENAME=stableDISTRIB_ID=UbuntuDISTRIB_RELEASE=16.04DISTRIB_CODENAME=trustyDISTRIB_DESCRIPTION=\"Ubuntu 16.04.3 LTS\" 安装rEFInd引导https://www.ithome.com/0/425/537.htm 引导启动项顺序 https://blog.csdn.net/owen_suen/article/details/79050549 /etc/grub.d文件夹下的30_os-prober文件改名为08_os-prober sudo update-grub 修改Chrome滚动速度https://www.helplib.com/ubuntu/article_164190 SSR下载https://github.com/qingshuisiyuan/electron-ssr-backup/releases 安装Qt可能需要自己手动设置编译器上的C++路径，否则无法编译（5.13.1） 安装依赖库https://blog.csdn.net/qq_42378797/article/details/91038804 或者输入下面一句话也可以安装所有的库： 1sudo apt-get install build-essential libgl1-mesa-dev 打包程序https://blog.csdn.net/qing666888/article/details/78577633 支持中文https://my.oschina.net/lieefu/blog/505363?fromerr=NNm21wBS 支持qDebug添加环境变量后重启 Qt Creator： 1export QT_LOGGING_TO_CONSOLE=1 安装Android Studio安装 Java：sudo apt install default-jdk 安装 SDK：wget http://dl.google.com/android/android-sdk_r22.0.5-linux.tgz 安装 AS：sudo apt install android-studio 安装 Gradle：AS安装https://shimo.im/docs/C7Om170UHl0Ih8yD/read 安装 Virtual Box：sudo apt-get install virtualbox 安装 Genymotion：https://www.jianshu.com/p/53bd3408439c 手动下载后安装方法： 123&gt; chmod 755 genymotion.bin # 需要权限&gt; ./genymotion -d /home/mrxy001/Programs&gt; Android Studio 连接不上 Genymotion 设备：Genymotion &gt; Settings &gt; adb &gt; custom &gt; /home/mrxy001/Android/Sdk/ 挂载FTP1curlftpfs -o codepage=utf8 ftp://username:password@iwxyi.com /home/mrxy001/ftp 开机自动挂载： 1echo \"curlftpfs -o codepage=utf8 ftp://username:password@iwxyi.com /home/mrxy001/ftp\" &gt;&gt; /etc/fstab 安装Fira Code字体https://blog.csdn.net/m0_37952030/article/details/99958890 翻墙https://github.com/qingshuisiyuan/electron-ssr-backup 安装PHPStudyhttps://blog.csdn.net/qq_40842615/article/details/81075231 安装ZSHhttps://blog.csdn.net/sinat_37064286/article/details/94303227 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Deepin","slug":"Deepin","permalink":"http://blog.iwxyi.com/tags/Deepin/"}]},{"title":"PS照片偏黄","date":"2021-03-11T08:31:00.000Z","path":"2021/03/11/PS照片偏黄/","text":"PS中照片偏黄的处理方式： 按Ctrl+J复制一层，图像-应用图像，将RGB改为”绿“，混合模式改为”滤色“，适当调整不透明度，确定。 再调出曲线，降低它的红色，适当提高一下蓝色，最后适当整体提高高度。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PhotoShop","slug":"PhotoShop","permalink":"http://blog.iwxyi.com/tags/PhotoShop/"}]},{"title":"Fiddler创建根证书不成功","date":"2021-03-10T09:52:00.000Z","path":"2021/03/10/Fiddler创建根证书不成功/","text":"运行命令创建证书： 1makecert.exe -r -ss my -n \"CN=DO_NOT_TRUST_FiddlerRoot, O=DO_NOT_TRUST, OU=Created by http://www.fiddler2.com\" -sky signature -eku 1.3.6.1.5.5.7.3.1 -h 1 -cy authority -a sha1 -m 120 -b 10/12/2026 注意最后的时间要超过安装软件的时间 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"MySQL marked as crashed and should be repaired","date":"2021-03-08T09:40:00.000Z","path":"2021/03/08/MySQL-marked-as-crashed-and-should-be-repaired/","text":"MySQL备份时中断，报错：marked as crashed and should be repaired 首先进入mysql命令台：mysql -u root -p，回车 输入密码 查询所有的库mysql&gt; show databases; 进入数据库“eduyun_2015_sp1”是库名mysql&gt; use eduyun_2015_sp1; check table error_table（error_table是错误的表的名字）用来检查出现问题的表的状态，出现错误就正常 然后用repair table newabout 再用check table newabout 检查一下 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"SQL","slug":"SQL","permalink":"http://blog.iwxyi.com/tags/SQL/"}]},{"title":"Qt获取exe版本信息","date":"2021-02-22T08:47:00.000Z","path":"2021/02/22/Qt获取exe版本信息/","text":"pro文件引入 version.lib 1unix|win32: LIBS += -lVersion 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180QString GetFileVertion(QString fullName){ DWORD dwLen = 0; char* lpData=NULL; LPCWSTR str_path; str_path=fullName.toStdWString().c_str(); BOOL bSuccess = FALSE; QString fileInfomation; DWORD vHandle=0; //获得文件基础信息 //-------------------------------------------------------- dwLen = GetFileVersionInfoSize( str_path, &amp;vHandle); if (0 == dwLen) { qDebug()&lt;&lt;\"获取版本字节信息失败!\"; return\"\"; } qDebug()&lt;&lt;\"版本信息字节大小：\"&lt;&lt;dwLen; lpData =(char*)malloc(dwLen+1); if (NULL == lpData) { qDebug()&lt;&lt;\"分配内存失败\"; return \"\"; } bSuccess = GetFileVersionInfo( fullName.toStdWString().c_str(),0, dwLen+1, lpData); if (!bSuccess) { qDebug()&lt;&lt;\"获取文件版本信息错误!\"; return\"\"; } LPVOID lpBuffer = NULL; UINT uLen = 0; //获得语言和代码页(language and code page),规定，套用即可 //--------------------------------------------------- bSuccess = VerQueryValue( lpData, (TEXT(\"\\\\VarFileInfo\\\\Translation\")), &amp;lpBuffer, &amp;uLen); QString strTranslation,str1,str2; unsigned short int *p =(unsigned short int *)lpBuffer; str1.setNum(*p,16); str1=\"000\"+ str1; strTranslation+= str1.mid(str1.size()-4,4); str2.setNum(*(++p),16); str2=\"000\"+ str2; strTranslation+= str2.mid(str2.size()-4,4); QString str_value; QString code; //以上步骤需按序进行，以下步骤可根据需要增删或者调整 //获得文件说明：FileDescription //--------------------------------------------------------- code =\"\\\\StringFileInfo\\\\\"+ strTranslation +\"\\\\FileDescription\"; bSuccess = VerQueryValue(lpData, (code.toStdWString().c_str()), &amp;lpBuffer, &amp;uLen); if (!bSuccess) { qDebug()&lt;&lt;\"Get file verstion error!\"; } else { str_value=\"文件说明：\" + QString::fromUtf16((const unsigned short int *)lpBuffer)+\"\\n\"; fileInfomation +=str_value; } //获得文件版本信息：FileVersion //----------------------------------------------------- code =\"\\\\StringFileInfo\\\\\"+ strTranslation +\"\\\\FileVersion\"; bSuccess = VerQueryValue(lpData, (code.toStdWString().c_str()), &amp;lpBuffer, &amp;uLen); if (!bSuccess) { qDebug()&lt;&lt;\"获取文件版本信息错误!\"; } else { str_value=\"文件版本信息：\" + QString::fromUtf16((const unsigned short int *)lpBuffer)+\"\\n\"; fileInfomation +=str_value; } //获得文件产品名称 //--------------------------------------------------------- code =\"\\\\StringFileInfo\\\\\"+ strTranslation +\"\\\\ProductName\"; bSuccess = VerQueryValue(lpData, (code.toStdWString().c_str()), &amp;lpBuffer, &amp;uLen); if (!bSuccess) { qDebug()&lt;&lt;\"Get file ProductName error!\"; } else { str_value=\"产品名称：\" + QString::fromUtf16((const unsigned short int *)lpBuffer)+\"\\n\"; fileInfomation +=str_value; } //获得产品版本信息：ProductVersion //----------------------------------------------------- code =\"\\\\StringFileInfo\\\\\"+ strTranslation +\"\\\\ProductVersion\"; bSuccess = VerQueryValue(lpData, (code.toStdWString().c_str()), &amp;lpBuffer, &amp;uLen); if (!bSuccess) { qDebug()&lt;&lt;\"获取产品版本信息错误!\"; } else { str_value=\"产品版本信息：\" + QString::fromUtf16((const unsigned short int *)lpBuffer)+\"\\n\"; fileInfomation +=str_value; } //获得文件内部名称 InternalName //--------------------------------------------------------- code =\"\\\\StringFileInfo\\\\\"+ strTranslation +\"\\\\InternalName\"; bSuccess = VerQueryValue(lpData, (code.toStdWString().c_str()), &amp;lpBuffer, &amp;uLen); if (!bSuccess) { qDebug()&lt;&lt;\"Get file InternalName error!\"; } else { str_value=\"内部名称：\" + QString::fromUtf16((const unsigned short int *)lpBuffer)+\"\\n\"; fileInfomation +=str_value; } //获得原始文件名 OriginalFileName //--------------------------------------------------------- code =\"\\\\StringFileInfo\\\\\"+ strTranslation +\"\\\\OriginalFileName\"; bSuccess = VerQueryValue(lpData, (code.toStdWString().c_str()), &amp;lpBuffer, &amp;uLen); if (!bSuccess) { qDebug()&lt;&lt;\"Get file OriginalFileName error!\"; } else { str_value=\"原始文件名：\" + QString::fromUtf16((const unsigned short int *)lpBuffer)+\"\\n\"; fileInfomation +=str_value; } //获得合法版权 LegalTradeMarks //--------------------------------------------------------- code =\"\\\\StringFileInfo\\\\\"+ strTranslation +\"\\\\Type\"; bSuccess = VerQueryValue( lpData, (code.toStdWString().c_str()), &amp;lpBuffer, &amp;uLen); if (!bSuccess) { qDebug()&lt;&lt;\"Get file LegalTradeMarks error!\"; } else { str_value=\"版权：\" + QString::fromUtf16((const unsigned short int *)lpBuffer)+\"\\n\"; fileInfomation +=str_value; } delete lpData; return fileInfomation;} https://blog.csdn.net/scz653037148/article/details/83307252 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"Flutter各种问题整理与解决","date":"2021-01-31T08:11:00.000Z","path":"2021/01/31/Flutter各种问题/","text":"卡在flutter pub get不动1234567891011//命令行输入vim ~/.bash_profile//添加下面三行，保存export PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cnexport PATH=/Users/计算机名称/flutter/bin:$PATH //下载的flutterSDK的路径//命令行输入source ~/.bash_profileflutter -h 运行 flutter doctor 命令，再 package get 运行按钮灰色：not applicable for the “main.dart” configuration是因为 Flutter SDK 没有设置：File &gt; setting&gt; Language &amp; Framework &gt; flutter java.lang.NoClassDefFoundError: Could not initialize class org.codehaus.groovy.vmplugin.v7.Java7目录/android/gradle/wrapper/gradle-wrapper.properties 修改 distributionUrl属性。 例如：distributionUrl=https\\://services.gradle.org/distributions/gradle-5.6.2-all.zip 改为 distributionUrl=file:///D:/DevKits/gradle/gradle-6.4.1-all.zip（这是我本地下载好了的） setState() called after dispose() State 对象被从对象数卸载释放之后再次调用 setState 就会报 setState() called after dispose()。 State 的 mounted 源码： 12345678910/// Whether this [State] object is currently in a tree.////// After creating a [State] object and before calling [initState], the/// framework \"mounts\" the [State] object by associating it with a/// [BuildContext]. The [State] object remains mounted until the framework/// calls [dispose], after which time the framework will never ask the [State]/// object to [build] again.////// It is an error to call [setState] unless [mounted] is true.bool get mounted =&gt; _element != null; 注释中说得很清楚：判断 State 对象现在还在不在对象树中。 So，解决方案就是在 setState 之前先判断一下该 State 是否已经被释放： 123456/// 更新用户状态void updateState(fn){ if (mounted) { setState(fn); }} MissingPluginException(No implementation found for method initialize on channel dexterous.com/flutter/local_notifications) 报丢失插件错误，是因为“hot reload”问题。 我们新添加的插件包就无法直接通过热重载打入手机应用包中，有的人会尝试直接点击绿色向右小三角安装，这样也是无法实现重新编译打包安装到手机的，这个时候你必须停止掉应用（红色小正方形按钮），再重新点击安装才行。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://blog.iwxyi.com/tags/Flutter/"}]},{"title":"Flutter监听变量","date":"2021-01-31T08:05:00.000Z","path":"2021/01/31/Flutter监听变量/","text":"123456789101112131415161718192021222324252627282930313233class MyHomePage extends StatelessWidget { final number = new ValueNotifier(0);//值变化通知 @override Widget build(BuildContext context) { return Scaffold( body: ValueListenableBuilder&lt;int&gt;( valueListenable: number, builder: (context, value, child) { return Center( child: RaisedButton( onPressed: () { number.value++;//触发通知 }, child: MyWidget(number), ), ); }, ), ); }} class MyWidget extends StatelessWidget { final ValueListenable&lt;int&gt; number; MyWidget(this.number); @override Widget build(BuildContext context) { return new Text(number.value.toString());//同步变化 }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://blog.iwxyi.com/tags/Flutter/"}]},{"title":"C&CPP分支预测","date":"2021-01-31T07:32:00.000Z","path":"2021/01/31/C-CPP分支预测/","text":"转载自知乎回答：程序喵大人 https://www.zhihu.com/question/441518636/answer/1701252133 if-else涉及到分支预测的概念。 首先看一段经典的代码，并统计它的执行时间： 1234567891011121314151617181920212223242526272829303132333435// test_predict.cc#include &lt;algorithm&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;int main() { const unsigned ARRAY_SIZE = 50000; int data[ARRAY_SIZE]; const unsigned DATA_STRIDE = 256; for (unsigned c = 0; c &lt; ARRAY_SIZE; ++c) data[c] = std::rand() % DATA_STRIDE; std::sort(data, data + ARRAY_SIZE); { // 测试部分 clock_t start = clock(); long long sum = 0; for (unsigned i = 0; i &lt; 100000; ++i) { for (unsigned c = 0; c &lt; ARRAY_SIZE; ++c) { if (data[c] &gt;= 128) sum += data[c]; } } double elapsedTime = static_cast&lt;double&gt;(clock() - start) / CLOCKS_PER_SEC; std::cout &lt;&lt; elapsedTime &lt;&lt; \"\\n\"; std::cout &lt;&lt; \"sum = \" &lt;&lt; sum &lt;&lt; \"\\n\"; } return 0;}~/test$ g++ test_predict.cc ;./a.out7.95312sum = 480124300000 此程序的执行时间是7.9秒，如果把排序那一行代码注释掉，即 1// std::sort(data, data + ARRAY_SIZE); 结果为： 123~/test$ g++ test_predict.cc ;./a.out24.2188sum = 480124300000 改动后的程序执行时间变为了24秒。 其实只改动了一行代码，程序执行时间却有3倍的差距，而且看上去数组是否排序与程序执行速度貌似没什么关系，这里面其实涉及到CPU分支预测的知识点。 提到分支预测，首先要介绍一个概念：流水线。 拿理发举例，小理发店一般都是一个人工作，一个人洗剪吹一肩挑，而大理发店分工明确，洗剪吹都有特定的员工，第一个人在剪发的时候，第二个人就可以洗头了，第一个人剪发结束吹头发的时候，第二个人可以去剪发，第三个人就可以去洗头了，极大的提高了效率。 img img img img 这里的洗剪吹就相当于是三级流水线，在CPU架构中也有流水线的概念，如图： img img 在执行指令的时候一般有以下几个过程： 取指：Fetch 译指：Decode 执行：execute 回写：Write-back 流水线架构可以更好的压榨流水线上的四个员工，让他们不停的工作，使指令执行的效率更高。 再谈分支预测，举个经典的例子： 火车高速行驶的过程中遇到前方有个岔路口，假设火车内没有任何通讯手段，那火车就需要在岔路口前停下，下车询问别人应该选择哪条路走，弄清楚路线后后再重新启动火车继续行驶。高速行驶的火车慢速停下，再重新启动后加速，可以想象这个过程浪费了多少时间。 有个办法，火车在遇到岔路口前可以猜一条路线，到路口时直接选择这条路行驶，如果经过多个岔路口，每次做出选择时都能选择正确的路口行驶，这样火车一路上都不需要减速，速度自然非常快。但如果火车开过头才发现走错路了，就需要倒车回到岔路口，选择正确的路口继续行驶，速度自然下降很多。所以预测的成功率非常重要，因为预测失败的代价较高，预测成功则一帆风顺。 计算机的分支预测就如同火车行驶中遇到了岔路口，预测成功则程序的执行效率大幅提高，预测失败程序的执行效率则大幅下降。 img img 图片取自下方参考资料中 CPU都是多级流水线架构运行，如果分支预测成功，很多指令都提前进入流水线流程中，则流水线中指令运行的非常顺畅，而如果分支预测失败，则需要清空流水线中的那些预测出来的指令，重新加载正确的指令到流水线中执行，然而现代CPU的流水线级数非常长，分支预测失败会损失10-20个左右的时钟周期，因此对于复杂的流水线，好的分支预测方法非常重要。 预测方法主要分为静态分支预测和动态分支预测： 静态分支预测：听名字就知道，该策略不依赖执行环境，编译器在编译时就已经对各个分支做好了预测。 动态分支预测：即运行时预测，CPU会根据分支被选择的历史纪录进行预测，如果最近多次都走了这个路口，那CPU做出预测时会优先考虑这个路口。 tips：这里只是简单的介绍了分支预测的方法，更多的分支预测方法资料大家可关注公众号回复分支预测关键字领取。 了解了分支预测的概念，我们回到最开始的问题，为什么同一个程序，排序和不排序的执行速度相差那么多。 因为程序中有个if条件判断，对于不排序的程序，数据散乱分布，CPU进行分支预测比较困难，预测失败的频率较高，每次失败都会浪费10-20个时钟周期，影响程序运行的效率。而对于排序后的数据，CPU根据历史记录比较好判断即将走哪个分支，大概前一半的数据都不会进入if分支，后一半的数据都会进入if分支，预测的成功率非常高，所以程序运行速度很快。 如何解决此问题？总体思路肯定是在程序中尽量减少分支的判断，方法肯定是具体问题具体分析了，对于该示例程序，这里提供两个思路削减if分支。 方法一：使用位操作： 12int t = (data[c] - 128) &gt;&gt; 31;sum += ~t &amp; data[c]; 方法二：使用表结构： 1234567891011121314151617181920212223242526272829303132333435#include &lt;algorithm&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;int main() { const unsigned ARRAY_SIZE = 50000; int data[ARRAY_SIZE]; const unsigned DATA_STRIDE = 256; for (unsigned c = 0; c &lt; ARRAY_SIZE; ++c) data[c] = std::rand() % DATA_STRIDE; int lookup[DATA_STRIDE]; for (unsigned c = 0; c &lt; DATA_STRIDE; ++c) { lookup[c] = (c &gt;= 128) ? c : 0; } std::sort(data, data + ARRAY_SIZE); { // 测试部分 clock_t start = clock(); long long sum = 0; for (unsigned i = 0; i &lt; 100000; ++i) { for (unsigned c = 0; c &lt; ARRAY_SIZE; ++c) { // if (data[c] &gt;= 128) sum += data[c]; sum += lookup[data[c]]; } } double elapsedTime = static_cast&lt;double&gt;(clock() - start) / CLOCKS_PER_SEC; std::cout &lt;&lt; elapsedTime &lt;&lt; \"\\n\"; std::cout &lt;&lt; \"sum = \" &lt;&lt; sum &lt;&lt; \"\\n\"; } return 0;} 其实Linux中有一些工具可以检测出分支预测成功的次数，有valgrind和perf，使用方式如图： img img 条件分支的使用会影响程序执行的效率，我们平时开发过程中应该尽可能减少在程序中随意使用过多的分支，能避免则避免。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C语言","slug":"C语言","permalink":"http://blog.iwxyi.com/tags/C语言/"},{"name":"优化","slug":"优化","permalink":"http://blog.iwxyi.com/tags/优化/"}]},{"title":"Tomcat配置","date":"2021-01-30T08:14:00.000Z","path":"2021/01/30/Tomcat配置/","text":"安装 https://blog.csdn.net/gyshun/article/details/79582763 下载地址：http://tomcat.apache.org/，注意下载那个zip文件，还要注意与jdk版本吻合（参考链接:http://www.bubuko.com/infodetail-674892.html） 新建环境变量CATALINA_HOME，变量值为解压目录，如E:\\tomcat 运行执行 service.bat install 如果成功，会有成功提示 修改端口tomcat/conf/server.xml中 123&lt;Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt; 修改JRE路径 在tomcat中，bin/路径下找到catalina.bat文件； 编辑catalina.bat文件，修改如下信息 set JRE_HOME=D:\\DevKits\\JDK8\\jre JAVA_HOME应该系统自带了 实测JSPStudy更换JRE会导致Tomcat跑不了 输出中文乱码1淇℃伅 [main] org.apache.catalina.startup.VersionLoggerListener.log Server.鏈嶅姟鍣ㄧ増鏈�: 到tomcat/conf/目录下 修改logging.properties 找到 java.util.logging.ConsoleHandler.encoding = utf-8这行 更改为 java.util.logging.ConsoleHandler.encoding = GBK 时区问题12Caused by: com.mysql.cj.exceptions.InvalidConnectionAttributeException: The server time zone value 'ÖÐ¹ú±ê×¼Ê±¼ä' is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support. https://blog.csdn.net/syc000666/article/details/100580972 方法一： 在连接字符串 url 后加上 &amp;serverTimezone=UTC 方法二：服务器默认时区跟随系统时区。通过服务器时区配置属性来配置服务器的时区 12345-- 修改mysql全局时区为东八区，即表示北京时间set global time_zone = '+8:00';flush privileges;-- 时区修改生效之后，再次查询mysql时区show variables like \"%time_zone%\"; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"http://blog.iwxyi.com/tags/Tomcat/"}]},{"title":"npm下载卡住","date":"2021-01-24T08:29:00.000Z","path":"2021/01/24/npm下载卡住/","text":"遇到的问题1npm install -g @angular/cli 安装angular cli工具时，发现进度条一直卡住不动 方案一：安装cnpm镜像这个是比较常用的方法，我首先也是使用了这个方法。cnpm的安装方法，参考http://npm.taobao.org/ 1npm install -g cnpm --registry=https://registry.npm.taobao.org cmd输入以上命令就可以了，然后输入 1cnpm install -g @angular/cli 后面的操作跟不使用镜像的操作是差不多的。但是笔者在后续使用过程中遇到了一些问题，运行ng eject后发生了一些错误，所以放弃了这个方案，采用了方案二。 方案二：使用代理registry在网上查阅了一些资料后，决定使用代理的方式，方法也很简单，就是 1npm config set registry https://registry.npm.taobao.org 然后后续的install等命令还是通过npm运作，而不是cnpm。有点小强迫症的我还是喜欢npm install… document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.iwxyi.com/tags/Node-js/"},{"name":"npm","slug":"npm","permalink":"http://blog.iwxyi.com/tags/npm/"}]},{"title":"Nginx反向代理其他端口","date":"2021-01-24T08:27:00.000Z","path":"2021/01/24/Nginx反向代理其他端口/","text":"这里用的是小皮面板（PHPStudy），先添加网站。 找到nginx/conf/vhost/网站.conf，server中原先的location全删了，改为下面： 1234567server { listen 80; server_name cloud.iwxyi.com; location / { proxy_pass http://iwxyi.com:5212; }} 其余配置如root等都不需要了。 访问cloud.iwxyi.com，都会变成http://iwxyi.com:5212 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://blog.iwxyi.com/tags/Nginx/"}]},{"title":"添加文件VSCode右键菜单","date":"2020-12-28T09:51:00.000Z","path":"2020/12/28/添加文件VSCode右键菜单/","text":"添加右键打开文件1, Win+R 打开运行，输入regedit，打开注册表，找到HKEY_CLASSES_ROOT*\\shell分支，如果没有shell分支，则在*下点击右键，选择“新建－项”，建立shell分支。 2, 在shell下新建“VisualCode”项，在右侧窗口的“默认”键值栏内输入“用VSCode打开文件”，这是右键上显示值，也就是文字。其事可以随便写，只是为了方便记忆和分辨。 3, 在“VisualCode”下再新建Command项，在右侧窗口的“默认”键值栏内输入程序所在的安装路径，我的是：“D:\\Program Files (x86)\\VSCode\\code.exe” “%1”。其中的%1表示要打开的文件参数。 4, 关闭注册表，即可生效。 添加右键打开文件夹以上方法可以在选中文件时右键在菜单栏中显示：“用VSCode打开文件夹”，但当右键文件夹时仍然不能显示此选项，所以还要进行下面的操作： 打开注册表，找到HKEY_CLASSES_ROOT\\Directory\\shell，按照上面2、3的方法添加即可。 添加 Icon也就是文字前面的图标在原有的VisualCode项上新建可扩充字符串值，命名为Icon，像一个键值对那样把”D:\\Program Files (x86)\\Microsoft VS Code\\code.exe“放进去就可以了。 转载自：https://blog.csdn.net/z1324402468/article/details/97410827 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"VSCode","slug":"VSCode","permalink":"http://blog.iwxyi.com/tags/VSCode/"}]},{"title":"Windows下安装Redis","date":"2020-12-25T08:50:00.000Z","path":"2020/12/25/Windows下安装Redis/","text":"下载地址：https://github.com/tporadowski/redis/releases 打开一个 cmd 窗口 使用 cd 命令切换目录到 C:\\redis 运行： 1redis-server.exe redis.windows.conf 如果想方便的话，可以把 redis 的路径加到系统的环境变量里，这样就省得再输路径了，后面的那个 redis.windows.conf 可以省略，如果省略，会启用默认的。 这时候另启一个 cmd 窗口（原来的不要关闭，不然就无法访问服务端了）。 切换到 redis 目录下运行: 1redis-cli.exe -h 127.0.0.1 -p 6379 设置键值对: 1set myKey abc 取出键值对: 1get myKey document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Redis","slug":"Redis","permalink":"http://blog.iwxyi.com/tags/Redis/"}]},{"title":"SpringBoot使用Redis","date":"2020-12-24T09:34:00.000Z","path":"2020/12/24/SpringBoot使用Redis/","text":"1、添加依赖123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt; 2、添加redis配置1234567891011121314spring: redis: #数据库索引 database: 2 host: 127.0.0.1 port: 6379 password: abcd123 jedis: pool: max-active: 8 max-wait: -1ms max-idle: 8 min-idle: 0 timeout: 300s 3、注入CacheManager既然是用redis，当然要注入RedisCacheManager ，redis缓存管理器。 123456789101112131415@Configurationpublic class RedisConfig extends CachingConfigurerSupport { @Bean public RedisCacheManager cacheManager(RedisConnectionFactory factory) { return RedisCacheManager.create(factory); } @Bean public RedisTemplate&lt;String, String&gt; redisTemplate(RedisConnectionFactory factory) { RedisTemplate&lt;String, String&gt; redisTemplate = new RedisTemplate&lt;&gt;(); redisTemplate.setConnectionFactory(factory); return redisTemplate; }} 4、具体使用简单来说，主要有三个注解 @Cacheable 表示将返回结果缓存到redis，key值为dict::“#p0”表示取第一个参数，如果参数为对象，则可以通过#p0.id获取对象的id @CacheEvict表示删除该缓存数据 @CachePut表示修改该缓存数据 12345678@ApiOperation(value = \"获取字典详情\", notes = \"根据id获取字典\")@ApiImplicitParam(name = \"id\", value = \"字典ID\", required = true, dataType = \"String\", paramType = \"query\")@RequestMapping(value = \"get-by-id\", method = RequestMethod.GET)@Cacheable(value = \"dict\", key = \"#p0\")public ResultModel&lt;PtDict&gt; getById(@RequestParam(\"id\") String id) { System.out.println(\"开始获取id为【\" + id + \"】的字典\"); return new ResultModel&lt;&gt;(ResultStatus.SUCCESS, dictService.selectById(id));} 5、缓存结果请求两次上面的controller，返回结果如下： 结果被缓存到redis 第二次请求时候没有输出“开始获取id为【58ce515474cd454fb6266f49a01833c0】的字典”，因为此时数据已从redis获取 img 转自：https://www.jianshu.com/p/8b026187dc62 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Spring","slug":"Spring","permalink":"http://blog.iwxyi.com/tags/Spring/"}]},{"title":"C++文字转语音并保存到文件","date":"2020-12-24T07:35:00.000Z","path":"2020/12/24/C-文字转语音并保存到文件/","text":"1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;sapi.h&gt;#include &lt;sphelper.h&gt;bool isCreatWavFile = false; // false播放出来，true输出到.wav音频文件int main(){ ISpVoice* pVoice = NULL; if (FAILED(::CoInitialize(NULL))) return FALSE; HRESULT hr = CoCreateInstance(CLSID_SpVoice, NULL, CLSCTX_ALL, IID_ISpVoice, (void**)&amp;pVoice); if (SUCCEEDED(hr)) { if (isCreatWavFile) // 输出到文件（不播放） { CComPtr &lt;ISpStream&gt; cpWavStream; CComPtr &lt;ISpStreamFormat&gt; cpOldStream; CSpStreamFormat originalFmt; pVoice-&gt;GetOutputStream(&amp;cpOldStream); originalFmt.AssignFormat(cpOldStream); hr = SPBindToFile(L\"d:\\\\output.wav\", SPFM_CREATE_ALWAYS, &amp;cpWavStream, &amp;originalFmt.FormatId(), originalFmt.WaveFormatExPtr()); if (SUCCEEDED(hr)) { pVoice-&gt;SetOutput(cpWavStream, TRUE); WCHAR WTX[] = L\"凡事何必都看淡，自己理解就很好，决定我们一生的，是我们的选择。我们时刻都在失去，我们努力的想去拥有更多的精彩，可惜只有两只手，所以必须学会选择，学会放弃。要清楚哪些是我们不需要的，如果心的欲望太大，什么都想抓，可能最后什么知足心灵。只平淡命运无奈\"; pVoice-&gt;Speak(WTX, SPF_IS_XML, NULL); pVoice-&gt;Release(); pVoice = NULL; } } else // 播放 { hr = pVoice-&gt;Speak(L\"Hello World\", 0, NULL); pVoice-&gt;Release(); pVoice = NULL; } } ::CoUninitialize(); return TRUE;} 如果运行过程中出现error C4996:’GetVersionExW’:被声明为已否决的错误，请请右键-项目-属性-C/C++-常规-SDL检查-否（/sdl）就可解决。 转自：https://blog.csdn.net/wuquanl/article/details/79525314 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"文件","slug":"文件","permalink":"http://blog.iwxyi.com/tags/文件/"},{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"}]},{"title":"Python简单Web服务","date":"2020-12-23T08:33:00.000Z","path":"2020/12/23/Python简单Web服务/","text":"一个非常简单的计数Web： 12345678910111213141516171819202122232425import timeimport redisfrom flask import Flaskapp = Flask(__name__)cache = redis.Redis(host='redis', port=6379)def get_hit_count(): retries = 5 while True: try: return cache.incr('hits') except redis.exceptions.ConnectionError as exc: if retries == 0: raise exc retries -= 1 time.sleep(0.5)@app.route('/')def hello(): count = get_hit_count() return 'Hello World! I have been seen {} times.\\n'.format(count)if __name__ == \"__main__\": app.run(host=\"0.0.0.0\", debug=True) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Python","slug":"Python","permalink":"http://blog.iwxyi.com/tags/Python/"}]},{"title":"AngularJS-学习笔记","date":"2020-12-23T07:21:00.000Z","path":"2020/12/23/AngularJS学习笔记/","text":"简单入门下载与使用下载地址：https://angularjs.org，点 DEVELOP / Download，找到 angularjs-1.x.x.zip 为全部文件 引入文件 1&lt;script src=\"js/angular.js\"&gt;&lt;/script&gt; 数据绑定ng-app123456789101112&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=\"js/angular.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div ng-app&gt; &lt;!-- ng-app 表示作用域 --&gt; &lt;h1&gt;{{1+2}}&lt;/h1&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ng-app表示Angular的作用于，在一个HTML文档中有且只能有一个。如果有多个，以第一个为准。所以ng-app一般放在&lt;html&gt;标签中。 可以使用 &lt;html ng-app&gt;，也可以是 &lt;html ng-app=\"\"&gt; Angular中数据使用双花括号{\\{}\\}表示数据 ng-init声明变量并赋初值 12345678910111213141516&lt;html ng-app&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=\"js/angular.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 后面部分代码，html/head/body略，仅记录重要部分 --&gt; &lt;h1&gt;{{1+2}}&lt;/h1&gt; &lt;!-- 常量 --&gt; &lt;h1 ng-init=\"a=1; b='字符串'; c={'name':'张三', 'age':18}\"&gt;&lt;/h1&gt; &lt;h2&gt;{{a}}&lt;/h2&gt; &lt;!-- 变量 --&gt; &lt;h2&gt;{{\"a\"}}&lt;/h2&gt; &lt;!-- 字符串常量 --&gt; &lt;h2&gt;姓名：{{c.name}}&lt;/h2&gt; &lt;h2&gt;年龄：{{c.age}}&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; ng-model数据与HTML元素绑定，修改元素内容则修改对应数据，以及所有显示该数据的元素 &lt;element ng-model=\"name\"&gt;&lt;/element&gt; &lt;input&gt;/&lt;select&gt;/&lt;textarea&gt;元素支持该指令 12345&lt;h1 ng-init=\"p={'name':'张三', 'age':18}\"&gt;&lt;/h1&gt;&lt;h2&gt;姓名：{{p.name}}&lt;/h2&gt;&lt;h2&gt;年龄：{{p.age}}&lt;/h2&gt;&lt;input type=\"text\" ng-model=\"p.name\"/&gt;&lt;input type=\"number\" ng-model=\"p.age\"/&gt; 模块和控制器模块的创建语法：angular.module(\"app\", []); 其中”app”是HTML中唯一一个ng-app=\"app\"的值 依赖：require(字符串数组) 1234567891011121314151617&lt;html ng-app=\"app\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=\"js/angular.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- Code... --&gt;&lt;/body&gt;&lt;script&gt; angular.module('app', []); // 创建模块&lt;/script&gt;&lt;/html&gt; 控制器$scope绑定的是数据模型，可直接使用 $scope.xxx 1234567891011&lt;body ng-controller=\"ctrl\"&gt; &lt;!-- 表示对应的控制器是 ctrl --&gt; &lt;h1&gt;{{name}}&lt;/h1&gt; &lt;!-- 相当于 $scope.name，即 张三 --&gt;&lt;/body&gt;&lt;script&gt; var myApp = angular.module('app', []); myApp.controller(\"ctrl\", [\"$scope\", function($scope) { $scope.name = '张三'; }]);&lt;/script&gt; 常用指令ng-repeat循环输出指定次数的HTML元素，集合必须是数组或对象 方式1：item in list 方式2：(key, value) in list 12345678910111213141516171819202122232425262728293031323334353637383940&lt;body ng-controller=\"ctrl\"&gt; &lt;!-- 循环数组 --&gt; &lt;ul&gt; &lt;li ng-repeat=\"s in scores\"&gt; &lt;h2&gt;{{s.name}}-{{s.score}}&lt;/h2&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr&gt; &lt;!-- 循环对象 --&gt; &lt;ul&gt; &lt;li ng-repeat=\"(key, value) in person\"&gt; &lt;h2&gt;{{key}}-{{value}}&lt;/h2&gt; &lt;/li&gt; &lt;/ul&gt; &lt;hr&gt; &lt;!-- 双重循环，使用对象的方式循环数组 --&gt; &lt;ul&gt; &lt;li ng-repeat=\"s in scores\"&gt; &lt;h2 ng-repeat=\"(key, value) in s\"&gt; {{key}}-{{value}} &lt;/h2&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;script&gt; var myApp = angular.module('app', []); myApp.controller('ctrl', [\"$scope\", function ($scope) { // 数组 $scope.scores = [ { \"name\": \"语文\", \"score\": 88 }, { \"name\": \"数学\", \"score\": 100 }, { \"name\": \"英语\", \"score\": 98 } ]; // 对象 $scope.person = {\"name\": \"张三\", \"age\": 18}; }]);&lt;/script&gt; 12345678910111213·语文-88·数学-100·英语-98---------·name-张三·age-18---------·name-语文 score-88·name-数学 score-100·name-英语 score-98 循环索引所有下标都是从 0 开始 $index 循环的索引 $first 是否是第一项 $last 是否是最后一项 $middle 是否是中间项（非第一、最后第一） $odd 下标是否是奇数（第0项false） $even 下标是否是偶数（第0项true） 123456789101112131415161718192021222324252627&lt;body ng-controller=\"ctrl\"&gt; &lt;div class=\"container\"&gt; &lt;table class='table table-bordered'&gt; &lt;tr ng-repeat=\"item in list\"&gt; &lt;td&gt;{{$index}}&lt;/td&gt; &lt;td&gt;{{item.name}}&lt;/td&gt; &lt;td&gt;{{item.age}}&lt;/td&gt; &lt;td&gt;{{$first}}&lt;/td&gt; &lt;td&gt;{{$odd}}&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var myApp = angular.module('app', []); myApp.controller('ctrl', [\"$scope\", function ($scope) { $scope.list = [ {'name': '张三1', 'age': 18}, {'name': '张三2', 'age': 18}, {'name': '张三3', 'age': 18}, {'name': '张三4', 'age': 18}, {'name': '张三5', 'age': 18}, ]; }]);&lt;/script&gt; ng-class给HTML元素动态绑定一个或多个CSS类 如果值是字符串，多个类名用空格分隔 如果值是对象，需要使用 key-value 的方式，key 为要添加的类名，value 是布尔值，仅在为 true 时添加 如果值是数组，可以由字符串或对象组合组成，数组的元素可以是字符串或对象 123456789101112131415161718192021222324252627282930&lt;html ng-app=\"app\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap.min.css\" /&gt; &lt;script src=\"js/angular.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-controller=\"ctrl\"&gt; &lt;div class=\"container\"&gt; &lt;!-- 字符串的方式：（字符串常量在双引号里面再加一个单引号） --&gt; &lt;div ng-class=\" 'btn-primary text-center' \"&gt;方式1&lt;/div&gt; &lt;!-- 对象的方式：name-bool --&gt; &lt;div ng-class=\"{ 'bg-info': true }\"&gt;方式2.1&lt;/div&gt; &lt;div ng-class=\"{ 'bg-info': isAdd }\"&gt;方式2.2&lt;/div&gt; &lt;!-- 使用控制器中的变量 --&gt; &lt;!-- 数组的方式 --&gt; &lt;div ng-class=\"[ 'btn-primary', 'text-right' ]\"&gt;方式3&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var myApp = angular.module('app', []); myApp.controller('ctrl', [\"$scope\", function ($scope) { $scope.isAdded = false; // 是否添加一个类 }]);&lt;/script&gt;&lt;/html&gt; ng-click元素被点击后需要执行的操作，所有 HTML 元素都支持 &lt;element ng-click=\"express\"&gt;&lt;/element&gt; 123456789101112131415161718&lt;body ng-controller=\"ctrl\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"btn btn-primary\" ng-click=\"temp=!temp\"&gt; 点击后切换下面H1的class的开关 &lt;/div&gt; &lt;h1 ng-class=\"{ 'bg-primary': temp, 'bg-danger': !temp }\"&gt; 使用对象的方式开关类 &lt;/h1&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var myApp = angular.module('app', []); myApp.controller('ctrl', [\"$scope\", function ($scope) { $scope.temp = true; // 赋初值 }]);&lt;/script&gt; function1234567891011121314151617181920212223&lt;body ng-controller=\"ctrl\"&gt; &lt;div class=\"container\"&gt; &lt;h1 ng-class=\"{ 'btn-primary': temp }\"&gt;{{name}}&lt;/h1&gt; &lt;!-- 普通的单击方式 --&gt; &lt;div class=\"btn btn-success\" ng-click=\"name='李四'\"&gt;修改姓名&lt;/div&gt; &lt;!-- 使用function的单击方式 --&gt; &lt;div class=\"btn btn-success\" ng-click=\"change()\"&gt;修改姓名2&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var myApp = angular.module('app', []); myApp.controller('ctrl', [\"$scope\", function ($scope) { $scope.name = \"张三\"; $scope.temp = false; $scope.change=function() { $scope.name = \"王五\"; $scope.temp = true; }; }]);&lt;/script&gt; 元素的显示与隐藏ng-show、ng-hide 元素的显示或隐藏时通过改变CSS的display属性值来实现的 1&lt;h1 ng-show=\"false\"&gt;&lt;/h1&gt; ng-show=false 或 ng-hide=true 时，会自动给元素添加上：class=\"ng-hide\" ng-if在表达式为 false 时移除 HTML 元素；true 时会添加移除的元素并显示 ng-if 不同于 ng-hide。ng-hide 是隐藏元素，而 ng-if 是从 DOM 中移除元素 1234&lt;body ng-controller=\"ctrl\" ng-init=\"check=true\"&gt; &lt;h1 ng-if=\"check==true\"&gt;文字文字&lt;/h1&gt; &lt;button ng-click=\"check = !check\"&gt;按钮&lt;/button&gt;&lt;/body&gt; ng-switch根据表达式显示或隐藏对应的部分。 ng-switch-when: 如果匹配选中选择显示 ng-switch-default: 如果都没有匹配，则默认显示 12345678&lt;body ng-controller=\"ctrl\" ng-init=\"val='b'\"&gt; &lt;div ng-switch=\"val\"&gt; &lt;h1 ng-switch-when=\"a\"&gt;选项一&lt;/h1&gt; &lt;h1 ng-switch-when=\"b\"&gt;选项二&lt;/h1&gt; &lt;h1 ng-switch-when=\"c\"&gt;选项三&lt;/h1&gt; &lt;h1 ng-switch-default&gt;默认&lt;/h1&gt; &lt;/div&gt;&lt;/body&gt; 不同控制器的数据共享父子关系 子controller / $scope 可以继承父 controller 的 $scope 对象 子controller 的 $scope 同名字段会替换掉父容器的同名字段 父级 controller 里定义一个方法，操作父级的 scope 对象，在子级 controller 里调用该方法，实现了子父通讯 123456789101112131415161718&lt;body ng-controller=\"ctrl\"&gt; &lt;h1&gt;父级的标题-{{myTitle}}&lt;/h1&gt; &lt;!--父级的标题--&gt; &lt;div ng-controller='innerCtrl'&gt; &lt;h1&gt;子级的标题-{{myTitle}}&lt;/h1&gt; &lt;!--父级的标题--&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var myApp = angular.module('app', []); myApp.controller('ctrl', [\"$scope\", function ($scope) { $scope.myTitle = '父级的标题'; }]); myApp.controller('innerCtrl', [\"$scope\", function ($scope) { }]);&lt;/script&gt; 123456789101112131415161718&lt;body ng-controller=\"ctrl\"&gt; &lt;h1&gt;父级的标题-{{myTitle}}&lt;/h1&gt; &lt;!--父级的标题--&gt; &lt;div ng-controller='innerCtrl'&gt; &lt;h1&gt;子级的标题-{{myTitle}}&lt;/h1&gt; &lt;!--子级的标题--&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var myApp = angular.module('app', []); myApp.controller('ctrl', [\"$scope\", function ($scope) { $scope.myTitle = '父级的标题'; }]); myApp.controller('innerCtrl', [\"$scope\", function ($scope) { $scope.myTitle = '子级的标题'; // 覆盖了父级 }]);&lt;/script&gt; 12345678910111213141516171819202122232425262728&lt;body ng-controller=\"ctrl\"&gt; &lt;h1&gt;父级的标题-{{myTitle}}&lt;/h1&gt; &lt;span class=\"btn btn-primary\" ng-click=\"changeTitle()\"&gt;点击切换标题&lt;/span&gt; &lt;div ng-controller='innerCtrl'&gt; &lt;!-- 子控制器 --&gt; &lt;h1&gt;子级的标题-{{myTitle}}&lt;/h1&gt; &lt;span class=\"btn btn-primary\" ng-click=\"changeTitle()\"&gt;点击切换标题&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var myApp = angular.module('app', []); myApp.controller('ctrl', [\"$scope\", function ($scope) { $scope.myTitle = '父级的标题'; $scope.changeTitle = function() { $scope.myTitle = '父级的标题2'; // 只改变父级 } }]); myApp.controller('innerCtrl', [\"$scope\", function ($scope) { $scope.myTitle = '子级的标题'; $scope.changeTitle = function () { $scope.myTitle = '子级的标题2'; // 只改变子级 } }]);&lt;/script&gt; $rootScopescope是html和单个controller之间的桥梁，数据绑定就靠他了。rootscope是各个controller中的桥梁。用rootscope定义的值，可以在各个controller中使用 $rootScope是由angularjs加载模块的时候自动创建的，每个模块只会有1个rootScope。 简而言之：$rootScope就是全局对象 1234567891011121314151617181920212223&lt;body&gt; &lt;div ng-controller=\"ctrl\"&gt; &lt;h1&gt;{{title}}&lt;/h1&gt; &lt;!-- 控制器一 --&gt; &lt;h1&gt;{{content}}&lt;/h1&gt; &lt;!-- 全局rootScope内容 --&gt; &lt;/div&gt; &lt;div ng-controller=\"ctrl2\"&gt; &lt;h1&gt;{{title}}&lt;/h1&gt; &lt;!-- 不显示内容 --&gt; &lt;h1&gt;{{content}}&lt;/h1&gt; &lt;!-- 全局rootScope内容 --&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var myApp = angular.module('app', []); myApp.controller('ctrl', [\"$scope\", \"$rootScope\", function ($scope, $rootScope) { $scope.title='控制器一'; $rootScope.content='全局rootScope内容'; }]); myApp.controller('ctrl2', [\"$scope\", function ($scope) { }]);&lt;/script&gt; 监听变化$watch用于监听模型的变化 $watch(watchExpression, listener, objectEquality); 参数一：监听的对象，可以是表达式如'name'，或函数function() { return $scope.name } 参数二：变化时要调用的函数或表达式，接收三个参数： 参数一：newValue 新值 参数二：oldValue 旧值（watchExpression 表达式的值） 参数三：scope 作用域 参数三：是否深度监听。若true，则检查所监控的对象中每一个属性的变化。如果要监控数组的个别元素或者对象的属性而不是一个普通的值，那么应该使用他 1234567891011121314151617181920&lt;script&gt; var myApp = angular.module('app', []); myApp.controller('ctrl', [\"$scope\", function ($scope) { $scope.title = 'a'; $scope.title2 = 'b'; $scope.$watch('title==title2', function(newVal, oldVal, scope){ /* 检测到 title==title2 表达式值发生变化时 */ }); $scope.user = { \"name\": \"张三\", \"age\": 20 }; $scope.$watch('user', function(newVal, oldVal, scope){ /* 检测到 user 值发生变化时 */ console.log(JSON.stringify(newVal)); }); }]);&lt;/script&gt; $apply传播 module 变化 12345678// 错误用法myApp.controller('ctrl', [\"$scope\", function ($scope) { $scope.num = 0; setInterval(function () { // 原生JS定时器 // 这个语句不会及时更改界面，因为更改num时，Angular不知道值改变了 $scope.num++; }, 1000);}]); 12345678myApp.controller('ctrl', [\"$scope\", function ($scope) { $scope.num = 0; setInterval(function () { $scope.$apply(function () { // 放在 $apply 里面，则可以立马监听到值改变了 $scope.num++; }); }, 1000);}]); 123456789// 使用Angular自带定时器，免applymyApp.controller('ctrl', [\"$scope\", \"$interval\", function($scope, $interval) { $scope.num = 0; var timer = $interval(function() { // 自带的定时器 $scope.num++; if ($scope.num == 10) $interval.cancel(timer); // 取消定时器 }, 1000);}]); $ng-bind使用给定的变量或表达式的值来替换 HTML 元素的内容 如果给定的变量或表达式修改了，指定替换的 HTML 元素也会修改 nb-bind作用和{\\{}\\}是一样的 用双大括号的形式，浏览器会先加载HTML，再加载Angular。在网速慢或反应慢的时候，会先短暂出现一大堆的{\\{}\\}，再消失 12&lt;h1&gt;{{title}}&lt;/h1&gt;&lt;h1 ng-bind=\"title\"&gt;&lt;/h1&gt; 框架搭建表单验证 ng-minlength 最小长度 ng-maxlength 最大长度 ng-required 是否是必填项 ng-pattern 正则匹配 ng-disabled 指令设置表单输入字段的disabled属性（input, select, textarea），true时禁用 123456789101112131415161718192021222324252627282930313233&lt;form name=\"form1\"&gt; &lt;div class=\"form-group\"&gt; &lt;label class=\"col-sm-2 control-label\"&gt;用户名&lt;/label&gt; &lt;div class=\"col-sm-5\"&gt; &lt;!-- 设置输入控件条件、必填项 --&gt; &lt;input type=\"text\" name=\"User\" ng-model=\"UserName\" class=\"form-control\" ng-minlength=\"4\" ng-maxlength=\"20\" ng-required=\"true\" /&gt; &lt;/div&gt; &lt;div class=\"col-sm-5\"&gt; &lt;p class=\"form-control-static\" ng-show=\"form1.User.$invalid\"&gt;请输入4-20位用户名&lt;/p&gt; &lt;!-- &lt;p class=\"form-control-static\" ng-hide=\"form1.User.$valid\"&gt;请输入4-20位用户名&lt;/p&gt; --&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label class=\"col-sm-2 control-label\"&gt;手机号&lt;/label&gt; &lt;div class=\"col-sm-5\"&gt; &lt;!-- 使用正则表达式 --&gt; &lt;input type=\"tel\" name=\"tel\" ng-model=\"tel\" class=\"form-control\" ng-model=\"tel\" ng-pattern=\"/1[3578]\\d{9}/\" ng-required=\"true\" /&gt; &lt;/div&gt; &lt;div class=\"col-sm-5\"&gt; &lt;!-- 使用 $error 逐个验证 invalid 原因 --&gt; &lt;p class=\"form-control-static\" ng-show=\"form1.tel.$error.required\"&gt;手机号不能为空&lt;/p&gt; &lt;p class=\"form-control-static\" ng-show=\"form1.tel.$error.pattern\"&gt;请输入正确的手机号&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;div class=\"col-sm-offset-2 col-sm-10\"&gt; &lt;!-- 所有输入控件有效时才允许输入 --&gt; &lt;button type=\"submit\" class=\"btn btn-primary\" ng-disabled=\"form1.$invalid\"&gt;注册&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; ng-option在表达式中使用数组来字段生成一个select中的option列表 用法： 是一个数组时： 1$scope.names = [\"Email\", \"Tobias\", \"Linus\"]; item for item in names 是一个对象数组时 1234$scope.colors = [ {id:1, name:'black', shade:'dark'}, {id:2, name:'white', shade:'light'}]; c.name for c in colors 使用name作为列表 c.id as c.name for c in colors 显示name，但是value是id；不加as则默认值为对象JSON c.id as c.name group by c.shade for c in colors 通过某一数组分组（二层树状） 123456789101112131415161718192021222324252627282930&lt;body ng-controller=\"ctrl\"&gt; &lt;!-- ng-options设置下拉列表，ng-model（必须加上）设置默认值 --&gt; &lt;select class=\"form-control\" ng-options=\"a for a in names\" ng-model=\"name\"&gt;&lt;/select&gt; &lt;!-- 第二种方式提前设置默认值（必须加上ng-model）。（别设置$scope.name默认值） --&gt; &lt;select class=\"form-control\" ng-options=\"a for a in names\" ng-model=\"name\"&gt; &lt;option value=\"\"&gt;--请选择--&lt;/option&gt; &lt;/select&gt; &lt;hr&gt; &lt;!-- 遍历对象，并设置id&lt;==name --&gt; &lt;select class=\"form-control\" ng-options=\"color.id as color.name for color in colors\" ng-model=\"color\"&gt; &lt;/select&gt; &lt;h1&gt;选中了{{color}}&lt;/h1&gt;&lt;/body&gt;&lt;script&gt; var myApp = angular.module('app', []); // 使用Angular自带定时器，免apply myApp.controller('ctrl', [\"$scope\", function ($scope) { $scope.names = [\"张三\", \"李四\", \"王五\"]; $scope.name = \"张三\"; // 第二种方式不可设置此行name默认值，否则option默认值不生效 $scope.colors = [ { id: 1, name: 'black', shade: 'dark' }, { id: 2, name: 'white', shade: 'light' } ]; $scope.color=''; }]);&lt;/script&gt; 过滤器filter，用来过滤变量的值，或者格式化输出，得到自己所期望的结果或格式 filter格式 data|filter 数据源|过滤器名称 data|filter:params 数据源|过滤器名称:过滤器参数 data|filter:param1:param2 添加多个参数 data|filter1:param|filter2:param 添加多个过滤器 常用过滤器 currency 数值格式化为货币格式，并自动每3位加逗号。{\\{123 | currency}\\} data 日期格式化成需要的格式 number:num 用来精确浮点数，默认保留3位 limitTo:num 数据的截取 Lowercase\\uppercase 大小写过滤器 123456789&lt;h1&gt;货币符号过滤器：{{100|currency}}&lt;/h1&gt; &lt;!-- $100.00 --&gt;&lt;h1&gt;货币符号过滤器：{{100|currency:\"￥\"}}&lt;/h1&gt; &lt;!-- ￥100.00 --&gt;&lt;h1&gt;日期过滤器：{{now}}&lt;/h1&gt; &lt;!-- 2020-02-26T06:45:17.463Z --&gt;&lt;h1&gt;日期过滤器：{{now|date:\"yyyy-MM-dd HH:mm:ss\"}}&lt;/h1&gt; &lt;!-- 2020-2-26 06:45:17 --&gt;&lt;h1&gt;number过滤器：{{100.123456|number:2}}&lt;/h1&gt; &lt;!-- 100.12，默认保留3位 --&gt;&lt;h1&gt;limitTo过滤器：{{\"文本左边截取\"|limitTo:3}}&lt;/h1&gt; &lt;!-- 文本左 --&gt;&lt;h1&gt;小写过滤器：{{\"aaaBBB\"|lowercase}}&lt;/h1&gt; &lt;!-- aaabbb --&gt;&lt;h1&gt;大小过滤器：{{\"aaaBBB\"|uppercase}}&lt;/h1&gt; &lt;!-- AAABBB --&gt;&lt;h1&gt;多个一起用：{{\"aaaBBB\"|uppercase|limitTo:4}}&lt;/h1&gt; &lt;!-- AAAB --&gt; 1234var myApp = angular.module('app', []);myApp.controller('ctrl', [\"$scope\", function ($scope) { $scope.now = new Date();}]); orderBy格式：data|orderby:param 参数： 排序字段 是否逆向排序，true为逆向，默认false “-字段”该字段逆向 排序规则： 数字：从小到大 字符串：按照字母表排，数字优先级大于字母 汉字：按照字库排序，不是按照拼音 12345&lt;tr ng-repeat=\"i in list|orderBy:'name'\"&gt; &lt;!-- 注意单引号 --&gt; &lt;td&gt;{{i.id}}&lt;/td&gt; &lt;td&gt;{{i.name}}&lt;/td&gt; &lt;td&gt;{{i.type}}&lt;/td&gt;&lt;/tr&gt; 12&lt;tr ng-repeat=\"i in list|orderBy:'type':true\"&gt; &lt;!-- 倒序 --&gt;&lt;tr ng-repeat=\"i in list|orderBy:'-type'\"&gt; &lt;!-- 同倒序 --&gt; 1&lt;tr ng-repeat=\"i in list|orderBy:['type','-id']\"&gt; &lt;!-- 多项：按type顺序、id倒序 --&gt; 点击标题修改排序方式、顺序逆序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;body ng-controller=\"ctrl\"&gt; &lt;table class=\"table table-bordered\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;td ng-click=\"clickOrder('id')\"&gt;ID&lt;/td&gt; &lt;td ng-click=\"clickOrder('name')\"&gt;name&lt;/td&gt; &lt;td ng-click=\"clickOrder('type')\"&gt;type&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;!-- 使用了两个变量：排序方式、是否逆序 --&gt; &lt;tr ng-repeat=\"l in list|orderBy:orderType:reverse\"&gt; &lt;td&gt;{{l.id}}&lt;/td&gt; &lt;td&gt;{{l.name}}&lt;/td&gt; &lt;td&gt;{{l.type}}&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/body&gt;&lt;script&gt; var myApp = angular.module('app', []); // 使用Angular自带定时器，免apply myApp.controller('ctrl', [\"$scope\", function ($scope) { $scope.orderType = 'id'; $scope.reverse = false; $scope.list = [ {\"id\": 1, \"name\": \"北京\", \"type\": \"a\"}, {\"id\": 2, \"name\": \"上海\", \"type\": \"b\"}, {\"id\": 3, \"name\": \"山东\", \"type\": \"a\"}, {\"id\": 4, \"name\": \"江苏\", \"type\": \"b\"}, {\"id\": 5, \"name\": \"浙江\", \"type\": \"b\"}, ]; $scope.clickOrder = function(o) { if ($scope.orderType == o) { // 切换顺序/逆序 $scope.reverse = !$scope.reverse; } else { $scope.reverse = false; $scope.orderType = o; } } }]);&lt;/script&gt; filter格式：data|filter:param 第一个参数为字符串表示会搜索所有的字段 第一个参数为对象 {\"key\":\"\"}，key 为字段名称，只查找该字段 {\"$\":\"\"} 全属性查找 第二个参数为true时表示精确匹配；否则模糊匹配 列表关键词过滤示例： 检测item的字段：根据 search 里面的内容，过滤下方 ul 的项目 123456&lt;input type=\"text\" class=\"form-control\" ng-model=\"search\" /&gt;&lt;ul class=\"list-group\"&gt; &lt;li class=\"list-group-item\" ng-repeat=\"l in list|filter:search\"&gt; &lt;p&gt;{{l.id}}-{{l.name}}-{{l.type}}&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 只过滤一个字段： 1&lt;li class=\"list-group-item\" ng-repeat=\"l in list|filter:{'name':search}\"&gt; 全属性中过滤（相等于不用字段）： 1&lt;li class=\"list-group-item\" ng-repeat=\"l in list|filter:{'$':search}\"&gt; 精确匹配：某一字段完全等于search值 1&lt;li class=\"list-group-item\" ng-repeat=\"l in list|filter:search:true\"&gt; 省-市 过滤示例： 1234567&lt;select ng-model=\"province\" ng-options=\"item.id as item.name for item in provinceList\"&gt; &lt;option value=\"\"&gt;--请选择省份--&lt;/option&gt;&lt;/select&gt;&lt;!-- 市.provinceId = 省.id --&gt;&lt;select ng-model=\"city\" ng-options=\"item.id as item.name for item in cityList|filter:{'provinceId':province}\"&gt; &lt;option value=\"\"&gt;--请选择县市--&lt;/option&gt;&lt;/select&gt; 自定义过滤器12345App.filter(\"filterName\", [function(){ return function(data) { return data; }}]) 示例： 123456789101112// 不带参数的：四舍五入myApp.filter(\"round\", [function () { return function (data) { return Math.round(data); }}]);// 带一个参数：乘以倍数myApp.filter(\"multi\", [function () { return function (data, arg1) { return data * arg1; }}]); 路由使用路由需要引入第三方的js: angular-route.js 1&lt;script src=\"js/angular-route.js\"&gt;&lt;/script&gt; 配置路由模块的config函数里面，需要依赖注入$routeProvider 12345678var myApp = angular.module('app', [\"ngRoute\"]);myApp.config([\"$routeProvider\", function ($routeProvider) { $routeProvider.when(\"路由地址\", { template: \"\", templateUrl: \"\", controller: \"\", });}]) template简单路由示例： 使用 ng-view 自动适应对应的 template 或 templateUrl，并套上对应的 controller 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;html ng-app=\"app\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link rel=\"stylesheet\" href=\"css/bootstrap.min.css\" /&gt; &lt;script src=\"js/angular.js\"&gt;&lt;/script&gt; &lt;script src=\"js/angular-route.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-controller=\"ctrl\"&gt; &lt;nav class=\"navbar navbar-inverse\"&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;!-- AngularJS版本1.6之后，#后需要加一个感叹号 --&gt; &lt;li&gt;&lt;a href=\"#!\"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#!/list\"&gt;列表&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#!/func\"&gt;功能&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;div class=\"container\"&gt; &lt;div ng-view&gt; &lt;!-- 自动使用对应nav中template中的内容，不需要再写 --&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var myApp = angular.module('app', [\"ngRoute\"]); myApp.config([\"$routeProvider\", function ($routeProvider) { $routeProvider.when(\"/\", { template: \"&lt;h1&gt;首页的内容&lt;/h1&gt;\", }).when(\"/list\", { \"template\": \"&lt;h1&gt;列表的内容&lt;/h1&gt;\", }).when(\"/func\", { \"template\": \"&lt;h1&gt;功能的内容&lt;/h1&gt;\", }).otherwise(\"/\"); }]); myApp.controller('ctrl', [\"$scope\", function ($scope) { }]);&lt;/script&gt;&lt;/html&gt; templateUrl路由至单独页面、每个页面单独的控制器： 注意：templateUrl 方式需要用 localhost/file.html 访问，浏览器直接读取本地文件将无效 1234567891011121314151617181920212223var myApp = angular.module('app', [\"ngRoute\"]);myApp.config([\"$routeProvider\", function ($routeProvider) { $routeProvider.when(\"/\", { templateUrl: \"view/home.html\", // 导航至对应页面 controller: \"homeCtrl\", // 该页面单独的控制器 }).when(\"/list\", { \"templateUrl\": \"view/list.html\", controller: \"listCtrl\", }).when(\"/func\", { \"templateUrl\": \"view/func.html\", controller: \"funcCtrl\", }).otherwise(\"/\");}]);/* 多个控制器的数据互不影响 */myApp.controller(\"homeCtrl\", [\"$scope\", function($scope) {}]);myApp.controller(\"listCtrl\", [\"$scope\", function($scope) {}]);myApp.controller(\"funcCtrl\", [\"$scope\", function($scope) {}]); 路由传参配置路由时路径 path/:param1/:param2 获取参数：在控制器里面依赖注入 $routeParams，使用 $routeParams.param1 来获取参数 1234&lt;!-- 子页面 --&gt;&lt;a ng-init=\"name='test'\"&gt;&lt;a href=\"#!/detail/:'hhh'\"&gt;查看详情&lt;/a&gt;&lt;a href=\"#!/detail/:name\"&gt;查看详情&lt;/a&gt; 1234567891011121314151617181920212223242526&lt;script&gt; var myApp = angular.module('app', [\"ngRoute\"]); myApp.config([\"$routeProvider\", function ($routeProvider) { $routeProvider.when(\"/\", { \"templateUrl\": \"view/home.html\", \"controller\": \"homeCtrl\" }).when(\"/list\", { \"templateUrl\": \"view/list.html\", \"controller\": \"listCtrl\" }).when(\"/func\", { \"templateUrl\": \"view/func.html\", \"controller\": \"funcCtrl\" }).when(\"/detail/:name\", { \"templateUrl\": \"view/detail.html\", \"controller\": \"detailCtrl\" }).otherwise(\"/list\"); }]); /* 多个控制器的数据互不影响 */ /* ... */ myApp.controller(\"detailCtrl\", [\"$scope\", \"$routeParams\", function($scope, $routeParams) { // 获取到的参数数据，在detail.html中使用并显示出来 $scope.name = $routeParams.name; }]);&lt;/script&gt; 服务所有服务都不能HTML中直接使用，必须要和控制器scope的某个值绑定 也可以把整个服务赋值给控制器成员变量，则相当于直接使用 factory123456789101112131415161718192021222324var myApp = angular.module('app', []);// 服务注入到控制器（一般自己写的服务加在最后面）myApp.controller('ctrl', [\"$scope\", \"myService\", function ($scope) { $scope.msg = myService.msg; $scope.num = myService.num; $scope.sum = myService.sum(1,2);}]);// 服务里面可以嵌套另一个服务myApp.factory(\"myService\", [\"number\", function() { return { \"msg\": \"hello\", // 常量 \"num\": 10, \"sum\": function(a, b) { // 功能性方法 return a + b * number.multi; } };}]);myApp.factory(\"number\", [function(){ return { multi:20 }}]); service同factory，只是把返回的数组改用this 12345myApp.service(\"myService\", [function() { this.sum = function(a, b) { return a + b; }}]); constant一般常量用 constant 和 value constant 一般用作不做修改的全局变量 12345678myApp.controller(\"ctrl\", [\"$scope\", \"config\", function($scope, config) { $scope.config = config; // 赋值整个config，则可以直接如 {{config.bgColor}}}]);myApp.constant(\"myConfig\", { \"version\": \"1.2.0\", \"bgColor\": \"red\"}); value123myApp.value(\"data\", { \"num\": 10}); provider类似service服务，不过分成了两部分 12345678910111213141516171819202122232425// 服务注入到 config。名称中**必须**再加上 `Provider` 后缀// 只能用 $get 外面的myApp.config([\"calcProvider\", function() { console.log(calcProvider.msg);}]);// 在控制器中只能用 $get 里面的myApp.controller(\"ctrl\", [\"$scope\", \"calc\", function($scope, calc) { $scope.num = calc.sum(1, 2);}]);myApp.service(\"calc\", [function() { // 只能在config函数里面使用 this.msg = \"\"; this.num = 10; // $get 里面的对象只能在控制器controller中使用 this.$get = function() { return { sum: function(a, b) { return a + b; } }; }}]); 自定义指令可以理解成在特定DOM元素上运行的函数，指令可以扩展成这个元素的功能 123456angular.module('myApp', []) .directive('myDirective', [function() { return { restrict: \"ESMA\", }; }]); restrict、template、replace restrict 调用方式，值为： E: 标签调用 A: 属性调用 C: 类名调用 M: 注释调用 template 模板HTML 模板必须有一个根元素，即最外层不能多个标签并行（包括 templateUrl 的文件） replace 指令标记是否被替换 12345678910111213141516171819&lt;body&gt; &lt;!--以下四种情况都会替换为 template 中内容--&gt; &lt;hello-dir&gt;E元素标签&lt;/hello-dir&gt; &lt;div hello-dir&gt;A属性方式&lt;/div&gt; &lt;div class=\"hello-dir\"&gt;C类名方式&lt;/div&gt; &lt;!-- directive: hello-dir --&gt; &lt;!-- M注释方式，注意结尾要留空 --&gt;&lt;/body&gt;&lt;script&gt; var myApp = angular.module('app', []); // 驼峰命名法要改格式，调用改成：hello-dir myApp.directive('helloDir', [function () { return { \"restrict\": \"ESMA\", \"template\": \"&lt;h1&gt;Hello, Directory&lt;/h1&gt;\", \"replace\": true // 完全替换掉原来的标签；注释调用此项也必须要true }; }]);&lt;/script&gt; templateURL 方式一：值为HTML路径 12345678// &lt;hello&gt;元素标签&lt;/hello&gt;myApp.directive('hello', [function () { return { \"restrict\": \"E\", \"templateUrl\": \"view/link.html\", // 注意改文字必须有一个root标签 \"replace\": true };}]); 方式二：页面里添加一个script标签，type属性为：text/ng-template，id属性值自己定义，templateUrl的值就是这个script标签的id属性值（通过 id 进行关联） 1234567891011121314151617&lt;body&gt; &lt;hello&gt;元素标签的形式&lt;/hello&gt;&lt;/body&gt;&lt;script&gt; var myApp = angular.module('app', []); myApp.directive('hello', [function () { return { \"restrict\": \"ECMA\", \"templateUrl\": \"tpl1\" }; }]);&lt;/script&gt;&lt;script type=\"text/ng-template\" id=\"tpl1\"&gt; &lt;h1&gt;第二种模板&lt;/h1&gt;&lt;/script&gt; transcludeboolean，保留指令标记原有内容。默认 false（覆盖原内容） true 时原有内容被保留在模板页里有 ng-transclude 指令的元素中 main.html 12345678910111213141516&lt;body&gt; &lt;hello&gt; &lt;a&gt;原有的内容&lt;/a&gt; &lt;/hello&gt;&lt;/body&gt;&lt;script&gt; var myApp = angular.module('app', []); myApp.directive('hello', [function () { return { \"restrict\": \"E\", \"templateUrl\": \"view/link.html\", \"transclude\": true }; }]);&lt;/script&gt; link.html 1234&lt;div&gt; &lt;!-- 注意需要一个根标签 --&gt; &lt;div&gt; 模板内容 &lt;/div&gt; &lt;div ng-transclude&gt;&lt;/div&gt; &lt;!-- 这里显示原来的内容 --&gt;&lt;/div&gt; scope 指令的scope有三种选择： false （默认） 可以直接使用父作用域中的变量，共享同一个model，修改数据会反映到父作用域即标签中使用ng-model 123456789101112131415161718192021222324252627282930&lt;!-- main.html --&gt;&lt;body ng-controller=\"ctrl\"&gt; &lt;h1&gt;{{title}}&lt;/h1&gt; &lt;!-- 出现两个相同标题 --&gt; &lt;!-- 相当于两个input，修改任意一个model随之修改 --&gt; &lt;input type=\"text\" ng-model=\"name\" /&gt; &lt;hello&gt;&lt;/hello&gt; &lt;!-- 这里替换为另一个相同model的input --&gt;&lt;/body&gt;&lt;script&gt; var myApp = angular.module('app', []); myApp.controller('ctrl', [\"$scope\", function ($scope) { $scope.name = \"张三\"; // 这是共享的变量 }]); myApp.directive('hello', [function () { return { \"restrict\": \"E\", \"templateUrl\": \"view/link.html\", \"controller\": [\"$scope\", function($scope) { // 声明一个子控制器 $scope.title = \"标题\"; // 子作用于反向作用于父控制器 }], // \"scope\": true // 设置为true 后，父子作用域不通 }; }]);&lt;/script&gt;&lt;!-- link.html --&gt;&lt;div&gt; &lt;h1&gt;{{title}}&lt;/h1&gt; &lt;input type=\"text\" ng-model=\"name\" /&gt;&lt;/div&gt; true 创建一个新的作用域，继承自父作用域。 {} 创建与父作用域隔离的新作用域，使在不知道外部环境的情况下可以正常工作，不依赖外部环境。 可以通过向 scope 的 { } 中传入特殊的前缀标识符（即prefix）来进行数据的绑定。 在创建了隔离的作用域，我们可以通过 @, &amp;, = 引用应用指令的元素的属性。 1234567891011121314151617181920212223242526272829303132333435&lt;!-- main.html --&gt;&lt;body ng-controller=\"ctrl\"&gt; &lt;input type=\"text\" ng-model=\"name\" /&gt; &lt;!-- 一、@单向绑定，这里用的是out-cons，使之可以使用name --&gt; &lt;hello out-cons=\"{{name}}\"&gt;&lt;/hello&gt; &lt;!-- 二、=双向项绑定（不需要花括号） --&gt; &lt;hello out-cons=\"{{name}}\" out-funs=\"sum()\"&gt;&lt;/hello&gt;&lt;/body&gt;&lt;script&gt; var myApp = angular.module('app', []); myApp.controller('ctrl', [\"$scope\", function ($scope) { $scope.name = \"张三\"; // 这是共享的变量 $scope.sum = function() { } // 共享的方法 }]); myApp.directive('hello', [function () { return { \"restrict\": \"E\", \"templateUrl\": \"view/home.html\", \"scope\": { \"innerCons\": \"@outCons\", // 单向绑定，父作用域改则子作用域改，反之不改 \"innerFuns\": \"=outFuns\", // 双向绑定 } }; }]);&lt;/script&gt;&lt;!-- link.html --&gt;&lt;div&gt; &lt;!-- 这里用的是inner（key） --&gt; &lt;input type=\"text\" ng-model=\"innerCons\" /&gt; &lt;span ng-click=\"innerFuns()\"&gt;&lt;/div&gt; linklink 参数要求声明一个链接函数。在此函数中，可操作 template 中的元素，设置样式、添加回调事件等 12function(scope, element, attrs) {} 12345678910111213141516171819- scope: 与指令元素相关联的当前作用域- element: 当前指令对应的元素，使用它可以操作该元素及其子元素。例如`&lt;span my-directive&gt;&lt;/span&gt;`，这个 span 就是指令 `my-directive` 所使用的的元素- attrs: 由当前的元素的属性组成的对象```jsmyApp.directive('hello', [function () { return { \"restrict\": \"EA\", \"template\": \"&lt;span&gt;点击&lt;/span&gt;\", \"link\": function(scope, element, attr) { console.log(element); element.find(\"span\").addClass(\"btn btn-success\"); element.find(\"span\").on(\"click\", function(){ alert(111); }); } };}]); require 可以将其他指令穿给自己 directiveName 通过驼峰命名法的命名制定了控制器应该带有哪一条指令，默认会从同一个元素上的指令 ^directiveName 在父级查找指令 ?directiveName 表示指令是可选的，如果找不到，不需要抛出移除 1234567891011121314151617181920212223242526272829303132&lt;body ng-controller=\"ctrl\"&gt; &lt;!-- dire2 里面要用到 dire1 的函数 --&gt; &lt;dire2 dire1&gt;&lt;/dire2&gt;&lt;/body&gt;&lt;script&gt; var myApp = angular.module('app', []); myApp.controller('ctrl', [\"$scope\", function ($scope) { }]); myApp.directive('dire1', [function () { return { \"restrict\": \"EA\", \"controller\": ['$scope', function($scope) { this.getName = function(name) { return \"name=\" + name; } }] }; }]); myApp.directive('dire2', [function () { return { \"restrict\": \"EA\", \"require\": \"dire1\", // 多个可用数组：[\"dire1\", \"dire3\"]，ctrl参数变为数组类型 \"template\": \"{{name}}\", \"link\": function (scope, element, attrs, ctrl/*ctrl里面的dire2有dire1*/) { scope.name = ctrl.getName(\"张三的name\"); /* require数组时，ctrl也变为数组，使用：ctrl[0].getName(\"\") */ } }; }]);&lt;/script&gt; 父级概念： 12345&lt;dire2 dire1&gt;&lt;/dire2&gt;&lt;!-- 下面为父子级，子级可向上require父级 --&gt;&lt;dire1&gt; &lt;dire2&gt;&lt;/dire2&gt;&lt;/dire1&gt; $http用于读取远程服务器的数据 123456789101112131415$http({ url:url, //请求的url路径 method:method, //GET/DELETE/HEAD/JSONP/POST/PUT params:params , //转为 ?param1=xx1¶m2=xx2的形式 data: data //包含了将被当做消息体发送给服务器的数据，通常在POST}).then(function(response){ response.data; // 请求成功执行代码}, function(response){ // 请求失败执行代码});$http.get('/someUrl', config).then(successCallback, errorCallback);$http.post('/someUrl', config).then(successCallback, errorCallback); 小提示：ng-repeat 不想要某项重复的话在结尾加：item in list track by $index response参数： data:响应体，就是后台响应后返回的数据。格式为字符串或对象 status:http返回的状态码,如200，表示服务器响应成功 headers(函数)：头信息的getter函数，可以接受一个参数，用来获取对应名字的值 config(对象)：生成原始请求的完整设置对象 statusText:相应的http状态文本，如”ok” document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.iwxyi.com/tags/学习笔记/"},{"name":"AngularJS","slug":"AngularJS","permalink":"http://blog.iwxyi.com/tags/AngularJS/"}]},{"title":"Thymeleaf用法","date":"2020-12-22T09:33:00.000Z","path":"2020/12/22/Thymeleaf用法/","text":"作者：纯洁的微笑出处：http://www.ityouknow.com/ thymeleaf介绍简单说， Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。相较与其他的模板引擎，它有如下三个极吸引人的特点： 1.Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。 2.Thymeleaf 开箱即用的特性。它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、该jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。 3.Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。 标准表达式语法它们分为四类： 1.变量表达式 2.选择或星号表达式 3.文字国际化表达式 4.URL表达式 变量表达式变量表达式即OGNL表达式或Spring EL表达式(在Spring术语中也叫model attributes)。如下所示：${session.user.name} 它们将以HTML标签的一个属性来表示： 12&lt;span th:text=\"${book.author.name}\"&gt;&lt;li th:each=\"book : ${books}\"&gt; 选择(星号)表达式选择表达式很像变量表达式，不过它们用一个预先选择的对象来代替上下文变量容器(map)来执行，如下：*{customer.name} 被指定的object由th:object属性定义： 12345&lt;div th:object=\"${book}\"&gt;...&lt;span th:text=\"*{title}\"&gt;...&lt;/span&gt;...&lt;/div&gt; 文字国际化表达式文字国际化表达式允许我们从一个外部文件获取区域文字信息(.properties)，用Key索引Value，还可以提供一组参数(可选). 12#{main.title}#{message.entrycreated(${entryId})} 可以在模板文件中找到这样的表达式代码： 123456&lt;table&gt; ... &lt;th th:text=\"#{header.address.city}\"&gt;...&lt;/th&gt; &lt;th th:text=\"#{header.address.country}\"&gt;...&lt;/th&gt; ...&lt;/table&gt; URL表达式URL表达式指的是把一个有用的上下文或回话信息添加到URL，这个过程经常被叫做URL重写。@{/order/list}URL还可以设置参数：@{/order/details(id=${orderId})}相对路径：@{../documents/report} 让我们看这些表达式： 12&lt;form th:action=\"@{/createOrder}\"&gt;&lt;a href=\"main.html\" th:href=\"@{/main}\"&gt; 变量表达式和星号表达有什么区别吗？如果不考虑上下文的情况下，两者没有区别；星号语法评估在选定对象上表达，而不是整个上下文什么是选定对象？就是父标签的值，如下： 12345&lt;div th:object=\"${session.user}\"&gt; &lt;p&gt;Name: &lt;span th:text=\"*{firstName}\"&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=\"*{lastName}\"&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=\"*{nationality}\"&gt;Saturn&lt;/span&gt;.&lt;/p&gt;&lt;/div&gt; 这是完全等价于： 12345&lt;div th:object=\"${session.user}\"&gt; &lt;p&gt;Name: &lt;span th:text=\"${session.user.firstName}\"&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=\"${session.user.lastName}\"&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=\"${session.user.nationality}\"&gt;Saturn&lt;/span&gt;.&lt;/p&gt;&lt;/div&gt; 当然，美元符号和星号语法可以混合使用： 12345&lt;div th:object=\"${session.user}\"&gt; &lt;p&gt;Name: &lt;span th:text=\"*{firstName}\"&gt;Sebastian&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Surname: &lt;span th:text=\"${session.user.lastName}\"&gt;Pepper&lt;/span&gt;.&lt;/p&gt; &lt;p&gt;Nationality: &lt;span th:text=\"*{nationality}\"&gt;Saturn&lt;/span&gt;.&lt;/p&gt;&lt;/div&gt; 表达式支持的语法字面（Literals） 文本文字（Text literals）: 'one text', 'Another one!',… 数字文本（Number literals）: 0, 34, 3.0, 12.3,… 布尔文本（Boolean literals）: true, false 空（Null literal）: null 文字标记（Literal tokens）: one, sometext, main,… 文本操作（Text operations） 字符串连接(String concatenation): + 文本替换（Literal substitutions）: |The name is ${name}| 算术运算（Arithmetic operations） 二元运算符（Binary operators）: +, -, *, /, % 减号（单目运算符）Minus sign (unary operator): - 布尔操作（Boolean operations） 二元运算符（Binary operators）:and, or 布尔否定（一元运算符）Boolean negation (unary operator):!, not 比较和等价(Comparisons and equality) 比较（Comparators）: &gt;, &lt;, &gt;=, &lt;= (gt, lt, ge, le) 等值运算符（Equality operators）:==, != (eq, ne) 条件运算符（Conditional operators） If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue) 所有这些特征可以被组合并嵌套： 1'User is of type ' + (${user.isAdmin()} ? 'Administrator' : (${user.type} ?: 'Unknown')) 常用th标签都有那些？ 关键字 功能介绍 案例 th:id 替换id &lt;input th:id=\"'xxx' + ${collect.id}\"/&gt; th:text 文本替换 &lt;p th:text=\"${collect.description}\"&gt;description&lt;/p&gt; th:utext 支持html的文本替换 &lt;p th:utext=\"${htmlcontent}\"&gt;conten&lt;/p&gt; th:object 替换对象 &lt;div th:object=\"${session.user}\"&gt; th:value 属性赋值 &lt;input th:value=\"${user.name}\" /&gt; th:with 变量赋值运算 &lt;div th:with=\"isEven=${prodStat.count}%2==0\"&gt;&lt;/div&gt; th:style 设置样式 th:style=\"'display:' + @{(${sitrue} ? 'none' : 'inline-block')} + ''\" th:onclick 点击事件 th:onclick=\"'getCollect()'\" th:each 属性赋值 tr th:each=\"user,userStat:${users}\"&gt; th:if 判断条件 &lt;a th:if=\"${userId == collect.userId}\" &gt; th:unless 和th:if判断相反 &lt;a th:href=\"@{/login}\" th:unless=${session.user != null}&gt;Login&lt;/a&gt; th:href 链接地址 &lt;a th:href=\"@{/login}\" th:unless=${session.user != null}&gt;Login&lt;/a&gt; /&gt; th:switch 多路选择 配合th:case 使用 &lt;div th:switch=\"${user.role}\"&gt; th:case th:switch的一个分支 &lt;p th:case=\"'admin'\"&gt;User is an administrator&lt;/p&gt; th:fragment 布局标签，定义一个代码片段，方便其它地方引用 &lt;div th:fragment=\"alert\"&gt; th:include 布局标签，替换内容到引入的文件 &lt;head th:include=\"layout :: htmlhead\" th:with=\"title='xx'\"&gt;&lt;/head&gt; /&gt; th:replace 布局标签，替换整个标签到引入的文件 &lt;div th:replace=\"fragments/header :: title\"&gt;&lt;/div&gt; th:selected selected选择框 选中 th:selected=\"(${xxx.id} == ${configObj.dd})\" th:src 图片类地址引入 &lt;img class=\"img-responsive\" alt=\"App Logo\" th:src=\"@{/img/logo.png}\" /&gt; th:inline 定义js脚本可以使用变量 &lt;script type=\"text/javascript\" th:inline=\"javascript\"&gt; th:action 表单提交的地址 &lt;form action=\"subscribe.html\" th:action=\"@{/subscribe}\"&gt; th:remove 删除某个属性 &lt;tr th:remove=\"all\"&gt; 1.all:删除包含标签和所有的孩子。 th:attr 设置标签属性，多个属性可以用逗号分隔 比如 th:attr=\"src=@{/image/aa.jpg},title=#{logo}\"，此标签不太优雅，一般用的比较少。 还有非常多的标签，这里只列出最常用的几个,由于一个标签内可以包含多个th:x属性，其生效的优先级顺序为:include,each,if/unless/switch/case,with,attr/attrprepend/attrappend,value/href,src ,etc,text/utext,fragment,remove。 几种常用的使用方法1、赋值、字符串拼接12&lt;p th:text=\"${collect.description}\"&gt;description&lt;/p&gt;&lt;span th:text=\"'Welcome to our application, ' + ${user.name} + '!'\"&gt; 字符串拼接还有另外一种简洁的写法 1&lt;span th:text=\"|Welcome to our application, ${user.name}!|\"&gt; 2、条件判断 If/UnlessThymeleaf中使用th:if和th:unless属性进行条件判断，下面的例子中，&lt;a&gt;标签只有在th:if中条件成立时才显示： 12&lt;a th:if=\"${myself=='yes'}\" &gt; &lt;/i&gt; &lt;/a&gt;&lt;a th:unless=${session.user != null} th:href=\"@{/login}\" &gt;Login&lt;/a&gt; th:unless于th:if恰好相反，只有表达式中的条件不成立，才会显示其内容。 也可以使用 (if) ? (then) : (else) 这种语法来判断显示的内容 3、for 循环12345678910&lt;tr th:each=\"collect,iterStat : ${collects}\"&gt; &lt;th scope=\"row\" th:text=\"${collect.id}\"&gt;1&lt;/th&gt; &lt;td &gt; &lt;img th:src=\"${collect.webLogo}\"/&gt; &lt;/td&gt; &lt;td th:text=\"${collect.url}\"&gt;Mark&lt;/td&gt; &lt;td th:text=\"${collect.title}\"&gt;Otto&lt;/td&gt; &lt;td th:text=\"${collect.description}\"&gt;@mdo&lt;/td&gt; &lt;td th:text=\"${terStat.index}\"&gt;index&lt;/td&gt;&lt;/tr&gt; iterStat称作状态变量，属性有： index:当前迭代对象的index（从0开始计算） count: 当前迭代对象的index(从1开始计算) size:被迭代对象的大小 current:当前迭代变量 even/odd:布尔值，当前循环是否是偶数/奇数（从0开始计算） first:布尔值，当前循环是否是第一个 last:布尔值，当前循环是否是最后一个 4、URLURL在Web应用模板中占据着十分重要的地位，需要特别注意的是Thymeleaf对于URL的处理是通过语法@{…}来处理的。如果需要Thymeleaf对URL进行渲染，那么务必使用th:href，th:src等属性，下面是一个例子 12345&lt;!-- Will produce 'http://localhost:8080/standard/unread' (plus rewriting) --&gt;&lt;a th:href=\"@{/standard/{type}(type=${type})}\"&gt;view&lt;/a&gt;&lt;!-- Will produce '/gtvg/order/3/details' (plus rewriting) --&gt;&lt;a href=\"details.html\" th:href=\"@{/order/{orderId}/details(orderId=${o.id})}\"&gt;view&lt;/a&gt; 设置背景 1&lt;div th:style=\"'background:url(' + @{/&lt;path-to-image&gt;} + ');'\"&gt;&lt;/div&gt; 根据属性值改变背景 1&lt;div class=\"media-object resource-card-image\" th:style=\"'background:url(' + @{(${collect.webLogo}=='' ? 'img/favicon.png' : ${collect.webLogo})} + ')'\" &gt;&lt;/div&gt; 几点说明： 上例中URL最后的(orderId=${o.id}) 表示将括号内的内容作为URL参数处理，该语法避免使用字符串拼接，大大提高了可读性 @{...}表达式中可以通过{orderId}访问Context中的orderId变量 @{/order}是Context相关的相对路径，在渲染时会自动添加上当前Web应用的Context名字，假设context名字为app，那么结果应该是/app/order 5、内联js内联文本：[[…]]内联文本的表示方式，使用时，必须先用th:inline=”text/JavaScript/none”激活，th:inline可以在父级标签内使用，甚至作为body的标签。内联文本尽管比th:text的代码少，不利于原型显示。 12345678&lt;script th:inline=\"javascript\"&gt;/*&lt;![CDATA[*/...var username = /*[[${sesion.user.name}]]*/ 'Sebastian';var size = /*[[${size}]]*/ 0;.../*]]&gt;*/&lt;/script&gt; js附加代码： 123/*[+var msg = 'This is a working application';+]*/ js移除代码： 123/*[- */var msg = 'This is a non-working template';/* -]*/ 6、内嵌变量为了模板更加易用，Thymeleaf还提供了一系列Utility对象（内置于Context中），可以通过#直接访问： dates ： java.util.Date的功能方法类。 calendars : 类似#dates，面向java.util.Calendar numbers : 格式化数字的功能方法类 strings : 字符串对象的功能类，contains,startWiths,prepending/appending等等。 objects: 对objects的功能类操作。 bools: 对布尔值求值的功能方法。 arrays：对数组的功能类方法。 lists: 对lists功能类方法 sets maps… 下面用一段代码来举例一些常用的方法： dates123456789101112131415161718/* * Format date with the specified pattern * Also works with arrays, lists or sets */${#dates.format(date, 'dd/MMM/yyyy HH:mm')}${#dates.arrayFormat(datesArray, 'dd/MMM/yyyy HH:mm')}${#dates.listFormat(datesList, 'dd/MMM/yyyy HH:mm')}${#dates.setFormat(datesSet, 'dd/MMM/yyyy HH:mm')}/* * Create a date (java.util.Date) object for the current date and time */${#dates.createNow()}/* * Create a date (java.util.Date) object for the current date (time set to 00:00) */${#dates.createToday()} strings12345678910111213141516171819202122232425262728293031323334/* * Check whether a String is empty (or null). Performs a trim() operation before check * Also works with arrays, lists or sets */${#strings.isEmpty(name)}${#strings.arrayIsEmpty(nameArr)}${#strings.listIsEmpty(nameList)}${#strings.setIsEmpty(nameSet)}/* * Check whether a String starts or ends with a fragment * Also works with arrays, lists or sets */${#strings.startsWith(name,'Don')} // also array*, list* and set*${#strings.endsWith(name,endingFragment)} // also array*, list* and set*/* * Compute length * Also works with arrays, lists or sets */${#strings.length(str)}/* * Null-safe comparison and concatenation */${#strings.equals(str)}${#strings.equalsIgnoreCase(str)}${#strings.concat(str)}${#strings.concatReplaceNulls(str)}/* * Random */${#strings.randomAlphanumeric(count)} 使用thymeleaf布局使用thymeleaf布局非常的方便 定义代码片段 123&lt;footer th:fragment=\"copy\"&gt;&amp;copy; 2016&lt;/footer&gt; 在页面任何地方引入： 1234&lt;body&gt; &lt;div th:include=\"footer :: copy\"&gt;&lt;/div&gt; &lt;div th:replace=\"footer :: copy\"&gt;&lt;/div&gt;&lt;/body&gt; th:include 和 th:replace区别，include只是加载，replace是替换 返回的HTML如下： 1234&lt;body&gt; &lt;div&gt; &amp;copy; 2016 &lt;/div&gt; &lt;footer&gt;&amp;copy; 2016 &lt;/footer&gt;&lt;/body&gt; 下面是一个常用的后台页面布局，将整个页面分为头部，尾部、菜单栏、隐藏栏，点击菜单只改变content区域的页面 123456789&lt;body class=\"layout-fixed\"&gt; &lt;div th:fragment=\"navbar\" class=\"wrapper\" role=\"navigation\"&gt; &lt;div th:replace=\"fragments/header :: header\"&gt;Header&lt;/div&gt; &lt;div th:replace=\"fragments/left :: left\"&gt;left&lt;/div&gt; &lt;div th:replace=\"fragments/sidebar :: sidebar\"&gt;sidebar&lt;/div&gt; &lt;div layout:fragment=\"content\" id=\"content\" &gt;&lt;/div&gt; &lt;div th:replace=\"fragments/footer :: footer\"&gt;footer&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 任何页面想使用这样的布局值只需要替换中见的 content模块即可 1234&lt;html xmlns:th=\"http://www.thymeleaf.org\" layout:decorator=\"layout\"&gt; &lt;body&gt; &lt;section layout:fragment=\"content\"&gt; ... 也可以在引用模版的时候传参 1&lt;head th:include=\"layout :: htmlhead\" th:with=\"title='Hello'\"&gt;&lt;/head&gt; layout 是文件地址，如果有文件夹可以这样写 fileName/layout:htmlheadhtmlhead 是指定义的代码片段 如 th:fragment=\"copy\" 源码案例这里有一个开源项目几乎使用了这里介绍的所有标签和布局，大家可以参考：cloudfavorites 参考thymeleaf官方指南新一代Java模板引擎ThymeleafThymeleaf基本知识thymeleaf总结文章Thymeleaf 模板的使用thymeleaf 学习笔记 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Thymeleaf","slug":"Thymeleaf","permalink":"http://blog.iwxyi.com/tags/Thymeleaf/"}]},{"title":"服务器部署SpringBoot","date":"2020-12-20T09:29:00.000Z","path":"2020/12/20/服务器部署SpringBoot/","text":"环境搭建 JDK包 环境变量 CLASSPATH = .;%Java_Home%\\bin;%Java_Home%\\lib\\dt.jar;%Java_Home%\\lib\\tools.jar Java_Home = D:\\DevKits\\JDK Path += D:\\DevKits\\JDK\\bin maven包 环境变量 Path += D:\\DevKits\\maven\\bin conf /conf/settings.xml 中的 localRepository 值改为存放 repository 的绝对位置 命令行运行12mvn compilemvn spring-boot:run document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://blog.iwxyi.com/tags/SpringBoot/"}]},{"title":"Qt的QDebug输出到文件","date":"2020-12-10T08:43:00.000Z","path":"2020/12/10/Qt的QDebug输出到文件/","text":"qInstallMessageHandler把输出信息写入文件和显示在调试窗qInstallMessageHandler来实现输出详细日志，输出文件名，行号，所在函数及事件，并写入文件。最后调用系统原来的函数，使信息像之前一样输出到调试窗口，便于开发。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#ifndef DLOG_H#define DLOG_H#include &lt;qapplication.h&gt;#include &lt;QDateTime&gt;#include &lt;QFile&gt;#include &lt;QTextStream&gt;#include &lt;QtMsgHandler&gt;#include &lt;QMessageLogContext&gt;#include &lt;QMutex&gt; void myMsgOutput(QtMsgType type, const QMessageLogContext &amp;context, const QString&amp; msg){ static QMutex mutex; mutex.lock(); QString time=QDateTime::currentDateTime().toString(QString(\"[ yyyy-MM-dd HH:mm:ss:zzz ]\")); QString mmsg; switch(type) { case QtDebugMsg: mmsg=QString(\"%1: Debug:\\t%2 (file:%3, line:%4, func: %5)\").arg(time).arg(msg).arg(QString(context.file)).arg(context.line).arg(QString(context.function)); break; case QtInfoMsg: mmsg=QString(\"%1: Info:\\t%2 (file:%3, line:%4, func: %5)\").arg(time).arg(msg).arg(QString(context.file)).arg(context.line).arg(QString(context.function)); break; case QtWarningMsg: mmsg=QString(\"%1: Warning:\\t%2 (file:%3, line:%4, func: %5)\").arg(time).arg(msg).arg(QString(context.file)).arg(context.line).arg(QString(context.function)); break; case QtCriticalMsg: mmsg=QString(\"%1: Critical:\\t%2 (file:%3, line:%4, func: %5)\").arg(time).arg(msg).arg(QString(context.file)).arg(context.line).arg(QString(context.function)); break; case QtFatalMsg: mmsg=QString(\"%1: Fatal:\\t%2 (file:%3, line:%4, func: %5)\").arg(time).arg(msg).arg(QString(context.file)).arg(context.line).arg(QString(context.function)); abort(); } QFile file(\"debug.txt\"); file.open(QIODevice::ReadWrite | QIODevice::Append); QTextStream stream(&amp;file); stream &lt;&lt; mmsg &lt;&lt; \"\\r\\n\"; file.flush(); file.close(); mutex.unlock();} #endif // DLOG_H 上面代码里使用gDefaultHandler 保留了qInstallMessageHandler返回的系统原来的函数，最后再调用。这样qDebug()、qInfo()的信息和之前一样写入调试窗口，同时也写入了文件。 Release 版本默认不包含这些信息:文件名、函数名、行数，需要在项目文件加入以下代码，加入后最好重新构建项目使之生效： xxx.pro: 1DEFINES += QT_MESSAGELOGCONTEXT main.cpp: 12345#include \"tool/dlog.h\"void main() { qInstallMessageHandler(myMsgOutput);} 参考链接：https://blog.csdn.net/sunbo94/article/details/79778905 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"Win10资源管理器连接WebDAV","date":"2020-11-28T09:49:00.000Z","path":"2020/11/28/Win10资源管理器连接WebDAV/","text":"去服务里打开WebClient，改为自动启动 修改注册表使得WIN同时支持http和https：定位到 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\WebClient\\Parameters把BasicAuthLevel 值改成2，即同时支持http和https，默认只支持https，然后重启服务 然后映射网络驱动器（添加网络位置）即可 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"C++的nullptr","date":"2020-11-19T07:37:00.000Z","path":"2020/11/19/C-的nullptr/","text":"C的NULL在C语言中，我们使用NULL表示空指针，也就是我们可以写如下代码： 12int *i = NULL;foo_t *f = NULL; 实际上在C语言中，NULL通常被定义为如下： 1#define NULL ((void *)0) 也就是说NULL实际上是一个void *的指针，然后吧void *指针赋值给int *和foo_t *的指针的时候，隐式转换成相应的类型。而如果换做一个C++编译器来编译的话是要出错的，因为C++是强类型的，void *是不能隐式转换成其他指针类型的，所以通常情况下，编译器提供的头文件会这样定义NULL： 12345#ifdef __cplusplus ---简称：cpp c++ 文件 #define NULL 0#else #define NULL ((void *)0)#endif C++的0因为C++中不能将void *类型的指针隐式转换成其他指针类型，而又为了解决空指针的问题，所以C++中引入0来表示空指针（注：0表示，还是有缺陷不完美），这样就有了类似上面的代码来定义NULL。实际上C++的书都会推荐说C++中更习惯使用0来表示空指针而不是NULL，尽管NULL在C++编译器下就是0。为什么C++的书都推荐使用0而不是NULL来表示空指针呢？我们看一个例子： 在foo.h文件中声明了一个函数： 1void bar(sometype1 a, sometype2 *b); 这个函数在a.cpp、b.cpp中调用了，分别是： a.cpp: 1bar(a, b); b.cpp: 1bar(a, 0); 好的，这些代码都是正常完美的编译运行。但是突然在某个时候我们功能扩展，需要对bar函数进行扩展，我们使用了重载，现在foo.h的声明如下： 12void bar(sometype1 a, sometype2 *b);void bar(sometype1 a, int i); // 原本的NULL会调用这个方法 这个时候危险了，a.cpp和b.cpp中的调用代码这个时候就不能按照期望的运行了。但是我们很快就会发现b.cpp中的0是整数，也就是在overload resolution的时候，我们知道它调用的是void bar(sometype1 a, int i)这个重载函数，于是我们可以做出如下修改让代码按照期望运行： 1bar(a, static_cast&lt;sometype2 *&gt;(0)); 我知道，如果我们一开始就有bar的这两个重载函数的话，我们会在一开始就想办法避免这个问题（不使用重载）或者我们写出正确的调用代码，然而后面的这个重载函数或许是我们几个月或者很长一段时间后加上的话，那我们出错的可能性就会加大了不少。貌似我们现在说道的这些跟C++通常使用0来表示空指针没什么关系，好吧，假设我们的调用代码是这样的： foo.h 1void bar(sometype1 a, sometype2 *b); a.cpp 1bar(a, b); b.cpp 1bar(a, NULL); 当bar的重载函数在后面加上来了之后，我们会发现出错了，但是出错的时候，我们找到b.cpp中的调用代码也很快可能忽略过去了，因为我们用的是NULL空指针啊，应该是调用的void bar(sometype1 a, sometype2 *b)这个重载函数啊。实际上NULL在C++中就是0，写NULL这个反而会让你没那么警觉，因为NULL不够“明显”，而这里如果是使用0来表示空指针，那就会够“明显”，因为0是空指针，它更是一个整形常量。 在C++中，使用0来做为空指针会比使用NULL来做空指针会让你更加警觉。 C++ 11的nullptr虽然上面我们说明了0比NULL可以让我们更加警觉，但是我们并没有避免这个问题。这个时候C++ 11的nullptr就很好的解决了这个问题，我们在C++ 11中使用nullptr来表示空指针，这样最早的代码是这样的， foo.h 1void bar(sometype1 a, sometype2 *b); a.cpp 1bar(a, b); b.cpp 1bar(a, nullptr); 在我们后来把bar的重载加上了之后，代码是这样： foo.h 12void bar(sometype1 a, sometype2 *b);void bar(sometype1 a, int i); a.cpp 1bar(a, b); b.cpp 1bar(a, nullptr); 这时候，我们的代码还是能够如预期的一样正确运行。 在没有C++ 11的nullptr的时候，我们怎么解决避免这个问题呢？我们可以自己实现一个（《Imperfect C++》上面有一个实现）： 123456789101112131415constclass nullptr_t{public: template&lt;class T&gt; inline operator T*() const { return 0; } template&lt;class C, class T&gt; inline operator T C::*() const { return 0; } private: void operator&amp;() const;} nullptr = {}; 参考：https://www.cnblogs.com/porter/p/3611718.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"}]},{"title":"Windows端口被占用","date":"2020-10-23T09:47:00.000Z","path":"2020/10/23/Windows端口被占用/","text":"寻找端口（看结果右边列） 1netstat -ano | findstr 8080 强制关闭端口 1taskkill /pid 4708 /f document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"DOS","slug":"DOS","permalink":"http://blog.iwxyi.com/tags/DOS/"}]},{"title":"QTreeView","date":"2020-10-23T08:49:00.000Z","path":"2020/10/23/QTreeView/","text":"Model 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include \"ModelTree.h\"#include \"Common.h\"#include \"DaRecord.h\"#include \"ScopeTailed.h\"/*最重要的就是对interpointer()这个内部指针的运用与QTableView不同的是多了parent()和index()函数的重写，这也是关键之处*/ModelTree::ModelTree(){ header_ &lt;&lt;....;}ModelTree::~ModelTree(){}bool ModelTree::loadRoots(){ beginResetModel(); mode_ = FULL; root_.children_.clear(); root_.spbm_ = \"0\"; ScopeTailed endReset([this](){endResetModel(); }); DaRecord da; if (!da.expandItem(root_)) return false; return true;}void ModelTree::loadResult(RecordTree &amp;root){ beginResetModel(); mode_ = RESULT; root_ = root; root_.buildTree(); endResetModel();}QVariant ModelTree::headerData(int section, Qt::Orientation orientation, int role /* = Qt::DisplayRole */) const{ if (orientation == Qt::Horizontal &amp;&amp; role == Qt::DisplayRole) return header_[section]; return QVariant();}int ModelTree::columnCount(const QModelIndex &amp;parent /* = QModelIndex() */) const{ return header_.count();}QVariant ModelTree::data(const QModelIndex &amp;index, int role /* = Qt::DisplayRole */) const{ if (role==Qt::DisplayRole &amp;&amp; index.isValid()) { RecordTree *pRec = static_cast&lt;RecordTree*&gt;(index.internalPointer()); switch (index.column()) { case 0:return pRec-&gt;spmc_; case 1:return pRec-&gt;spbm_; case 2:return pRec-&gt;zs_; case 3:return pRec-&gt;slv_.toString(); } } return QVariant();}int ModelTree::rowCount(const QModelIndex &amp;parent /* = QModelIndex() */) const{ if (!parent.isValid()) return root_.children_.count(); RecordTree *pRec = static_cast&lt;RecordTree*&gt;(parent.internalPointer()); if (mode_==FULL &amp;&amp; !pRec-&gt;expanded_) { DaRecord da; da.expandItem(*pRec); } return pRec-&gt;children_.count();}QModelIndex ModelTree::index(int row, int column, const QModelIndex &amp;parent /* = QModelIndex() */) const{ if (!parent.isValid()) { if (row &lt; root_.children_.count()) return createIndex(row, column, const_cast&lt;RecordTree*&gt;(&amp;root_.children_[row])); else return QModelIndex(); } RecordTree *pRec = static_cast&lt;RecordTree*&gt;(parent.internalPointer()); return createIndex(row, column, &amp;pRec-&gt;children_[row]);}QModelIndex ModelTree::parent(const QModelIndex &amp;index) const{ RecordTree *rec = static_cast&lt;RecordTree*&gt;(index.internalPointer()); if (rec-&gt;parent_ == &amp;root_) return QModelIndex(); return createIndex(rec-&gt;parent_-&gt;rowIndex_, 0, rec-&gt;parent_);} 结构 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#pragma once#include &lt;QString&gt;#include &lt;QList&gt;#include \"Common.h\"#include \"DatabaseAccess.h\"class RecordTree{public: RecordTree(); ~RecordTree();public: QString spbm_; QString spmc_; QString pid_; QString zs_; Currency slv_; bool nodeType_; //1为父节点 0没有子节点 QList&lt;RecordTree&gt; children_; bool expanded_ = false; int rowIndex_ = 0; RecordTree *parent_ = nullptr; //创建一个树结构的数据 void buildTree() { for (int i = 0; i &lt; children_.count(); i++) { RecordTree &amp;child = children_[i]; child.parent_ = this; child.rowIndex_ = i; child.buildTree(); } } //根据所传来的字段找到这个树结构的数据 RecordTree *search(QString spbm) { if (spbm_ == spbm) return this; for (RecordTree &amp;child : children_) { RecordTree *result = child.search(spbm); if (result) return result; } return nullptr; }}; 加载数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include \"DaRecord.h\"#include \"Global.h\"#include \"Database.h\"DaRecord::DaRecord(){ setDatabase(global&lt;Database&gt;()-&gt;db());}DaRecord::~DaRecord(){}bool DaRecord::selectByPid(QString &amp;pid, QList&lt;RecordTree&gt; &amp;commodity){ QString condition = QString(\"pid='%1'\").arg(pid); if (!selectBy(condition, commodity)) return false; return true;}bool DaRecord::expandItemImpl(RecordTree &amp;root){ QList&lt;RecordTree&gt; treeList; if (!selectByPid(root.spbm_, treeList)) return false; for (RecordTree &amp;res : treeList) { res.parent_ = &amp;root; res.rowIndex_ = root.children_.count(); root.children_ &lt;&lt; res; } root.expanded_ = true; return true;}bool DaRecord::expandItem(RecordTree &amp;root){ if (!expandItemImpl(root)) return false; for (RecordTree &amp;res : root.children_) if (!expandItemImpl(res)) return false; return true;}bool DaRecord::selectBySpbm(QString &amp;spbm, RecordTree &amp;res){ QString selectSql = QString(\"spbm='%1'\").arg(spbm); QList&lt;RecordTree&gt; resList; if (!selectBy(selectSql, resList)) return false; res = resList.first(); return true;}bool DaRecord::selectBykeyword(QString &amp;keyword, QList&lt;RecordTree&gt; &amp;commomdity){ QString condition = QString(\"spmc like '%%1% or zs like '%%2%'\").arg(keyword).arg(keyword); if (!selectBy(condition, commomdity)) return false; return true;}//...(查找项目)bool DaRecord::searchItem(QString &amp;keyword, RecordTree &amp;root){ QList&lt;RecordTree&gt; commoditys; if (!selectBykeyword(keyword, commoditys)) return false; for (auto &amp;cur : commoditys) { RecordTree *parent = nullptr; while (cur.pid_ != \"0\") { parent = root.search(cur.spbm_); if (!parent) { RecordTree newParent; if (!selectBySpbm(cur.pid_, newParent)) return false; root.children_ &lt;&lt; cur; cur = newParent; } else { parent-&gt;children_ &lt;&lt; cur; break; } } if (!parent) root.children_ &lt;&lt; cur; } return true;} 转载自：https://www.cnblogs.com/adeng-x/p/8097864.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"SpringBoot定义查询条件、多表查询","date":"2020-10-08T09:28:00.000Z","path":"2020/10/08/SpringBoot定义查询条件、多表查询/","text":"转载自 孙义朗： https://www.cnblogs.com/arrrrrya/p/7865090.html 实体类 123456789101112131415161718package com.syl.demo.daomain;import lombok.Data;import javax.persistence.*;@Entity@Datapublic class User { @Id private String userId; private String userName; private String password; private String gender;//性别 private String age; @ManyToOne private School school; @ManyToOne private Grade grade;} 1234567891011121314import lombok.Data;import javax.jws.soap.SOAPBinding;import javax.persistence.Entity;import javax.persistence.Id;import javax.persistence.ManyToOne;import javax.persistence.OneToMany;@Data@Entitypublic class School { @Id private String schoolId; private String schoolName;} 12345678910111213package com.syl.demo.daomain;import lombok.Data;import javax.persistence.*;@Entity@Datapublic class Grade { @Id private String gradeId; private String gradeName; @ManyToOne private School school;} 封装查询条件类 123456789101112131415package com.syl.demo.daomain;import lombok.Data;import javax.persistence.Id;@Datapublic class Params { private String userId; private String userName; private String gender; private String age; private String gradeName; private String schoolName;} Dao层 12345678910111213141516package com.syl.demo.dao;import com.syl.demo.daomain.Grade;import com.syl.demo.daomain.School;import com.syl.demo.daomain.User;import org.springframework.data.domain.Pageable;import org.springframework.data.jpa.domain.Specification;import org.springframework.data.jpa.repository.JpaRepository;import java.util.List;public interface UserRepository extends JpaRepository&lt;User,String&gt; { List&lt;User&gt; findAll(); List&lt;User&gt; findAll(Specification&lt;User&gt; spc, Pageable pageable);} Service及实现 12345678910111213141516package com.syl.demo.service;import com.syl.demo.daomain.Grade;import com.syl.demo.daomain.Params;import com.syl.demo.daomain.School;import com.syl.demo.daomain.User;import org.springframework.data.domain.Pageable;import org.springframework.data.jpa.domain.Specification;import java.util.List;public interface UserService { List&lt;User&gt; findAll(); List&lt;User&gt; findAll(int pageNum, int pageSize,User user); List&lt;User&gt; findAll(int pageNum, int pageSize, Params params);} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.syl.demo.service.impl;import com.syl.demo.dao.UserRepository;import com.syl.demo.daomain.Grade;import com.syl.demo.daomain.Params;import com.syl.demo.daomain.School;import com.syl.demo.daomain.User;import com.syl.demo.service.UserService;import org.apache.commons.lang3.StringUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.data.jpa.domain.Specification;import org.springframework.stereotype.Service;import javax.persistence.criteria.*;import java.util.ArrayList;import java.util.List;@Servicepublic class UserServiceImpl implements UserService { @Autowired private UserRepository userRepository; @Override public List&lt;User&gt; findAll() { return userRepository.findAll(); } //查询User，单表，多条件 @Override public List&lt;User&gt; findAll(int pageNum, int pageSize, User user) { Pageable pageable = new PageRequest(pageNum, pageSize); List&lt;User&gt; uList = userRepository.findAll(new Specification&lt;User&gt;() { @Override public Predicate toPredicate(Root&lt;User&gt; root, CriteriaQuery&lt;?&gt; criteriaQuery, CriteriaBuilder cb) { List&lt;Predicate&gt; predicates = new ArrayList&lt;&gt;(); if (user.getUserId() != null &amp;&amp; !user.getUserId().equals(\"\")) { predicates.add(cb.like(root.get(\"userId\").as(String.class), \"%\" + user.getUserId() + \"%\")); } if (user.getUserName() != null &amp;&amp; !user.getUserName().equals(\"\")) { predicates.add(cb.like(root.get(\"userName\").as(String.class), \"%\" + user.getUserName() + \"%\")); } if (user.getGender() != null &amp;&amp; !user.getGender().equals(\"\")) { predicates.add(cb.like(root.get(\"gender\").as(String.class), \"%\" + user.getGender() + \"%\")); } if (user.getAge() != null &amp;&amp; !user.getAge().equals(\"\")) { predicates.add(cb.like(root.get(\"age\").as(String.class), \"%\" + user.getAge() + \"%\")); } Predicate[] pre = new Predicate[predicates.size()]; criteriaQuery.where(predicates.toArray(pre)); return cb.and(predicates.toArray(pre)); } }, pageable); return uList; } //查询User，多表，多条件 @Override public List&lt;User&gt; findAll(int pageNum, int pageSize, Params params) { Pageable pageable = new PageRequest(pageNum, pageSize); List&lt;User&gt; uList = userRepository.findAll(new Specification&lt;User&gt;() { @Override public Predicate toPredicate(Root&lt;User&gt; root, CriteriaQuery&lt;?&gt; criteriaQuery, CriteriaBuilder cb) { List&lt;Predicate&gt; list = new ArrayList&lt;&gt;(); //根据userId 查询user if (StringUtils.isNotBlank(params.getUserId())) { list.add(cb.equal(root.get(\"userId\").as(String.class), params.getUserId())); } //根据userName 模糊查询user if (StringUtils.isNotBlank(params.getUserName())) { list.add(cb.like(root.get(\"userName\").as(String.class), \"%\" + params.getUserName() + \"%\")); } //根据gender 查询user if (StringUtils.isNotBlank(params.getGender())) { list.add(cb.equal(root.get(\"gender\").as(String.class), params.getGender())); } //根据age&gt;? 查询user if (StringUtils.isNotBlank(params.getAge())) { list.add(cb.gt(root.get(\"age\").as(Integer.class), Integer.valueOf(params.getAge()))); } //根据gradeName 查询user if (StringUtils.isNotBlank(params.getGradeName())) { Join&lt;Grade, User&gt; join = root.join(\"grade\", JoinType.LEFT); list.add(cb.equal(join.get(\"gradeName\"), params.getGradeName())); } //根据schoolName 查询user if (StringUtils.isNotBlank(params.getSchoolName())) { Join&lt;School, User&gt; join = root.join(\"grade\", JoinType.LEFT); list.add(cb.equal(join.get(\"school\").get(\"schoolName\"), params.getSchoolName())); } Predicate[] pre = new Predicate[list.size()]; criteriaQuery.where(list.toArray(pre)); return cb.and(list.toArray(pre)); } }, pageable); return uList; }} 控制层 123456789101112131415161718192021222324252627282930313233343536373839404142package com.syl.demo.controller;import com.syl.demo.daomain.Grade;import com.syl.demo.daomain.Params;import com.syl.demo.daomain.School;import com.syl.demo.daomain.User;import com.syl.demo.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import java.util.List;/** * Created by 孙义朗 on 2017/11/16 0016. */@RestControllerpublic class UserController { @Autowired UserService userService; @GetMapping(value = \"/getUser\") public List&lt;User&gt; getUser() { List&lt;User&gt; uList = userService.findAll(); return uList; } //查询User，单表，多条件 @PostMapping(value = \"/getUser/{pageNum}/{pageSize}\") public List&lt;User&gt; getUser(@PathVariable(\"pageNum\") Integer pageNum, @PathVariable(\"pageSize\") Integer pageSize, @RequestBody User user) { List&lt;User&gt; uList = userService.findAll(pageNum, pageSize, user); return uList; } //查询User，多表，多条件 @PostMapping(value = \"/getUser2/{pageNum}/{pageSize}\") public List&lt;User&gt; getUser2(@PathVariable(\"pageNum\") Integer pageNum, @PathVariable(\"pageSize\") Integer pageSize, @RequestBody Params params) { List&lt;User&gt; uList = userService.findAll(pageNum, pageSize, params); return uList; }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Spring","slug":"Spring","permalink":"http://blog.iwxyi.com/tags/Spring/"}]},{"title":"Qt设置连接token","date":"2020-09-19T08:42:00.000Z","path":"2020/09/19/Qt设置连接token/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142...QString Url_serial = \"https://www.example/api/\";QUrl serviceUrl(Url_serial);QNetworkRequest request_registered(serviceUrl);// 设置SSL认证方式QSslConfiguration sslconfig;sslconfig.setPeerVerifyMode(QSslSocket::VerifyNone);sslconfig.setProtocol(QSsl::TlsV1_2);//sslconfig.setPeerVerifyDepth(1);//设置本地证书QFile keyFile(\"client.p12\");bool openOK = keyFile.open(QIODevice::ReadWrite);QSslKey key;QSslCertificate certs;QList&lt;QSslCertificate&gt; caCerts;QByteArray passPhrase = QString(\"12345678\").toLatin1();openOK = QSslCertificate::importPkcs12(&amp;keyFile, &amp;key, &amp;certs, &amp;caCerts, passPhrase);keyFile.close();request_registered.setSslConfiguration(sslconfig);request_registered.setRawHeader(\"Accept\",\"*/*\");request_registered.setRawHeader(\"Connection\",\"keep-alive\");//设置 token 登陆凭证；request_registered.setRawHeader(QByteArray(\"Authorization\"),QByteArray(getQJsonDocumentFromQJsonValue(token_val)));request_registered.setHeader(QNetworkRequest::UserAgentHeader,\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/33.0.1750.152 Safari/537.36\");request_registered.setHeader(QNetworkRequest::ContentTypeHeader, \"application/x-www-form-urlencoded\");//组装数据QUrlQuery postData1;QByteArray serial_check1((char*)Serial_num, 16);serial_check = serial_check1.toHex();postData1.addQueryItem(\"seq\",serial_check);qDebug() &lt;&lt; tr(\"提交的用户token：\") + getQJsonDocumentFromQJsonValue(token_val);//发起网络请求QNetworkReply* check = m_accessManager_Registered-&gt;post(request_registered,postData1.toString(QUrl::FullyEncoded).toUtf8());.... 转自：https://codess.cc/archives/219.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"SpringBoot报错总结","date":"2020-09-16T09:26:00.000Z","path":"2020/09/16/SpringBoot报错总结/","text":"时区【报错信息】： 1Caused by: com.mysql.cj.exceptions.InvalidConnectionAttributeException: The server time zone value 'ÖÐ¹ú±ê×¼Ê±¼ä' is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support. 【解决方法】修改database的url： 1spring.datasource.url=jdbc:mysql://localhost:3306/springboot?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2B8 【报错信息】 1java.sql.SQLException: Zero date value prohibited ​ Mysql数据库在面对0000-00-00 00:00:00日期的处理时，如果没有设置对应的对策，就会产生异常 【解决方法】在jdbcUrl中设置处理zeroDateTimeBehavior 1driver-url=jdbc:mysql://127.0.0.1/test?zeroDateTimeBehavior=CONVERT_TO_NULL ​ ZERO日期会转化为null 注意：CONVERT_TO_NULL 一定是大写的，否则报错 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Spring","slug":"Spring","permalink":"http://blog.iwxyi.com/tags/Spring/"}]},{"title":"SpringBoot获取Request的三种方式","date":"2020-09-10T09:27:00.000Z","path":"2020/09/10/SpringBoot获取Request的三种方式/","text":"通过静态方法获取 1234ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();HttpServletRequest request = servletRequestAttributes.getRequest();HttpServletResponse response = servletRequestAttributes.getResponse(); 通过参数直接获取，在方法上加上参数，Springboot就会自动绑定，可以直接使用。如果有多个参数，把这两个加到后面即可。 1234@GetMapping(value = \"/test\")public String test(String str, HttpServletRequest request,HttpServletResponse response) {} 注入到类，这样就不用每个方法都写了 12345678@Autowiredprivate HttpServletRequest request;@Autowiredprivate HttpServletResponse response;@GetMapping(value = \"/test\")public String test() {} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Spring","slug":"Spring","permalink":"http://blog.iwxyi.com/tags/Spring/"}]},{"title":"查询数据库历史记录","date":"2020-09-08T09:39:00.000Z","path":"2020/09/08/查询数据库历史记录/","text":"正在执行使用processlist，但是有个弊端，就是只能查看正在执行的sql语句，对应历史记录，查看不到。好处是不用设置，不会保存。 12use information_schema;show processlist; 或者： 1select * from information_schema.`PROCESSLIST` where info is not null; 日志1、设置123SET GLOBAL log_output = 'TABLE';SET GLOBAL general_log = 'ON'; //日志开启SET GLOBAL log_output = 'TABLE'; SET GLOBAL general_log = 'OFF'; //日志关闭 2、查询1SELECT * from mysql.general_log ORDER BY event_time DESC; 3、清空表（delete对于这个表，不允许使用，只能用truncate）1truncate table mysql.general_log; 在查询sql语句之后，在对应的 C:\\Program Files\\MySQL\\MySQL Server 5.7\\data 文件夹下面有对应的log记录 ps:在查询到所需要的记录之后，应尽快关闭日志模式，占用磁盘空间比较大 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"SQL","slug":"SQL","permalink":"http://blog.iwxyi.com/tags/SQL/"}]},{"title":"SpringBoot使用JWT认证","date":"2020-09-06T09:26:00.000Z","path":"2020/09/06/SpringBoot使用JWT认证/","text":"JSON Web Token（JWT）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息。JWT的组成 一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名。简单说明就到此为止，下面我们简单介绍如何使用JWT。 1、引入相关的包 在pom.xml中引入JWT的包，和SpringMVC包。 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.auth0&lt;/groupId&gt; &lt;artifactId&gt;java-jwt&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt;&lt;/dependency&gt; 2、定义加密的秘钥 这个可以省略，可以使用用户的密码作为加密秘钥。 123public class ConstantKey { public static final String PICEA_JWT_KEY = \"spring-boot-jwt-key~#^\";} 3、直接在控制类里面引入JWT生成方法 主要说明JWT.create()方法，注释中说明了 withAudience(name) // 将 user id 保存到 token 里面 withExpiresAt(new Date(System.currentTimeMillis() + 2 * 60 * 1000)) //定义token的有效期 sign(Algorithm.HMAC256(ConstantKey.PICEA_JWT_KEY));// 加密秘钥，也可以使用用户保持在数据库中的密码字符串。最后我们得到的JWT，其实是如下一串字符串。 1eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhdWQiOiJ6aGFuZ3NhbiIsImV4cCI6MTU1NTQ5MzI0OH0.FZISiYvyLJcrARe0nC8umMZ_MdR0YMkjMXI2mXYUncE 控制类的代码如下。 1234567891011121314151617181920212223@RestControllerpublic class PiceaContoller { @RequestMapping(\"/login\") public Object login(String name, String password) throws Exception { /** * 这里为了简单，就不验证用户名和密码的正确性了，实际验证跟其他的方式一样， * 就是比对一下输入的用户名密码跟数据的数据是否一样 */ String token = \"\"; token = JWT.create() .withAudience(name)// 将 user id 保存到 token 里面 .withExpiresAt(new Date(System.currentTimeMillis() + 2 * 60 * 1000))//定义token的有效期 .sign(Algorithm.HMAC256(ConstantKey.PICEA_JWT_KEY));// 加密秘钥，也可以使用用户保持在数据库中的密码字符串 return token; } @RequestMapping(\"/queryPicea\") public String queryPicea() { String ret = \"通过验证\"; return ret; }} 4、使用拦截器实现认证 如果你对拦截器还不明白，请移步Spring Boot使用处理器拦截器HandlerInterceptor。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class AuthenticationInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object object) throws Exception { String token = httpServletRequest.getHeader(\"token\");// 从 http 请求头中取出 token // 如果不是映射到方法直接通过 if(!(object instanceof HandlerMethod)){ return true; } HandlerMethod handlerMethod=(HandlerMethod)object; Method method=handlerMethod.getMethod(); //检查方法名是否是“login”如果是则跳过，也可以加注解，用注解过滤不需要权限的方法 if (\"login\".equals(method.getName())) { return true; } // 执行认证 if (token == null) { throw new RuntimeException(\"无token，请重新登录\"); } // 获取 token 中的 name String name; try { name = JWT.decode(token).getAudience().get(0); } catch (JWTDecodeException j) { throw new RuntimeException(\"401\"); } // 验证 token JWTVerifier jwtVerifier = JWT.require(Algorithm.HMAC256(ConstantKey.PICEA_JWT_KEY)).build(); try { jwtVerifier.verify(token); } catch (JWTVerificationException e) { throw new RuntimeException(\"401\"); } return true; } @Override public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception { } @Override public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception { }} 5、建立InterceptorConfig注册拦截器 12345678910111213@Configurationpublic class InterceptorConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(authenticationInterceptor()) .addPathPatterns(\"/**\"); } @Bean public AuthenticationInterceptor authenticationInterceptor() { return new AuthenticationInterceptor(); }} 转载自：https://www.jianshu.com/p/e52f9fbf8bb8 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Spring","slug":"Spring","permalink":"http://blog.iwxyi.com/tags/Spring/"}]},{"title":"SpringBoot@RequestBody的使用","date":"2020-08-27T09:18:00.000Z","path":"2020/08/27/SpringBoot-RequestBody的使用/","text":"@RequestBody的使用 转载自：https://blog.csdn.net/justry_deng/article/details/80972817 基础知识介绍@RequestBody主要用来接收前端传递给后端的json字符串中的数据的(请求体中的数据的)；GET方式无请求体，所以使用@RequestBody接收数据时，前端不能使用GET方式提交数据，而是用POST方式进行提交。在后端的同一个接收方法里，@RequestBody与@RequestParam()可以同时使用，@RequestBody最多只能有一个，而@RequestParam()可以有多个。 注：一个请求，只有一个RequestBody；一个请求，可以有多个RequestParam。 注：当同时使用@RequestParam（）和@RequestBody时，@RequestParam（）指定的参数可以是普通元素、数组、集合、对象等等(即:当，@RequestBody 与@RequestParam()可以同时使用时，原SpringMVC接收参数的机制不变，只不过RequestBody 接收的是请求体里面的数据；而RequestParam接收的是key-value里面的参数，所以它会被切面进行处理从而可以用普通元素、数组、集合、对象等接收)。 即：如果参数时放在请求体中，传入后台的话，那么后台要用@RequestBody才能接收到；如果不是放在请求体中的话，那么后台接收前台传过来的参数时，要用@RequestParam来接收，或则形参前什么也不写也能接收。 注：如果参数前写了@RequestParam(xxx)，那么前端必须有对应的xxx名字才行(不管其是否有值，当然可以通过设置该注解的required属性来调节是否必须传)，如果没有xxx名的话，那么请求会出错，报400。 注：如果参数前不写@RequestParam(xxx)的话，那么就前端可以有可以没有对应的xxx名字才行，如果有xxx名的话，那么就会自动匹配；没有的话，请求也能正确发送。 追注：这里与feign消费服务时不同；feign消费服务时，如果参数前什么也不写，那么会被默认是@RequestBody的。 如果后端参数是一个对象，且该参数前是以@RequestBody修饰的，那么前端传递json参数时，必须满足以下要求： 后端@RequestBody注解对应的类在将HTTP的输入流(含请求体)装配到目标类(即：@RequestBody后面的类)时，会根据json字符串中的key来匹配对应实体类的属性，如果匹配一致且json中的该key对应的值符合(或可转换为)，这一条我会在下面详细分析，其他的都可简单略过，但是本文末的核心逻辑代码以及几个结论一定要看！ 实体类的对应属性的类型要求时,会调用实体类的setter方法将值赋给该属性。 json字符串中，如果value为””的话，后端对应属性如果是String类型的，那么接受到的就是””，如果是后端属性的类型是Integer、Double等类型，那么接收到的就是null。 json字符串中，如果value为null的话，后端对应收到的就是null。 如果某个参数没有value的话，在传json字符串给后端时，要么干脆就不把该字段写到json字符串中；要么写value时， 必须有值，null 或””都行。千万不能有类似”stature”:，这样的写法，如: upload successful 注：关于@RequestParam()的用法，这里就不再一一说明了，可详见 《程序员成长笔记(一)》中的相关章节。 示例详细说明先给出两个等下要用到的实体类 User实体类： upload successful Team实体类： upload successful @RequestBody直接以String接收前端传过来的json数据后端对应的Controller： upload successful 使用PostMan测试： upload successful @RequestBody以简单对象接收前端传过来的json数据后端对应的Controller： upload successful 使用PostMan测试： upload successful @RequestBody以复杂对象接收前端传过来的json数据后端对应的Controller： upload successful 使用PostMan测试： upload successful @RequestBody与简单的@RequestParam()同时使用后端对应的Controller： upload successful 使用PostMan测试： upload successful @RequestBody与复杂的@RequestParam()同时使用后端对应的Controller： upload successful 使用PostMan测试： upload successful @RequestBody接收请求体中的json数据；不加注解接收URL中的数据并组装为对象后端对应的Controller： upload successful 使用PostMan测试： upload successful 注：如果在后端方法参数前，指定了@RequestParam()的话，那么前端必须要有对应字段才行(当然可以通过设置 该注解的required属性来调节是否必须传)，否者会报错；如果参数前没有任何该注解，那么前端可以传，也可 以不传，如： upload successful 上图中，如果我们传参中没有指定token，那么请求能正常进去，但是token为null；如果在String token前指定了@RequestParam(“token”)，那么前端必须要有token这个键时，请求才能正常进去，否者报400错误。 @RequestBody与前端传过来的json数据的匹配规则 声明：根据不同的Content-Type等情况,Spring-MVC会采取不同的HttpMessageConverter实现来进行信息转换解析。下面介绍的是最常用的：前端以Content-Type 为application/json,传递json字符串数据;后端以@RequestBody模型接收数据的情况。 解析json数据大体流程概述：Http传递请求体信息，最终会被封装进com.fasterxml.jackson.core.json.UTF8StreamJsonParser中(提示：Spring采用CharacterEncodingFilter设置了默认编码为UTF-8)，然后在public class BeanDeserializer extends BeanDeserializerBase implements java.io.Serializable中，通过 public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt) throws IOException方法进行解析。 核心逻辑分析示例假设前端传的json串是这样的： {\"name1\":\"邓沙利文\",\"age\":123,\"mot\":\"我是一只小小小小鸟~\"} 后端的模型只有name和age属性，以及对应的setter/getter方法；给出一般用到的deserializeFromObject(JsonParser p, DeserializationContext ctxt)方法的核心逻辑： upload successful 小技巧之指定模型中的属性对应什么key这里简单介绍，更多的可参考： 1public class BeanPropertyMap implements Iterable&lt;SettableBeanProperty&gt;,java.io.Serializable 给出Controller中的测试类: upload successful 给出模型中的属性(setter/getter方法没截出来)： upload successful 使用postman测试一下，示例： upload successful 上图简单测试了一下，但是测得并不全面,这里就不带大家一起测试了，直接给出。 全面的结论：结论①：@JsonAlias注解，实现:json转模型时，使json中的特定key能转化为特定的模型属性;但是模型转json时，对应的转换后的key仍然与属性名一致，见：上图示例中的name字段的请求与响应。以下图进一步说明： upload successful 此时，json字符串转换为模型时，json中key为Name或为name123或为name的都能识别。 结论②：@JsonProperty**注解，实现：json转模型时，使json中的特定key能转化为指定的模型属性；同样的，模 型转json时，对应的转换后的key为指定的key，见：示例中的motto字段的请求与响应。 以下图进一步说明： upload successful 此时，json字符串转换为模型时，key为MOTTO的能识别，但key为motto的不能识别。 结论③：@JsonAlias注解需要依赖于setter、getter，而@JsonProperty注解不需要。 结论④：在不考虑上述两个注解的一般情况下，key与属性匹配时,默认大小写敏感。 结论⑤：有多个相同的key的json字符串中，转换为模型时，会以相同的几个key中，排在最后的那个key的值给模型属性复制，因为setter会覆盖原来的值。见示例中的gender属性。 结论⑥：后端@RequestBody注解对应的类在将HTTP的输入流(含请求体)装配到目标类(即:@RequestBody后面的类)时，会根据json字符串中的key来匹配对应实体类的属性，如果匹配一致且json中的该key对应的值符合(或可转换为)实体类的对应属性的类型要求时，会调用实体类的setter方法将值赋给该属性。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Spring","slug":"Spring","permalink":"http://blog.iwxyi.com/tags/Spring/"}]},{"title":"Lambda表达式递归","date":"2020-08-19T07:38:00.000Z","path":"2020/08/19/Lambda表达式递归/","text":"置顶一个求和方法： 123std::function&lt;int(const int&amp;)&gt;s = [&amp;](const int&amp; n) { return n == 1 ? 1 : n + s(n - 1);}; 可以直接使用 0x00问题引入对于一个求自然数1-N和的问题，我们很容易写出以下递归公式： 1f(n) = n == 1 ? 1 : n + f(n - 1); 若想使用C++lambda表达式实现上述过程，我们很容易将其改写为以下代码： 123const auto&amp; f = [](const int&amp; n) { return n == 1 ? 1 : n + f(n - 1);}; 发现编译无法通过，为什么呢？原因是，由于lambda表达式的匿名特性，无法直接在lambda内部递归调用lambda，我们需要另寻其道来解决该问题。 0x01使用std::functionstd::function可以把lambda包装起来，相当于赋予了其一个函数名，在通过引用捕获并实现递归调用，实现如下： 1234567const auto&amp; sum1 = [](const int&amp; n) { std::function&lt;int(const int&amp;)&gt;s; s = [&amp;](const int&amp; n) { return n == 1 ? 1 : n + s(n - 1); }; return s(n);}; 0x02将lambda作为参数先附上代码： 123456const auto&amp; sum2 = [](const int&amp; n) { const auto&amp; s = [&amp;](auto&amp;&amp; self, const int&amp; x) -&gt; int{ return x == 1 ? 1 : x + self(self, x - 1); }; return s(s,n);}; 注意到，调用s(s,n)时，我们把lambda表达式本身作为了参数传入来实现递归调用。 error: auto not alowed in lambda prameter 0x03使用Y组合子构造一个Y组合子如下： 123456789const auto&amp; y = [](const auto&amp; f) { return [&amp;](const auto&amp; x) { return x(x); }([&amp;](const auto&amp; x) -&gt; std::function&lt;int(int)&gt; { return f([&amp;](const int&amp; n) { return x(x)(n); }); });}; 再实现一个求和函数的高阶函数如下： 12345const auto&amp; sum3 = [](const auto&amp; f) { return [=](const int&amp; n) { return n == 1 ? 1 : n + f(n - 1); };}; 然后连接即可。 0x04测试在main中简单测试一下上述实现: 12345int main() { std::cout &lt;&lt; sum1(100);//print 5050 std::cout &lt;&lt; sum2(100);//print 5050 std::cout &lt;&lt; y(sum3)(100);//print 5050} 运行结果符合预期。 参考来源：https://blog.csdn.net/weixin_43686836/article/details/106952856 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++11","slug":"C-11","permalink":"http://blog.iwxyi.com/tags/C-11/"}]},{"title":"SpringBoot从打包到启动","date":"2020-08-17T09:07:00.000Z","path":"2020/08/17/SpringBoot从打包到启动/","text":"一、创建项目创建项目一共有两种方式，下面分别进行介绍。 1，在线创建项目（1）在线创建是 Spring Boot 官方提供的一种创建方式，在浏览器中访问如下网址： https://start.spring.io/ （2）在打开的页面中我们可以选择项目的构建工具是 Maven 还是 Gradle、语言是 Java 还是其它、要使用的 Spring Boot 版本号、项目的组织 Id（包名）、模块名称以及项目的依赖。 因为我要创建一个 SpringBoot 项目，所以项目依赖这块我们输入 Web 回车后进行添加。 upload successful （3）所有信息填写完毕后，点击下方的“Generate Project”按钮即可将生成的模版下载到本地，解压后使用 IDE 打开即可开始项目的开发了。 2，使用 Intellij IDEA 创建（1）创建项目时选择 Spring Initializr upload successful （2）接着输入项目的基本信息，包括组织 Id、模块名称、项目构建类型、最终生成包的类型、Java 的版本、开发语言、项目版本号、项目描述以及项目的包。 upload successful （3）接着选择项目所需要的依赖，之后 Intellij IDEA 会自动把选中的依赖添加到项目的 pom.xml 文件中。 因为我要创建一个 SpringBoot 项目，所以这里我们添加了个 Web 依赖。 upload successful （4）最后一步选择好创建路径，一个可运行的 Spring Boot 项目就创建成功了。 upload successful 二、运行项目有三种不同的方式启动项目，下面分别进行介绍。 1，使用 Maven 命令启动（1）打开终端进入项目文件夹，执行如下 mvn 命令启动项目： 1mvn spring-boot:run （2）启动完毕后终端会显示成功信息。 upload successful （3）使用浏览器访问 http://localhost:8080/ 则可显示项目主页。 upload successful 2，直接运行 main 方法（1）在 Intellij IDEA 中右键点击 App 类，然后点击 run 按钮即可启动项目。 upload successful （2）项目启动后控制台中可以看到相关的启动信息。 upload successful 3，打包启动Spring Boot 应用也可以直接打成 jar 包运行。在生产环境中，常常通过这样的方式来运行一个 Spring Boot 应用。 （1）打开终端进入项目文件夹，执行如下 mvn 命令进行打包。 1mvn package （2）如果使用的是 Intellij IDEA，我们还可以点击界面右侧的 Maven -&gt; Lifecycle -&gt; package 进行打包。 upload successful （3）上面打包方式的前提是项目使用了 spring-boot-starter-parent 作为 parent，不过在大部分项目中，项目的 parent 可能并不是 spring-boot-starter-parent，而是公司内部定义好的一个配置，此时 spring-boot-maven-plugin 插件并不能直接使用，我们只要做如下额外的配置即可。配置完毕后就和之前一样，可以通 Maven 命令或者 IntelliJ IDEA 中的 Maven 插件进行打包。 1234567891011&lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; （4）打包完成后，在项目的 target 目录下会生成一个 jar 文件。 upload successful （5）通过 java -jar 命令可以直接启动这个 jar 文件。 1java -jar demo-0.0.1-SNAPSHOT.jar upload successful （6）我们还可以在命令后面加个 &amp;，表示后台运行。 1java -jar demo-0.0.1-SNAPSHOT.jar &amp; （7）由于在生产环境中，Linux 大多数情况下都是远程服务器，然后使用远程工具连接 Linux。如果使用上面命令启动 JAR，一旦窗口关闭，JAR 也就停止运行了，因此一般通过如下命令启动 JAR： 注意：nohup 表示当窗口关闭时服务不挂起，继续在后台运行。 1nohup java -jar demo-0.0.1-SNAPSHOT.jar &amp; 三、一个简单的 RESTful 服务样例（1）首先我们在项目中新建一个名为 HelloController 的 Java 类。 upload successful （2）该类里面的内容如下： @RestController 注解：告诉 Spring 以字符串的形式渲染结果，并直接返回给调用者。该注解相当于 @ResponseBody ＋ @Controller 合在一起的作用。 @RequestMapping 注解：提供路由信息，它告诉 Spring 任何来自“/hello”路径的 HTTP 请求（Get）都应该被映射到 hello 方法。 123456789101112package com.example.demo; import org.springframework.web.bind.annotation.RestController;import org.springframework.web.bind.annotation.GetMapping; @RestControllerpublic class HelloController { @GetMapping(\"/hello\") public String hello() { return \"welcome to hangge.com\"; }} （3）运行启动程序后，访问 http://localhost:8080/hello 就可以访问这个 controller 的功能了。 upload successful 转载自：https://www.hangge.com/blog/cache/detail_2454.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Spring","slug":"Spring","permalink":"http://blog.iwxyi.com/tags/Spring/"}]},{"title":"Spring基础","date":"2020-08-17T09:06:00.000Z","path":"2020/08/17/Spring基础/","text":"[TOC] 介绍 Spring框架是个轻量级的Java EE框架。所谓轻量级，是指不依赖于容器就能运行的。Struts、Hibernate也是轻量级的。 Spring以IoC、AOP为主要思想，其中IoC，Inversion of Control 指控制反转或反向控制。在Spring框架中我们通过配置创建类对象，由Spring在运行阶段实例化、组装对象。AOP，Aspect Oriented Programming，面向切面编程，其思想是在执行某些代码前执行另外的代码，使程序更灵活、扩展性更好，可以随便地添加、删除某些功能。Servlet中的Filter便是一种AOP思想的实现。 Spring同时也是一个“一站式”框架，即Spring在JavaEE的三层架构[表现层（Web层）、业务逻辑层（Service层）、数据访问层（DAO层）]中，每一层均提供了不同的解决技术。如下： 表现层（Web层）：Spring MVC 业务逻辑层（Service层）：Spring的IoC 数据访问层（DAO层）：Spring的jdbcTemplate Spring中的IoC操作 将对象的创建交由Spring框架进行管理。 IoC操作分为：IoC配置文件方式和IoC的注解方式。 IoC入门案例（1）导入Spring框架中的相关jar包，这里只导入Spring的Core模块（Core模块是框架的核心类库）下的jar包（使用IoC的基本操作，并不需要导入Spring的所有jar包，只导入spring-beans、spring-core、spring-context、spring-expression这4个jar包），以及 支持日志输出的 commons-logging 和 log4j 的jar包；（2）创建一个普通的Java类，并在该类中创建方法，如下： User.java 123456789101112131415package com.wm103.ioc;/** * Created by DreamBoy on 2018/3/17. */public class User { public void add() { System.out.println(\"User Add Method.\"); } @Override public String toString() { return \"This is a user object.\"; }}123456789101112131415 （3）创建Spring的配置文件，进行Bean的配置 Spring的核心配置文件名称和位置不是固定的。但官方件建议将该核心配置文件放在src目录下，且命名为 applicationContext.xml。 这里为了方便，将核心配置文件放在src目录下，并命名为 applicationContext.xml，内容如下： 123456&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"user\" class=\"com.wm103.ioc.User\"&gt;&lt;/bean&gt;&lt;/beans&gt;123456 （４）编写测试类进行测试，通过配置文件创建类对象 TestIoC.java 123456789101112131415161718192021package com.wm103.ioc;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * Created by DreamBoy on 2018/3/17. */public class TestIoc { @Test public void runUser() { // 1. 加载Spring配置文件，根据创建对象 ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); // 2. 得到配置创建的对象 User user = (User) context.getBean(\"user\"); System.out.println(user); user.add(); }}123456789101112131415161718192021 Spring的bean管理（配置文件）Bean实例化的方式 在Spring中通过配置文件创建对象。 Bean实例化三种方式实现：（1）使用类的无参数构造创建，如： 12&lt;!-- 等同于 user = new com.wm103.ioc.User(); --&gt;&lt;bean id=\"user\" class=\"com.wm103.ioc.User\"&gt;&lt;/bean&gt;12 （2）使用静态工厂创建 如果一个Bean不能通过new直接实例化，而是通过工厂类的某个静态方法创建的，需要把&lt;bean&gt;的class属性配置为工厂类。如： 12&lt;!-- 等同于 user = com.wm103.ioc.UserFactory.createInstance(); --&gt;&lt;bean id=\"user\" class=\"com.wm103.ioc.UserFactory\" factory-method=\"createInstance\"&gt;&lt;/bean&gt;12 （3）使用实例工厂创建 如果一个Bean不能通过new直接实例化，而是通过工厂类的某个实例方法创建的，需要先配置工厂的&lt;bean&gt;标签，然后在需要创建的对象的bean标签的factory-bean属性配置为工厂类对象，factory-method属性配置为产生实例的方法。如： 1234&lt;!-- 等同于 userFactory = new com.wm103.ioc.UserFactory(); --&gt;&lt;bean id=\"userFactory\" class=\"com.wm103.ioc.UserFactory\"&gt;&lt;/bean&gt;&lt;!-- 等同于 user = userFactory.createInstance(); --&gt;&lt;bean id=\"user\" factory-bean=\"userFactory\" factory-method=\"createInstance\"&gt;&lt;/bean&gt;1234 Bean标签的常用属性（1）id属性：用于指定配置对象的名称，不能包含特殊符号。（2）class属性：创建对象所在类的全路径。（3）name属性：功能同id属性一致。但是在name属性值中可以包含特殊符号。（4）scope属性 singleton：默认值，单例单例模式下，在程序下只有一个实例。非单态模式下，每次请求该Bean，都会生成一个新的对象。 prototype：多例 request：创建对象后将对象存放到request域 session：创建对象后将对象存放到session域 globalSession：创建对象后将对象存放到globalSession域 属性注入 属性注入指创建对象时，向类对象的属性设置属性值。 在Spring框架中支持set方法注入和有参构造函数注入，即创建对象后通过set方法设置属性或采用有参构造函数创建对象并初始化属性。 使用有参构造函数注入属性 案例： Student.java 提供有参的构造方法 12345678910111213141516package com.wm103.ioc;public class Student { private String name; public Student(String name) { this.name = name; } @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + '}'; }}12345678910111213141516 bean的配置： 123&lt;bean id=\"student\" class=\"com.wm103.ioc.Student\"&gt; &lt;constructor-arg name=\"name\" value=\"DreamBoy\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;123 创建Student对象进行测试： 12345678@Testpublic void runStudent() { // 1. 加载Spring配置文件，根据创建对象 ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); // 2. 得到配置创建的对象 Student student = (Student) context.getBean(\"student\"); System.out.println(student);}12345678 使用set方法注入属性 案例： Teacher.java 提供属性的set方法 123456789101112131415package com.wm103.ioc;public class Teacher { private String name; public void setName(String name) { this.name = name; } @Override public String toString() { return \"Teacher{\" + \"name='\" + name + '\\'' + '}'; }}123456789101112131415 bean的配置： 123&lt;bean id=\"teacher\" class=\"com.wm103.ioc.Teacher\"&gt; &lt;property name=\"name\" value=\"Teacher Wu\"&gt;&lt;/property&gt;&lt;/bean&gt;123 创建Teacher对象进行测试： 12345678@Testpublic void runTeacher() { // 1. 加载Spring配置文件，根据创建对象 ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); // 2. 得到配置创建的对象 Teacher teacher = (Teacher) context.getBean(\"teacher\"); System.out.println(teacher);}12345678 注入对象类型属性 以三层架构中的service层和dao层为例，为了让service层使用dao层的类创建的对象，需要将dao对象注入到service层类中。具体实现过程中如下：（1）创建service类、dao层接口、dao类，如下：UserService.java 12345678910111213package com.wm103.exp;public class UserService { private UserDao userDao; // 声明为接口类型，降低service层与dao层的耦合度，不依赖于dao层的具体实现 public void setUserDao(UserDao userDao) { this.userDao = userDao; } public void add() { System.out.println(\"UserService Add...\"); this.userDao.add(); }}12345678910111213 UserDao.java 123456789package com.wm103.exp;/** * 暴露给service层的接口 * Created by DreamBoy on 2018/3/17. */public interface UserDao { void add();}123456789 UserDaoImpl.java 123456789101112package com.wm103.exp;/** * 接口UserDao的具体实现 * Created by DreamBoy on 2018/3/17. */public class UserDaoImpl implements UserDao { @Override public void add() { System.out.println(\"UserDaoImpl Add...\"); }}123456789101112 （2）在配置文件中注入关系，如下： 1234567891011&lt;!-- 配置service和dao对象 --&gt;&lt;!-- 因为service依赖于dao，所以先进行dao对象的bean配置 --&gt;&lt;bean id=\"userDaoImpl\" class=\"com.wm103.exp.UserDaoImpl\"&gt;&lt;/bean&gt;&lt;bean id=\"userService\" class=\"com.wm103.exp.UserService\"&gt; &lt;!-- 注入dao对象 name属性值为：service中的某一属性名称 ref属性值为：被引用的对象对应的bean标签的id属性值 --&gt; &lt;property name=\"userDao\" ref=\"userDaoImpl\"&gt;&lt;/property&gt;&lt;/bean&gt;1234567891011 （3）创建测试方法进行测试，如下： 12345678@Testpublic void runUserService() { // 1. 加载Spring配置文件，根据创建对象 ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); // 2. 得到配置创建的对象 UserService userService = (UserService) context.getBean(\"userService\"); userService.add();}12345678 p名称空间注入属性 之前提到了一种set方法的属性注入方式，这里将介绍另一种属性注入的方式，名为 p名称空间注入。对比set方法的属性注入方式，核心配置文件配置修改如下： 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"teacher\" class=\"com.wm103.ioc.Teacher\" p:name=\"Teacher Wu\"&gt;&lt;/bean&gt;&lt;/beans&gt;1234567 注入复杂类型属性 对象注入复杂类型属性，如数组、List、Map、Properties。 案例： PropertyDemo.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.wm103.ioc;import java.util.List;import java.util.Map;import java.util.Properties;public class PropertyDemo { private String[] arrs; private List&lt;String&gt; list; private Map&lt;String, String&gt; map; private Properties properties; public String[] getArrs() { return arrs; } public void setArrs(String[] arrs) { this.arrs = arrs; } public List&lt;String&gt; getList() { return list; } public void setList(List&lt;String&gt; list) { this.list = list; } public Map&lt;String, String&gt; getMap() { return map; } public void setMap(Map&lt;String, String&gt; map) { this.map = map; } public Properties getProperties() { return properties; } public void setProperties(Properties properties) { this.properties = properties; }}1234567891011121314151617181920212223242526272829303132333435363738394041424344 bean配置文件，内容如下： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"prop\" class=\"com.wm103.ioc.PropertyDemo\"&gt; &lt;!-- 注入数组 --&gt; &lt;property name=\"arrs\"&gt; &lt;list&gt; &lt;value&gt;Value 1 of Array&lt;/value&gt; &lt;value&gt;Value 2 of Array&lt;/value&gt; &lt;value&gt;Value 3 of Array&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 注入List集合 --&gt; &lt;property name=\"list\"&gt; &lt;list&gt; &lt;value&gt;Value 1 of List&lt;/value&gt; &lt;value&gt;Value 2 of List&lt;/value&gt; &lt;value&gt;Value 3 of List&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 注入Map集合 --&gt; &lt;property name=\"map\"&gt; &lt;map&gt; &lt;entry key=\"key1\" value=\"Value 1 of Map\"&gt;&lt;/entry&gt; &lt;entry key=\"key2\" value=\"Value 2 of Map\"&gt;&lt;/entry&gt; &lt;entry key=\"key3\" value=\"Value 3 of Map\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- 注入Properties --&gt; &lt;property name=\"properties\"&gt; &lt;props&gt; &lt;prop key=\"username\"&gt;root&lt;/prop&gt; &lt;prop key=\"password\"&gt;123456&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;1234567891011121314151617181920212223242526272829303132333435363738 创建PropertyDemo对象进行测试： 12345678910@Testpublic void runPropertyDemo() { ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); PropertyDemo pd = (PropertyDemo) context.getBean(\"prop\"); System.out.println(pd); System.out.println(Arrays.toString(pd.getArrs())); System.out.println(pd.getList()); System.out.println(pd.getMap()); System.out.println(pd.getProperties());}12345678910 IoC和DI的区别 IoC，控制反转，将传统的对象创建流程转变为交由框架进行创建和管理。在Spring中，对象的创建交给Spring进行配置。它包括依赖注入。 DI，依赖注入，向类的属性设置值。 IoC与DI的关系：依赖注入不能单独存在，需要在IoC基础之上完成操作。 Spring的bean管理（注解） 注解是代码中特殊的标记，使用注解可以完成特定的功能。注解可以使用在类、方法或属性上，写法如：@注解名称(属性名称=属性值)。 Spring的bean管理注解方式，案例如下。 Spring注解开发准备（1）导入jar包： 导入基本的jar包：commons-logging、log4j、spring-beans、spring-context、spring-core、spring-expression相关jar包。 导入AOP的jar包：spring-aopjar包。 （2）创建类、方法 User.java 123456789package com.wm103.anno;import org.springframework.stereotype.Component;public class User { public void add() { System.out.println(\"User Add Method.\"); }}123456789 （3）创建Spring配置文件，引入约束；并开启注解扫描 bean1.xml 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 开启注解扫描 （1）到包中扫描类、方法、属性上是否有注解 --&gt; &lt;context:component-scan base-package=\"com.wm103\"&gt;&lt;/context:component-scan&gt; &lt;!-- （2）只扫描属性上的注解 --&gt; &lt;!--&lt;context:annotation-config&gt;&lt;/context:annotation-config&gt;--&gt;&lt;/beans&gt;123456789101112131415161718 注解创建对象 在创建对象的类上面使用注解实现，如： 12@Component(value=\"user\")public class User {12 创建测试类 TestAnno.java和测试方法，如： 123456789101112131415package com.wm103.anno;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestAnno { @Test public void runUser() { ApplicationContext context = new ClassPathXmlApplicationContext(\"bean1.xml\"); User user = (User) context.getBean(\"user\"); user.add(); }}123456789101112131415 除了上述提到的 @Component注解外，Spring中还提供了@Component的3个衍生注解，其功能就目前来说是一致的，均是为了创建对象。 @Controller ：WEB层 @Service ：业务层 @Repository ：持久层 以单例或多实例方式创建对象，默认为单例，多例对象设置注解如下： 123@Component(value=\"user\")@Scope(value=\"prototype\")public class User {123 注解注入属性 案例：创建Service类和Dao类，并在Service中注入Dao对象。如下：（1）创建Dao和Service对象 UserDao.java 12345678910package com.wm103.anno;import org.springframework.stereotype.Repository;@Repository(value=\"userDao\")public class UserDao { public void add() { System.out.println(\"UserDao Add Method.\"); }}12345678910 UserService.java 12345678910111213package com.wm103.anno;import org.springframework.stereotype.Service;import javax.annotation.Resource;@Service(value=\"userService\")public class UserService { public void add() { System.out.println(\"UserService Add Method.\"); userDao.add(); }}12345678910111213 （2）在Service类中定义UserDao类型的属性，并使用注解完成对象的注入@Autowired：自动注入或自动装配，是根据类名去找到类对应的对象来完成注入的。 12@Autowiredprivate UserDao userDao;12 或者 @Resource 12@Resource(name=\"userDao\")private UserDao userDao;12 其中该注解的name属性值为注解创建Dao对象的value属性的值。 这两种注解方式都不一定要为需要注入的属性定义set方法。（3）创建测试方法 123456@Testpublic void runUserService() { ApplicationContext context = new ClassPathXmlApplicationContext(\"bean1.xml\"); UserService userService = (UserService) context.getBean(\"userService\"); userService.add();}123456 注：配置文件和注解混合使用1）创建对象的操作一般使用配置文件方式实现；2）注入属性的操作一般使用注解方式实现。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Spring","slug":"Spring","permalink":"http://blog.iwxyi.com/tags/Spring/"}]},{"title":"杭州社保办理流程","date":"2020-08-15T09:42:00.000Z","path":"2020/08/15/杭州社保办理流程/","text":"社保 登录网址：杭州政务服务网 http://www.zjzwfw.gov.cn/ 切换到杭州市，部门窗口—市人力社保局 底部 杭州社会保险网上服务大厅 法人登录—法人数字证书登录—e照通扫码 医保 http://www.zjzwfw.gov.cn/ 搜索医保，杭州市|基本医疗保险职工参保登记 按时间来，注意停保当月不缴费 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"社保","slug":"社保","permalink":"http://blog.iwxyi.com/tags/社保/"}]},{"title":"Dart多态","date":"2020-08-10T08:02:00.000Z","path":"2020/08/10/Dart多态/","text":"继承 使用关键字 extends 继承一个类 子类会继承父类可见的属性和方法，不会继承构造方法 子类能够复写父类的方法，getter 和 setter 单继承，多态性 示例1234567891011121314class Person{ String name; int age; // 计算属性 bool get adult =&gt; this.age &gt; 18; // 私有属性，对于子类不可见 String _birthday; void run(){ print(\"Person running...\"); }} 子类访问父类中的属性和方法1234567891011121314151617181920class Student extends Person{ void study(){ print(\"Student studying...\"); }}void main(){ Student student = new Student(); // 调用 子类自己的方法 student.study(); // Student studying... // 访问 父类中的属性 student.age = 20; // 调用 父类的方法 student.run(); // Person running... // 访问 父类的计算属性 print(student.adult); // true} 覆盖父类的方法以及属性 和 java 中类似，使用 @override 表示覆写。 1234567891011121314151617181920212223class Student extends Perosn{ // 覆写父类的计算属性 bool get adult =&gt; this.age &gt; 15; void study(){ print(\"Student studying...\"); } @override void run() { // 调用父类的方法 super.run(); print(\"student running...\"); }}void main(){ Student student = new Student(); student.age = 16; student.run(); // Person running... student running... print(student.adult); // true} 继承中多态的使用123456789101112131415161718192021222324class Student extends Person{ void study(){ print(\"Student studying...\"); } @override void run() { // 调用父类的方法 super.run(); print(\"student running...\"); }}void main(){ Person person = new Student(); // error: 这里无法访问到 子类的方法，因为使用多态生成的对象是 Person，Person 中没有 study方法 // person.study(); // 使用 is 表示将 person 转换为了 Student，下面就可以访问了 if (person is Student) { person.run(); person.study(); }} 继承中的构造方法 子类的构造方法默认会调用父类的无名无参构造方法 如果父类没有无名无参构造方法，则需要显示调用父类的构造方法 在构造方法参数后使用 : super(arg) 显示调用父类构造方法，使用:this(arg)调用自己的其他构造方法（也可以是带名字的构造方法） 12345678910111213141516171819void main() { var student = new Student(\"name\"); // object}class Person{ String name; // 父类中的构造器 Person(this.name); Person.withName(this.name){ print(\"object\"); }}class Student extends Person{ // 使用 : super 调用父类的构造方法 // Student(String name) : super(name); 这种写法与下面的写法一致 Student(String name) : super.withName(name);} 构造方法执行顺序 父类的构造方法在子类构造方法体开始执行的位置调用 如果有初始化列表，初始化列表会在父类构造方法之前执行 子类的构造方法初始化列表，必须要在父类初始化列表之前，否则就会报错。 抽象类 使用 abstract class ClassName 创建抽象类 抽象类里面的抽象方法是不实现的（可以有非抽象方法），由子类进行实现，@override关键词，一般用于来约束子类，制定标准。 同样抽象类不能实例化，里面的属性和实现的方法，只能通过子类去访问，但是可以通过子类的实例赋值给父类的引用实现 继承抽象类是用来约束子类，接口实现抽象类是用来制定标准 接口 使用 implements关键词 实现接口，不仅要实现抽象类的属性还要实现抽象类的方法（extends不需要再写一遍属性） 混入（mixin） Dart中的Mixins通过创建一个新类来实现，该类将mixin的实现层叠在一个超类之上以创建一个新类 ，它不是“在超类中”，而是在超类的“顶部”，因此如何解决查找问题不会产生歧义。— Lasse R. H. Nielsen on StackOverflow. 关键词with，class A with B, C, D，后面会覆盖前面 可以实现多接口 函数命名冲突： 遇到相同功能的函数，最后载入的会覆盖之前的函数定义（如果子类没有重写的话），即最后一个继承的类的方法 参考： https://blog.csdn.net/hxl517116279/article/details/88563348 https://blog.csdn.net/litter_lj/article/details/93336327 https://blog.csdn.net/qq_18948359/article/details/91851781 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Dart","slug":"Dart","permalink":"http://blog.iwxyi.com/tags/Dart/"}]},{"title":"Qt开发经验-飞扬青云","date":"2020-07-16T08:41:00.000Z","path":"2020/07/16/Qt开发经验-飞扬青云/","text":"全部转载自： https://gitee.com/feiyangqingyun/qtkaifajingyan 一、开发经验总结 当编译发现大量错误的时候，从第一个看起，一个一个的解决，不要急着去看下一个错误，往往后面的错误都是由于前面的错误引起的，第一个解决后很可能都解决了。 定时器是个好东西，学会好使用它，有时候用QTimer::singleShot可以解决意想不到的问题。 打开creator，在构建套件的环境中增加MAKEFLAGS=-j8，可以不用每次设置多线程编译。珍爱时间和生命。新版的QtCreator已经默认就是j8。 如果你想顺利用QtCreator部署安卓程序，首先你要在AndroidStudio 里面配置成功，把坑全部趟平。 很多时候找到Qt对应封装的方法后，记得多看看该函数的重载，多个参数的，你会发现不一样的世界，有时候会恍然大悟，原来Qt已经帮我们封装好了。 可以在pro文件中写上标记版本号+ico图标（Qt5才支持） 12VERSION = 2020.10.25RC_ICONS = main0.ico 管理员运行程序，限定在MSVC编译器。 12QMAKE_LFLAGS += /MANIFESTUAC:\"level='requireAdministrator' uiAccess='false'\" #以管理员运行QMAKE_LFLAGS += /SUBSYSTEM:WINDOWS,\"5.01\" #VS2013 在XP运行 运行文件附带调试输出窗口CONFIG += console pro 绘制平铺背景QPainter::drawTiledPixmap,绘制圆角矩形QPainter::drawRoundedRect(),而不是QPainter::drawRoundRect(); 移除旧的样式 1234//移除原有样式style()-&gt;unpolish(ui-&gt;btn);//重新设置新的该控件的样式。style()-&gt;polish(ui-&gt;btn); 获取类的属性 12345678const QMetaObject *metaobject = object-&gt;metaObject();int count = metaobject-&gt;propertyCount();for (int i = 0; i &lt; count; ++i) { QMetaProperty metaproperty = metaobject-&gt;property(i); const char *name = metaproperty.name(); QVariant value = object-&gt;property(name); qDebug() &lt;&lt; name &lt;&lt; value;} Qt内置图标封装在QStyle中，大概七十多个图标，可以直接拿来用。QStyle::SP_TitleBarMenuButton 根据操作系统位数判断加载 1234win32 { contains(DEFINES, WIN64) { DESTDIR = $${PWD}/../../bin64 } else { DESTDIR = $${PWD}/../../bin32 }} Qt5增强了很多安全性验证，如果出现setGeometry: Unable to set geometry，请将该控件的可见移到加入布局之后。 可以将控件A添加到布局，然后控件B设置该布局，这种灵活性大大提高了控件的组合度，比如可以在文本框左侧右侧增加一个搜索按钮，按钮设置图标即可。 123456QPushButton *btn = new QPushButton;btn-&gt;resize(30, ui-&gt;lineEdit-&gt;height());QHBoxLayout *layout = new QHBoxLayout(ui-&gt;lineEdit);layout-&gt;setMargin(0);layout-&gt;addStretch();layout-&gt;addWidget(btn); 对QLCDNumber控件设置样式，需要将QLCDNumber的segmentstyle设置为flat。 巧妙的使用findChildren可以查找该控件下的所有子控件。findChild为查找单个。 123456//查找指定类名objectName的控件QList&lt;QWidget *&gt; widgets = parentWidget.findChildren&lt;QWidget *&gt;(\"widgetname\");//查找所有QPushButtonQList&lt;QPushButton *&gt; allPButtons = parentWidget.findChildren&lt;QPushButton *&gt;();//查找一级子控件,不然会一直遍历所有子控件QList&lt;QPushButton *&gt; childButtons = parentWidget.findChildren&lt;QPushButton *&gt;(QString(), Qt::FindDirectChildrenOnly); 巧妙的使用inherits判断是否属于某种类。 1234QTimer *timer = new QTimer; // QTimer inherits QObjecttimer-&gt;inherits(\"QTimer\"); // returns truetimer-&gt;inherits(\"QObject\"); // returns truetimer-&gt;inherits(\"QAbstractButton\"); // returns false 使用弱属性机制，可以存储临时的值用于传递判断。可以通过widget-&gt;dynamicPropertyNames()列出所有弱属性名称，然后通过widget-&gt;property(\"name\")取出对应的弱属性的值。 在开发时, 无论是出于维护的便捷性, 还是节省内存资源的考虑, 都应该有一个 qss 文件来存放所有的样式表, 而不应该将 setStyleSheet 写的到处都是。如果是初学阶段或者测试阶段可以直接UI上右键设置样式表，正式项目还是建议统一到一个qss样式表文件比较好，统一管理。 如果出现Z-order assignment: is not a valid widget.错误提示，用记事本打开对应的ui文件，找到&lt;zorder&gt;&lt;/zorder&gt;为空的地方，删除即可。 善于利用QComboBox的addItem的第二个参数设置用户数据，可以实现很多效果，使用itemData取出来。 如果用了webengine模块，发布程序的时候带上QtWebEngineProcess.exe+translations文件夹+resources文件夹。 a.setAttribute(Qt::AA_NativeWindows);可以让每个控件都拥有独立的句柄。 Qt+Android防止程序被关闭。 1234567#if defined(Q_OS_ANDROID)QAndroidService a(argc, argv);return a.exec()#elseQApplication a(argc, argv);return a.exec();#endif 可以对整体的指示器设置样式，例如 *::down-arrow,*::menu-indicator{} *::up-arrow:disabled,*::up-arrow:off{}。 可以执行位置设置背景图片。 123456QMainWindow &gt; .QWidget { background-color: gainsboro; background-image: url(:/images/pagefold.png); background-position: top right; background-repeat: no-repeat} 嵌入式linux运行Qt程序 Qt4写法：./HelloQt -qws &amp; Qt5写法：./HelloQt --platform xcb Qtcreator软件的配置文件存放在：C:\\Users\\Administrator\\AppData\\Roaming\\QtProject，有时候如果发现出问题了，将这个文件夹删除后打开creator自动重新生成即可。 QMediaPlayer依赖本地解码器，WIN上下载k-lite或者LAV Filters安装即可。 判断编译器类型、编译器版本、操作系统。 12345678910111213141516171819202122232425262728293031323334353637383940414243//GCC编译器#ifdef __GNUC__#if __GNUC__ &gt;= 3 // GCC3.0以上//MSVC编译器#ifdef _MSC_VER#if _MSC_VER &gt;=1000 // VC++4.0以上#if _MSC_VER &gt;=1100 // VC++5.0以上#if _MSC_VER &gt;=1200 // VC++6.0以上#if _MSC_VER &gt;=1300 // VC2003以上#if _MSC_VER &gt;=1400 // VC2005以上#if _MSC_VER &gt;=1500 // VC2008以上#if _MSC_VER &gt;=1600 // VC2010以上#if _MSC_VER &gt;=1700 // VC2012以上#if _MSC_VER &gt;=1800 // VC2013以上#if _MSC_VER &gt;=1900 // VC2015以上//Borland C++#ifdef __BORLANDC__//Cygwin#ifdef __CYGWIN__#ifdef __CYGWIN32__//mingw#ifdef __MINGW32__//windows#ifdef _WIN32 //32bit#ifdef _WIN64 //64bit#ifdef _WINDOWS //图形界面程序#ifdef _CONSOLE //控制台程序//Windows（95/98/Me/NT/2000/XP/Vista）和Windows CE都定义了#if (WINVER &gt;= 0x030a) // Windows 3.1以上#if (WINVER &gt;= 0x0400) // Windows 95/NT4.0以上#if (WINVER &gt;= 0x0410) // Windows 98以上#if (WINVER &gt;= 0x0500) // Windows Me/2000以上#if (WINVER &gt;= 0x0501) // Windows XP以上#if (WINVER &gt;= 0x0600) // Windows Vista以上//_WIN32_WINNT 内核版本#if (_WIN32_WINNT &gt;= 0x0500) // Windows 2000以上#if (_WIN32_WINNT &gt;= 0x0501) // Windows XP以上#if (_WIN32_WINNT &gt;= 0x0600) // Windows Vista以上 在pro中判断Qt版本及构建套件位数 1234567891011121314151617181920212223#打印版本信息message(qt version: $$QT_VERSION)#判断当前qt版本号QT_VERSION = $$[QT_VERSION]QT_VERSION = $$split(QT_VERSION, \".\")QT_VER_MAJ = $$member(QT_VERSION, 0)QT_VER_MIN = $$member(QT_VERSION, 1)#下面是表示 Qt5.5greaterThan(QT_VER_MAJ, 4) {greaterThan(QT_VER_MIN, 4) {#自己根据需要做一些处理}}#QT_ARCH是Qt5新增的,在Qt4上没效果#打印当前Qt构建套件的信息message($$QT_ARCH)#表示arm平台构建套件contains(QT_ARCH, arm) {}#表示32位的构建套件contains(QT_ARCH, i386) {}#表示64位的构建套件contains(QT_ARCH, x86_64) {} Qt最小化后恢复界面假死冻结，加上代码 1234void showEvent(QShowEvent *e){setAttribute(Qt::WA_Mapped);QWidget::showEvent(e);} 获取标题栏高度：style()-&gt;pixelMetric(QStyle::PM_TitleBarHeight); PM_TitleBarHeight点进去你会发现新大陆。 设置高分屏属性以便支持2K4K等高分辨率，尤其是手机app。必须写在main函数的QApplication a(argc, argv);的前面。 123#if (QT_VERSION &gt; QT_VERSION_CHECK(5,6,0)) QGuiApplication::setAttribute(Qt::AA_EnableHighDpiScaling);#endif 如果运行程序出现 Fault tolerant heap shim applied to current process. This is usually due to previous crashes. 错误。办法：打开注册表，找到HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags\\Layers\\，选中Layers键值，从右侧列表中删除自己的那个程序路径即可。 Qt内置了QFormLayout表单布局用于自动生成标签+输入框的组合的表单界面。 qml播放视频在linux需要安装 sudo apt-get install libpulse-dev。 可以直接继承QSqlQueryModel实现自定义的QueryModel，比如某一列字体颜色，占位符，其他样式等，重写QVariant CustomSqlModel::data(const QModelIndex &amp;index, int role) const。 Qt5以后提供了类QScroller直接将控件滚动。 1234567891011//禁用横向滚动条ui-&gt;listWidget-&gt;setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);//禁用纵向滚动条ui-&gt;listWidget-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);//设置横向按照像素值为单位滚动ui-&gt;listWidget-&gt;setHorizontalScrollMode(QListWidget::ScrollPerPixel);//设置纵向按照像素值为单位滚动ui-&gt;listWidget-&gt;setVerticalScrollMode(QListWidget::ScrollPerPixel);//设置滚动对象以及滚动方式为鼠标左键拉动滚动QScroller::grabGesture(ui-&gt;listWidget, QScroller::LeftMouseButtonGesture);//还有个QScrollerProperties可以设置滚动的一些参数 如果使用sqlite数据库不想产生数据库文件，可以创建内存数据库。 12QSqlDatabase db = QSqlDatabase::addDatabase(\"QSQLITE\");db.setDatabaseName(\":memory:\"); 清空数据表并重置自增ID，sql = truncate table table_name。 Qtchart模块从Qt5.7开始自带，最低编译要求Qt5.4。在安装的时候记得勾选，默认不勾选。使用该模块需要引入命名空间。 123#include &lt;QChartView&gt;QT_CHARTS_USE_NAMESPACEclass CustomChart : public QChartView QPushButton左对齐文字，需要设置样式表QPushButton{text-align:left;} QLabel有三种设置文本的方法，掌握好Qt的属性系统，举一反三，可以做出很多效果。 123ui-&gt;label-&gt;setStyleSheet(\"qproperty-text:hello;\");ui-&gt;label-&gt;setProperty(\"text\", \"hello\");ui-&gt;label-&gt;setText(\"hello\"); 巧妙的用QEventLoop开启事件循环，可以使得很多同步获取返回结果而不阻塞界面。QEventLoop内部新建了线程执行。 123QEventLoop loop;connect(reply, SIGNAL(finished()), &amp;loop, SLOT(quit()));loop.exec(); 多种预定义变量 #if (defined webkit) || (defined webengine)，去掉生成空的debug和release目录 CONFIG -= debug_and_release。 新版的Qtcreator增强了语法检查，会弹出很多警告提示等，可以在插件列表中关闭clang打头的几个即可，Help&gt;About Plugins。也可以设置代码检查级别，Tools&gt;Options &gt;C++ &gt;Code Model。 QSqlTableModel的rowCount方法，默认最大返回256，如果超过256，可以将表格拉到底部，会自动加载剩余的，每次最大加载256条数据，如果需要打印或者导出数据，记得最好采用sql语句去查询，而不是使用QSqlTableModel的rowCount方法。不然永远最大只会导出256条数据。如果数据量很小，也可以采用如下方法： 1234//主动加载所有数据,不然获取到的行数&lt;=256while(model-&gt;canFetchMore()) { model-&gt;fetchMore();} 如果需要指定无边框窗体，但是又需要保留操作系统的边框特性，可以自由拉伸边框，可以使用 setWindowFlags(Qt::CustomizeWindowHint); 在某些http post数据的时候，如果采用的是&amp;字符串连接的数据发送，中文解析乱码的话，需要将中文进行URL转码。 12QString content = \"测试中文\";QString note = content.toUtf8().toPercentEncoding(); Qt默认不支持大资源文件，比如添加了字体文件，需要pro文件开启。CONFIG += resources_big Qt中继承QWidget之后，样式表不起作用，解决办法有三个。强烈推荐方法一。 方法一：设置属性 this-&gt;setAttribute(Qt::WA_StyledBackground, true); 方法二：改成继承QFrame，因为QFrame自带paintEvent函数已做了实现，在使用样式表时会进行解析和绘制。 方法三：重新实现QWidget的paintEvent函数时，使用QStylePainter绘制。 1234567void Widget::paintEvent(QPaintEvent *){ QStyleOption option; option.initFrom(this); QPainter painter(this); style()-&gt;drawPrimitive(QStyle::PE_Widget, &amp;option, &amp;painter, this);} 有时候在界面上加了弹簧，需要动态改变弹簧对应的拉伸策略，对应方法为changeSize，很多人会选择使用set开头去找，找不到的。 在使用QFile的过程中，不建议频繁的打开文件写入然后再关闭文件，比如间隔5ms输出日志，IO性能瓶颈很大，这种情况建议先打开文件不要关闭，等待合适的时机比如析构函数中或者日期变了需要重新变换日志文件的时候关闭文件。不然短时间内大量的打开关闭文件会很卡，文件越大越卡。 在很多网络应用程序，需要自定义心跳包来保持连接，不然断电或者非法关闭程序，对方识别不到，需要进行超时检测，但是有些程序没有提供心跳协议，此时需要启用系统层的保活程序，此方法适用于TCP连接。 123456789int fd = tcpSocket-&gt;socketDescriptor();int keepAlive = 1; //开启keepalive属性,缺省值:0(关闭)int keepIdle = 5; //如果在5秒内没有任何数据交互,则进行探测,缺省值:7200(s)int keepInterval = 2; //探测时发探测包的时间间隔为2秒,缺省值:75(s)int keepCount = 2; //探测重试的次数,全部超时则认定连接失效,缺省值:9(次)setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (void *)&amp;keepAlive, sizeof(keepAlive));setsockopt(fd, SOL_TCP, TCP_KEEPIDLE, (void *)&amp;keepIdle, sizeof(keepIdle));setsockopt(fd, SOL_TCP, TCP_KEEPINTVL, (void *)&amp;keepInterval, sizeof(keepInterval));setsockopt(fd, SOL_TCP, TCP_KEEPCNT, (void *)&amp;keepCount, sizeof(keepCount)); 如果程序打包好以后弹出提示 This application failed to start because it could not find or load the Qt platform plugin 一般都是因为platforms插件目录未打包或者打包错了的原因导致的。 非常不建议tr中包含中文，尽管现在的新版Qt支持中文到其他语言的翻译，但是很不规范，也不知道TMD是谁教的，tr的本意是包含英文，然后翻译到其他语言比如中文，现在大量的初学者滥用tr，如果没有翻译的需求，禁用tr，tr需要开销的，Qt默认会认为他需要翻译，会额外进行特殊处理。 很多人Qt和Qt Creator傻傻分不清楚，经常问Qt什么版本结果发一个Qt Creator的版本过来，Qt Creator是使用Qt编写的集成开发环境IDE，和宇宙第一的Visual Studio一样，他可以是msvc编译器的（WIN对应的Qt集成安装环境中自带的Qt Cerator是msvc的），也可以是mingw编译的，还可以是gcc的。如果是自定义控件插件，需要集成到Qt Creator中，必须保证该插件的动态库文件（dll或者so等文件）对应的编译器和Qt版本以及位数和Qt Creator的版本完全一致才行，否则基本不大可能集成进去。特别注意的是Qt集成环境安装包中的Qt版本和Qt Creator版本未必完全一致，必须擦亮眼睛看清楚，有些是完全一致的。 超过两处相同处理的代码，建议单独写成函数。代码尽量规范精简，比如 if(a == 123) 要写成 if (123 == a)，值在前面，再比如if (ok == true) 要写成 if (ok)，if (ok == false) 要写成 if (!ok)等。 很多人问Qt嵌入式平台用哪个好，这里统一回答（当前时间节点2018年）：imx6+335x比较稳定，性能高就用RK3288 RK3399，便宜的话就用全志H3，玩一玩可以用树莓派香橙派。 对于大段的注释代码，建议用 #if 0 #endif 将代码块包含起来，而不是将该段代码选中然后全部 // ，下次要打开这段代码的话，又需要重新选中一次取消，如果采用的是 #if 0则只要把0改成1即可，效率大大提升。 Qt打包发布，有很多办法，Qt5以后提供了打包工具windeployqt（linux上为linuxdeployqt，mac上为macdeployqt）可以很方便的将应用程序打包，使用下来发现也不是万能的，有时候会多打包一些没有依赖的文件，有时候又会忘记打包一些插件尤其是用了qml的情况下，而且不能识别第三方库，比如程序依赖ffmpeg，则对应的库需要自行拷贝，终极大法就是将你的可执行文件复制到Qt安装目录下的bin目录，然后整个一起打包，挨个删除不大可能依赖的组件，直到删到正常运行为止。 Qt中的动画，底层用的是QElapsedTimer定时器来完成处理，比如产生一些指定规则算法的数据，然后对属性进行处理。 在绘制无背景颜色只有边框颜色的圆形时候，可以用绘制360度的圆弧替代，效果完全一致。 1234QRect rect(-radius, -radius, radius * 2, radius * 2);//以下两种方法二选一,其实绘制360度的圆弧=绘制无背景的圆形painter-&gt;drawArc(rect, 0, 360 * 16);painter-&gt;drawEllipse(rect); 不要把d指针看的很玄乎，其实就是在类的实现文件定义了一个私有类，用来存放局部变量，个人建议在做一些小项目时，没有太大必要引入这种机制，会降低代码可读性，增加复杂性，新手接受项目后会看的很懵逼。 很多人在绘制的时候，设置画笔以为就只可以设置个单调的颜色，其实QPen还可以设置brush，这样灵活性就提高不知道多少倍，比如设置QPen的brush以后，可以使用各种渐变，比如绘制渐变颜色的进度条和文字等，而不再是单调的一种颜色。 很多控件都带有viewport，比如QTextEdit/QTableWidget/QScrollArea，有时候对这些控件直接处理的时候发现不起作用，需要对其viewport()设置才行，比如设置滚动条区域背景透明，需要使用scrollArea-&gt;viewport()-&gt;setStyleSheet(\"background-color:transparent;\");而不是scrollArea-&gt;setStyleSheet(\"QScrollArea{background-color:transparent;}\"); 有时候设置了鼠标跟踪setMouseTracking为真，如果该窗体上面还有其他控件，当鼠标移到其他控件上面的时候，父类的鼠标移动事件MouseMove识别不到了，此时需要用到HoverMove事件，需要先设置 setAttribute(Qt::WA_Hover, true); Qt封装的QDateTime日期时间类非常强大，可以字符串和日期时间相互转换，也可以毫秒数和日期时间相互转换，还可以1970经过的秒数和日期时间相互转换等。 12345678910QDateTime dateTime;QString dateTime_str = dateTime.currentDateTime().toString(\"yyyy-MM-dd hh:mm:ss\");//从字符串转换为毫秒（需完整的年月日时分秒）datetime.fromString(\"2011-09-10 12:07:50:541\", \"yyyy-MM-dd hh:mm:ss:zzz\").toMSecsSinceEpoch();//从字符串转换为秒（需完整的年月日时分秒）datetime.fromString(\"2011-09-10 12:07:50:541\", \"yyyy-MM-dd hh:mm:ss:zzz\").toTime_t();//从毫秒转换到年月日时分秒datetime.fromMSecsSinceEpoch(1315193829218).toString(\"yyyy-MM-dd hh:mm:ss:zzz\");//从秒转换到年月日时分秒（若有zzz，则为000）datetime.fromTime_t(1315193829).toString(\"yyyy-MM-dd hh:mm:ss[:zzz]\"); 在我们使用QList、QStringList、QByteArray等链表或者数组的过程中，如果只需要取值，而不是赋值，强烈建议使用 at() 取值而不是 [] 操作符，在官方书籍《C++ GUI Qt 4编程（第二版）》的书中有特别的强调说明，此教材的原作者据说是Qt开发的核心人员编写的，所以还是比较权威，至于使用 at() 与使用 [] 操作符速度效率的比较，网上也有网友做过此类对比。原文在书的212页，这样描述的：Qt对所有的容器和许多其他类都使用隐含共享，隐含共享是Qt对不希望修改的数据决不进行复制的保证，为了使隐含共享的作用发挥得最好，可以采用两个新的编程习惯。第一种习惯是对于一个（非常量的）向量或者列表进行只读存取时，使用 at() 函数而不用 [] 操作符，因为Qt的容器类不能辨别 [] 操作符是否将出现在一个赋值的左边还是右边，他假设最坏的情况出现并且强制执行深层赋值，而 at() 函数则不被允许出现在一个赋值的左边。 如果是dialog窗体，需要在exec以后还能让其他代码继续执行，请在dialog窗体exec前增加一行代码，否则会阻塞窗体消息。 123QDialog dialog;dialog.setWindowModality(Qt::WindowModal);dialog.exec(); 安全的删除Qt的对象类，强烈建议使用deleteLater而不是delete，因为deleteLater会选择在合适的时机进行释放，而delete会立即释放，很可能会出错崩溃。如果要批量删除对象集合，可以用qDeleteAll，比如 qDeleteAll(btns); 在QTableView控件中，如果需要自定义的列按钮、复选框、下拉框等其他模式显示，可以采用自定义委托QItemDelegate来实现，如果需要禁用某列，则在自定义委托的重载createEditor函数返回0即可。自定义委托对应的控件在进入编辑状态的时候出现，如果想一直出现，则需要重载paint函数用drawPrimitive或者drawControl来绘制。 将 QApplication::style() 对应的drawPrimitive、drawControl、drawItemText、drawItemPixmap等几个方法用熟悉了，再结合QStyleOption属性，可以玩转各种自定义委托，还可以直接使用paint函数中的painter进行各种绘制，各种牛逼的表格、树状列表、下拉框等，绝对屌炸天。QApplication::style()-&gt;drawControl 的第4个参数如果不设置，则绘制出来的控件不会应用样式表。 心中有坐标，万物皆painter，强烈建议在学习自定义控件绘制的时候，将qpainter.h头文件中的函数全部看一遍、试一遍、理解一遍，这里边包含了所有Qt内置的绘制的接口，对应的参数都试一遍，你会发现很多新大陆，会大大激发你的绘制的兴趣，犹如神笔马良一般，策马崩腾遨游代码绘制的世界。 在使用setItemWidget或者setCellWidget的过程中，有时候会发现设置的控件没有居中显示而是默认的左对齐，而且不会自动拉伸填充，对于追求完美的程序员来说，这个可不大好看，有个终极通用办法就是，将这个控件放到一个widget的布局中，然后将widget添加到item中，这样就完美解决了，而且这样可以组合多个控件产生复杂的控件。 12345678910//实例化进度条控件QProgressBar *progress = new QProgressBar;//增加widget+布局巧妙实现居中QWidget *widget = new QWidget;QHBoxLayout *layout = new QHBoxLayout;layout-&gt;setSpacing(0);layout-&gt;setMargin(0);layout-&gt;addWidget(progress);widget-&gt;setLayout(layout);ui-&gt;tableWidget-&gt;setCellWidget(0, 0, widget); 很多时候需要在已知背景色的情况下，能够清晰的绘制文字，这个时候需要计算对应的文字颜色。 123//根据背景色自动计算合适的前景色double gray = (0.299 * color.red() + 0.587 * color.green() + 0.114 * color.blue()) / 255;QColor textColor = gray &gt; 0.5 ? Qt::black : Qt::white; 对QTableView或者QTableWidget禁用列拖动。 12345#if (QT_VERSION &lt;= QT_VERSION_CHECK(5,0,0)) ui-&gt;tableView-&gt;horizontalHeader()-&gt;setResizeMode(0, QHeaderView::Fixed);#else ui-&gt;tableView-&gt;horizontalHeader()-&gt;setSectionResizeMode(0, QHeaderView::Fixed);#endif 从Qt4转到Qt5，有些类的方法已经废弃或者过时了，如果想要在Qt5中启用Qt4的方法，比如QHeadVew的setMovable，可以在你的pro或者pri文件中加上一行即可：DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0 Qt中的QColor对颜色封装的很完美，支持各种转换，比如rgb、hsb、cmy、hsl，对应的是toRgb、toHsv、toCmyk、toHsl，还支持透明度设置，颜色值还能转成16进制格式显示。 123QColor color(255, 0, 0, 100);qDebug() &lt;&lt; color.name() &lt;&lt; color.name(QColor::HexArgb);//输出 #ff0000 #64ff0000 QVariant类型异常的强大，可以说是万能的类型，在进行配置文件的存储的时候，经常会用到QVariant的转换，QVariant默认自带了toString、toFloat等各种转换，但是还是不够，比如有时候需要从QVariant转到QColor，而却没有提供toColor的函数，这个时候就要用到万能办法。 12345if (variant.typeName() == \"QColor\") { QColor color = variant.value&lt;QColor&gt;(); QFont font = variant.value&lt;QFont&gt;(); QString nodeValue = color.name(QColor::HexArgb);} Qt中的QString和const char *之间转换，最好用toStdString().c_str()而不是toLocal8Bit().constData()，比如在setProperty中如果用后者，字符串中文就会不正确，英文正常。 Qt的信号槽机制非常牛逼，也是Qt的独特的核心功能之一，有时候我们在很多窗体中传递信号来实现更新或者处理，如果窗体层级比较多，比如窗体A的父类是窗体B，窗体B的父类是窗体C，窗体C有个子窗体D，如果窗体A一个信号要传递给窗体D，问题来了，必须先经过窗体B中转到窗体C再到窗体D才行，这样的话各种信号关联信号的connect会非常多而且管理起来比较乱，可以考虑增加一个全局的单例类AppEvent，公共的信号放这里，然后窗体A对应信号绑定到AppEvent，窗体D绑定AppEvent的信号到对应的槽函数即可，干净清爽整洁。 QTextEdit右键菜单默认英文的，如果想要中文显示，加载widgets.qm文件即可，一个Qt程序中可以安装多个翻译文件，不冲突。 Qt中有个全局的焦点切换信号focusChanged，可以用它做自定义的输入法。Qt4中默认会安装输入法上下文，比如在main函数打印a.inputContext会显示值，这个默认安装的输入法上下文，会拦截两个牛逼的信号QEvent::RequestSoftwareInputPanel和QEvent::CloseSoftwareInputPanel，以至于就算你安装了全局的事件过滤器依然识别不到这两个信号，你只需要在main函数执行a.setInputContext(0)即可，意思是安装输入法上下文为空。 在Qt5.10以后，表格控件QTableWidget或者QTableView的默认最小列宽改成了15，以前的版本是0，所以在新版的qt中，如果设置表格的列宽过小，不会应用，取的是最小的列宽。所以如果要设置更小的列宽需要重新设置ui-&gt;tableView-&gt;horizontalHeader()-&gt;setMinimumSectionSize(0); Qt源码中内置了一些未公开的不能直接使用的黑科技，都藏在对应模块的private中，比如gui-private widgets-private等，比如zip文件解压类QZipReader、压缩类QZipWriter就在gui-private模块中，需要在pro中引入QT += gui-private才能使用。 12345678910111213141516171819202122232425#include \"QtGui/private/qzipreader_p.h\"#include \"QtGui/private/qzipwriter_p.h\"QZipReader reader(dirPath);QString path(\"\");//解压文件夹到当前目录reader.extractAll(path);//文件夹名称QZipReader::FileInfo fileInfo = reader.entryInfoAt(0);//解压文件QFile file(filePath);file.open(QIODevice::WriteOnly);file.write(reader.fileData(QString::fromLocal8Bit(\"%1\").arg(filePath)));file.close();reader.close();QZipWriter *writer = new QZipWriter(dirPath);//添加文件夹writer-&gt;addDirectory(unCompress);//添加文件QFile file(filePath);file.open(QIODevice::ReadOnly);writer-&gt;addFile(data, file.readAll());file.close();writer-&gt;close(); 理论上串口和网络收发数据都是默认异步的，操作系统自动调度，完全不会卡住界面，网上那些说收发数据卡住界面主线程的都是扯几把蛋，真正的耗时是在运算以及运算后的处理，而不是收发数据，在一些小数据量运算处理的项目中，一般不建议动用线程去处理，线程需要调度开销的，不要什么东西都往线程里边扔，线程不是万能的。只有当真正需要将一些很耗时的操作比如编码解码等，才需要移到线程处理。 在构造函数中获取控件的宽高很可能是不正确的，需要在控件首次显示以后再获取才是正确的，控件是在首次显示以后才会设置好正确的宽高值，记住是在首次显示以后，而不是构造函数或者程序启动好以后，如果程序启动好以后有些容器控件比如QTabWidget中的没有显示的页面的控件，你去获取宽高很可能也是不正确的，万无一失的办法就是首次显示以后去获取。 数据库处理一般建议在主线程，如果非要在其他线程，务必记得打开数据库也要在那个线程，即在那个线程使用数据库就在那个线程打开，不能打开数据库在主线程，执行sql在子线程，很可能出问题。 新版的QTcpServer类在64位版本的Qt下很可能不会进入incomingConnection函数，那是因为Qt5对应的incomingConnection函数参数变了，由之前的int改成了qintptr，改成qintptr有个好处，在32位上自动是quint32而在64位上自动是quint64，如果在Qt5中继续写的参数是int则在32位上没有问题在64位上才有问题，所以为了兼容Qt4和Qt5，必须按照不一样的参数写。 12345#if (QT_VERSION &gt; QT_VERSION_CHECK(5,0,0)) void incomingConnection(qintptr handle);#else void incomingConnection(int handle);#endif Qt支持所有的界面控件比如QPushButton、QLineEdit自动关联 on_控件名_信号(参数) 信号槽，比如按钮的单击信号 on_pushButton_clicked()，然后直接实现槽函数即可。 QWebEngineView控件由于使用了opengl，在某些电脑上可能由于opengl的驱动过低会导致花屏或者各种奇奇怪怪的问题，比如showfullscreen的情况下鼠标右键失效，需要在main函数启用软件opengl渲染。 1234#if (QT_VERSION &gt; QT_VERSION_CHECK(5,4,0)) QCoreApplication::setAttribute(Qt::AA_UseSoftwareOpenGL);#endif QApplication a(argc, argv); 另外一个方法解决 全屏+QWebEngineView控件一起会产生右键菜单无法弹出的BUG,需要上移一个像素 1234QRect rect = qApp-&gt;desktop()-&gt;geometry();rect.setY(-1);rect.setHeight(rect.height());this-&gt;setGeometry(rect); QStyle内置了很多方法用处很大，比如精确获取滑动条鼠标按下处的值。 1QStyle::sliderValueFromPosition(minimum(), maximum(), event-&gt;x(), width()); 用QFile读写文件的时候，推荐用QTextStream文件流的方式来读写文件，速度快很多，基本上会有30%的提升，文件越大性能区别越大。 123456789101112131415161718//从文件加载英文属性与中文属性对照表QFile file(\":/propertyname.txt\");if (file.open(QFile::ReadOnly)) { //QTextStream方法读取速度至少快30%#if 0 while(!file.atEnd()) { QString line = file.readLine(); appendName(line); }#else QTextStream in(&amp;file); while (!in.atEnd()) { QString line = in.readLine(); appendName(line); }#endif file.close();} 用QFile.readAll()读取QSS文件默认是ANSI格式，不支持UTF8，如果在QtCreator中打开qss文件来编辑保存，这样很可能导致qss加载以后没有效果。 123456789101112131415161718192021222324252627282930void frmMain::initStyle(){ //加载样式表 QString qss; //QFile file(\":/qss/psblack.css\"); //QFile file(\":/qss/flatwhite.css\"); QFile file(\":/qss/lightblue.css\"); if (file.open(QFile::ReadOnly)) {#if 1 //用QTextStream读取样式文件不用区分文件编码 带bom也行 QStringList list; QTextStream in(&amp;file); //in.setCodec(\"utf-8\"); while (!in.atEnd()) { QString line; in &gt;&gt; line; list &lt;&lt; line; } qss = list.join(\"\\n\");#else //用readAll读取默认支持的是ANSI格式,如果不小心用creator打开编辑过了很可能打不开 qss = QLatin1String(file.readAll());#endif QString paletteColor = qss.mid(20, 7); qApp-&gt;setPalette(QPalette(QColor(paletteColor))); qApp-&gt;setStyleSheet(qss); file.close(); }} QString内置了很多转换函数，比如可以调用toDouble转为double数据，但是当你转完并打印的时候你会发现精确少了，只剩下三位了，其实原始数据还是完整的精确度的，只是打印的时候优化成了三位，如果要保证完整的精确度，可以调用 qSetRealNumberPrecision 函数设置精确度位数即可。 1234QString s1, s2;s1 = \"666.5567124\";s2.setNum(888.5632123, 'f', 7);qDebug() &lt;&lt; qSetRealNumberPrecision(10) &lt;&lt; s1.toDouble() &lt;&lt; s2.toDouble(); 用QScriptValueIterator解析数据的时候，会发现总是会多一个节点内容，并且内容为空，如果需要跳过则增加一行代码。 123456while (it.hasNext()) { it.next(); if (it.flags() &amp; QScriptValue::SkipInEnumeration) continue; qDebug() &lt;&lt; it.name();} setPixmap是最糟糕的贴图方式，一般只用来简单的不是很频繁的贴图，频繁的建议painter绘制，默认双缓冲，在高级点用opengl绘制，利用GPU。 如果需要在尺寸改变的时候不重绘窗体，则设置属性即可 this-&gt;setAttribute(Qt::WA_StaticContents, true); 这样可以避免可以避免对已经显示区域的重新绘制。 默认程序中获取焦点以后会有虚边框，如果看着觉得碍眼不舒服可以去掉，设置样式即可：setStyleSheet(\"*{outline:0px;}\"); Qt表格控件一些常用的设置封装，QTableWidget继承自QTableView，所以下面这个函数支持传入QTableWidget。 1234567891011121314151617181920212223242526272829303132333435void QUIHelper::initTableView(QTableView *tableView, int rowHeight, bool headVisible, bool edit){ //奇数偶数行颜色交替 tableView-&gt;setAlternatingRowColors(false); //垂直表头是否可见 tableView-&gt;verticalHeader()-&gt;setVisible(headVisible); //选中一行表头是否加粗 tableView-&gt;horizontalHeader()-&gt;setHighlightSections(false); //最后一行拉伸填充 tableView-&gt;horizontalHeader()-&gt;setStretchLastSection(true); //行标题最小宽度尺寸 tableView-&gt;horizontalHeader()-&gt;setMinimumSectionSize(0); //行标题最大高度 tableView-&gt;horizontalHeader()-&gt;setMaximumHeight(rowHeight); //默认行高 tableView-&gt;verticalHeader()-&gt;setDefaultSectionSize(rowHeight); //选中时一行整体选中 tableView-&gt;setSelectionBehavior(QAbstractItemView::SelectRows); //只允许选择单个 tableView-&gt;setSelectionMode(QAbstractItemView::SingleSelection); //表头不可单击#if (QT_VERSION &gt; QT_VERSION_CHECK(5,0,0)) tableView-&gt;horizontalHeader()-&gt;setSectionsClickable(false);#else tableView-&gt;horizontalHeader()-&gt;setClickable(false);#endif //鼠标按下即进入编辑模式 if (edit) { tableView-&gt;setEditTriggers(QAbstractItemView::CurrentChanged | QAbstractItemView::DoubleClicked); } else { tableView-&gt;setEditTriggers(QAbstractItemView::NoEditTriggers); }} 在一些大的项目中，可能嵌套了很多子项目，有时候会遇到子项目依赖其他子项目的时候，比如一部分子项目用来生成动态库，一部分子项目依赖这个动态库进行编译，此时就需要子项目按照顺序编译。 123456TEMPLATE = subdirs#设置ordered参数以后会依次编译 demo designer examplesCONFIG += orderedSUBDIRS += demoSUBDIRS += designerSUBDIRS += examples MSVC编译器的选择说明 如果是32位的Qt则编译器选择x86开头的 如果是64位的Qt则编译器选择amd64开头的 具体是看安装的Qt构建套件版本以及目标运行平台的系统位数和架构 一般现在的电脑默认以64位的居多，选择amd64即可 如果用户需要兼容32位的系统则建议选择32位的Qt，这样即可在32位也可以在64位系统运行 诸葛大佬补充：x86/x64都是编译环境和运行环境相同，没有或。带下划线的就是交叉编译，前面是编译环境，后面是运行环境。 名称 说明 x86 32/64位系统上编译在32/64位系统上运行 x86_amd64 32/64位系统上编译在64位系统上运行 x86_arm 32/64位系统上编译在arm系统上运行 amd64 64位系统上编译在64位系统上运行 amd64_x86 64位系统上编译在32/64位系统上运行 amd64_arm 64位系统上编译在arm系统上运行 很多时候用QDialog的时候会发现阻塞了消息，而有的时候我们希望是后台的一些消息继续运行不要终止，此时需要做个设置。 12QDialog dialog;dialog.setWindowModality(Qt::WindowModal); 很多初学者甚至几年工作经验的人，对多线程有很深的误解和滥用，尤其是在串口和网络通信这块，什么都往多线程里面丢，一旦遇到界面卡，就把数据收发啥的都搞到多线程里面去，殊不知绝大部分时候那根本没啥用，因为没找到出问题的根源。 如果你没有使用wait***函数的话，大部分的界面卡都出在数据处理和展示中，比如传过来的是一张图片的数据，你需要将这些数据转成图片，这个肯定是耗时的； 还有就是就收到的数据曲线绘制出来，如果过于频繁或者间隔过短，肯定会给UI造成很大的压力的，最好的办法是解决如何不要频繁绘制UI比如合并数据一起绘制等； 如果是因为绘制UI造成的卡，那多线程也是没啥用的，因为UI只能在主线程； 串口和网络的数据收发默认都是异步的，由操作系统调度的，如果数据处理复杂而且数据量大，你要做的是将数据处理放到多线程中； 如果没有严格的数据同步需求，根本不需要调用wait***之类的函数来立即发送和接收数据，实际需求中大部分的应用场景其实异步收发数据就足够了； 有严格数据同步需求的场景还是放到多线程会好一些，不然你wait***就卡在那边了； 多线程是需要占用系统资源的，理论上来说，如果线程数量超过了CPU的核心数量，其实多线程调度可能花费的时间更多，各位在使用过程中要权衡利弊； 在嵌入式linux上，如果设置了无边框窗体，而该窗体中又有文本框之类的，发现没法产生焦点进行输入，此时需要主动激活窗体才行。 123456//这种方式设置的无边框窗体在嵌入式设备上无法产生焦点setWindowFlags(Qt::WindowStaysOnTopHint | Qt::FramelessWindowHint | Qt::X11BypassWindowManagerHint);//需要在show以后主动激活窗体w-&gt;show();w-&gt;activateWindow(); 二、其他经验 Qt界的中文乱码问题，版本众多导致的如何选择安装包问题，如何打包发布程序的问题，堪称Qt界的三座大山！ 在Qt的学习过程中，学会查看对应类的头文件是一个好习惯，如果在该类的头文件没有找到对应的函数，可以去他的父类中找找，实在不行还有爷爷类，肯定能找到的。通过头文件你会发现很多函数接口其实Qt已经帮我们封装好了，有空还可以阅读下他的实现代码。 Qt安装目录下的Examples目录下的例子，看完学完，月薪20K起步；Qt常用类的头文件的函数看完学完使用一遍并加以融会贯通，月薪30K起步。 Qt在开发阶段不支持中文目录，切记，这是无数人可能犯的错误，在安装Qt集成开发环境以及编译器的时候，务必记得目录必须英文，否则很可能不正常，建议尽量用默认的安装位置。 如果出现崩溃和段错误，80%都是因为要么越界，要么未初始化，死扣这两点，80%的问题解决了。 Qt一共有几百个版本，关于如何选择Qt版本的问题，我一般保留四个版本，为了兼容Qt4用4.8.7，最后的支持XP的版本5.7.0，最新的长期支持版本比如5.12，最高的新版本比如5.14.2。强烈不建议使用5.0到5.3之间的版本，太多BUG和坑，稳定性和兼容性相比于之后的版本相当差，能换就换，不能换睡服领导也要换。 终极秘籍：如果遇到问题搜索Qt方面找不到答案，试着将关键字用JAVA C# android打头，你会发现别有一番天地，其他人很可能做过！ 最后一条：珍爱生命，远离编程。祝大家头发浓密，睡眠良好，情绪稳定，财富自由！ 三、推荐的Qt论坛+个人博客+网站+群 名称 网址 QQ学习群 Qt交流大会群 853086607 Qt技术交流群 46679801 Qt进阶之路群 734623697 QtWidget开源demo集合 https://gitee.com/feiyangqingyun/QWidgetDemo QtQuick/Qml开源demo集合 https://gitee.com/jaredtao/TaoQuick qtcn http://www.qtcn.org 豆子的空间 https://www.devbean.net yafeilinux http://www.qter.org 一去二三里 http://blog.csdn.net/liang19890820 乌托邦2号 http://blog.csdn.net/taiyang1987912 foruok http://blog.csdn.net/foruok jason http://blog.csdn.net/wsj18808050 朝十晚八 http://www.cnblogs.com/swarmbees BIG_C_GOD http://blog.csdn.net/big_c_god 公孙二狗 https://qtdebug.com/qtbook 雨田哥 https://blog.csdn.net/ly305750665 郑天佐 https://blog.csdn.net/zhengtianzuo06 寒山-居士 https://blog.csdn.net/esonpo feiyangqingyun https://blog.csdn.net/feiyangqingyun 前行中小猪 http://blog.csdn.net/goforwardtostep 涛哥的知乎专栏 https://zhuanlan.zhihu.com/TaoQt Qt君 https://blog.csdn.net/nicai_xiaoqinxi Qt老外视频教程 http://space.bilibili.com/2592237/#!/index Qt维基补充文档 https://wiki.qt.io/Main Qt源码查看网站 https://code.woboq.org/qt5 Qt官方下载地址 https://download.qt.io Qt官方下载新地址 https://download.qt.io/new_archive/qt/ Qt国内镜像下载地址 https://mirrors.cloud.tencent.com/qt 精美图表控件QWT http://qwt.sourceforge.net/ 精美图表控件QCustomPlot https://www.qcustomplot.com/ 免费图标下载 http://www.easyicon.net/ 图形字体下载 https://www.iconfont.cn/ 漂亮界面网站 https://www.ui.cn/ 三、其他 C++入门书籍推荐《C++ primer plus》，进阶书籍推荐《C++ primer》。 Qt入门书籍推荐霍亚飞的《Qt Creator快速入门》，Qt进阶书籍推荐官方的《C++ GUI Qt4编程》，qml书籍推荐《Qt5编程入门》。 强烈推荐程序员自我修养和规划系列书《大话程序员》《程序员的成长课》《解忧程序员》，受益匪浅，受益终生！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"整理","slug":"整理","permalink":"http://blog.iwxyi.com/tags/整理/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"C语言文件操作","date":"2020-07-16T07:30:00.000Z","path":"2020/07/16/C语言文件操作/","text":"二进制文件读取文件，再写入到另一个文件里面： 1、获取文件大小 12345FILE* fp = fopen(\"T:/img.jpg\", \"rb\");fseek(fp, 0, SEEK_END);int size = ftell(fp);fclose(fp);cout &lt;&lt; \"文件大小(指针偏移计算):\" &lt;&lt; size; // 字节大小 2、读取文件 1234FILE* fp = fopen(\"T:/img.jpg\", \"rb\");int* buffer = (int*)malloc(size+4); // 可以改成其他类型也没事，比如 char*fread(buffer, size, 1, fp);fclose(fp); 3、写入到另一个文件 123FILE* fp = fopen(\"T:/img1.png\", \"wb\");fwrite(buffer, size, 1, fp); // 方法一fclose(fp); fread和write的size可以更大，不影响结果（表示上限） 实测一张jpg图片： size超过体积，保存的会是size的大小 1/10时：图片只有一半显示，体积也只有1/10 1/4时：上方5/6的部分清晰，剩下的模糊 1/2时：虽然体积只有一半，但是好像一样清晰…… 文本文件读取文本文件 1234FILE *fp = fopen(\"/tmp/test.txt\", \"w+\");fprintf(fp, \"This is testing for fprintf...\\n\");fputs(\"This is testing for fputs...\\n\", fp);fclose(fp); //记得用完关闭文件 写入文本文件 12345char buff[255];FILE *fp = fopen(\"/tmp/test.txt\", \"r\");fscanf(fp, \"%s\", buff); //只有字符串变量前不加‘&amp;’，其他int、double等类型前都要加‘&amp;’符号fgets(buff, 255, (FILE*)fp); //scanf遇到空格就会断开，gets会读取空格，遇到换行就结束fclose(fp); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C语言","slug":"C语言","permalink":"http://blog.iwxyi.com/tags/C语言/"},{"name":"文件操作","slug":"文件操作","permalink":"http://blog.iwxyi.com/tags/文件操作/"}]},{"title":"Maven安装与配置","date":"2020-07-15T08:52:00.000Z","path":"2020/07/15/Maven安装与配置/","text":"Maven安装与配置一、需要准备的东西 JDK Eclipse Maven程序包 二、下载与安装 前往https://maven.apache.org/download.cgi下载最新版的Maven程序： upload successful 将文件解压到D:\\Program Files\\Apache\\maven目录下: upload successful 新建环境变量MAVEN_HOME，赋值D:\\Program Files\\Apache\\maven upload successful 编辑环境变量Path，追加%MAVEN_HOME%\\bin; upload successful 至此，maven已经完成了安装，我们可以通过DOS命令检查一下我们是否安装成功： 1mvn -v upload successful 三、配置Maven本地仓库 在D:\\Program Files\\Apache\\目录下新建maven-repository文件夹，该目录用作maven的本地库。 打开D:\\Program Files\\Apache\\maven\\conf\\settings.xml文件，查找下面这行代码： 1&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt; localRepository节点默认是被注释掉的，需要把它移到注释之外，然后将localRepository节点的值改为我们在3.1中创建的目录D:\\Program Files\\Apache\\maven-repository。 localRepository节点用于配置本地仓库，本地仓库其实起到了一个缓存的作用，它的默认地址是 C:\\Users\\用户名.m2。 当我们从maven中获取jar包的时候，maven首先会在本地仓库中查找，如果本地仓库有则返回；如果没有则从远程仓库中获取包，并在本地库中保存。 此外，我们在maven项目中运行mvn install，项目将会自动打包并安装到本地仓库中。 运行一下DOS命令 1mvn help:system 如果前面的配置成功，那么D:\\Program Files\\Apache\\maven-repository会出现一些文件。 四、配置Eclipse的Maven环境 Eclipse Oxygen，打开Window-&gt;Preferences-&gt;Maven-&gt;Installations，右侧点击Add。 upload successful 设置maven的安装目录，然后Finish upload successful 选中刚刚添加的maven，并Apply。 upload successful 打开Window-&gt;Preferences-&gt;Maven-&gt;User Settings，配置如下并Apply： upload successful 至此，Maven的安装和配置全部结束。 转载自：https://www.cnblogs.com/eagle6688/p/7838224.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Maven","slug":"Maven","permalink":"http://blog.iwxyi.com/tags/Maven/"},{"name":"Spring","slug":"Spring","permalink":"http://blog.iwxyi.com/tags/Spring/"}]},{"title":"ffmpeg无损合并视频音频","date":"2020-06-20T09:43:00.000Z","path":"2020/06/20/ffmpeg无损合并视频音频/","text":"将音频融入视频音轨无损合并（超级超级快速） 1ffmpeg.exe -i %audio% -i %video% -acodec copy -vcodec copy output.mp4 合并（慢速度，会肉眼不明显的压缩一点） 1ffmpeg -i 音频文件名 -i 视频文件名 输出文件名 如果ffmpeg不在当前操作的文件夹内，文件名就要带上全路径。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"ffmpeg","slug":"ffmpeg","permalink":"http://blog.iwxyi.com/tags/ffmpeg/"}]},{"title":"Java通配符和边界","date":"2020-06-16T08:12:00.000Z","path":"2020/06/16/Java通配符和边界/","text":"&lt;? extends T&gt;：是指 “上界通配符（Upper Bounds Wildcards）” &lt;? super T&gt;：是指 “下界通配符（Lower Bounds Wildcards）” 上界通配符使得支持类似下面的转换：List&lt;Parent&gt; =&gt; List&lt;Base&gt; 即模板类T的泛型 Plate&lt;Apple&gt; =&gt; Plate&lt;Fruit&gt; ——“装水果的盘子一定能装苹果” 适用于频繁往外面读取 副作用是无法插入数据 123456class Plate&lt;T&gt;{ private T item; public Plate(T t){item=t;} public void set(T t){item=t;} public T get(){return item;}} 12345678910Plate&lt;? extends Fruit&gt; p=new Plate&lt;Apple&gt;(new Apple()); //不能存入任何元素p.set(new Fruit()); //Errorp.set(new Apple()); //Error //读取出来的东西只能存放在Fruit或它的基类里。Fruit newFruit1=p.get();Object newFruit2=p.get();Apple newFruit3=p.get(); //Error 原因是编译器只知道容器内是Fruit或者它的派生类，但具体是什么类型不知道。可能是Fruit？可能是Apple？也可能是Banana，RedApple，GreenApple？编译器在看到后面用Plate赋值以后，盘子里没有被标上有“苹果”。而是标上一个占位符：CAP#1，来表示捕获一个Fruit或Fruit的子类，具体是什么类不知道，代号CAP#1。然后无论是想往里插入Apple或者Meat或者Fruit编译器都不知道能不能和这个CAP#1匹配，所以就都不允许。 下界通配符不影响往里存，但往外取只能放在Object对象里适用于频繁往里面插入 12345678910Plate&lt;? super Fruit&gt; p=new Plate&lt;Fruit&gt;(new Fruit()); //存入元素正常p.set(new Fruit());p.set(new Apple()); //读取出来的东西只能存放在Object类里。Apple newFruit3=p.get(); //ErrorFruit newFruit1=p.get(); //ErrorObject newFruit2=p.get(); 下界规定了元素的最小粒度的下限，实际上是放松了容器元素的类型控制。既然元素是Fruit的基类，那往里存粒度比Fruit小的都可以。但往外读取元素就费劲了，只有所有类的基类Object对象才能装下。但这样的话，元素的类型信息就全部丢失。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Java","slug":"Java","permalink":"http://blog.iwxyi.com/tags/Java/"}]},{"title":"Qt各种string转换","date":"2020-06-12T08:41:00.000Z","path":"2020/06/12/Qt各种string转换/","text":"TChar转QString 12345#ifdef UNICODE qs = QString::fromUtf16((ushort*)ts);#else qs = QString::fromLocal8Bit(ts);#endif // UNICODE document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"Qt嵌入桌面","date":"2020-06-12T08:40:00.000Z","path":"2020/06/12/Qt嵌入桌面/","text":"窗口最底层：浮在图标上面，但是Win+D会最小化窗口 123456setAttribute(Qt::WA_TranslucentBackground, true); // 按需加上setWindowFlags(Qt::FramelessWindowHint //去边框 | Qt::X11BypassWindowManagerHint //linux下脱离任务管理器 | Qt::WindowStaysOnBottomHint //最低层显示 | Qt::Tool //不在任务栏显示 ); 嵌入桌面：浮在图标上面，Win+D不会隐藏窗口 .h 12static BOOL enumUserWindowsCB(HWNDhwnd,LPARAMlParam); //静态全局函数HWND findDesktopIconWnd(); .cpp 123456789101112131415161718192021BOOL Test::enumUserWindowsCB(HWND hwnd,LPARAM lParam){ long wflags = GetWindowLong(hwnd, GWL_STYLE); if(!(wflags &amp; WS_VISIBLE)) return TRUE; HWND sndWnd; if( !(sndWnd=FindWindowEx(hwnd, NULL, L\"SHELLDLL_DefView\", NULL)) ) return TRUE; HWND targetWnd; if( !(targetWnd=FindWindowEx(sndWnd, NULL, L\"SysListView32\", L\"FolderView\")) ) return TRUE; HWND* resultHwnd = (HWND*)lParam; *resultHwnd = targetWnd; return FALSE;}HWND Test::findDesktopIconWnd(){ HWND resultHwnd = NULL; EnumWindows((WNDENUMPROC)enumUserWindowsCB, (LPARAM)&amp;resultHwnd); return resultHwnd;} main 123HWND desktopHwnd = findDesktopIconWnd();if(desktopHwnd) SetParent((HWND)widget-&gt;winId(), desktopHwnd); 桌面壁纸finddesktop.h 123456789#include &lt;qt_windows.h&gt;/*因为msvc编译器的缘故，要链接以下库文件*/#pragma comment(lib,\"winmm.lib\")#pragma comment(lib,\"User32.lib\")#pragma comment(lib,\"gdi32.lib\")/*分割*/HWND findDesktopIconWnd();//找到桌面句柄void SendMessageToDesktop();//召唤WorkerWHWND GetWorkerW();//得到WorkerW finddesktop.cpp 12345678910111213141516171819202122232425262728293031323334#include\"finddesktop.h\"HWND WorkerW=NULL;HWND findDesktopIconWnd(){ HWND hWorkerW = NULL;//WorkerW的句柄 HWND hDefView = NULL;//SHELLDLL_DefView的句柄 //找到WorkerW类的窗口 hWorkerW = FindWindowEx(NULL, NULL, L\"WorkerW\", NULL); //通过遍历找到包含SHELLDLL_DefView的WorkerW while ((!hDefView) &amp;&amp; hWorkerW) { hDefView = FindWindowEx(hWorkerW, NULL, L\"SHELLDLL_DefView\", NULL); WorkerW=hWorkerW;//得到WorkerW hWorkerW = FindWindowEx(NULL, hWorkerW, L\"WorkerW\", NULL); } //隐藏窗口，不让mainwindow被挡住 ShowWindow(hWorkerW,0); return FindWindow(L\"Progman\",NULL);}void SendMessageToDesktop(){ PDWORD_PTR result = NULL; //发送消息，召唤WorkerW //参考：https://www.codeproject.com/articles/856020/draw-behind-desktop-icons-in-windows SendMessageTimeout(FindWindow(L\"Progman\",NULL), 0x52c, 0, 0, SMTO_NORMAL, 1000, result);}HWND GetWorkerW(){ findDesktopIconWnd(); return WorkerW;//得到WorkerW} main.cpp 12345MainWindow w;SendMessageToDesktop();//发送消息HWND desktopWnd = findDesktopIconWnd();//获取桌面句柄if (desktopWnd) SetParent((HWND)w.winId(), desktopWnd); // 设置为桌面壁纸级 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"Qt设置桌面壁纸","date":"2020-06-12T08:40:00.000Z","path":"2020/06/12/Qt设置桌面壁纸/","text":"Windows1234567891011#include &lt;windows.h&gt;void WallPaper::setWallPaper(QString filePath){ const char *tmp = filePath.toStdString().c_str(); std::wstringstream wss; wss &lt;&lt; tmp; const wchar_t *filename = wss.str().c_str(); if( !SystemParametersInfo(SPI_SETDESKWALLPAPER, 0, (void*)filename, SPIF_UPDATEINIFILE) )//调用windows的API函数 qDebug(\"设置桌面背景失败!\");} 注： win10可调用此函数实现其功能。但win7会将桌面背景变成纯黑色 Ubuntu鉴于Ubuntu的相关API函数使用难度较大，需要安装一些库，过程太过繁琐。这里介绍一种比较简单的实现方法，即Qt的C++与SHELL结合使用来实现此功能： 在本project的目录下，单独存了一个SHELL文件。该SHELL中主要包含了一个图片路径变量和设置Ubuntu桌面背景的相关指令。 使用QFile设置更改SHELL文件中当前的图片路径。 使用QProcess执行此SHELL文件，更换壁纸。注：该SHELL文件的右键属性权限中应设置为“允许作为程序执行文件”。 Qt程序： 123456789101112131415161718#include &lt;QProcess&gt;void WallPaper::setWallPaper(QString filePath){ //更改SHELL文件“setwallpaperforUbuntu”中的图片路径信息 QFile file(qApp-&gt;applicationDirPath() + \"/setwallpaperforUbuntu\"); file.open(QIODevice::ReadWrite); QTextStream textStream(&amp;file); QString text = textStream.readAll(); int start = text.indexOf(\"/home\"); textStream.seek(start); textStream &lt;&lt; filePath &lt;&lt; \"' \";//这么多空格是因为每次路径字符串长度不等，保证能够覆盖。SHELL文件相应位置也有空格（empty spaces） file.close(); //调用执行该SHELL文件 QProcess *setWallPaperSHELL = new QProcess; QString command = qApp-&gt;applicationDirPath() + \"/setwallpaperforUbuntu\"; setWallPaperSHELL-&gt;start(command);} Shell文件 setwallpaperforubuntu： 1234567891011121314151617#!/bin/bash# Set picture options# Valid options are: none,wallpaper,centered,scaled,stretched,zoom,span nedpicOpts=\"zoom\"# File Path, the location where the Bing pics are stored, NOTICE: there are many empty spaces after the \".jpg'\", which is very necessary!filePath='/home/yinhe/Pictures/WaldkauzDE_ZH-CN10024135858_1920x1080.jpg'# Set the GNOME3 wallpaperDISPLAY=:0 GSETTINGS_BACKEND=dconf gsettings set org.gnome.desktop.background picture-uri '\"file://'$filePath'\"'# Set the GNOME 3 wallpaper picture optionsDISPLAY=:0 GSETTINGS_BACKEND=dconf gsettings set org.gnome.desktop.background picture-options $picOpts# Exit the scriptexit 参考来源： https://www.jianshu.com/p/7b069405fe8a document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"C语言编译过程","date":"2020-06-11T07:24:00.000Z","path":"2020/06/11/C语言编译过程/","text":"C语言编译过程1. 预处理对C源文件的伪指令（以#开头 ）和特殊符号进行处理 伪指令包括： 宏定义：#define PI (3.1415) 条件编译：#if (conditions) 头文件：#include &lt;filename&gt; 特殊符号有：__func__、__LINE__、__FILE__等 这里不做语法的检查，仅仅替换 2. 编译对语法和词法进行分析，确保指令都符合语法规则后，将其翻译成等价的中间代码或汇编代码。 进行语法和语法的分析，确保指令都符合语法规则后，将其翻译成等价的中间代码或者汇编代码。 3. 优化中间代码的优化，主要的工作时删除公共表达式、循环优化（代码外提、强度削弱、变换循环控制条件、已知量的合并等）、复写传播，以及无用赋值的删除等等。 偏向硬件执行的优化，考虑如何充分利用机器的各个硬件寄存器存放的有关变量的值，以减少对于内存的访问次数。另外，如何根据机器硬件执行指令的特点（如流水线、RISC、CISC、VLIW等）而对指令进行一些调整使目标代码比较短，执行的效率比较高。 4. 汇编将汇编语言代码翻译成目标机器指令的过程，即将优化后的汇编代码翻译成一个目标文件。 这个目标文件不能执行，因为可能需要用到其他库或者其他文件的一些函数，所以需要链接 目标文件由段组成，通常一个目标文件中至少有两段： 代码段：主要包含程序的指令。一般是可读和可执行的，但不可写。 数据段：主要存放程序中要用到的各种全局变量或静态的数据。一般是可读、可写、可执行的。 5. 链接将有关的目标文件彼此相连接，即将一个文件中引用的符号同该符号在另一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。 链接分为静态和动态。静态是涉及到的函数和符号，直接从源文件中copy过来，形成最终的可执行文件。动态只是记录这些函数和符号的一些信息，在执行的时候才从内存中查找，并映射到可执行文件的进程虚拟空间中。 两种方式的对比：静态的安全，但是可执行文件占用内存空间较大；动态的灵活，占用内存小，但是性能上可能会受到一些损害。 优化选项gcc默认提供了5级优化选项的集合: -O0:无优化(默认) -O和-O1：使用能减少目标文件大小以及执行时间并且不会使编译时间明显增加的优化，移除冗余变量和函数（静态、内联）。在编译大型程序的时候会显著增加编译时内存的使用。能得到最佳调试视图。 -O2：包含-O1的优化并增加了不需要在目标文件大小和执行速度上进行折衷的优化。编译器不执行循环展开以及函数内联。此选项将增加编译时间和目标文件的执行性能。（默认优化级别） -Os：专门优化目标文件大小，执行所有的不增加目标文件大小（对齐优化）的-O2优化选项。并且执行专门减小目标文件大小的优化选项。 -O3：打开所有-O2的优化选项并且增加 -finline-functions, -funswitch-loops, -fpredictive-commoning, -fgcse-after-reload, -ftree-vectorize优化选项。通常和-O3 -Otime（默认）或-O3 -Ospace配合使用。以-O3 -Otime为例，以增大印象大小为代价缩短执行时间，如下： 1while (expression) body; 会优化为： 12345if (expression) { do { body; } while (expression);} 参考来源： https://www.cnblogs.com/cyc2009/p/4346558.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C语言","slug":"C语言","permalink":"http://blog.iwxyi.com/tags/C语言/"},{"name":"编译原理","slug":"编译原理","permalink":"http://blog.iwxyi.com/tags/编译原理/"}]},{"title":"Qt枚举与字符串互相转换","date":"2020-06-09T08:37:00.000Z","path":"2020/06/09/Qt枚举与字符串互相转换/","text":"在QT中将枚举类型注册(QT_Q_ENUM或QT_Q_FLAG)后，就可以利用QT的元对象进行枚举类型与字符串类型转换了。 代码示例： 12345678910111213#include &lt;QtCore/QMetaEnum&gt;int main() { QMetaEnum metaEnum = QMetaEnum::fromType&lt;Qt::Alignment&gt;(); //字符串转枚举值 Qt::Alignment alignment = (Qt::Alignment)metaEnum.keyToValue(\"Qt::AlignLeft\"); alignment = (Qt::Alignment)metaEnum.keysToValue(\"Qt::AlignLeft | Qt::AlignVCenter\"); //枚举值转字符串 const char* s = metaEnum.valueToKey(Qt::AlignCenter); return 0;} 在qss中我们可以这样使用枚举类型： 1234QTabBar#CustomTabBar { /* Qt::AlignmentFlag定义 */ qproperty-text_align: \"AlignLeft | AlignVCenter\";} QT中判断信号是否与槽连接： 12QPushButton btn;int receivers = btn.receivers(SIGNAL(clicked(bool)); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"GAP8运行PulpOS Demo","date":"2020-04-13T05:57:00.000Z","path":"2020/04/13/GAP8搭建PulpOS运行HelloWorld/","text":"运行 HelloWorld 下载 SDK： https://github.com/GreenWaves-Technologies/gap_sdk 在 gap_sdk 文件夹下执行命令 1source sourceme.sh 选择平台，第1个即可 运行 HelloWorld Demo 12cd examples/native/pulpos/helloworldmake clean all run platform=gvsoc document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PulpOS","slug":"PulpOS","permalink":"http://blog.iwxyi.com/tags/PulpOS/"}]},{"title":"死记硬背的快排","date":"2020-03-19T09:46:00.000Z","path":"2020/03/19/死记硬背的快排/","text":"切分部分： 1234567891011121314int partition(int arr[], int low, int high) {&nbsp;&nbsp; &nbsp;int pivot = arr[low];&nbsp;&nbsp; &nbsp;while (low &lt; high) {&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;while (low &lt; high &amp;&amp; arr[high] &gt;= pivot) high--;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// swap(arr[low], arr[high]); arr[low] = arr[high]; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;while (low &lt; high &amp;&amp; arr[low] &lt;= pivot) low++;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;// swap(arr[low], arr[high]); arr[high] = arr[low];&nbsp;&nbsp; &nbsp;} arr[low] = pivot;&nbsp;&nbsp; &nbsp;return low;} swap包含在头文件&lt;algorithm&gt;中，当然用传统t = a, a = b, b = t的办法也可以。 主体部分： 1234567void QSort(int arr[], int low, int high) {&nbsp;&nbsp; &nbsp;if (low &lt; high) {&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int pivot = partition(arr, low, high);&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;QSort(arr, low, pivot - 1); //采用递归的方式对切分后的子数组排序&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;QSort(arr, pivot + 1, high);&nbsp;&nbsp; &nbsp;}} 其中，参数low和high表示的是数组元素的下标，分别代表待排序数组的最左端元素和最右端元素（都包括）。 样例： 123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;ctime&gt;using namespace std; int main(){&nbsp;&nbsp; &nbsp;srand(time(0));&nbsp;&nbsp; &nbsp;int a[100];&nbsp;&nbsp; &nbsp;for (int i = 0; i != 100; i++)&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;a[i] = rand() % 1000;&nbsp;&nbsp; &nbsp;//QSort(a, 0, 100)&nbsp;&nbsp; &nbsp;QSort(a, 0, 99); //拳打下标越界，脚踢死循环。 &nbsp;&nbsp; &nbsp;for (int i = 0; i != 100; i++) {&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;cout &lt;&lt; a[i] &lt;&lt; ' ';&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;if ((i + 1) % 10 == 0)&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;cout &lt;&lt; endl;&nbsp;&nbsp; &nbsp;}&nbsp;&nbsp; &nbsp;return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"算法","slug":"算法","permalink":"http://blog.iwxyi.com/tags/算法/"}]},{"title":"Flutter可扩展列表","date":"2020-03-12T05:22:00.000Z","path":"2020/03/12/Flutter可扩展列表/","text":"Flutter可扩展的面板 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import 'package:flutter/material.dart';class ExpansionTileSample extends StatelessWidget { @override Widget build(BuildContext context) { return new MaterialApp( home: new Scaffold( appBar: new AppBar( title: const Text('ExpansionTile'), ), body: new ListView.builder( itemBuilder: (BuildContext context, int index) =&gt; new EntryItem(data[index]), itemCount: data.length, ), ), ); }}// One entry in the multilevel list displayed by this app.class Entry { Entry(this.title, [this.children = const &lt;Entry&gt;[]]); final String title; final List&lt;Entry&gt; children;}// The entire multilevel list displayed by this app.final List&lt;Entry&gt; data = &lt;Entry&gt;[ new Entry('Chapter A', &lt;Entry&gt;[ new Entry('Section A0', &lt;Entry&gt;[ new Entry('Item A0.1'), new Entry('Item A0.2'), new Entry('Item A0.3'), ], ), new Entry('Section A1'), new Entry('Section A2'), ], ),];// Displays one Entry. If the entry has children then it's displayed// with an ExpansionTile.class EntryItem extends StatelessWidget { const EntryItem(this.entry); final Entry entry; Widget _buildTiles(Entry root) { if (root.children.isEmpty) return new ListTile(title: new Text(root.title)); return new ExpansionTile( key: new PageStorageKey&lt;Entry&gt;(root), title: new Text(root.title), children: root.children.map(_buildTiles).toList(), ); } @override Widget build(BuildContext context) { return _buildTiles(entry); }}void main() { runApp(new ExpansionTileSample());} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://blog.iwxyi.com/tags/Flutter/"}]},{"title":"ThinkPHP隐藏URL中index文件","date":"2020-03-05T05:56:00.000Z","path":"2020/03/05/ThinkPHP隐藏URL中index文件/","text":"以Apache为例，需要在入口文件的同级添加.htaccess文件（官方默认自带了该文件），内容如下： 1234567&lt;IfModule mod_rewrite.c&gt;Options +FollowSymlinks -MultiviewsRewriteEngine onRewriteCond %{REQUEST_FILENAME} !-dRewriteCond %{REQUEST_FILENAME} !-fRewriteRule ^(.*)$ index.php/$1 [QSA,PT,L]&lt;/IfModule&gt; 如果用的phpstudy，规则如下： 1234567&lt;IfModule mod_rewrite.c&gt; Options +FollowSymlinks -Multiviews RewriteEngine on RewriteCond %{REQUEST_FILENAME} !-d RewriteCond %{REQUEST_FILENAME} !-f RewriteRule ^(.*)$ index.php [L,E=PATH_INFO:$1] &lt;/IfModule&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"http://blog.iwxyi.com/tags/ThinkPHP/"}]},{"title":"MySQL导入大文件没有数据","date":"2020-03-03T06:06:00.000Z","path":"2020/03/03/数据库常见问题/","text":"还原.psc文件大表没有数据mysql是根据配置文件限制server接受的数据包大小，有时候大的插入和更新会被 max_allowed_packet 参数限制掉，导致失败 在MySQL安装目录下找到my.ini，在[mysqld]字段下修改或加上： 1max_allowed_packet=1000M 至少要大于 .psc 文件的大小吧 重启MySQL重新导入 .psc 文件 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"SQL","slug":"SQL","permalink":"http://blog.iwxyi.com/tags/SQL/"}]},{"title":"Qt在Linux下透明窗口失效","date":"2020-02-28T05:59:00.000Z","path":"2020/02/28/Qt在Linux下透明窗口失效/","text":"Qt参考文档 Platform notes:X11: This feature relies on the use of an X server that supports ARGB visuals and a compositing window manager.Windows: The widget needs to have the Qt::FramelessWindowHintwindow flag set for the translucency to work. 平台注意事项： X11（linux）：此特性依赖于能提供支持ARGB视觉效果和复合式视窗管理的X服务的功能开启。 Windows：此控件需要设置窗口标志Qt::FramelessWindowHint才能开启透明功能。 WindowssetWindowFlags(Qt::FramelessWindowHint);setAttribute(Qt::WA_TranslucentBackground,true);可以实现透明功能 Linux需要安装渲染工具compiz 方法如下：root用户下： yum install compiz运行：compiz –replace &amp; 参考：https://blog.csdn.net/weixin_38980184/article/details/89342922 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"Flutter-学习笔记","date":"2020-02-25T05:25:00.000Z","path":"2020/02/25/Flutter学习笔记/","text":"安装与运行Windows下载安装包：https://flutter.io/sdk-archive/#windows 临时镜像： 12export PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 在Flutter安装目录的flutter文件下找到flutter_console.bat，双击运行并启动flutter命令行。 将 flutter\\bin 添加到环境变量 Path。 编译桌面端 安装go：https://studygolang.com/dl 安装hover 123go env -w GOPROXY=https://goproxy.cnset GO111MODULE=ongo get -u -a github.com/go-flutter-desktop/hover 如果出现如下错误提示，则需要升级你的go版本，最低支持1.12： 1cmdApp.ProcessState.ExitCode undefined (type *os.ProcessState has no field or method ExitCode) 还需要确保你的电脑具有GLFW的依赖：看这里https://github.com/go-flutter-desktop/hover，或者这里https://www.glfw.org/docs/latest/compile.html#compile_deps。 编译第一次将hover应用于项目时，需要初始化桌面项目。hover init需要项目路径，通常是你在GitHub或者托管到git服务上的项目路径。如： 1hover init github.com/iwxyi/QQ-Notification_Reply 这路径不重要以后可以随时更改执行初始化之后将在项目中创建desktop并添加样板文件，如go代码和默认图标。 默认flutter项目是以main.dart作为入口文件，编译桌面应用，你需要新建一个名为main_desktop.dart的文件，并且在runApp(..);之前加上以下代码： 1debugDefaultTargetPlatformOverride = TargetPlatform .fuchsia; 然后执行hover run启动程序即可，项目启动后，在命令行按r可以热重载。 要构建一个独立的应用程序可以使用hover build命令。输出在desktop/build/outputs/Windows目录中。 第一个应用本笔记来源：Flutter中文网 1、Hello Worldlib/main.dart文件 1234567891011121314151617181920import 'package:flutter/material.dart';void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return new MaterialApp( title: 'Welcome to Flutter', home: new Scaffold( // Scaffold提供默认的导航栏、标题和主屏幕widget树 appBar: new AppBar( title: new Text('Welcome to Flutter'), ), body: new Center( child: new Text('Hello World'), ), ), ); }} 2、Packagepubspec.yaml 123456dependencies: flutter: sdk: flutter cupertino_icons: ^0.1.0 english_words: ^3.1.0 点击右上角的 Packages get，会自动下载依赖包 lib/main.dart 1234567891011121314151617181920212223import 'package:flutter/material.dart';import 'package:english_words/english_words.dart';void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { final wordPair = new WordPair.random(); return new MaterialApp( title: 'Welcome to Flutter', home: new Scaffold( appBar: new AppBar( title: new Text('Welcome to Flutter'), ), body: new Center(// child: new Text('Hello World'), child: new Text(wordPair.asPascalCase), ), ), ); }} 3、StateStatefulWidget类本身是不变的，但是 State类在widget生命周期中始终存在 12345678910111213141516171819202122232425262728import 'package:flutter/material.dart';import 'package:english_words/english_words.dart';void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { final wordPair = new WordPair.random(); return new MaterialApp( title: 'Welcome to Flutter', home: new RandomWords(), ); }}class RandomWords extends StatefulWidget { @override createState() =&gt; new RandomWordsState();}class RandomWordsState extends State&lt;RandomWords&gt; { @override Widget build(BuildContext context) { final wordPair = new WordPair.random(); return new Text(wordPair.asPascalCase); }} 4、ListViewListView设置方法：ListView.builder( itemBuilder：(context, i) { } ) 12345678910Widget _buildList() { return new ListView.builder(itemBuilder: (context, i){ // return new Text(\"Text\"); // 简单文字 return new ListTile( // 列表项组 title: new Text(\"text\"), trailing: new Icon(Icons.favorite), onTap: (){}, ); });} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/*...*/class RandomWordsState extends State&lt;RandomWords&gt; { final _suggestions = &lt;WordPair&gt;[]; // 列表项 @override Widget build(BuildContext context) { return new Scaffold( // 设置整体界面 appBar: new AppBar( title: new Text('Flutter'), ), body: _buildSuggestions(), ); } // 在Dart语言中使用下划线前缀标识符，会强制其变成私有的 Widget _buildSuggestions() { // ListView类提供了一个builder属性，itemBuilder 值是一个匿名回调函数， 接受两个参数 // - BuildContext和行迭代器i。迭代器从0开始， 每调用一次该函数，i就会自增1，对于每个 // 建议的单词对都会执行一次。该模型允许建议的单词对列表在用户滚动时无限增长。 return new ListView.builder( padding: const EdgeInsets.all(16.0), // 对于每个建议的单词对都会调用一次itemBuilder，然后将单词对添加到ListTile行中 // 在偶数行，该函数会为单词对添加一个ListTile row. // 在奇数行，该函数会添加一个分割线widget，来分隔相邻的词对。 // 注意，在小屏幕上，分割线看起来可能比较吃力。 itemBuilder: (context, i) { // 在每一列之前，添加一个1像素高的分隔线widget if (i.isOdd) return new Divider(); // 语法 \"i ~/ 2\" 表示i除以2，但返回值是整形（向下取整），比如i为：1, 2, 3, 4, 5 // 时，结果为0, 1, 1, 2, 2， 这可以计算出ListView中减去分隔线后的实际单词对数量 final index = i ~/ 2; // 如果是建议列表中最后一个单词对 if (index &gt;= _suggestions.length) { // 接着再生成10个单词对，然后添加到建议列表 _suggestions.addAll(generateWordPairs().take(10)); } return _buildRow(_suggestions[index]); }, ); } Widget _buildRow(WordPair pair) { return new ListTile( title: new Text( pair.asPascalCase, style: new TextStyle(fontSize: 18.0), ), ); }} 5、onTap1234567891011121314151617181920212223242526272829303132/*...*/class RandomWordsState extends State&lt;RandomWords&gt; { final _suggestions = &lt;WordPair&gt;[]; final _saved = new Set&lt;WordPair&gt;(); // 收藏的单词 /*...*/ // 记录每一项的状态 Widget _buildRow(WordPair pair) { final alreadySaved = _saved.contains(pair); return new ListTile( title: new Text( pair.asPascalCase, style: new TextStyle(fontSize: 18.0), ), trailing: new Icon( alreadySaved ? Icons.favorite : Icons.favorite_border, color: alreadySaved ? Colors.red : null, ), onTap: (){ // 会出现点击水波纹动画效果 setState((){ // 调用setState() 会为State对象触发build()方法，导致UI更新 if (alreadySaved) { _saved.remove(pair); // 移除出收藏夹 } else { _saved.add(pair); // 加入到收藏夹 } }); }, ); }} 6、Router123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class RandomWordsState extends State&lt;RandomWords&gt; { final _suggestions = &lt;WordPair&gt;[]; final _saved = new Set&lt;WordPair&gt;(); final _biggerFont = const TextStyle(fontSize: 18.0); @override Widget build(BuildContext context) { return new Scaffold( appBar: new AppBar( title: new Text('Flutter'), // 为AppBar添加一个列表图标，以及点击事件 actions: &lt;Widget&gt;[ new IconButton(icon: new Icon(Icons.list), onPressed: _pushSaved), ], ), body: _buildSuggestions(), ); } /* ... */ void _pushSaved() { // 添加Navigator.push调用，这会使路由入栈（以后路由入栈均指推入到导航管理器的栈）s Navigator.of(context).push( // 添加MaterialPageRoute及其builder new MaterialPageRoute(builder: (context){ // 生成ListTile行 final tiles = _saved.map((pair) { return new ListTile( title: new Text( pair.asPascalCase, style: _biggerFont, ), ); }); // ListTile的divideTiles()方法在每个ListTile之间添加1像素的分割线 final divided = ListTile .divideTiles( context: context, tiles: tiles ).toList(); // builder返回一个Scaffold return new Scaffold( appBar: new AppBar( title: new Text('Saved Suggestions'), ), body: new ListView(children: divided), ); }), ); }} 7、Theme12345678910111213class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return new MaterialApp( title: 'Welcome to Flutter', // 设置主色调白色（包括应用栏） theme: new ThemeData( primaryColor: Colors.white, ), home: new RandomWords(), ); }} 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128import 'package:flutter/material.dart';import 'package:english_words/english_words.dart';void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return new MaterialApp( title: 'Welcome to Flutter', // 设置主色调白色（包括应用栏） theme: new ThemeData( primaryColor: Colors.white, ), home: new RandomWords(), ); }}class RandomWords extends StatefulWidget { @override createState() =&gt; new RandomWordsState();}class RandomWordsState extends State&lt;RandomWords&gt; { // 在Dart语言中使用下划线前缀标识符，会强制其变成私有的 final _suggestions = &lt;WordPair&gt;[]; // 列表项 final _saved = new Set&lt;WordPair&gt;(); // 收藏的单词 final _biggerFont = const TextStyle(fontSize: 18.0); @override Widget build(BuildContext context) { return new Scaffold( // Scaffold提供默认的导航栏、标题和主屏幕widget树 appBar: new AppBar( title: new Text('Flutter'), // 为AppBar添加一个列表图标 actions: &lt;Widget&gt;[ new IconButton(icon: new Icon(Icons.list), onPressed: _pushSaved), ], ), body: _buildSuggestions(), ); } /// 加载整个列表 Widget _buildSuggestions() { // ListView类提供了一个builder属性，itemBuilder 值是一个匿名回调函数， 接受两个参数 // - BuildContext和行迭代器i。迭代器从0开始， 每调用一次该函数，i就会自增1，对于每个 // 建议的单词对都会执行一次。该模型允许建议的单词对列表在用户滚动时无限增长。 return new ListView.builder( padding: const EdgeInsets.all(16.0), // 对于每个建议的单词对都会调用一次itemBuilder，然后将单词对添加到ListTile行中 // 在偶数行，该函数会为单词对添加一个ListTile row. // 在奇数行，该函数会添加一个分割线widget，来分隔相邻的词对。 // 注意，在小屏幕上，分割线看起来可能比较吃力。 itemBuilder: (context, i) { // 在每一列之前，添加一个1像素高的分隔线widget if (i.isOdd) return new Divider(); // 语法 \"i ~/ 2\" 表示i除以2，但返回值是整形（向下取整），比如i为：1, 2, 3, 4, 5 // 时，结果为0, 1, 1, 2, 2， 这可以计算出ListView中减去分隔线后的实际单词对数量 final index = i ~/ 2; // 如果是建议列表中最后一个单词对 if (index &gt;= _suggestions.length) { // 接着再生成10个单词对，然后添加到建议列表 _suggestions.addAll(generateWordPairs().take(10)); } return _buildRow(_suggestions[index]); }, ); } /// 加载一行 Widget _buildRow(WordPair pair) { final alreadySaved = _saved.contains(pair); // 记录每一项的状态 return new ListTile( title: new Text( pair.asPascalCase, style: _biggerFont, ), trailing: new Icon( alreadySaved ? Icons.favorite : Icons.favorite_border, color: alreadySaved ? Colors.red : null, ), onTap: (){ // 会出现点击水波纹动画效果 setState((){ // 调用setState() 会为State对象触发build()方法，导致UI更新 if (alreadySaved) { _saved.remove(pair); // 移除出收藏夹 } else { _saved.add(pair); // 加入到收藏夹 } }); }, ); } /// 单击事件 void _pushSaved() { // 添加Navigator.push调用，这会使路由入栈（以后路由入栈均指推入到导航管理器的栈）s Navigator.of(context).push( // 添加MaterialPageRoute及其builder new MaterialPageRoute(builder: (context){ // 生成ListTile行 final tiles = _saved.map((pair) { return new ListTile( title: new Text( pair.asPascalCase, style: _biggerFont, ), ); }); // ListTile的divideTiles()方法在每个ListTile之间添加1像素的分割线 final divided = ListTile .divideTiles( context: context, tiles: tiles ).toList(); // builder返回一个Scaffold return new Scaffold( appBar: new AppBar( title: new Text('Saved Suggestions'), ), body: new ListView(children: divided), ); }), ); }} Widget总览Widget目录 基础 Widget Text Row、Column Stack Container：矩形视觉元素 处理手势1234567891011121314151617181920212223class MyButton extends StatelessWidget { @override Widget build(BuildContext context) { // 使用GestureDetector来检测各种输入手势，包括点击、拖动和缩放 return new GestureDetector( // GestureDetector 不具有显示效果 onTap: () { print('MyButton was tapped!'); }, child: new Container( height: 36.0, padding: const EdgeInsets.all(8.0), margin: const EdgeInsets.symmetric(horizontal: 8.0), decoration: new BoxDecoration( borderRadius: new BorderRadius.circular(5.0), color: Colors.lightGreen[500], ), child: new Center( child: new Text('Engage'), ), ), ); }} StatefulWidget每次点击“Increment”按钮，显示的Count+1 1234567891011121314151617181920212223242526class _CounterState extends State&lt;Counter&gt; { int _counter = 0; void _increment() { setState(() { // 告诉Flutter这个State发生改变，并通过build()刷新界面 _counter++; }); } // 多次build()，class中的成员变量保持不变 @override Widget build(BuildContext context) { // 每次setState()被调用(即_increment())，立即运行build() // 任何更新界面的改动都会在这里 return new Row( children: &lt;Widget&gt;[ new RaisedButton( onPressed: _increment, child: new Text('Increment'), ), new Text('Count: $_counter'), ], ); }} Stateless+Stateful123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import 'package:flutter/material.dart';void main() { runApp(new MaterialApp( title: 'Flutter Tutorial', home: new Counter(), ));}// 计数显示class CounterDisplay extends StatelessWidget { CounterDisplay({this.count}); final int count; @override Widget build(BuildContext context) { return new Text('Count: $count'); }}// 计数按钮class CounterIncrementor extends StatelessWidget { CounterIncrementor({this.onPressed}); final VoidCallback onPressed; // 按下按钮的回调 @override Widget build(BuildContext context) { return new RaisedButton( onPressed: onPressed, child: new Text('Increment'), ); }}// 计数组件class Counter extends StatefulWidget { @override _CounterState createState() =&gt; new _CounterState();}// 计数Stateclass _CounterState extends State&lt;Counter&gt; { int _counter = 0; void _increment() { setState(() { ++_counter; }); } @override Widget build(BuildContext context) { return new Row(children: &lt;Widget&gt;[ new CounterIncrementor(onPressed: _increment), new CounterDisplay(count: _counter), ]); }} 购物车示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546import 'package:flutter/material.dart';class Product { const Product({this.name}); final String name;}typedef void CartChangedCallback(Product product, bool inCart);// 单个Item的控件class ShoppingListItem extends StatelessWidget { ShoppingListItem({Product product, this.inCart, this.onCartChanged}) : product = product, super(key: new ObjectKey(product)); // 属性值作为构造函数参数传入 final Product product; final bool inCart; final CartChangedCallback onCartChanged; Color _getColor(BuildContext context) { return inCart ? Colors.black54 : Theme.of(context).primaryColor; } TextStyle _getTextStyle(BuildContext context) { if (!inCart) return null; return new TextStyle( color: Colors.black54, decoration: TextDecoration.lineThrough, ); } @override Widget build(BuildContext context) { return new ListTile( onTap: () { onCartChanged(product, !inCart); }, leading: new CircleAvatar( // 圆角图像框 backgroundColor: _getColor(context), child: new Text(product.name[0]), // 名字首字母作为头像 ), title: new Text(product.name, style: _getTextStyle(context)), ); }} 该ShoppingListItem widget是无状态的。它将其在构造函数中接收到的值存储在final成员变量中，然后在build函数中使用它们。 例如，inCart布尔值表示在两种视觉展示效果之间切换：一个使用当前主题的主色，另一个使用灰色。 当用户点击列表项时，widget不会直接修改其inCart的值。相反，widget会调用其父widget给它的onCartChanged回调函数。 此模式可让您在widget层次结构中存储更高的状态，从而使状态持续更长的时间。在极端情况下，存储传给runApp应用程序的widget的状态将在的整个生命周期中持续存在。 当父项收到onCartChanged回调时，父项将更新其内部状态，这将触发父项使用新inCart值重建ShoppingListItem新实例。 虽然父项ShoppingListItem在重建时创建了一个新实例，但该操作开销很小，因为Flutter框架会将新构建的widget与先前构建的widget进行比较，并仅将差异部分应用于底层RenderObject。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class ShoppingList extends StatefulWidget { ShoppingList({Key key, this.products}) : super(key: key); final List&lt;Product&gt; products; // 先作为构造函数参数传入，之后传递到 State 中 @override _ShoppingListState createState() =&gt; new _ShoppingListState();}class _ShoppingListState extends State&lt;ShoppingList&gt; { Set&lt;Product&gt; _shoppingCart = new Set&lt;Product&gt;(); // 延长Item值生命周期 // Item 单击事件，作为参数传入 item 的 Widget 中 void _handleCartChanged(Product product, bool inCart) { setState(() { // 通知更新界面，即重新调用 build() if (inCart) _shoppingCart.add(product); else _shoppingCart.remove(product); }); } @override Widget build(BuildContext context) { return new Scaffold( appBar: new AppBar( title: new Text('Shopping List'), ), body: new ListView( padding: new EdgeInsets.symmetric(vertical: 8.0), // 获取并遍历ShoppingList.products，从 Widget 中传递到 State // ☆返回单行控件，List&lt;Product&gt; =&gt; Map&lt;Widget&gt; =&gt; List&lt;Widget&gt; children: widget.products.map((Product product) { return new ShoppingListItem( product: product, inCart: _shoppingCart.contains(product), onCartChanged: _handleCartChanged, ); }).toList(), ), ); }}void main() { runApp(new MaterialApp( title: 'Shopping App', home: new ShoppingList( products: &lt;Product&gt;[ // 直接拟造数据list new Product(name: 'Eggs'), new Product(name: 'Flour'), new Product(name: 'Chocolate chips'), ], ), ));} 当这个widget的父级重建时，父级将创建一个新的ShoppingList实例，但是Flutter框架将重用已经在树中的_ShoppingListState实例，而不是再次调用createState创建一个新的。 要访问当前ShoppingList的属性，_ShoppingListState可以使用它的widget属性。 如果父级重建并创建一个新的ShoppingList，那么 _ShoppingListState也将用新的widget值重建。如果希望在widget属性更改时收到通知，则可以覆盖didUpdateWidget函数，以便将旧的oldWidget与当前widget进行比较。 生命周期事件在StatefulWidget调用createState之后，框架将新的状态对象插入树中，然后调用状态对象的initState。 子类化State可以重写initState，以完成仅需要执行一次的工作。 Key使用key来控制框架将在widget重建时与哪些其他widget匹配。要求两个widget具有相同的key和runtimeType。 如果没有key，当前构建中的第一个条目将始终与前一个构建中的第一个条目同步 通过给列表中的每个条目分配为“语义” key，无限列表可以更高效，因为框架将同步条目与匹配的语义key并因此具有相似（或相同）的可视外观。此外，语义上同步条目意味着在有状态子widget中，保留的状态将附加到相同的语义条目上，而不是附加到相同数字位置上的条目。 全局 Key使用全局key来唯一标识子widget。全局key在整个widget层次结构中必须是全局唯一的，这与局部key不同，后者只需要在同级中唯一。由于它们是全局唯一的，因此可以使用全局key来检索与widget关联的状态。 零散控件笔记NestedScrollView详细说明：NestedScrollView类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657final _tabs = ['Tab1', 'Tab2', 'Tab3'];DefaultTabController( length: _tabs.length, child: NestedScrollView( // 滚动嵌套 headerSliverBuilder: (BuildContext context, bool innerBoxIsScrolled) { return &lt;Widget&gt;[ SliverOverlapAbsorber( // 水平重叠控件 handle: NestedScrollView.sliverOverlapAbsorberHandleFor(context), child: SliverAppBar( // 可收起的标题栏 title: const Text('Books'), // 标题栏文字 pinned: true, // 是否阻止标题栏向上收起 expandedHeight: 150.0, // 可收起的距离 forceElevated: innerBoxIsScrolled, bottom: TabBar( // 添加水平Tab标签 tabs: _tabs.map((String name) =&gt; Tab(text: name)).toList(), ), ), ), ]; }, body: TabBarView( // 可水平滑动的大页面 children: _tabs.map((String name) { // 添加每个Tab子页面 return SafeArea( top: false, bottom: false, child: Builder( builder: (BuildContext context) { return CustomScrollView( // 竖向列表框 key: PageStorageKey&lt;String&gt;(name), slivers: &lt;Widget&gt;[ SliverOverlapInjector( // 支持多个重叠手势？ handle: NestedScrollView.sliverOverlapAbsorberHandleFor(context), ), SliverPadding( padding: const EdgeInsets.all(8.0), sliver: SliverFixedExtentList( // 添加竖向列表框items itemExtent: 48.0, delegate: SliverChildBuilderDelegate( (BuildContext context, int index) { return ListTile( title: Text('Item $index'), ); }, childCount: 30, ), ), ), ], ); }, ), ); }).toList(), ), ),) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.iwxyi.com/tags/学习笔记/"},{"name":"Flutter","slug":"Flutter","permalink":"http://blog.iwxyi.com/tags/Flutter/"}]},{"title":"CSS、JS瀑布流","date":"2020-02-24T05:08:00.000Z","path":"2020/02/24/CSS、JS瀑布流/","text":"纯CSS方式multi-columns 方式通过 Multi-columns 相关的属性 column-count、column-gap配合 break-inside来实现瀑布流布局。 设置这样的 html 结构： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;div class=\"masonry\"&gt; &lt;div class=\"item\"&gt; &lt;div class=\"item_content content-lar\"&gt; 1 &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"item_content content-sma\"&gt; 2 &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"item_content content-mid\"&gt; 3 &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"item_content content-sma\"&gt; 4 &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"item_content content-mid\"&gt; 5 &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"item_content content-lar\"&gt; 6 &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"item_content content-sma\"&gt; 7 &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"item_content content-lar\"&gt; 8 &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"item_content content-lar\"&gt; 9 &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"item_content content-sma\"&gt; 10 &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"item_content content-mid\"&gt; 11 &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"item_content content-mid\"&gt; 12 &lt;/div&gt; &lt;/div&gt; &lt;!-- more items --&gt; &lt;/div&gt; .masonry 是瀑布流容器，里面放置了列表 item，在 .masonry中设置 column-count（列数）和 column-gap（列间距） item 中设置 break-inside:avoid，这是为了控制文本块分解成单独的列，以免项目列表的内容跨列，破坏整体的布局。 在 css 中设置包裹 masonry 和 item 的属性样式： 123456789101112131415161718.masonry { -moz-column-count:3; /* Firefox */ -webkit-column-count:3; /* Safari 和 Chrome */ column-count:3; -moz-column-gap: 2em; -webkit-column-gap: 2em; column-gap: 2em; width: 80%; margin:2em auto;}.item { padding: 2em; margin-bottom: 2em; -moz-page-break-inside: avoid; -webkit-column-break-inside: avoid; break-inside: avoid; background: #f60;} 当然为了布局具有响应式效果，可以借助媒体查询属性，在不同屏幕大小的条件下设置瀑布流容器 masonry 的 column-count 来自适应改变列数： 12345678910@media screen and (max-width: 800px) { .masonry { column-count: 2; // two columns on larger phones } } @media screen and (max-width: 500px) { .masonry { column-count: 1; // two columns on larger phones } } 也是根据屏幕大小自适应改变列数 flexbox 方式html 的结构依旧和上面的 Multi-columns 展示的一样。只是在 .masonry容器中使用的 CSS 不一样： 在 .masonry中是通过采用 flex-flow来控制列，并且允许它换行。 这里关键是容器的高度，我这里要显式的设置 height属性，当然除了设置 px值，还可以设置100vh，让 .masonry容器的高度和浏览器视窗高度一样。 记住，这里height可以设置成任何高度值（采用任何的单位），但不能不显式的设置，如果没有显式的设置，容器就无法包裹住项目列表。 1234567.masonry { height: 800px; display: flex; flex-flow: column wrap; width: 80%; margin:2em auto;} 对于 .item，可以不再使用 break-inside:avoid，但其它属性可以是一样。 同样的，响应式设置，使用 Flexbox 实现响应式布局比多列布局 Multi-columns 要来得容易，他天生就具备这方面的能力，只不过我们这里需要对容器的高度做相关的处理。 前面也提到过了，如果不给 .masonry容器显式设置高度是无法包裹项目列表的，那么这里响应式设计中就需要在不同的媒体查询条件下设置不同的高度值： 1234567891011121314151617181920@media screen and (max-width: 1100px) { .masonry { height: 800px; } }@media screen and (max-width: 800px) { .masonry { height: 1100px; } } @media screen and (max-width: 600px) { .masonry { height: 1300px; } } @media screen and (max-width: 460px) { .masonry { height: 1600px; } } 那么所产生的效果是： 也是根据屏幕大小自适应改变列数。 看到这里，我们可以发现，使用纯 css 写瀑布流，每一块 item 都是从上往下排列，不能做到从左往右排列： img 这样子若是动态加载图片的瀑布流，体验就会很不好 我们想要的是这样： img 这样做只能通过 js 来写瀑布流 JS方式 html 结构与上面类似，这里我用图片来做示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;div class=\"masonry\"&gt; &lt;div class=\"item\"&gt; &lt;img class=\"lazy\" src=\"images/1.jpg\" alt=\"\" /&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;img class=\"lazy\" src=\"images/2.jpg\" alt=\"\" /&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;img class=\"lazy\" src=\"images/3.jpg\" alt=\"\" /&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;img class=\"lazy\" src=\"images/4.jpg\" alt=\"\" /&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;img class=\"lazy\" src=\"images/5.jpg\" alt=\"\" /&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;img class=\"lazy\" src=\"images/6.jpg\" alt=\"\" /&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;img class=\"lazy\" src=\"images/7.jpg\" alt=\"\" /&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;img class=\"lazy\" src=\"images/8.jpg\" alt=\"\" /&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;img class=\"lazy\" src=\"images/9.jpg\" alt=\"\" /&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;img class=\"lazy\" src=\"images/10.jpg\" alt=\"\" /&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;img class=\"lazy\" src=\"images/11.jpg\" alt=\"\" /&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;img class=\"lazy\" src=\"images/12.jpg\" alt=\"\" /&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;img class=\"lazy\" src=\"images/13.jpg\" alt=\"\" /&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;img class=\"lazy\" src=\"images/14.jpg\" alt=\"\" /&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;img class=\"lazy\" src=\"images/15.jpg\" alt=\"\" /&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;img class=\"lazy\" src=\"images/16.jpg\" alt=\"\" /&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;img class=\"lazy\" src=\"images/17.jpg\" alt=\"\" /&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;img class=\"lazy\" src=\"images/18.jpg\" alt=\"\" /&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;img class=\"lazy\" src=\"images/19.jpg\" alt=\"\" /&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;img class=\"lazy\" src=\"images/20.jpg\" alt=\"\" /&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;img class=\"lazy\" src=\"images/21.jpg\" alt=\"\" /&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;img class=\"lazy\" src=\"images/22.jpg\" alt=\"\" /&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;img class=\"lazy\" src=\"images/23.jpg\" alt=\"\" /&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;img class=\"lazy\" src=\"images/24.jpg\" alt=\"\" /&gt; &lt;/div&gt;&lt;/div&gt; css 内容： 123456789101112131415161718192021222324252627.masonry { width: 100%; margin-top: 50px; position:relative;}.item { z-index: 10; transition: 0.25s; overflow: hidden; position: absolute;}.item img{ width: 100%; height:100%; transition: 0.25s;}.item:hover img{ z-index: 100; transition: 0.25s; overflow: hidden; animation: bounceIn 0.25s ease-in 2 alternate;}@keyframes bounceIn{ 100% { transform: scale(1.07); }} js 瀑布流实现方式： css 的绝对定位方式：根据每张图片的位置设置 top 和 left 值： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//瀑布流效果//这里有一个坑（已经修复）：//因为是动态加载远程图片，在未加载完全无法获取图片宽高//未加载完全就无法设定每一个item(包裹图片)的top。//item的top值：第一行：top为0// 其他行：必须算出图片宽度在item宽度的缩小比例，与获取的图片高度相乘，从而获得item的高度// 就可以设置每张图片在瀑布流中每块item的top值（每一行中最小的item高度，数组查找）//item的left值：第一行：按照每块item的宽度值*块数// 其他行：与自身上面一块的left值相等function waterFall() { // 1- 确定图片的宽度 - 滚动条宽度 var pageWidth = getClient().width-8; var columns = 3; //3列 var itemWidth = parseInt(pageWidth/columns); //得到item的宽度 $(\".item\").width(itemWidth); //设置到item的宽度 var arr = []; $(\".masonry .item\").each(function(i){ var height = $(this).find(\"img\").height(); var width = $(this).find(\"img\").width(); var bi = itemWidth/width; //获取缩小的比值 var boxheight = parseInt(height*bi); //图片的高度*比值 = item的高度 if (i &lt; columns) { // 2- 确定第一行 $(this).css({ top:0, left:(itemWidth) * i }); arr.push(boxheight); } else { // 其他行 // 3- 找到数组中最小高度 和 它的索引 var minHeight = arr[0]; var index = 0; for (var j = 0; j &lt; arr.length; j++) { if (minHeight &gt; arr[j]) { minHeight = arr[j]; index = j; } } // 4- 设置下一行的第一个盒子位置 // top值就是最小列的高度 $(this).css({ top:arr[index], left:$(\".masonry .item\").eq(index).css(\"left\") }); // 5- 修改最小列的高度 // 最小列的高度 = 当前自己的高度 + 拼接过来的高度 arr[index] = arr[index] + boxheight; } });}//clientWidth 处理兼容性function getClient() { return { width: window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth, height: window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight }}// 页面尺寸改变时实时触发window.onresize = function() { //重新定义瀑布流 waterFall();};//初始化window.onload = function(){ //实现瀑布流 waterFall();} 效果图是： 这实现了横向排列的瀑布流效果 来源博客： https://www.cnblogs.com/ainyi/p/8766281.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"JS","slug":"JS","permalink":"http://blog.iwxyi.com/tags/JS/"},{"name":"CSS","slug":"CSS","permalink":"http://blog.iwxyi.com/tags/CSS/"}]},{"title":"Git按条件统计代码行数","date":"2020-02-23T06:18:00.000Z","path":"2020/02/23/Git按条件统计代码行数/","text":"GitHub统计某人在某段时间内提交的代码行数 1git log --author=\"mrxy001\" --author=\"MRXY001\" --since=\"2018-01-01\" --until=\"2020-01-01\" --pretty=tformat: --numstat -- . \":(exclude)debug\" \":(exclude)release\" \":(exclude)android\" \":(exclude)friso\" \":(exclude)jieba\" \":(exclude)tools\" \":(exclude)update_tools\" \":(exclude)resources\" | awk '{ add += $1; subs += $2; loc += $1 - $2 } END { printf \"added lines: %s, removed lines: %s, total lines: %s\\n\", add, subs, loc }' document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Git","slug":"Git","permalink":"http://blog.iwxyi.com/tags/Git/"}]},{"title":"PIP换源","date":"2020-02-16T05:58:00.000Z","path":"2020/02/16/PIP换源/","text":"pip国内的一些镜像 阿里云 http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 豆瓣(douban) http://pypi.douban.com/simple/ 清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/ 中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/ 临时使用可以在使用pip的时候在后面加上-i参数，指定pip源eg: pip install scrapy -i https://pypi.tuna.tsinghua.edu.cn/simple 永久修改linux:修改 ~/.pip/pip.conf (没有就创建一个)， 内容如下： 1234[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host=mirrors.aliyun.com windows:win+R 打开用户目录%HOMEPATH%，在此目录下创建 pip 文件夹，在 pip 目录下创建 pip.ini 文件, 内容如下 1234[global]timeout = 6000index-url = https://pypi.tuna.tsinghua.edu.cn/simpletrusted-host = pypi.tuna.tsinghua.edu.cn 参考来源：https://blog.csdn.net/yuzaipiaofei/article/details/80891108 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"整理","slug":"整理","permalink":"http://blog.iwxyi.com/tags/整理/"},{"name":"Python","slug":"Python","permalink":"http://blog.iwxyi.com/tags/Python/"}]},{"title":"前序、中序还原二叉树","date":"2020-01-21T09:46:00.000Z","path":"2020/01/21/前序、中序还原二叉树/","text":"已知二叉树的前序遍历、中序遍历，输出其后序遍历。 例如： 前序：DBEACF 中序：ABDEFC 123 A B CD E F 思路： 前序的第一个字符，是树根root，也是中序的中间字符，分割左右子树的中序； 中序左右子树长度，得到前序左右子树； 递归左/右的前序+中序 原来： 前序 DBE|==A==|CF、中序 ==A==|BDE|FC A 左： 前序 ==D==|B|E、中序 B|==D==|E A 右： 前序 ==C==|F、中序 F|==C== 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;struct Node{ Node *left = NULL, *right = NULL; char data = '?'; void LRD_Print() // 后序遍历递归 { if (left) left-&gt;LRD_Print(); if (right) right-&gt;LRD_Print(); cout &lt;&lt; data; }};Node *parse(string pre, string mid){ if (!pre.length()) return NULL; // 叶子结点 Node *node = new Node(); node-&gt;data = pre.substr(0, 1).c_str()[0]; // 前序遍历第一个字符串就是root int root_pos = mid.find(node-&gt;data); // 中序的root位置，也是左子树长度 node-&gt;left = parse(pre.substr(1, root_pos), mid.substr(0, root_pos)); node-&gt;right = parse(pre.substr(root_pos + 1), mid.substr(root_pos + 1)); return node;}int main(){ string pre = \"ABDECF\"; // 前序遍历 string mid = \"DBEAFC\"; // 中序遍历 Node *node = parse(pre, mid); if (node != NULL) node-&gt;LRD_Print();} 运行结果： 1DEBFCA document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://blog.iwxyi.com/tags/数据结构/"}]},{"title":"C++使用Lambda作为函数参数","date":"2020-01-14T07:40:00.000Z","path":"2020/01/14/C-使用Lambda作为函数参数/","text":"模板参数1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;string&gt; template &lt;typename F&gt;void print(F const &amp;f){ std::cout&lt;&lt;f()&lt;&lt;std::endl;} int main() { std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl; int num = 101; auto a = [&amp;]//以引用的方式捕获本函数中的变量 () //无参数 -&gt;std::string {//返回值的类型为std::string return std::to_string(num); }; print(a); num++; print(a); return 0;} std::function 编译器需要支持c++11标准，有的编译器可能需要添加参数-std=c++11 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;string&gt; void print(std::function&lt;std::string ()&gt; const &amp;f){ std::cout&lt;&lt;f()&lt;&lt;std::endl;} int main() { std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl; int num = 101; auto a = [&amp;]//以引用的方式捕获本函数中的变量 () //无参数 -&gt;std::string {//返回值的类型为std::string return std::to_string(num); }; print(a); num++; print(a); return 0;} std::function是个模板类；模板参数：返回值类型+函数参数类型列表；例如std::function&lt;int (int, int)&gt; f，f可以指向任意一个返回指为int，参数为两个int类型的函数。 观察上面的程序，lambda表达式无参数，返回值类型为string；故在print函数中声明一个类型为function&lt;std::string ()&gt;类型的变量f，就可以用来接收a。注意：f前面必须加上const，否则编译过不了。至于加不加&amp;，需要视程序而定，一般加上。 把lambda表达式作为子线程的参数12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;chrono&gt;#include &lt;vector&gt;#include &lt;atomic&gt; int main() { std::atomic_uint num(0);//atomic_uint时原子操作类，在不同的线程中访问时，是线程安全的。 // 无参数lambda表达式 auto a = [&amp;]() -&gt; void { std::this_thread::sleep_for(std::chrono::milliseconds(num*20));//休眠i*2ms num += 100; }; // 新建子线程 std::thread t(a); t.join(); int value = num; printf(\"%d\\n\",value); // 有参数lambda表达式 auto b = [&amp;](int i) -&gt; void { std::this_thread::sleep_for(std::chrono::milliseconds(i));//休眠i*2ms num += i; }; // 新建子线程 std::thread tt(b,1000); tt.join(); value = num; printf(\"%d\\n\",value); return 0;} 陷阱： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;chrono&gt;#include &lt;vector&gt; int main() { std::vector&lt;std::thread&gt; _threads; // 新建20个线程，每个线程打印i for(int i=0;i&lt;20;i++){ //定义一个lambda表达式a auto a = [=]() -&gt; std::string { std::this_thread::sleep_for(std::chrono::milliseconds(i*20));//休眠i*2ms return std::to_string(i); }; // 再定义一个wrapper包裹a auto wrapper = [&amp;]() { // &lt;&lt;== 注意这个地方 //这里有其他操作 std::string str = a(); //这里有其他操作 std::cout&lt;&lt;str&lt;&lt;\"\\t\"; }; // 新建子线程，并把线程放到vector里面 _threads.emplace_back(std::thread(wrapper)); } //对所有线程调用join函数，避免主线程先于子线程退出。 for(auto&amp; t : _threads) { if(t.joinable()){ t.join(); } } std::cout&lt;&lt;std::endl; return 0;} 观察上面的代码，理论上应该输出0～19。运行上面的程序，实际输出为 12319 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 Process finished with exit code 0 并不是预想的输出。直接调用wrapper()，可以得到正确的输出，但是把wrapper作为线程参数参数传进去时，结果却不正确。经过一番尝试，把定义wrapper的代码更改为如下代码 123456auto wrapper = [=]() { //把 &amp; 改为 =，把捕获变量的引用改为捕获变量的副本 //这里有其他操作 std::string str = a(); //这里有其他操作 std::cout&lt;&lt;str&lt;&lt;\"\\t\";}; 再运行上面的程序，得到的结果为 1230 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Process finished with exit code 0 初步的原因分析为，定义wrapper时，以引用的方式捕获a。然而在for循环中，虽然在更新a的定义，但是a的存储地址是固定的，故以引用的方式捕获a时，所有wapper里面的a都是最后一次更新的a。在子线程中调用wrapper时，自然都调用到在for循环中最后一次更新的a。定义wrapper时，以值的方式捕获a时，wrapper中保存的是a的副本，即使for循环中在更新a，也不影响之前定义的wapper。所以，在wrapper中，一定要以值的方式捕获用到的变量。 参考来源： https://blog.csdn.net/DumpDoctorWang/article/details/81903140 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++11","slug":"C-11","permalink":"http://blog.iwxyi.com/tags/C-11/"}]},{"title":"C++自定义字面量","date":"2020-01-14T07:39:00.000Z","path":"2020/01/14/C-自定义字面量/","text":"C++11新标准中引入了用户自定义字面量，也叫自定义后缀操作符，即通过实现一个后缀操作符，将申明了该后缀标识的字面量转化为需要的类型 123456789101112long double operator\"\" _mm(long double x) { return x / 1000; }long double operator\"\" _m(long double x) { return x; }long double operator\"\" _km(long double x) { return x * 1000; }int main(){ cout &lt;&lt; 1.0_mm &lt;&lt; endl; // 0.001 cout &lt;&lt; 1.0_m &lt;&lt; endl; // 1 cout &lt;&lt; 1.0_km &lt;&lt; endl; // 1000 return 0;} 需要注意的是后缀操作符函数根据C++ 11 标准，只有下面参数列表才是合法的： 1234567char const *unsigned long longlong doublechar const *, size_twchar_t const *, size_tchar16_t const *, size_tchar32_t const *, size_t 最后四个对于字符串相当有用，因为第二个参数会自动推断为字符串的长度 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"}]},{"title":"C++隐式转换重载","date":"2020-01-14T07:39:00.000Z","path":"2020/01/14/C-隐式转换重载/","text":"1、操作符重载C++可以通过operator实现重载操作符，格式如下：类型T operator 操作符 ()，比如重载+，比如下面这个例子 12345678910template&lt;typename T&gt; class A{ public: const T operator+(const T&amp; a) { return this-&gt;_m + a; } private: T _m;}; 又比如STL中的函数对象，重载()，比如下面这个例子 1234template&lt;typename T&gt; struct A{ T operator()(const T&amp; a, const T&amp; b){ return a-b; }}; 2、 操作隐式转换C++可以通过operator实现重载隐式转换，格式如下： operator T ()，其中T是一个类型，比如下面这个例子 1234567891011class A{ public: operator B*() { return this-&gt;_b*; } operator const B*() { return this-&gt;_b; } operator B&amp;() { return *this-&gt;_b; } private: B* _b;};A a; 当if(a)，编译时，它转换成if(a.operator B*())，其实也就是相当于 if(a._b) 编译器调用函数顺序（1）寻找和使用最符合函数名和参数类型（包括返回值）的函数，若找到则调用； （2）否则，寻找一个函数模板，将其实例化产生一个匹配的重载函数，若找到则调用； （3）否则，寻找可以通过类型转换进行参数匹配的重载函数，若找到则调用它。 如果以上步骤均未找到匹配函数，则这个调用是错误的；如果这个调用有多于一个的匹配选译，则调用匹配出现二义性，也是错误的。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"}]},{"title":"多线程高效单例模式","date":"2020-01-12T06:47:00.000Z","path":"2020/01/12/多线程高效单例模式/","text":"12345678910111213141516171819// 双检锁方式public class Singleton { private static Singleton instance = null; private Singleton() { } public static Singleton getInstance() { if (instance == null) { // 优化 synchronized 同步化方法效率 synchronized (Singleton.class) { // 保证下面线程安全 if (instance == null) { instance = new Singleton(); // 多线程可实例化多次 } } } return instance; }} 1234567891011121314// 静态内部类方式：public class Singleton { private static class SingletonHolder { public static Singleton instance = new Singleton(); } private Singleton() { } public static Singleton getInstance() { return SingletonHolder.instance; }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"多线程","slug":"多线程","permalink":"http://blog.iwxyi.com/tags/多线程/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.iwxyi.com/tags/设计模式/"}]},{"title":"Flutter模板参考","date":"2020-01-07T05:23:00.000Z","path":"2020/01/07/Flutter模板参考/","text":"Flutter最基础的空程序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import 'package:flutter/material.dart';void main() =&gt; runApp(MyApp());class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, ), home: MyHomePage(title: 'Flutter Demo Home Page'), ); }}class MyHomePage extends StatefulWidget { MyHomePage({Key key, this.title}) : super(key: key); final String title; @override _MyHomePageState createState() =&gt; _MyHomePageState();}class _MyHomePageState extends State&lt;MyHomePage&gt; { int _counter = 0; void _incrementCounter() { setState(() { _counter++; }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text( 'You have pushed the button this many times:', ), Text( '$_counter', style: Theme.of(context).textTheme.headline4, ), ], ), ), floatingActionButton: FloatingActionButton( onPressed: _incrementCounter, tooltip: 'Increment', child: Icon(Icons.add), ), ); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"模板","slug":"模板","permalink":"http://blog.iwxyi.com/tags/模板/"},{"name":"Flutter","slug":"Flutter","permalink":"http://blog.iwxyi.com/tags/Flutter/"}]},{"title":"Composer用法","date":"2019-12-24T08:28:00.000Z","path":"2019/12/24/Composer用法/","text":"这里用的是小皮面板（PHPStudy），先添加网站。 找到nginx/conf/vhost/网站.conf，server中原先的location全删了，改为下面： 1234567server { listen 80; server_name cloud.iwxyi.com; location / { proxy_pass http://iwxyi.com:5212; }} 其余配置如root等都不需要了。 访问cloud.iwxyi.com，都会变成http://iwxyi.com:5212 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.iwxyi.com/tags/PHP/"},{"name":"Composer","slug":"Composer","permalink":"http://blog.iwxyi.com/tags/Composer/"}]},{"title":"Qt一些有用的小功能","date":"2019-12-17T08:39:00.000Z","path":"2019/12/17/Qt一些有用的小功能/","text":"Q_GADGET：不需要从QObject继承就可以使用Qt的Meta Object功能 Q_ENUMS：对枚举对象进行反射（reflection） Q_SIGNAL：不需要signals关键字就可以将一个函数指定为singal函数 Q_SLOT：不需要slots关键字就可以将一个函数指定为slot函数 Q_FOREACH：Qt提供的关键字foreach在配置文件里面定义了no_keywords的时候就失效了，而Q_FOREACH宏无论何时都有效 Q_FOREVER：原因同Q_FOREACH，用法和关键字forever一样 qChecksum：计算基于CRC-16-CCITT算法的CRC-16校验码 qCompress/qUncompress：基于zlib的算法对字节缓存区进行压缩/解压，可以自定义压缩比 qDeleteAll：对容器或者迭代器中的每个对象进行delete操作 qRound/qRound64：对浮点数取整，四舍五入 qFuzzyCompare：线程安全的浮点数模糊比较，处理了浮点精度误差的问题 qVersion：获取当前正在运行的Qt的版本号 sender：在slot函数中调用可以获取发送该signal的对象。仅用于来自同一线程的Qt::DirectConnection连接的 signal。由于这种做法破坏了面向对象的原则，慎用！ QSysInfo：获取当前运行的系统信息，包括版本号等，Mac/Symbian/Windows均适用 QtEndian：处理不同体系架构下字节存储次序不同的问题 QObject::findChildren&lt;&gt;：找出隐藏的子对象 qobject_cast：不需要编译器RTTI的支持就可以实现C++标准库dynamic_cast的功能 QObject::deleteLater：在事件处理循环中调用，则在事件处理循环结束时删除自己；在事件处理循环外调用，则在下一个事件处理循环开始时删除自己 qPrintable：类似QString::toLocal8Bit()::constData()，但是更好记 qDebug()：类似Windows下的TRACE或者OutputDebugString connect(SomeObj, SIGNAL(foo()), SIGNAL(bar())：通过一个signal自动触发另一个signal 原文：Qt的一些鲜为人知但是非常有用的小功能 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"C++四种cast","date":"2019-12-17T08:01:00.000Z","path":"2019/12/17/C-中四种cast/","text":"static_cast 静态转换 主要用于内置数据类型之间的相互转换 用于自定义类时，静态转换会判断转换类型之间的关系，如果转换类型之间没有任何关系，则编译器会报错，不可转换 把void类型指针转为目标类型指针（不安全） const_cast 常量指针 被强转为 非常量指针，且仍然指向原来的对象 常量引用 被强转为 非常量引用，且仍然指向原来的对象 常量对象 被强转为 非常量对象 dynamic_cast dynamic_cast是运行时处理的，运行时要进行类型检查，而其他三种都是编译时完成的 不能用于内置基本数据类型间的强制转换 使用dynamic_cast进行转换时，基类中一定要有虚函数，否则编译不通过 dynamic_cast转换若成功，返回的是指向类的指针或引用；若失败则会返回NULL 在类的转换时，在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的。在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。向下转换的成败取决于将要转换的类型，即要强制转换的指针所指向的对象实际类型与将要转换后的类型一定要相同，否则转换失败。 reinterpret_cast用来处理无关类型之间的转换；它会产生一个新的值，这个值会有与原始参数（expression）有完全相同的比特位 从指针类型到一个足够大的整数类型 从整数类型或者枚举类型到指针类型 从一个指向函数的指针到另一个不同类型的指向函数的指针 从一个指向对象的指针到另一个不同类型的指向对象的指针 从一个指向类函数成员的指针到另一个指向不同类型的函数成员的指针 从一个指向类数据成员的指针到另一个指向不同类型的数据成员的指针 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"}]},{"title":"TCP/IP三次握手为什么不能两次","date":"2019-12-05T06:10:00.000Z","path":"2019/12/05/TCP-IP三次握手为什么不能两次/","text":"为什么需要三次握手，两次不行吗？ 弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。 第一次握手：客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。 第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。 第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。 因此，需要三次握手才能确认双方的接收与发送能力是否正常。 试想如果是用两次握手，则会出现下面这种情况： 如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。 后来收到了确认，建立了连接。数据传输完毕后，就释放了连接、 客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端； 此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了； 此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://blog.iwxyi.com/tags/计算机网络/"}]},{"title":"正则表达式之平衡组（堆栈）","date":"2019-11-12T06:00:00.000Z","path":"2019/11/12/正则表达式平衡组（堆栈）/","text":"在做LazyKey的时候，遇见了一个场景，光标在括号右边，需要获取改括号前面的函数名。虽然用堆栈写个语法分析器很方便，但是我就想着用正则表达式是不是更简单？ 坑啊， JS 不支持平衡组…… 平衡组介绍如果想要匹配可嵌套的层次性结构的话，就得使用平衡组了。举个例子吧，如何把xx &lt;aa &lt;bbb&gt; &lt;bbb&gt; aa&gt; yy这样的字符串里，最长的尖括号内的内容捕获出来？ 这里需要用到以下的语法构造： (?&lt;group&gt;) 把捕获的内容命名为group,并压入堆栈 (?&lt;-group&gt;) 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败 (?(group)yes|no) 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分 (?!) 顺序否定环视，由于没有后缀表达式，试图匹配总是失败 每碰到一个左括号，就添加一个 group，每碰到一个右括号，就去掉一个，到了最后看还有没有 group，如果有则证明左括号比右括号多，那么 匹配就失败了。 1234567891011121314&lt; #最外层的左括号 [^&lt;&gt;]* #最外层的左括号后面的不是括号的内容 ( ( (?'Open'&lt;) #碰到了左括号，添加一个\"Open\" [^&lt;&gt;]* #匹配左括号后面的不是括号的内容 )+ ( (?'-Open'&gt;) #碰到了右括号，去掉一个\"Open\" [^&lt;&gt;]* #匹配右括号后面不是括号的内容 )+ )* (?(Open)(?!)) #在遇到最外层的右括号前面，判断还有没有没去掉的\"Open\"；如果有，则匹配失败&gt; #最外层的右括号 平衡组的概念平衡组，故名思义，平衡即对称，主要是结合几种正则语法规则，提供对配对出现的嵌套结构的匹配。平衡组有狭义与广义两种定义，狭义平衡组指(?Expression) 语法，而广义平衡组并不是固定的语法规则，而是几种语法规则的综合运用，我们平时所说的平衡组通常指的是广义平衡组。本文中如无特殊说明，平衡组这种简写指的是广义平衡组。 平衡组的匹配原理平衡组的匹配原理可以用堆栈来解释，先举个例子，再根据例子进行解释。 源字符串：a+(b*(c+d))/e+f-(g/(h-i))*j 正则表达式：((?&lt;Open&gt;\\()|(?&lt;−Open&gt;((?&lt;Open&gt;\\()|(?&lt;−Open&gt;)|[^()])*(?(Open)(?!))\\) 需求说明：匹配成对出现的()中的内容 输出：(b*(c+d)) 和 (g/(h-i)) 我将上面正则表达式代码分行写，并加上注释，这样看起来有层次，而且方便 12345678910\\( #普通字符“(” ( #分组构造，用来限定量词“*”修饰范围 (?&lt;Open&gt;\\() #命名捕获组，遇到开括弧“Open”计数加1 | #分支结构 (?&lt;-Open&gt;\\)) #狭义平衡组，遇到闭括弧“Open”计数减1 | #分支结构 [^()]+ #非括弧的其它任意字符 )* #以上子串出现0次或任意多次 (?(Open)(?!)) #判断是否还有“Open”，有则说明不配对，什么都不匹配\\) #普通闭括弧 对于一个嵌套结构而言，开始和结束标记都是确定的，对于本例开始为“(”，结束为“)”，那么接下来就是考察中间的结构，中间的字符可以划分为三类，一类是“(”，一类是“)”，其余的就是除这两个字符以外的任意字符。 平衡组的匹配原理1、先找到第一个(，作为匹配的开始。即上面的第1行，匹配了：a+==(==b*(c+d))/e+f-(g/(h-i))*j 2、在第1步以后，每匹配到一个(，就入栈一个Open捕获组，计数加 1 3、在第1步以后，每匹配到一个)，就出栈最近入栈的Open捕获组，计数减 1 也就是讲，上面的第一行正则\\(匹配了：a+==(==b*(c+d))/e+f-(g/(h-i))*j 然后，匹配到c前面的(，此时，计数加1；继续匹配，匹配到d后面的)，计数减1；——注意喽：此时堆栈中的计数是0，正则还是会向前继续匹配的，但是，如果匹配到)的话，比如，这个例子中 d)==)== ——引擎此时将控制权交给(?(Open)(?!))，判断堆栈中是否为0，如果为0，则执行匹配“no”分支，由于这个条件判断结构中没有“no”分支，所以什么都不做，把控制权交给接下来的\\) 这个正则表达式\\)可匹配接下来的)，即 b)==)== 4、后面的 (?(Open)(?!))用来保证堆栈中Open捕获组计数是否为0，也就是(和)是配对出现的 5、最后的)，作为匹配的结束 匹配过程首先匹配第一个(，然后一直匹配，直到出现以下两种情况之一时，把控制权交给(?(Open)(?!))： a)堆栈中Open计数已为0，此时再遇到) b)匹配到字符串结束符 这时控制权交给(?(Open)(?!))，判断Open是否有匹配，由于此时计数为0，没有匹配，那么就匹配“no”分支，由于这个条件判断结构中没有“no”分支，所以什么都不做，把控制权交给接下来的\\) 如果上面遇到的是情况 a)，那么此时“)”可以匹配接下来的)，匹配成功； 如果上面遇到的是情况 b)，那么此时会进行回溯，直到)匹配成功为止，否则报告整个表达式匹配失败。 由于.NET中的狭义平衡组(?&lt;Close-Open&gt;Expression)结构，可以动态的对堆栈中捕获组进行计数，匹配到一个开始标记，入栈，计数加1，匹配到一个结束标记，出栈，计数减1，最后再判断堆栈中是否还有Open，有则说明开始和结束标记不配对出现，不匹配，进行回溯或报告匹配失败；如果没有，则说明开始和结束标记配对出现，继续进行后面子表达式的匹配。 需要对(?!)进行一下说明，它属于顺序否定环视，完整的语法是(?!Expression)。由于这里的“Expression”不存在，表示这里不是一个位置，所以试图尝试匹配总是失败的，作用就是在Open不配对出现时，报告匹配失败。 参考：https://blog.csdn.net/zm2714/article/details/7946437 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://blog.iwxyi.com/tags/数据结构/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://blog.iwxyi.com/tags/正则表达式/"}]},{"title":"Resize冲突","date":"2019-11-07T04:57:00.000Z","path":"2019/11/07/Resize冲突/","text":"BUG 场景《写作天下》新出了名片库功能，所有的操作都在侧边栏中，包括添加名片、修改名片等。 原图 在侧边栏的按钮中添加名片、双击卡片弹出编辑窗口。 为了方便，将之转移到了编辑框中，在编辑框的菜单中弹出名片操作。 名片图 本以为只是极度简单的添加菜单、信号槽连接，第一次测试并没有问题，心中侥幸，但在接下来的使用过程中却出现了偶尔的卡死崩溃问题。 BUG 复现编辑框的右键菜单中添加名片，通过信号槽连接到主窗口，弹出名片编辑弹窗。实测有几率崩溃。 之后重复了上百遍的尝试添加打开弹窗，然而只有3次崩溃，其余并没有任何问题。 换了个思路，点击“创建名片”按钮，并无异样，名片也顺利创建了。然而在第二次点击创建的时候，程序直接卡死，崩溃。 找到了百分百复现的地方，接下来就开始了探索。 BUG 探索从“添加名片”的按钮点击事件开始，打LOG。 123456789101112131415void CardEditor::slotCreateCard() // “创建”按钮的槽{ log(\"创建名片\"); if (gd-&gt;clm.currentLib() == nullptr) return; card-&gt;name = name_edit-&gt;text(); /* ...省略一部分... */ log(\" 添加到全局名片\"); gd-&gt;clm.currentLib()-&gt;addCard(card); // 添加到全局名片中 log(\" 名片创建完毕信号\"); emit signalCardCreated(card); log(\"创建名片 结束\");} 因为行数较少，所以在每一小步的前后都加上log。 接着一步步深入，这是信号槽顺序： 名片编辑窗口.创建名片 &gt;&gt; 名片库.添加名片 &gt;&gt; 名片库.触发添加信号 &gt;&gt; 名片库管理器.接收槽 &gt;&gt; 名片列表控件管理器.接收槽 &gt;&gt; 2个名片列表.添加新名片 &gt;&gt; 名片列表控件管理器.触发刷新章节名片信号 &gt;&gt; 开线程异步刷新 &gt;&gt; 刷新当前章节的名片 &gt;&gt; 刷新章节名片列表控件 &gt;&gt; 关闭名片编辑窗口 这么多文件？一步步深入，写了几十行的log代码，打印出上百行。 按钮 &gt;&gt; 名片库 &gt;&gt; 名片库管理器 &gt;&gt; 名片控件列表管理器 &gt;&gt; 名片控件列表 &gt;&gt; 章节编辑器，主要就是这四个类。 名片库 Cardlib 1234567891011void Cardlib::addCard(CardBean *card){log(\"Cardlib.addCard\"); if (card-&gt;id.isEmpty()) card-&gt;id = getRandomId();log(\" save\"); saveToFile(card);log(\" append\"); appendCard(card);log(\"Cardlib.AddCard finish\");} 名片库管理器 CardlibManager 1234567connect(cardlib, &amp;Cardlib::signalCardAppened, [=](CardBean *card) { log(\"clm.signalCardAppend\"); emit signalCardAppened(card); log(\"clm.signalRehighlight\"); emit signalRehighlight(); log(\"clm.signalRehighlight finish\");}); 名片控件列表管理器 CardlibGroup 12345678910// 名片库添加名片时，添加到卡片列表末尾，并且聚焦此卡片connect(&amp;gd-&gt;clm, &amp;CardlibManager::signalCardAppened, [=](CardBean *card) { log(\"接收到CardlibManager的signalCardAppend\"); if (card-&gt;disabled) return; using_list_widget-&gt;addOneCard(card); using_list_widget-&gt;scrollToBottom(); log(\"发送刷新正在编辑的章节名片信号\"); emit signalNeedRefreshEditingCards();}); 名片控件，由于之前在侧边栏的操作无异常，所以只简要测试。 章节编辑器 ChapterEditor 1234567connect(&amp;gd-&gt;clm, &amp;CardlibManager::signalRehighlight, [=] { if (!editing.isChapter() &amp;&amp; !editing.isOutline()) return ; log(\"editor.highlighter begin\"); highlighter-&gt;rehighlight(); // 关键词高亮 log(\"editor.highlighter end\"); });}); 查看日志，最后卡在了 editor.highlighter begin 这一行，说明是 highlighter 这一行出问题了，高亮显示名片内容时崩溃。 进入 highlighter，重绘高亮的 highlightBlock 的方法中在名片部分前后打上 log，输出，发现有头有尾，应该是正常运行，无法发现在哪里停止运行。 12345678log(\"highlightBlock begin\"); if (gd-&gt;clm.currentLib() != nullptr) { CardList&amp; cards = gd-&gt;clm.currentLib()-&gt;using_cards; foreach (CardBean* card, cards) { /* ...省略... */ } }log(\"highlightBlock end\"); 甚至注释掉名片部分，也无法阻止在第二次创建名片的时候停止运行。 日志是这样的： 1234567891011clm.signalRehighlighteditor.highlighter begin highlightBlock begin highlightBlock end highlightBlock begin highlightBlock end ...editor.highlighter end...editor.highlighter begin（第二次创建名片，崩溃） 问题肯定就出在了 highlighter-&gt;rehighlight(); 这一行。将它延时100毫秒： 12345678connect(&amp;gd-&gt;clm, &amp;CardlibManager::signalRehighlight, [=] { log(\"editor.slot.rehighter\"); QTimer::singleShot(100, [=]{ log(\"editor.rehighter begin\"); highlighter-&gt;rehighlight(); // 关键词高亮 log(\"editor.rehighter end\"); });}); 继续崩溃。 注释掉 highlighter-&gt;rehighlight(); ，这下子倒是没有问题了，但是也彻底丧失了高亮的功能，这是我不想的，日志如下： 123456789101112131415clm.signalRehighlighteditor.slot.rehightereditor.slot.rehightereditor.slot.rehightereditor.slot.rehighter... (延迟100毫秒后) editor.highlighter begin editor.highlighter end editor.highlighter begin editor.highlighter end editor.highlighter begin editor.highlighter end editor.highlighter begin editor.highlighter end 思考为什么会导致崩溃。最可能的原因就是空指针了。 再研究日志，通过全局的名片库管理器发送的信号，只发送了一次，但是为什么接收到了4次，即高亮四次？ 这才想到，目前一共打开了2个能接收信号的自定义编辑框，分别是章节、大纲，但还有两次呢？ 突然意识过来，名片编辑窗口中，显示名片自己信息的编辑框，就是和章节编辑一模一样的自定义编辑框！而且还是两个！这就解释了为什么会多出两个接收的槽。 BUG 原因名片编辑窗口，为了显示简介和详情的高亮，它内部本身就用了略微修改的章节编辑框ChapterEditor类，由其派生出一个通用的GeneralEditor，后期可添加适配多个场景，例如大纲。而在构造函数中，连接了全局的名片管理器，统一刷新名片高亮。 除了两个特殊的编辑框，还有一个“创建名片”按钮，点击后创建名片，并且关闭弹窗本身。为了防止内存溢出，又设置了自动 delete 的属性setAttribute(Qt::WA_DeleteOnClose);。创建名片之后，立即关闭自己，触发delete，同时由于控件的父子关系，自动析构子对象，包括两个正在刷新名片高亮的编辑框。 原因也正是如此，可能 Qt 在高亮时没有阻塞主线程，正在高亮的同时又 delete 掉编辑框控件，导致没有高亮的对象，野指针导致停止运行。 BUG 解决自定义编辑框连接信号槽时，判断编辑的对象类型，如果是名片编辑窗口的那两个，则不刷新高亮。 123456if (!editing.isBrief() &amp;&amp; !editing.isDetail()) // 如果不是名片的简介和详情{ connect(&amp;gd-&gt;clm, &amp;CardlibManager::signalRehighlight, [=] { highlighter-&gt;rehighlight(); });} 这样的唯一问题，就是在编辑某一个名片时，这个窗口内部并不会立即修改高亮，而是需要等待后期刷新。 BUG 总结多线程关键词高亮，嗯，这个我真没想到。 还有编辑框析构后没有删除控制高亮的对象，也没有想到。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"BUG","slug":"BUG","permalink":"http://blog.iwxyi.com/tags/BUG/"}]},{"title":"数据库按分类排序及百分比","date":"2019-11-03T06:04:00.000Z","path":"2019/11/03/数据库按分类排序并计算百分比/","text":"1234567891011121314SELECT 字段名, n, round( n / s * 100, 5 ) rat FROM ( SELECT * FROM( SELECT 字段名, count( 1 ) n FROM sendsms_log GROUP BY 字段名 ) t1 INNER JOIN ( SELECT count( 1 ) s FROM sendsms_log ) t2 ON 1 = 1 ) t where条件在两个最里面的 from后，都要加上，否则百分比不准确 四舍五入：round 函数 末尾加百分号：concat(num, ‘%’) 中文按拼音排序： Oracle用函数 nlssort MySQL：编码为latin1_swedish_ci：order by birary(字段名) asc编码为 utf8_general_ci：ORDER BY CONVERT( 字段名 USING gbk ) COLLATE gbk_chinese_ci ASC 自定义枚举类型排序：order by field( name, ‘value1’, ‘value2’ ) 示例：研究土壤对生长势的影响 12345678910111213141516171819select 土壤名称, 生长势, n 数量, concat(round( n / s * 100, 2 ),'%') 百分比from ( select * from ( select 土壤名称, 生长势, count(1) n from `linan` -- where 生长场所='乡村' group by 土壤名称,生长势 order by convert( 土壤名称 using gbk ) collate gbk_chinese_ci asc ) t1 -- 各分类数 inner join ( select count(1) s from `linan` -- where 生长场所='乡村' ) t2 -- 总数 on 1 = 1) t-- order by field(生长势, '正常株', '衰弱株', '濒危株', '死亡株') 显示结果： 土壤名称 生长势 数量 百分比 红壤 正常株 7120 69.95% 黄壤 正常株 2049 20.13% 基性岩土 正常株 1 0.01% 石灰土 正常株 226 2.22% 水稻土 正常株 1 0.01% 紫色土 正常株 4 0.04% 红壤 衰弱株 507 4.98% 黄壤 衰弱株 33 0.32% 石灰土 衰弱株 4 0.04% 黄壤 濒危株 38 0.37% 石灰土 濒危株 1 0.01% 红壤 濒危株 147 1.44% 红壤 死亡株 40 0.39% 黄壤 死亡株 8 0.08% 可通过 union all 来合并多个搜索结果，并且计算每个土壤中各个生长势的百分比，即有各土壤各自都是 100% document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"SQL","slug":"SQL","permalink":"http://blog.iwxyi.com/tags/SQL/"}]},{"title":"VSCode调试C++","date":"2019-10-19T07:34:00.000Z","path":"2019/10/19/VSCode调试C/","text":"VSCode打开文件夹，新建.vscode文件夹（资源管理器不允许用户建立.开头的文件夹） launch.json 12345678910111213141516171819202122232425262728// https://github.com/Microsoft/vscode-cpptools/blob/master/launch.md{ \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"(gdb) Launch\", // 配置名称，将会在启动配置的下拉菜单中显示 \"type\": \"cppdbg\", // 配置类型，这里只能为cppdbg \"request\": \"launch\", // 请求配置类型，可以为launch（启动）或attach（附加） \"program\": \"${fileDirname}/${fileBasenameNoExtension}.exe\", // 将要进行调试的程序的路径 \"args\": [], // 程序调试时传递给程序的命令行参数，一般设为空即可 \"stopAtEntry\": false, // 设为true时程序将暂停在程序入口处，即开头断点 \"cwd\": \"${workspaceFolder}\", // 调试程序时的工作目录 \"environment\": [], // （环境变量？） \"externalConsole\": true, // 调试时是否显示控制台窗口，一般设置为true显示控制台 \"internalConsoleOptions\": \"neverOpen\", // 如果不设为neverOpen，调试时会跳到“调试控制台”选项卡，你应该不需要对gdb手动输命令吧？ \"MIMode\": \"gdb\", // 指定连接的调试器，可以为gdb或lldb。但目前lldb在windows下没有预编译好的版本。 \"miDebuggerPath\": \"gdb.exe\", // 调试器路径。 \"setupCommands\": [ { \"description\": \"Enable pretty-printing for gdb\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": true } ], \"preLaunchTask\": \"Compile\" // 调试会话开始前执行的任务，一般为编译程序。与tasks.json的label相对应 } ]} tasks.json 123456789101112131415161718192021222324252627282930// https://code.visualstudio.com/docs/editor/tasks{ \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"Compile\", // 任务名称，与launch.json的preLaunchTask相对应 \"command\": \"g++\", // 要使用的编译器 \"args\": [ \"${file}\", \"-o\", // 指定输出文件名，不加该参数则默认输出a.exe \"${fileDirname}/${fileBasenameNoExtension}.exe\", \"-g\", \"-static-libgcc\", // 静态链接 \"-std=c++11\" // C语言最新标准为c11，或根据自己的需要进行修改 ], // 编译命令参数 \"type\": \"shell\", \"group\": { \"kind\": \"build\", \"isDefault\": true // 设为false可做到一个tasks.json配置多个编译指令，需要自己修改本文件，我这里不多提 }, \"presentation\": { \"echo\": true, \"reveal\": \"always\", // 在“终端”中显示编译信息的策略，可以为always，silent，never。具体参见VSC的文档 \"focus\": false, // 设为true后可以使执行task时焦点聚集在终端，但对编译c和c++来说，设为true没有意义 \"panel\": \"shared\" // 不同的文件的编译信息共享一个终端面板 }, \"problemMatcher\":\"$gcc\" // 如果你不使用clang，去掉前面的注释符，并在上一条之后加个逗号。 } ]} F5 运行、断点调试 ctrl+shift+b 编译不运行 注：打开文件必须为 xxx.cpp，仅运行当前文件 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"VSCode","slug":"VSCode","permalink":"http://blog.iwxyi.com/tags/VSCode/"}]},{"title":"工厂模式","date":"2019-10-12T12:18:00.000Z","path":"2019/10/12/工厂模式/","text":"在平时编程中，构建对象最常用的方式是 new 一个对象。乍一看这种做法没什么不好，而实际上这也属于一种硬编码。每 new 一个对象，相当于调用者多知道了一个类，增加了类与类之间的联系，不利于程序的松耦合。其实构建过程可以被封装起来，工厂模式便是用于封装对象的设计模式。 简单工厂模式举个例子，直接 new 对象的方式相当于当我们需要一个苹果时，我们需要知道苹果的构造方法，需要一个梨子时，需要知道梨子的构造方法。更好的实现方式是有一个水果工厂，我们告诉工厂需要什么种类的水果，水果工厂将我们需要的水果制造出来给我们就可以了。这样我们就无需知道苹果、梨子是怎么种出来的，只用和水果工厂打交道即可。 水果工厂： 123456789public class FruitFactory { public Fruit create(String type){ switch (type){ case \"苹果\": return new Apple(); case \"梨子\": return new Pear(); default: throw new IllegalArgumentException(\"暂时没有这种水果\"); } }} 调用： 123456789public class User { private void eat(){ FruitFactory fruitFactory = new FruitFactory(); Fruit apple = fruitFactory.create(\"苹果\"); Fruit pear = fruitFactory.create(\"梨子\"); apple.eat(); pear.eat(); }} 事实上，将构建过程封装的好处不仅可以降低耦合，如果某个产品构造方法相当复杂，使用工厂模式可以大大减少代码重复。 简单工厂模式就是让一个工厂类承担构建所有对象的职责。调用者需要什么产品，让工厂生产出来即可。它的弊端也显而易见： 一是如果需要生产的产品过多，此模式会导致工厂类过于庞大，承担过多的职责，变成超级类。当苹果生产过程需要修改时，要来修改此工厂。梨子生产过程需要修改时，也要来修改此工厂。也就是说这个类不止一个引起修改的原因。违背了单一职责原则。 二是当要生产新的产品时，必须在工厂类中添加新的分支。而开闭原则告诉我们：类应该对修改封闭。我们希望在添加新功能时，只需增加新的类，而不是修改既有的类，所以这就违背了开闭原则。 工厂方法模式为了解决简单工厂模式的这两个弊端，工厂方法模式应运而生，它规定每个产品都有一个专属工厂。比如苹果有专属的苹果工厂，梨子有专属的梨子工厂，Java 代码如下： 苹果工厂： 12345public class AppleFactory { public Fruit create(){ return new Apple(); }} 梨子工厂： 12345public class PearFactory { public Fruit create(){ return new Pear(); }} 调用者： 12345678910public class User { private void eat(){ AppleFactory appleFactory = new AppleFactory(); Fruit apple = appleFactory.create(); PearFactory pearFactory = new PearFactory(); Fruit pear = pearFactory.create(); apple.eat(); pear.eat(); }} 调用者虽然不需要和 Apple 、Pear 类打交道了，但却需要和 AppleFactory、PearFactory 类打交道。有几种水果就需要知道几个工厂类，耦合度完全没有下降啊，甚至还增加了代码量！ 仔细想一想，工厂模式的第二个优点在工厂方法模式中还是存在的。当构建过程相当复杂时，工厂将构建过程封装起来，调用者可以很方便的直接使用，同样以苹果生产为例： 12345678public class AppleFactory { public Fruit create(){ AppleSeed appleSeed = new AppleSeed(); Sunlight sunlight = new Sunlight(); Water water = new Water(); return new Apple(appleSeed, sunlight, water); }} 调用者无需知道苹果的生产细节，当生产过程需要修改时也无需更改调用端。同时，工厂方法模式解决了简单工厂模式的两个弊端。 当生产的产品种类越来越多时，工厂类不会变成超级类。工厂类会越来越多，保持灵活。不会越来越大、变得臃肿。如果苹果的生产过程需要修改时，只需修改苹果工厂。梨子的生产过程需要修改时，只需修改梨子工厂。符合单一职责原则。 当需要生产新的产品时，无需更改既有的工厂，只需要添加新的工厂即可。保持了面向对象的可扩展性，符合开闭原则。 抽象工厂模式工厂方法模式可以进一步优化，提取出工厂接口： 123public interface IFactory { Fruit create();} 然后苹果工厂和梨子工厂都实现此接口： 123456public class AppleFactory implements IFactory { @Override public Fruit create(){ return new Apple(); }} 123456public class PearFactory implements IFactory { @Override public Fruit create(){ return new Pear(); }} 此时，调用者可以将 AppleFactory 和 PearFactory 统一作为 IFactory 对象使用： 12345678910public class User { private void eat(){ IFactory appleFactory = new AppleFactory(); Fruit apple = appleFactory.create(); IFactory pearFactory = new PearFactory(); Fruit pear = pearFactory.create(); apple.eat(); pear.eat(); }} 可以看到，我们在创建时指定了具体的工厂类后，在使用时就无需再关心是哪个工厂类，只需要将此工厂当作抽象的 IFactory 接口使用即可。这种经过抽象的工厂方法模式被称作抽象工厂模式。 由于客户端只和 IFactory 打交道了，调用的是接口中的方法，使用时根本不需要知道是在哪个具体工厂中实现的这些方法，这就使得替换工厂变得非常容易。 例如： 1234567public class User { private void eat(){ IFactory factory = new AppleFactory(); Fruit fruit = factory.create(); fruit.eat(); }} 如果需要替换为吃梨子，只需要更改一行代码即可： 1234567public class User { private void eat(){ IFactory factory = new PearFactory(); Fruit fruit = factory.create(); fruit.eat(); }} IFactory 中只有一个抽象方法时，或许还看不出抽象工厂模式的威力。实际上抽象工厂模式主要用于替换一系列方法。例如将程序中的 SQL Server 数据库整个替换为 Access 数据库，使用抽象方法模式的话，只需在 IFactory 接口中定义好增删改查四个方法，让 SQLFactory 和 AccessFactory 实现此接口，调用时直接使用 IFactory 中的抽象方法即可，调用者无需知道使用的什么数据库，我们就可以非常方便的整个替换程序的数据库，并且让客户端毫不知情。 抽象工厂模式很好的发挥了开闭原则、依赖倒置原则，但缺点是抽象工厂模式太重了，如果 IFactory 接口需要新增功能，则会影响到所有的具体工厂类。使用抽象工厂模式，替换具体工厂时只需更改一行代码，但要新增抽象方法则需要修改所有的具体工厂类。所以抽象工厂模式适用于增加同类工厂这样的横向扩展需求，不适合新增功能这样的纵向扩展。 参考：https://zhuanlan.zhihu.com/p/85624457 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.iwxyi.com/tags/设计模式/"}]},{"title":"单例模式","date":"2019-10-12T12:17:00.000Z","path":"2019/10/12/单例模式/","text":"单例模式非常常见，某个对象全局只需要一个实例时，就可以使用单例模式。它的优点也显而易见： 它能够避免对象重复创建，节约空间并提升效率 避免由于操作不同实例导致的逻辑错误 单例模式有两种实现方式：饿汉式和懒汉式。 饿汉式饿汉式：变量在声明时便初始化。 1234567891011public class Singleton { private static Singleton instance = new Singleton(); private Singleton() { } public static Singleton getInstance() { return instance; }} 可以看到，我们将构造方法定义为 private，这就保证了其他类无法实例化此类，必须通过 getInstance 方法才能获取到唯一的 instance 实例，非常直观。但饿汉式有一个弊端，那就是即使这个单例不需要使用，它也会在类加载之后立即创建出来，占用一块内存，并增加类初始化时间。就好比一个电工在修理灯泡时，先把所有工具拿出来，不管是不是所有的工具都用得上。就像一个饥不择食的饿汉，所以称之为饿汉式。 懒汉式懒汉式：先声明一个空变量，需要用时才初始化。 1234567891011121314public class Singleton { private static Singleton instance = null; private Singleton() { } public static Singleton getInstance(){ if (instance == null) { instance = new Singleton(); } return instance; }} 我们先声明了一个初始值为 null 的 instance 变量，当需要使用时判断此变量是否已被初始化，没有初始化的话才 new 一个实例出来。就好比电工在修理灯泡时，开始比较偷懒，什么工具都不拿，当发现需要使用螺丝刀时，才把螺丝刀拿出来。当需要用钳子时，再把钳子拿出来。就像一个不到万不得已不会行动的懒汉，所以称之为懒汉式。 懒汉式解决了饿汉式的弊端，好处是按需加载，避免了内存浪费，减少了类初始化时间。 双检锁方式：线程安全上述代码的懒汉式单例乍一看没什么问题，但其实它不是线程安全的。如果有多个线程同一时间调用 getInstance 方法，instance 变量可能会被实例化多次。为了保证线程安全，我们需要给判空过程加上锁： 12345678910111213141516public class Singleton { private static Singleton instance = null; private Singleton() { } public static Singleton getInstance() { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } return instance; }} 这样就能保证多个线程调用 getInstance 时，一次最多只有一个线程能够执行判空并 new 出实例的操作，所以 instance 只会实例化一次。 双检锁提高性能但这样的写法仍然有问题，当多个线程调用 getInstance 时，每次都需要执行 synchronized 同步化方法，这样会严重影响程序的执行效率。所以更好的做法是在同步化之前，再加上一层检查： 123456789101112131415161718public class Singleton { private static Singleton instance = null; private Singleton() { } public static Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; }} 这样增加一种检查方式后，如果 instance 已经被实例化，则不会执行同步化操作，大大提升了程序效率。上面这种写法也就是我们平时较常用的双检锁方式实现的线程安全的单例模式。 静态内部类方式除了双检锁方式外，还有一种比较常见的静态内部类方式保证懒汉式单例的线程安全： 12345678910111213public class Singleton { private static class SingletonHolder { public static Singleton instance = new Singleton(); } private Singleton() { } public static Singleton getInstance() { return SingletonHolder.instance; }} 虽然我们经常使用这种静态内部类的懒加载方式，但其中的原理不一定每个人都清楚。接下来我们便来分析其原理，搞清楚两个问题： 静态内部类方式是怎么实现懒加载的 静态内部类方式是怎么保证线程安全的 Java 类的加载过程包括：加载、验证、准备、解析、初始化。初始化阶段即执行类的 clinit 方法（clinit = class + initialize），包括为类的静态变量赋初始值和执行静态代码块中的内容。但不会立即加载内部类，内部类会在使用时才加载。所以当此 Singleton 类加载时，SingletonHolder 并不会被立即加载，所以不会像饿汉式那样占用内存。 另外，Java 虚拟机规定，当访问一个类的静态字段时，如果该类尚未初始化，则立即初始化此类。当调用Singleton 的 getInstance 方法时，由于其使用了 SingletonHolder 的静态变量 instance，所以这时才会去初始化 SingletonHolder，在 SingletonHolder 中 new 出 Singleton 对象。这就实现了懒加载。 第二个问题的答案是 Java 虚拟机的设计是非常稳定的，早已经考虑到了多线程并发执行的情况。虚拟机在加载类的 clinit 方法时，会保证 clinit 在多线程中被正确的加锁、同步。即使有多个线程同时去初始化一个类，一次也只有一个线程可以执行 clinit 方法，其他线程都需要阻塞等待，从而保证了线程安全。 懒汉式的缺点就是将程序加载时间从启动时延后到了运行时，虽然启动时间缩短了，但我们浏览页面时就会看到数据的 loading 过程。 一般的建议是：对于构建不复杂，加载完成后会立即使用的单例对象，推荐使用饿汉式。对于构建过程耗时较长，并不是所有使用此类都会用到的单例对象，推荐使用懒汉式。 参考：https://zhuanlan.zhihu.com/p/85624457 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"多线程","slug":"多线程","permalink":"http://blog.iwxyi.com/tags/多线程/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.iwxyi.com/tags/设计模式/"}]},{"title":"好玩的Linux命令行","date":"2019-10-05T05:54:00.000Z","path":"2019/10/05/好玩的Linux命令行/","text":"# 呼出命令 moo cowsay 你要说的话xcowsay 你要说的话 sl 蒸汽机 oneko 小猫 cmatrix 数据流雨 aafire 代码火 xeyes 两只眼睛 pv 模拟人工打字echo \"要说的话\" | pv -qL 10 toilet Hello! 字母组成文字图toilet -f mono12 -F metal Hello! 另一个风格 bb 外太空音乐 ASCIIquarium 水族箱 asciiview 图片路径 字符图（需要PNG图标） you-get \"网址\" 下载网址中的视频 安装【前言】作为一名程序员，在别人的眼里往往是充满科技感、神秘感的，而在我们自己的眼里却往往是觉得无聊、枯燥的。其实，在程序的世界里同样会充满着各种的彩蛋，这些彩蛋往往都是一些大神留下来的，我们未曾发现，只是我们缺少发现程序之美而已。 今天小编就来唠叨几个程序中，有趣酷炫的命令，来体验一波程序彩蛋之美。 Tips：施展功力的时候，最好有妹子在身边，装足一波逼的同时，说不定还能脱单哟~ 好，废话不多说，直接上命令： 一、moo彩蛋：你今天咩咩了没有？（滑稽眼） ~$ apt-get moo 效果： img 二、Cowsay彩蛋： 一看名字就知道是牛要说话了，哈哈，没错，就是设定一头牛跟你对话，有意识不？ 这个指令有两种牛，一个是普通的Cowsay牛，另一个是加强、纯种的XCowsay奶牛，下面就来看看： ~$ apt-get install cowsay # 安装【普通牛】程序 ~$ apt-get install xcowsay # 安装【加强牛】程序 ~$ cowsay 旁边坐的是你女朋友吧！ # 执行 ~$ xcowsay 旁边坐的是你女朋友吧！ # 执行 img img 三、sl （Steam Locomotive）彩蛋：在电脑屏幕上隆隆的驶过一辆蒸汽机火车（有趣吧！全屏效果更好哦~）。 ~$ apt-get install sl # 安装命令 ~$ sl # 执行命令 效果： img 四、oneko彩蛋：撸猫指令，”oneko”会生成一个图像猫，与你愉快的玩耍。 ~$ apt-get install oneko # 安装程序 ~$ oneko # 执行 效果： img 五、cmatrix彩蛋：有没有想过，你的电脑上也能像黑客片中的一样，让电脑上的数据飞起来，看看那引人瞩目、令人叹为观止的数据流，黑客中最神秘、不可思议的一个场景在自己电脑上是如何实现的。 ~$ apt-get install cmatrix # 安装程序 ~$ cmatrix # 执行 效果（全屏感觉更好）： img 六、xeyes彩蛋：生成一双会注视你工作的眼镜。想想在工作中，这是一种什么感觉。。。。。 ~$ apt-get install xeyes # 安装程序 ~$ xeyes # 执行 效果： img 七、ASCIIquarium彩蛋：把你的linux终端变成一个海洋世界，各种生物在不断呈现，有鱼、有水、有草…，真是Amazing~~ 1234567sudo apt-get install libcurses-perlcd /tmpwget http://search.cpan.org/CPAN/authors/id/K/KB/KBAUCOM/Term-Animation-2.4.tar.gztar -zxvf Term-Animation-2.4.tar.gzcd Term-Animation-2.4/perl Makefile.PL &amp;&amp; make &amp;&amp; make testsudo make install 效果： img 八、aview命令彩蛋：想象一下将一张图片以ASCII码格式在终端上显示出来是什么效果？实现后真实酷爆了。。。 安装aalib-1.4 123456wget https://sourceforge.net/projects/aa-project/files/latest/download?source=files # 可能需要手动改下载的文件名tar xvzf aalib-1.4rc5.tar.gzcd aalib-1.4.0./configuremakesudo make install 二、安装aview 12345wget http://prdownloads.sourceforge.net/aa-project/aview-1.3.0rc1.tar.gzcd aview-1.3.0./configuremakesudo make install 三、安装ImageMagick 1sudo apt-get install ImageMagick 可能要用： 1sudo apt-get install imagemagick 如果还是不行，用手动安装： 12345678wget https://www.imagemagick.org/download/ImageMagick.tar.gztar -xzvf ImageMagick.tar.gzcd ImageMagick-7.0.8-67/./configure # 会滚动一段时间make &amp;&amp; make install # 需要好久sudo ldconfig /usr/local/libconvert -version # 检查是否成功convert input.tif output.pdf # 执行成功当前目录下会生成output.pdf 如果convert -version出现convert command notfound，需要配置环境变量vim /etc/profile 添加如下： 123&gt; export ImageMagick_HOME=/usr/local/ImageMagick&gt; export PATH=$PATH:$ImageMagick_HOME/bin&gt; 四、测试是否成功 1asciiview songshu.jpg 效果： img 九、pv彩蛋：模仿人工打字。将预先设定好的文字内容按约定的时间逐个输出，类似有人在敲键盘。 ~$ apt-get install pv # 安装程序 ~$ echo “Tecmint[dot]com is a community of Linux Nerds and Geeks” | pv -qL 10 # 输出设定好的内容 效果： img 参考：https://www.jianshu.com/p/08e9094f61ce Linux最强大的一个特征就是它有大量的各种小命令工具，这也可以称做是它最有趣的一个地方了。你要知道，Linux命令终端并不是总来干一些严肃的事情的，这里列举一些很有趣的命令。（它们的有趣并不是因为无用，而是真的有趣。） 一、cmatrix （代码雨） 安装cmatrix：#sudo apt-get install cmatrix执行效果：# cmatix二、oneko （小猫）安装oneko: #sudo apt-get install oneko执行效果: # oneko三、aafire （代码火）安装：#sudo apt-get install libaa-bin执行效果：#aafire四、ASCIIquarium （水族馆）安装：# cd /tmp # wget http://www.robobunny.com/projects/asciiquarium/asciiquarium.tar.gz # tar -zxvf asciiquarium.tar.gz # cd asciiquarium_1.1/ # cp asciiquarium /usr/local/bin # chmod 0755 /usr/local/bin/asciiquarium执行效果：# asciiquarium五、toilet （不是厕所！！！它能用字母拼写出更大字母的工具，具体拼出什么字由命令后面的参数决定，不仅如此，它还能打印出各种风格的效果，比如彩色，金属光泽等。）安装： # sudo apt-get install toilet执行效果：# toilet Hello! # toilet -f mono12 -F metal Hello! 等等六、sl (蒸汽机。ls是linux命令最常用的一个命令，用来列表文件目录等。因为用的频繁，难免有着急打错的时候，一旦你敲成了 ‘sl’，会出现什么结果？）安装：#sudo apt-get install sl执行效果：#sl七、cowsay 和 xcowsay (牛牛说话啦！）安装：#sudo apt-get install cowsay #sudo apt-get install xcowsay执行效果：# cowsay 你好 # xcowsay 你好八、xeyes (大眼睛)安装：#sudo apt-get install xeyes执行效果：#xeyes九、moo (今天你咩咩了没？)无需安装执行效果：# apt-get moo十、bb (外太空音乐……)安装：# sudo apt-get install bb执行效果： # bb document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.iwxyi.com/tags/Linux/"}]},{"title":"PHP Redis函数","date":"2019-09-18T08:31:00.000Z","path":"2019/09/18/PHP-Redis函数/","text":"一、简单的字符串缓存比如针对一些sql查询较慢，更新不频繁的数据进行缓存。 123456789101112131415&lt;?php$redis = new Redis();$redis-&gt;connect('127.0.0.1', 6379, 60); $sql = 'select * from tb_order order by id desc limit 10';//伪代码，从数据库中获取数据$data = $db-&gt;query($sql);$data = json_encode($data, JSON_UNESCAPED_UNICODE);$key = md5($sql);//缓存数据$redis-&gt;set($key, $value, 60); //获取数据$data = $redis-&gt;get($key);print_r(json_decode($data, true)); 二、通过列表模拟简单队列比如我们需要批量的发送邮件，可以把发送邮件的任务存入队列中，然后启多个php脚本从队列中读取任务去发送邮件。 也可以用来处理商品秒杀，用户点击抢购时，把一个个的用户抢购任务放入队列中，串行化处理，判断队列数量，防止超卖的发生。 1234567891011121314151617181920212223242526&lt;?php$redis = new Redis();$redis-&gt;connect('127.0.0.1', 6379, 60); //循环的把发送1000条邮件任务插入队列for ($ix = 0; $ix &lt; 1000; $ix++) { $redis-&gt;lPush('send_email_queue', json_encode([ 'id' =&gt; $ix, 'send' =&gt; 'xxx@qq.com', 'receive' =&gt; 'yyy@qq.com', 'title' =&gt; 'xxx', 'body' =&gt; 'xxx', ]));} sleep(3); //从队列中取任务，执行任务while ($count = $redis-&gt;lLen('send_email_queue')) { echo \"当前任务队列数 {$count} &lt;br&gt;\"; $task = $redis-&gt;rpop('send_email_queue'); $task = json_decode($task, true); //伪代码，发送邮件 $mailer-&gt;send($task['send'], $task['receive'], $task['title'], $task['body']); echo \"任务 {$task['id']} 邮件发送成功&lt;br&gt;\";} 三、通过watch + multi 来实现乐观锁乐观锁，顾名思义，乐观的认为数据不会被修改，只有当更新时才去判断数据是否被修改过，通常用版本号或时间戳来实现。 redis中通过watch和multi来实现，watch会监视给定的key是否发生更改，当exec的时候如果监视的key发生过改变，则整个事务会失败。 当然我们可以调用多次watch监视多个key。 123456789101112131415161718192021&lt;?php$redis = new Redis();$redis-&gt;connect('127.0.0.1', 6379, 60); //设置商品的库存数为100$redis-&gt;set('goods_stock_nums', 100);//监视该key$redis-&gt;watch('goods_stock_nums'); //开启事务$redis-&gt;multi(); //修改库存数$redis-&gt;decr('goods_stock_nums'); //提交事务，如果在此期间有其他请求修改了该key，那么事务会失败if ($redis-&gt;exec()) { echo '抢购成功';} else { echo '数据错误，请重新再试';} 四、使用 set 来实现悲观锁悲观锁，顾名思义，悲观的认为数据总是会被修改，所以在操作前都会先加上锁，操作完后，再释放锁。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?phpfunction getRedis(){ $redis = new Redis(); $redis-&gt;connect('127.0.0.1', 6379, 60); return $redis;} function lock($key, $random){ $redis = getRedis(); return $redis-&gt;set($key, $random, ['nx', 'ex' =&gt; 3]);} function unlock($key, $random){ $redis = getRedis(); //使用lua脚本保证原子性 $script = 'if redis.call(\"get\",KEYS[1]) == ARGV[1] then return redis.call(\"del\",KEYS[1]) else return 0 end'; return $redis-&gt;eval($script, [$key, $random], 1);} function decrGoodsStockNums(){ $redis = getRedis(); //获取商品库存数 $ret = $redis-&gt;get('goods_stock_nums'); if ($ret === false) { return false; } if ($ret &lt;= 0) { return false; } $random = mt_rand(); //先获取锁 if (lock('goods_stock_nums_lock', $random)) { //修改库存数 $redis-&gt;decr('goods_stock_nums'); //释放锁 unlock('goods_stock_nums_lock', $random); return true; } else { usleep(100); decrGoodsStockNums(); }} decrGoodsStockNums(); 五、使用 publish + subscribe 完成发布和订阅123456789101112131415&lt;?php$redis = new Redis();$redis-&gt;pconnect('127.0.0.1', 6379); $ix = 0;//发布内容while (true) { $redis-&gt;publish('news', json_encode([ 'title' =&gt; '我是新闻标题' . $ix, 'content' =&gt; '我是新闻内容' . $ix, 'time' =&gt; date('Y-m-d H:i:s'), ])); $ix++; sleep(1);} 订阅代码： 123456789&lt;?php$redis = new Redis();$redis-&gt;pconnect('127.0.0.1', 6379); //订阅内容$redis-&gt;subscribe(['news'], function ($redis, $channel, $msg) { $msg = json_decode($msg, true); echo \"标题: {$msg['title']} 内容: {$msg['content']} 时间: {$msg['time']} &lt;br&gt;\";}); 参考博客：https://www.cnblogs.com/jkko123/p/10491342.html 函数用法：https://www.php.cn/php-weizijiaocheng-387118.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.iwxyi.com/tags/PHP/"},{"name":"Redis","slug":"Redis","permalink":"http://blog.iwxyi.com/tags/Redis/"}]},{"title":"GCC和G++的区别","date":"2019-09-18T00:23:00.000Z","path":"2019/09/18/GCC和G-的区别/","text":"gcc和g++都是GNU(组织)的一个编译器。 误区一:gcc只能编译c代码,g++只能编译c++代码两者都可以，但是请注意：1.后缀为.c的，gcc把它当作是C程序，而g++当作是c++程序；后缀为.cpp的，两者都会认为是c++程序，注意，虽然c++是c的超集，但是两者对语法的要求是有区别的。C++的语法规则更加严谨一些。2.编译阶段，g++会调用gcc，对于c++代码，两者是等价的，但是因为gcc命令不能自动和C＋＋程序使用的库联接，所以通常用g++来完成链接，为了统一起见，干脆编译/链接统统用g++了，这就给人一种错觉，好像cpp程序只能用g++似的。 误区二:gcc不会定义__cplusplus宏，而g++会实际上，这个宏只是标志着编译器将会把代码按C还是C++语法来解释，如上所述，如果后缀为.c，并且采用gcc编译器，则该宏就是未定义的，否则，就是已定义。 误区三:编译只能用gcc，链接只能用g++严格来说，这句话不算错误，但是它混淆了概念，应该这样说：编译可以用gcc/g++，而链接可以用g++或者gcc -lstdc++。因为gcc命令不能自动和C＋＋程序使用的库联接，所以通常使用g++来完成联接。但在编译阶段，g++会自动调用gcc，二者等价。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"编译原理","slug":"编译原理","permalink":"http://blog.iwxyi.com/tags/编译原理/"}]},{"title":"Qt工程转VS工程","date":"2019-09-11T10:48:00.000Z","path":"2019/09/11/Qt工程转VS工程/","text":"将pro文件转换成vcxproj，可通过VS打开： 1qmake -tp vc 我的电脑上qmake路径：D:\\IDE\\Qt5.11.3\\5.11.3\\msvc2017_64\\bin\\qmake.exe 如果报Can not run cl之类的错误，把 cl 加到环境变量中： D:\\IDE\\Visual Studio 2017 Enterprise\\VC\\Tools\\MSVC\\14.10.25017\\bin\\HostX64\\x64 由于编译器位数不一样，一些lib库可能需要用vs重新编译才能使用。 bat脚本 12path=%path%; D:\\IDE\\Qt5.13.1\\5.13.1\\msvc2017_64\\bin\\; D:\\IDE\\Visual Studio 2017 Enterprise\\VC\\Tools\\MSVC\\14.10.25017\\bin\\HostX64\\x64start qmake -tp vc 可能会有编码乱码问题？ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"},{"name":"VS","slug":"VS","permalink":"http://blog.iwxyi.com/tags/VS/"}]},{"title":"Qt自定义右键菜单和托盘菜单","date":"2019-08-28T11:12:00.000Z","path":"2019/08/28/Qt自定义菜单/","text":"自定义菜单包括右键菜单，按钮菜单和系统托盘菜单 一：右键菜单textEdit的右键菜单，通过槽函数on_textEdit_customContextMenuRequested()实现,其中的Action是已经创建好的 12345678910111213void MainWindow::on_textEdit_customContextMenuRequested(){ QMenu *menu = new QMenu(this); menu-&gt;addAction(ui-&gt;undoAction); menu-&gt;addAction(ui-&gt;redoAction); menu-&gt;addSeparator(); menu-&gt;addAction(ui-&gt;cutAction); menu-&gt;addAction(ui-&gt;copyAction); menu-&gt;addAction(ui-&gt;pasteAction); menu-&gt;addSeparator(); menu-&gt;addAction(ui-&gt;selectAllAction); menu-&gt;exec(QCursor::pos());} 参考：Qt之自定义菜单（右键菜单） 二：托盘菜单12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879void MainWindow::createSystemTrayIcon(){ trayIcon=new QSystemTrayIcon(this);//创建托盘 trayIcon-&gt;setIcon(QIcon(tr(\":images/icon\")));//设置托盘图标 trayIcon-&gt;setToolTip(tr(\"托盘\")); play_widget = new QWidget(); play_widget_Action = new QWidgetAction(this); /*********创建所需的按钮和动作并连接信号槽********/ play_Button = new QPushButton(); play_Button -&gt;setCursor(Qt::PointingHandCursor); play_Button -&gt;setFlat(true); play_Button-&gt;setFixedSize(40,40); connect(play_Button,SIGNAL(clicked()), this, SLOT(Play())); last_Button = new QPushButton(); last_Button -&gt;setCursor(Qt::PointingHandCursor); last_Button -&gt;setFlat(true); last_Button-&gt;setFixedSize(30,30); connect(last_Button, SIGNAL(clicked()), this, SLOT(Last())); next_Button = new QPushButton(); next_Button-&gt;setCursor(Qt::PointingHandCursor); next_Button -&gt;setFlat(true); next_Button-&gt;setFixedSize(30,30); connect(next_Button, SIGNAL(clicked()), this, SLOT(Next())); musicname_Label = new QLabel(); musicname_Label-&gt;setFixedWidth(100); musicname_Label-&gt;setAlignment(Qt::AlignCenter); aboutAction = new QAction(tr(\"关 于\"),this); aboutAction-&gt;setIcon(QIcon(\":/images/about\")); connect(aboutAction,SIGNAL(triggered()),this,SLOT(about())); quitAction=new QAction(tr(\"退 出\"), this); quitAction-&gt;setIcon(QIcon(\":/images/quit\")); connect(quitAction, SIGNAL(triggered()), this, SLOT(quit())); //使用样式表修饰按钮 last_Button-&gt;setStyleSheet(\"QPushButton {border-image:url(:/images/last);}QPushButton:hover{border-image:url(:/images/last_on);}QPushButton:hover:pressed{border-image:url(:/images/last);}\"); play_Button-&gt;setStyleSheet(\"QPushButton {border-image:url(:/images/play);}QPushButton:hover{border-image:url(:/images/play_on);}QPushButton:hover:pressed{border-image:url(:/images/play);}\"); next_Button-&gt;setStyleSheet(\"QPushButton {border-image:url(:/images/next);}QPushButton:hover{border-image:url(:/images/next_on);}QPushButton:hover:pressed{border-image:url(:/images/next);}\"); //将next，last和play按钮水平布局 QHBoxLayout *Hlayout = new QHBoxLayout(); Hlayout-&gt;addWidget(last_Button); Hlayout-&gt;addWidget(play_Button); Hlayout-&gt;addWidget(next_Button); Hlayout-&gt;setSpacing(0); Hlayout-&gt;setContentsMargins(20, 0, 20, 0); //将上面布好的一排按钮和歌名Label垂直布局 QVBoxLayout *Vlayout = new QVBoxLayout(); Vlayout-&gt;addLayout(Hlayout); Vlayout-&gt;addWidget(musicname_Label,0,Qt::AlignCenter); Vlayout-&gt;setSpacing(5); Vlayout-&gt;setContentsMargins(0, 0, 0, 5); musicname_Label-&gt;setEnabled(false); //将上面整合好的控件作为一个widget并将此widget赋给一个Action play_widget-&gt;setLayout(Vlayout); play_widget_Action-&gt;setDefaultWidget(play_widget); //new一个托盘菜单并将上面的Action和其他Action赋给托盘菜单 trayContextMenu=new QMenu(this); trayContextMenu-&gt;addAction(play_widget_Action); trayContextMenu-&gt;addSeparator(); trayContextMenu-&gt;addAction(aboutAction); trayContextMenu-&gt;addAction(quitAction); //将托盘菜单赋给托盘并显示托盘 trayIcon-&gt;setContextMenu(trayContextMenu); trayIcon-&gt;show(); //点击托盘执行的事件 connect(trayIcon, SIGNAL(activated(QSystemTrayIcon::ActivationReason)), this, SLOT(iconActivated(QSystemTrayIcon::ActivationReason)));} 参考：Qt之自定义菜单（托盘菜单） 参考：https://blog.csdn.net/csdn_sxl/article/details/50586856 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"C++可变长参数","date":"2019-08-11T00:13:00.000Z","path":"2019/08/11/C-可变长参数/","text":"type function(type arg1, ...) { } 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cstdarg&gt;using namespace std;int vsum(int count, ...) { // 定义一个变长参数类型的指针变量：ap （Argument Pointer） va_list ap; // 初始化指针变量ap. // 第二个参数count是用来确定ap的起始位置的，count是vsum的第一个参数， // 注意： 如果vsum在count参数后，还有一个命名的参数叫abc, 那么就要va_start(ap, abc)来初始化ap了 // 后边的变长参数是根据count的地址来计算出来 va_start(ap, count); int val(0); int sum(0); // 遍历变长参数内容，通过ap。 for (int i=0; i&lt;count; ++i) { // va_arg的第一个参数是va_list定义的变长参数指针ap， // 第二个参数指明了当前位置变长参数的类型。va_arg会自动改变ap的指针位置。 // 下次再调用va_arg它就自动取下一个参数了，这里ap就像个迭代器 val = va_arg(ap, int); sum += val; } // 清理工作 va_end(ap); return sum;}int main(){ cout &lt;&lt; vsum(4, 1,2,3,4) &lt;&lt; endl;} 示例：递归求和 123456789101112131415161718#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;T vsum(const T &amp;t) { return t; }template &lt;typename T, typename ... Args&gt;T vsum(const T &amp;t, const Args&amp;... args) { T sum(0); sum += t; sum += vsum(args...); return sum;}int main(){ cout &lt;&lt; vsum(1,2,3,4) &lt;&lt; endl;} 参考：https://blog.csdn.net/elloop/article/details/50092631 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"}]},{"title":"小顶堆TopN","date":"2019-07-07T12:48:00.000Z","path":"2019/07/07/小顶堆TopN/","text":"应用场景：10亿个数中取前1000大的数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105import java.util.Arrays;public class SmallHeap { /** * &lt;description&gt;获取前N数据&lt;/description&gt; * * @param arr * @param n * @author: ouyp * @since: Seeyon V7.0 SP2 * @date: 2018年10月16日 下午4:52:27 */ public static int[] topN(int[] arr, int n) { /** * 构建堆积 */ int[] list = new int[n]; System.arraycopy(arr, 0, list, 0, n); for (int i = 0; i &lt; n; i++) { int t = i; while (t != 0 &amp;&amp; list[parent(t)] &gt; list[t]) { swap(list, t, t = parent(t)); } } /** * 小顶堆 */ for (int i = n, len = arr.length; i &lt; len; i++) { if (arr[i] &gt;= list[0]) { // 置换栈顶 list[0] = arr[i]; // 调整栈顶 int t = 0; while ((left(t) &lt; n &amp;&amp; list[t] &gt; list[left(t)]) || (right(t) &lt; n &amp;&amp; list[t] &gt; list[right(t)])) { if (right(t) &lt; n &amp;&amp; list[right(t)] &lt; list[left(t)]) { swap(list, t, t = right(t)); } else { swap(list, t, t = left(t)); } } } } return list; } /** * &lt;description&gt;对象交换&lt;/description&gt; * * @param list * @param i * @param j * @author: ouyp * @since: Seeyon V7.0 SP2 * @date: 2018年10月16日 下午4:56:33 */ private static void swap(int[] list, int i, int j) { int tmp = list[i]; list[i] = list[j]; list[j] = tmp; } /** * &lt;description&gt;父节点索引&lt;/description&gt; * * @param i * @return * @author: ouyp * @date: 2018年10月16日 下午3:34:22 */ private static int parent(int i) { return (i - 1) / 2; } /** * &lt;description&gt;左孩子索引&lt;/description&gt; * * @param i * @return * @author: ouyp * @date: 2018年10月16日 下午4:01:30 */ private static int left(int i) { return 2 * i + 1; } /** * &lt;description&gt;右孩子索引&lt;/description&gt; * * @param i * @return * @author: ouyp * @date: 2018年10月16日 下午4:02:04 */ private static int right(int i) { return 2 * i + 2; } public static void main(String[] args) { int[] arr = new int[]{56, 30, 71, 18, 29, 93, 44, 75, 20, 65, 68, 34}; System.out.println(\"原始数组: \"); System.out.println(Arrays.toString(arr)); System.out.println(\"调整后数组: \"); System.out.println(Arrays.toString(SmallHeap.topN(arr, 5))); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"算法","slug":"算法","permalink":"http://blog.iwxyi.com/tags/算法/"}]},{"title":"Qt QString和unsigned char互转","date":"2019-07-07T09:41:00.000Z","path":"2019/07/07/Qt-QString和unsigned-char互转/","text":"QString 转 char 和 unsigned char 12345678910QString s(\"tttttest\");int len = strlen((char *)(s.toLatin1().data()));char *cs = (char*)malloc(sizeof(char) * len);strcpy(cs, (char *)(s.toLatin1().data()));qDebug() &lt;&lt; \"char*\" &lt;&lt; cs;unsigned char * us = (unsigned char *)cs;qDebug() &lt;&lt; \"unsigned char:\" &lt;&lt; us;free(cs); unsigned char 转 QString 12QString ss(QLatin1String((char *)us));qDebug() &lt;&lt; \"QString:\" &lt;&lt; ss; 1234QString s(\"test\");qDebug() &lt;&lt; QString(QLatin1String( (char*)(unsigned char *)s.toLatin1().data())); 注意：不支持中文这类双字节 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"打印丑丑的手写字体","date":"2019-06-30T11:59:00.000Z","path":"2019/06/30/打印丑丑的手写字体/","text":"先设置成丑的手写体再运行下方随即调整行距的宏： 12345678910111213141516171819202122232425262728293031323334353637383940414243Sub 字体修改()' 字体修改 宏 Dim R_Character As Range Dim FontSize(5) ' 字体大小在5个值之间进行波动，可以改写 FontSize(1) = \"21\" FontSize(2) = \"21.5\" FontSize(3) = \"22\" FontSize(4) = \"22.5\" FontSize(5) = \"23\" Dim FontName(3) '字体名称在三种字体之间进行波动，可改写，但需要保证系统拥有下列字体 FontName(1) = \"陈静的字完整版\" FontName(2) = \"萌妹子体\" FontName(3) = \"李国夫手写体\" Dim ParagraphSpace(5) '行间距 在一定以下值中均等分布，可改写 ParagraphSpace(1) = \"12\" ParagraphSpace(2) = \"13\" ParagraphSpace(3) = \"20\" ParagraphSpace(4) = \"7\" ParagraphSpace(5) = \"12\" '不懂原理的话，不建议修改下列代码 For Each R_Character In ActiveDocument.Characters VBA.Randomize R_Character.Font.Name = FontName(Int(VBA.Rnd * 3) + 1) R_Character.Font.Size = FontSize(Int(VBA.Rnd * 5) + 1) R_Character.Font.Position = Int(VBA.Rnd * 3) + 1 R_Character.Font.Spacing = 0 Next Application.ScreenUpdating = True For Each Cur_Paragraph In ActiveDocument.Paragraphs Cur_Paragraph.LineSpacing = ParagraphSpace(Int(VBA.Rnd * 5) + 1) Next Application.ScreenUpdating = TrueEnd Sub document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"office","slug":"office","permalink":"http://blog.iwxyi.com/tags/office/"}]},{"title":"AHK鼠标X1X2按键映射","date":"2019-06-29T11:55:00.000Z","path":"2019/06/29/AHK鼠标X1X2按键映射/","text":"AutoHotKey 针对鼠标 X1、X2 的按键映射 实现部分应用程序，包括 Android Studio、PyCharm、Idea、Qt Creator，按 X1 编译，X2 调试 快捷键按需配置，我自己是 ctrl+r 编译运行，ctrl+shift+r 调试 12345678910111213141516171819202122232425run1(){ send ^r ; ctrl+r}run2(){ send ^+r ; ctrl+shift+r}XButton1:: ; 靠近自己的那边 WinGetClass, class, A rst:=InStr(%class%, SunAwtFrame) ;MsgBox %class% ans result is %rst% IfInString class, SunAwtFrame run1() IfInString class, Qt5QWindowIcon run1() return XButton2:: ; 靠近屏幕的那边 WinGetClass, class, A IfInString class, SunAwtFrame run2() return document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"AHK","slug":"AHK","permalink":"http://blog.iwxyi.com/tags/AHK/"}]},{"title":"一加7Pro开启全局90Hz","date":"2019-06-22T11:57:00.000Z","path":"2019/06/22/一加7Pro开启全局90Hz/","text":"电脑adb：adb shell settings put global oneplus_screen_refresh_rate 0 本地终端：settings put global oneplus_screen_refresh_rate 0 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"搞机","slug":"搞机","permalink":"http://blog.iwxyi.com/tags/搞机/"}]},{"title":"Qt加载自定义字体","date":"2019-05-28T09:01:00.000Z","path":"2019/05/28/Qt加载自定义字体/","text":"加载外部字体，但是会稍微影响开启速度。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;QApplication&gt;#include &lt;QStyleFactory&gt;#include &lt;QFontDataBase&gt;#include &lt;QIODevice&gt;QString loadFontFamilyFromFiles(const QString &amp;fontFilePath){ QString font = \"\"; QFile fontFile(fontFilePath); if(!fontFile.open(QIODevice::ReadOnly)) { qDebug()&lt;&lt;\"Open font file error\"; return font; } int loadedFontID = QFontDatabase::addApplicationFontFromData(fontFile.readAll()); QStringList loadedFontFamilies = QFontDatabase::applicationFontFamilies(loadedFontID); if(!loadedFontFamilies.empty()) { font = loadedFontFamilies.at(0); } fontFile.close(); return font;}int main(int argc, char *argv[]){ QApplication a(argc, argv); QString font_path = \"字体路径（ttf/otf）\"; if (isFileExist(font_path)) { QString strFont = loadFontFamilyFromFiles(font_path); QFont font(strFont, 9); a.setFont(font); } MainWindow w; w.show(); return a.exec();}; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"C++调用Python","date":"2019-05-27T05:35:00.000Z","path":"2019/05/27/C-调用Python/","text":"Python代码 1234567891011import fastTextimport jieba# 判断小说类型的调用语句def judge(novel): print(novel, \" : \", classifier.predict(\" \".join(jieba.cut(novel)))) return str(classifier.predict(\" \".join(jieba.cut(novel)))[0][0])# classifier = fastText.train_supervised(\"data/novel_names.txt\", lr=0.1, wordNgrams=1, loss=\"hs\", epoch=20)# model = classifier.save_model(\"data/novel_names.model\")classifier = fastText.load_model(\"data/novel_names.model\") C++代码（Qt为例） 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;QCoreApplication&gt;#include &lt;iostream&gt;#include &lt;Python.h&gt;#include &lt;QDebug&gt;using namespace std;int main(int argc, char *argv[]){ QCoreApplication a(argc, argv); Py_Initialize(); if (!Py_IsInitialized()) { return -1; } PyObject* pModule = PyImport_ImportModule(\"wtnn\"); // 模块名（不带后缀的文件名） if (!pModule) { printf(\"Can't open python file!\\n\"); return -1; } PyObject* pFun = PyObject_GetAttrString(pModule, \"judge\"); // 函数名 if (!pFun) { printf(\"Get function failed\"); return -1; } PyObject* args = Py_BuildValue(\"(s)\", \"测试\"); // 构建参数，为元组形式 PyObject* result = PyObject_CallObject(pFun, args); if (result) { char* str = nullptr; PyArg_Parse(result, \"s\", &amp;str); qDebug() &lt;&lt; str; // 可以直接printf，但是中文乱码，得用qDebug } Py_Finalize(); return a.exec();} pro文件 12INCLUDEPATH += -I C:\\Users\\HP\\AppData\\Local\\Programs\\Python\\Python36\\includeLIBS += -LC:\\Users\\HP\\AppData\\Local\\Programs\\Python\\Python36\\libs -lpython36 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Python","slug":"Python","permalink":"http://blog.iwxyi.com/tags/Python/"}]},{"title":"FastText心得","date":"2019-05-20T05:36:00.000Z","path":"2019/05/20/FastText心得/","text":"安装方法一：手动安装 下载https://github.com/xiamx/fastText/releases的source code(zip)，解压后打开，输入： 1pip setup.py install 如果缺少什么库（比如pybind11），则用 pip 安装 方法二：PIP 12pip search fasttextpip install fasttext document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Python","slug":"Python","permalink":"http://blog.iwxyi.com/tags/Python/"},{"name":"NLP","slug":"NLP","permalink":"http://blog.iwxyi.com/tags/NLP/"}]},{"title":"Windows下建立Linux子系统","date":"2019-05-19T06:02:00.000Z","path":"2019/05/19/Windows下建立Linux子系统/","text":"在windows开窗口：先打开 xming，再输入： 1DISPLAY=:0 firefox 远程桌面控制：1sudo service xrdp start https://www.cnblogs.com/lihjacky/p/9106202.html 然后通过远程桌面链接到：127.0.0.1:3390 VNC连接：12zshvncserver 打开 VNC Viewer，访问：127.0.0.1:端口号，端口号为 Ubuntu 中的最后一个数字（从1开始，可能递增） http://www.cnblogs.com/kerrycode/p/6055126.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.iwxyi.com/tags/Linux/"}]},{"title":"Git用法","date":"2019-05-16T06:01:00.000Z","path":"2019/05/16/Git用法/","text":"Git 用法下载Gitgit-x.x.x-64-bit.exe 下载地址：https://git-scm.com/downloads 一路默认安装 linux下安装：sudo apt-get install git 启动在项目目录中打开 Git Bash 用命令行进行管理 身份 git config --global user.email \"you@example.com\" git config --global user.name \"Your Name\" 上传Git git init git add . （空格和 . ）将文件夹全部内容添加到 git（新文件+修改，不包括删除）git add -A 包括上传删除的文件 git commit -m “提交信息” git remote add origin GitHub项目https地址 连接仓库如果报错（一般是由于在其他设备使用），先使用 git remote rm origin 来清空，再重试 git push -u origin master 上传项目。会弹出窗口输入GitHub账号密码。如果要上传到已存在的仓库，要先使用git pull origin master来同步到本地 更新Git从上面第2点开始，最后一步可以直接 git push SSH连接1ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\" 三下回车，出现图案结果。 复制文件C:/Users/Administrator/.ssh/id_rsa.pub内容，把key添加到：github &gt; settings &gt; SSH and GPG keys &gt; New SSH key &gt; 粘贴保存。 Linux在：/home/用户名/.ssh/id_rsa.pub，可用命令行打开 Mac在：/Users/用户名/.ssh/id_rsa.pub 撤销提交git reset --soft HEAD^ 仅撤销提交，写的代码仍然保留 代码回滚 git log # 得到你需要回退一次提交的commit id git reset --hard &lt;commit_id&gt; git push origin HEAD --force # 强制提交一次，之前错误的提交就从远程仓库删除 创建分支 git checkout -b dev 创建并切换本地分支dev git checkout dev 切换分支 git remote add upstream [主仓库地址] 关联上游分支 git fetch upstream 分仓库获取主仓库最新状态 git push --set-upstream origin line64 首次上传（创建云端分支） git checkout master, git merge dev 合并分支 比较差异 git diff &lt;commit_id1&gt; &lt;commit_id2&gt; 比较两个版本的差异 git diff --cached 比较没有 commit 的差异 git diff HEAD 比较没有 add 和 commit 的改动 添加子模块123git submodule add git@github.com:iwxyi/NeveMusic.git order_playergit submodule initgit submodule uodate 在order_player文件夹中，导入 NeveMusic 仓库，代码会自动下载 其他操作多人协作http://www.imooc.com/article/279280 记住密码git config credential.helper store 12345$ git config credential.helper store$ git push https://github.com/owner/repo.git# 然后输入用户名和密码Username for 'https://github.com': &lt;USERNAME&gt;Password for 'https://USERNAME@github.com': &lt;PASSWORD&gt; 在其他项目，只要使用： 1git config --global credential.helper store 会自动调用全局的设置 更改 commit 信息1git commit --amend -m \"新提交信息\" 漏提交12git add 遗漏文件git commit --amend --no-edit // 表示提交消息不会更改，仅为一次提交 重新提交1git reset // 回退到上一个commit版本 回滚1234567git reset HEAD 文件名 // 取消暂存区的修改git reset --hard 提交ID // 全部回退到指定版本git reset --hard HEAD~1 // 回退一个版本git reset --soft HEAD~1 // 版本库回退一个版本，该版本之后的所有变更进入暂存区 撤销revert 和 reset 的区别：revert 也会作为一次操作进入版本库，reset 直接删除指定 commit 1git revert // 使用新的 commit 来回滚到之前的 commit 删除Repository点开项目–Settings–Delete this repository，会要求输入项目名字来确认删除 强推出了问题，不管三七二十一，强行push 1git push origin master -f 强制下载123git fetch --all git reset --hard origin/mastergit pull Git目录下新增文件在项目根目录直接添加新文件夹好像不会上传 需要手动添加到Git的上传列表里 123git add 文件夹名git commit -m \"\"git push 删除某个文件1git rm -r --cached xxx 再commit和push 其中目录需要强制-r 切换分支导致代码丢失1git reflog 可以看到按时间排列的所有提交 问题remote origin already exists12$ git remote add origin 项目地址fatal: remote origin already exists. 解决方法： 1git remote rm origin 再重新git remote add origin 项目地址 其实不用管它也没事的…… 多设备提交冲突123456789$ git push -u origin masterTo https://github.com/MRXY001/yunj.git ! [rejected] master -&gt; master (fetch first)error: failed to push some refs to 'https://github.com/MRXY001/yunj.git'hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details. 让你fetch first就是先git pull 一下 12git fetchgit merge 等同于 1git pull 还是不行的解决办法： 远程分支上存在本地分支中不存在的提交，往往是多人协作开发过程中遇到的问题，可以先fetch再merge，也就是pull，把远程分支上的提交合并到本地分支之后再push。 如果你确定远程分支上那些提交都不需要了，那么直接git push origin master -f，强行让本地分支覆盖远程分支。。。（不建议，会覆盖掉以前的所有 commits） SSH问题12345678910$ git push -u origin masterThe authenticity of host 'github.com (13.229.188.59)' can't be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added 'github.com,13.229.188.59' (RSA) to the list of known hosts.git@github.com: Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 解决办法： 需要重新创建SSH 1ssh-keygen -t rsa -C \"wxy19980615@gmail.com\" 把 /c/Users/Administrator/.ssh/id_rsa.pub 文件的内容放到 GitHub/Settings/SSH keys 里面然后再重新执行 git push -u origin master failed to push some refs to ‘origin’意思是本地和远程的文件应该合并后才能上传本地的新文件 12git pull origin mastergit push -u origin master 不匹配12error: src refspec master does not match any.error: failed to push some refs to git commit -m \"xxx\" 重新上传一遍 拒绝合并不相关的历史1fatal: refusing to merge unrelated histories 出现这个问题的最主要原因还是在于本地仓库和远程仓库实际上是独立的两个仓库。假如我之前是直接clone的方式在本地建立起远程github仓库的克隆本地仓库就不会有这问题了。 可以在pull命令后紧接着使用--allow-unrelated-history选项来解决问题（该选项可以合并两个独立启动仓库的历史） 1git pull origin master --allow-unrelated-histories （合并的文件很可能会有问题，需要手动调整） 直接push的话会继续报错：Updates were rejected because the tip of your current branch is behind its remote counterpart. Integrate the remote changes 然后add和commit，最后重新push一遍 Changes not staged for commit:123456789101112131415git commit -m \"更新文件结构\"On branch masterYour branch is up to date with 'origin/master'.Changes not staged for commit: modified: ../README.md deleted: ../picture/result.png deleted: ../qidian_collections.py deleted: ../train.pyUntracked files: ../name_collections.py ../name_train.pyno changes added to commit 解决方法：使用git add -A 进行添加line You are not currently on a branch git status 查看所有变化的文件, 把有改动的先删除（或者提交）注意, 注意, 注意, 最好额外备份一份 git checkout master 回到主分支就是回退到 master 主分支上，这次修改的内容会消失 git pull 保证一下本地是最新代码 然后将备份的内容 paste 就好了 fatal: your current branch appears to be broken现象： 打开git git log： fatal: your current branch appears to be broken 文件全部是new状态 解决办法：.git\\refs\\heads\\ 下有各个分支命名的HEAD的纪录文件，纪录当前分支指向哪个commit， 用notepad打开有一串NUL，去.git\\logs\\refs\\heads这个目录下，找到当前分支对应的文件，打开找到最后一次commit的hashcode 把这个code，复制到.git\\refs\\heads\\ 下对应的分支文件中，就可以了 error: You have not concluded your merge原因可能是在以前pull下来的代码自动合并失败 解决办法一:保留本地的更改,中止合并-&gt;重新合并-&gt;重新拉取 123git merge --abortgit reset --mergegit pull 解决办法二:舍弃本地代码,远端版本覆盖本地版本(慎重) 123git fetch --allgit reset --hard origin/mastergit fetch document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Git","slug":"Git","permalink":"http://blog.iwxyi.com/tags/Git/"}]},{"title":"Qt屏蔽中文输入法","date":"2019-05-05T12:00:00.000Z","path":"2019/05/05/Qt屏蔽中文输入法/","text":"只在屏蔽输入法的QLineEdit上调用： setAttribute(Qt::WA_InputMethodEnabled, false); 接下来就能监听到各种按键事件 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"Python网络爬虫","date":"2019-05-02T05:41:00.000Z","path":"2019/05/02/Python网络爬虫/","text":"一个提取起点小说名称的例子 12345678910111213141516171819202122232425262728# coding: utf-8import urllib.requestimport re# 获取网页源码def get_html(url): page = urllib.request.urlopen(url) _html = page.read() return str(_html, encoding='utf-8')# 保存到文本文件def save_text_file(file_name, contents): with open(file_name, 'w', encoding='utf-8') as f: f.write(contents)# 正则表达式提取数据def get_novel_names(source): return re.findall('&lt;h4&gt;&lt;a href=\"//book.qidian.com/info/\\\\d+\" target=\"_blank\" data-eid=\"qd_C40\" data-bid=\"\\\\d+\"&gt;(.+?)&lt;/a&gt;&lt;/h4&gt;', source)novels = [] # 所有的书名列表for page in range(1, 3): # 遍历2页 html = get_html(\"https://www.qidian.com/rank/fin?chn=21&amp;page=\"+str(page)) novels += get_novel_names(html)save_text_file(\"玄幻.txt\", \"\\n\".join(novels)) 这是最简单的例子，但是连续爬https会遇到报错：http.client.RemoteDisconnected: Remote end closed connection without response。需要加上headers: 123456# 获取网页源码def get_html(url): headers = {'User-Agent': 'User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36'} req = urllib.request.Request(url=url, headers=headers) html = urllib.request.urlopen(req) return html.read().decode('utf-8', 'ignore') document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Python","slug":"Python","permalink":"http://blog.iwxyi.com/tags/Python/"}]},{"title":"Jiaba分词","date":"2019-05-02T05:37:00.000Z","path":"2019/05/02/Jiaba分词/","text":"Jieba“结巴”中文分词：做最好的 Python 中文分词组件github : https://github.com/fxsjy/jieba 特点 支持三种分词模式 精确模式，试图将句子最精确地切开，适合文本分析； 全模式，把句子中所有的可以成词的词语都扫描出来, 速度非常快，但是不能解决歧义； 搜索引擎模式，在精确模式的基础上，对长词再次切分，提高召回率，适合用于搜索引擎分词。 支持繁体分词 支持自定义词典 MIT 授权协议 安装代码对 Python 2/3 均兼容 全自动安装：easy_install jieba 或者 pip install jieba / pip3 install jieba 半自动安装：先下载 http://pypi.python.org/pypi/jieba/ ，解压后运行 python setup.py install 手动安装：将 jieba 目录放置于当前目录或者 site-packages 目录 通过 import jieba 来引用 算法 基于前缀词典实现高效的词图扫描，生成句子中汉字所有可能成词情况所构成的有向无环图 (DAG) 采用了动态规划查找最大概率路径, 找出基于词频的最大切分组合 对于未登录词，采用了基于汉字成词能力的 HMM 模型，使用了 Viterbi 算法 主要功能1、分词 jieba.cut 方法接受三个输入参数: 需要分词的字符串；cut_all 参数用来控制是否采用全模式；HMM 参数用来控制是否使用 HMM 模型 jieba.cut_for_search 方法接受两个参数：需要分词的字符串；是否使用 HMM 模型。该方法适合用于搜索引擎构建倒排索引的分词，粒度比较细 待分词的字符串可以是 unicode 或 UTF-8 字符串、GBK 字符串。注意：不建议直接输入 GBK 字符串，可能无法预料地错误解码成 UTF-8 jieba.cut 以及 jieba.cut_for_search 返回的结构都是一个可迭代的 generator，可以使用 for 循环来获得分词后得到的每一个词语(unicode)，或者用 jieba.lcut 以及 jieba.lcut_for_search 直接返回 list jieba.Tokenizer(dictionary=DEFAULT_DICT) 新建自定义分词器，可用于同时使用不同词典。jieba.dt 为默认分词器，所有全局分词相关函数都是该分词器的映射。 代码示例 1234567891011121314# encoding=utf-8import jiebaseg_list = jieba.cut(\"我来到北京清华大学\", cut_all=True)print(\"Full Mode: \" + \"/ \".join(seg_list)) # 全模式seg_list = jieba.cut(\"我来到北京清华大学\", cut_all=False)print(\"Default Mode: \" + \"/ \".join(seg_list)) # 精确模式seg_list = jieba.cut(\"他来到了网易杭研大厦\") # 默认是精确模式print(\", \".join(seg_list))seg_list = jieba.cut_for_search(\"小明硕士毕业于中国科学院计算所，后在日本京都大学深造\") # 搜索引擎模式print(\", \".join(seg_list)) 输出 1234567【全模式】: 我/ 来到/ 北京/ 清华/ 清华大学/ 华大/ 大学【精确模式】: 我/ 来到/ 北京/ 清华大学【新词识别】：他, 来到, 了, 网易, 杭研, 大厦 (此处，“杭研”并没有在词典中，但是也被Viterbi算法识别出来了)【搜索引擎模式】： 小明, 硕士, 毕业, 于, 中国, 科学, 学院, 科学院, 中国科学院, 计算, 计算所, 后, 在, 日本, 京都, 大学, 日本京都大学, 深造 2、添加自定义词典载入词典 开发者可以指定自己自定义的词典，以便包含 jieba 词库里没有的词。虽然 jieba 有新词识别能力，但是自行添加新词可以保证更高的正确率 用法： jieba.load_userdict(file_name) file_name 为文件类对象或自定义词典的路径词典格式和 dict.txt 一样，一个词占一行；每一行分三部分：词语、词频（可省略）、词性（可省略），用空格隔开，顺序不可颠倒。file_name 若为路径或二进制方式打开的文件，则文件必须为 UTF-8 编码。 词频省略时使用自动计算的能保证分出该词的词频。 例如： 1234创新办 3 i云计算 5凱特琳 nz台中 更改分词器（默认为 jieba.dt）的 tmp_dir 和 cache_file 属性，可分别指定缓存文件所在的文件夹及其文件名，用于受限的文件系统。 范例： 自定义词典：https://github.com/fxsjy/jieba/blob/master/test/userdict.txt 用法示例：https://github.com/fxsjy/jieba/blob/master/test/test_userdict.py 之前： 李小福 / 是 / 创新 / 办 / 主任 / 也 / 是 / 云 / 计算 / 方面 / 的 / 专家 / 加载自定义词库后： 李小福 / 是 / 创新办 / 主任 / 也 / 是 / 云计算 / 方面 / 的 / 专家 / 123456789101112131415161718192021222324# encoding=utf-8from __future__ import print_function, unicode_literalsimport sysimport jiebaimport jieba.posseg as psegsys.path.append(\"../\") # 添加当前文件所在目录jieba.load_userdict(\"userdict.txt\") # 和PY文件是同一个目录jieba.add_word('石墨烯')jieba.add_word('凱特琳')jieba.del_word('自定义词')test_sent = ( \"李小福是创新办主任也是云计算方面的专家; 什么是八一双鹿\\n\" \"例如我输入一个带“韩玉赏鉴”的标题，在自定义词库中也增加了此词为N类\\n\" \"「台中」正確應該不會被切開。mac上可分出「石墨烯」；此時又可以分出來凱特琳了。\")words = jieba.cut(test_sent) # 数组，仅分出结果print('/'.join(words))result = pseg.cut(test_sent) # 包括每一个分割词的信息for w in result: print(w.word, \"/\", w.flag, \", \", end=' ') 调整词典 使用 add_word(word, freq=None, tag=None) 和 del_word(word) 可在程序中动态修改词典。 使用 suggest_freq(segment, tune=True) 可调节单个词语的词频，使其能（或不能）被分出来。 注意：自动计算的词频在使用 HMM 新词发现功能时可能无效。 12345678910111213&gt;&gt;&gt; print('/'.join(jieba.cut('如果放到post中将出错。', HMM=False)))如果/放到/post/中将/出错/。&gt;&gt;&gt; jieba.suggest_freq(('中', '将'), True) # 调节为分开 494&gt;&gt;&gt; print('/'.join(jieba.cut('如果放到post中将出错。', HMM=False)))如果/放到/post/中/将/出错/。&gt;&gt;&gt; print('/'.join(jieba.cut('「台中」正确应该不会被切开', HMM=False)))「/台/中/」/正确/应该/不会/被/切开&gt;&gt;&gt; jieba.suggest_freq('台中', True) # 调节为不分开69&gt;&gt;&gt; print('/'.join(jieba.cut('「台中」正确应该不会被切开', HMM=False)))「/台中/」/正确/应该/不会/被/切开 “通过用户自定义词典来增强歧义纠错能力” — https://github.com/fxsjy/jieba/issues/14 参考：https://blog.csdn.net/qq_34337272/article/details/79554772 更多功能与各语言版本请见此博客 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Python","slug":"Python","permalink":"http://blog.iwxyi.com/tags/Python/"},{"name":"NLP","slug":"NLP","permalink":"http://blog.iwxyi.com/tags/NLP/"}]},{"title":"使用Telegram收发微信","date":"2019-04-30T05:58:00.000Z","path":"2019/04/30/使用Telegram收发微信/","text":"介绍发代号 EH Forwarder Bot（简称 EFB）是一个可扩展的聊天平台隧道框架，基于 Python 3。目前已内置了 Telegram 主端 (Master Channel) 和微信从端 (Slave Channel)，用来在 Telegram 收发微信消息。其他从端开发已在计划之中。同时 EFB 也配备了详尽的文档，欢迎有兴趣的朋友们开发自己的主端或从端，来支持更多的平台。EFB 在 GitHub 中开放了源代码，并且在 Read The Docs 平台上发布的开发文档（英文，en-US）。 本文主要介绍了如何在一个虚拟服务器 (VPS) 中安装并配置 EFB、Telegram 主端和微信从端，以及如何使用 Telegram 主端来收发微信消息。 搭建环境服务器系统：CentOS 安装Python3.6123yum install -y https://centos7.iuscommunity.org/ius-release.rpmyum install -y python36u python36u-libs python36u-devel python36u-pip python36u-setuptoolswhich -a python3.6 运行完成后再shell中键入python3.6看能否进入python，如果能则进入下一步，如果显示路径错误则编辑~/bashrc文件vi ~/.bashrc在其中键入python3.6='/usr/bin/python3.6'退出vi编辑器并在shell下键入source ~/.bashrc保存更改 安装非Python依赖项123sudo rpm --import http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.rosudo rpm -Uvh http://li.nux.ro/download/nux/dextop/el7/x86_64/nux-dextop-release-0-5.el7.nux.noarch.rpmyum install -y libwebp-devel file-devel ffmpeg 下载源码并安装1234wget https://codeload.github.com/blueset/ehForwarderBot/tar.gz/v1.6.6tar -xvf v1.6.6cd ehForwarderBot-1.6.6pip3.6 install -r requirements.txt 配置 EFB 接下来就是进行各种必要的配置和初始化的步骤了。 4.1 创建 Telegram BotTelegram Bot 是 EFB（Telegram 主端）的出口，也是呈献给用户的渠道。我们在这里使用了 Telegram 官方的 Bot API，以最大化利用 Telegram Bot 所提供的各种便利功能。 要创建一个新的 Bot，要先向 @BotFather 发起会话。发送指令 /newbot 以启动向导。期间，你需要指定这个 Bot 的名称与用户名（用户名必须以 bot 结尾）。完毕之后 @BotFather 会提供给你一个密钥（Token），妥善保存这个密钥。请注意，为保护您的隐私及信息安全，请不要向任何人提供你的 Bot 用户名及密钥，这可能导致聊天信息泄露等各种风险。 接下来还要对刚刚启用的 Bot 进行进一步的配置：允许 Bot 读取非指令信息、允许将 Bot 添加进群组、以及提供指令列表。 发送 /setprivacy 到 @BotFather，选择刚刚创建好的 Bot 用户名，然后选择 “Disable”. 发送 /setjoingroups 到 @BotFather，选择刚刚创建好的 Bot 用户名，然后选择 “Enable”. 发送 /setcommands 到 @BotFather，选择刚刚创建好的 Bot 用户名，然后发送如下内容： 1234link - 将会话绑定到 Telegram 群组chat - 生成会话头recog - 回复语音消息以进行识别extra - 获取更多功能 然后还需要获取你自己的 Telegram ID，ID 应显示为一串数字。获取你自己的 ID 有很多方式，你可以选择任意一种。下面介绍两种可能的方式。 Plus Messenger如果你使用了 Plus Messenger 作为你的 Telegram 客户端，你可以直接打开你自己的资料页，在「自己」下面会显示你的 ID。 通过 Bot 查询 很多现存的 Bot 也提供了 ID 查询服务，直接向其发送特定的指令即可获得自己的数字 ID。在这里介绍一些接触过的。 123456@get_id_bot 发送 /start@mokubot 发送 /whoami@GroupButler_Bot 发送 /id@jackbot 发送 /me@userinfobot 发送任意文字@orzdigbot 发送 /user 4.2 配置 EFB 和 Telegram 主端这差不多就是安装过程的最后一步了。首先创建存储用文件夹并赋予其权限。回到 VPS 上 ehForwarderBot 目录。（不出意外的话你应该还在这个目录） 12mkdir storagechmod 777 storage 然后复制并编辑配置文件。 123cp config.sample.py config.pyeditor config.py# 其中 editor 是你所喜欢的文本编辑器，比如 vim 则 vim config.py 在配置文件中，token 后引号里面的内容替换为你之前获得的 Bot 密钥，admins 后方括号里面填入你自己的 Telegram ID。后面的 6 行是用来配置语音转文字功能的，不是必要功能，目前可以删除各行。如果有兴趣启用该功能的，请到各平台申请 API keys。详情请参见文档 的「ETM」章节。 参考：https://www.ishare.work/在centos-7下安装并使用-efb：在-telegram-收发微信消息/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"服务器","slug":"服务器","permalink":"http://blog.iwxyi.com/tags/服务器/"}]},{"title":"CSS样式表大全","date":"2019-04-24T05:02:00.000Z","path":"2019/04/24/CSS样式表大全/","text":"一、CSS文字属性： color : #999999; /文字颜色/ font-family : 宋体,sans-serif; /文字字体/ font-size : 9pt; /文字大小/ font-style:itelic; /文字斜体/ font-variant:small-caps; /小字体/ letter-spacing : 1pt; /字间距离/ line-height : 200%; /设置行高/ font-weight:bold; /文字粗体/ vertical-align:sub; /下标字/ vertical-align:super; /上标字/ text-decoration:line-through; /加删除线/ text-decoration: overline; /加顶线/ text-decoration:underline; /加下划线/ text-decoration:none; /删除链接下划线/ text-transform : capitalize; /首字大写/ text-transform : uppercase; /英文大写/ text-transform : lowercase; /英文小写/ text-align:right; /文字右对齐/ text-align:left; /文字左对齐/ text-align:center; /文字居中对齐/ text-align:justify; /文字分散对齐/ vertical-align属性 vertical-align:top; /垂直向上对齐/ vertical-align:bottom; /垂直向下对齐/ vertical-align:middle; /垂直居中对齐/ vertical-align:text-top; /文字垂直向上对齐/ vertical-align:text-bottom; /文字垂直向下对齐/ 二、CSS边框空白 padding-top:10px; /上边框留空白/ padding-right:10px; /右边框留空白/ padding-bottom:10px; /下边框留空白/ padding-left:10px; /*左边框留空白 三、CSS符号属性 list-style-type:none; /不编号/ list-style-type:decimal; /阿拉伯数字/ list-style-type:lower-roman; /小写罗马数字/ list-style-type:upper-roman; /大写罗马数字/ list-style-type:lower-alpha; /小写英文字母/ list-style-type:upper-alpha; /大写英文字母/ list-style-type:disc; /实心圆形符号/ list-style-type:circle; /空心圆形符号/ list-style-type:square; /实心方形符号/ list-style-image:url(/dot.gif); /图片式符号/ list-style-position: outside; /凸排/ list-style-position:inside; /缩进/ 四、CSS背景样式 background-color:#F5E2EC; /背景颜色/ background:transparent; /透视背景/ background-image : url(/image/bg.gif); /背景图片/ background-attachment : fixed; /浮水印固定背景/ background-repeat : repeat; /重复排列-网页默认/ background-repeat : no-repeat; /不重复排列/ background-repeat : repeat-x; /在x轴重复排列/ background-repeat : repeat-y; /在y轴重复排列/ 指定背景位置 background-position : 90% 90%; /背景图片x与y轴的位置/ background-position : top; /向上对齐/ background-position : buttom; /向下对齐/ background-position : left; /向左对齐/ background-position : right; /向右对齐/ background-position : center; /居中对齐/ 五、CSS连接属性 a /所有超链接/ a:link /超链接文字格式/ a:visited /浏览过的链接文字格式/ a:active /按下链接的格式/ a:hover /鼠标转到链接/ 鼠标光标样式： 链接手指 CURSOR: hand 十字体 cursor:crosshair 箭头朝下 cursor:s-resize 十字箭头 cursor:move 箭头朝右 cursor:move 加一问号 cursor:help 箭头朝左 cursor:w-resize 箭头朝上 cursor:n-resize 箭头朝右上 cursor:ne-resize 箭头朝左上 cursor:nw-resize 文字I型 cursor:text 箭头斜右下 cursor:se-resize 箭头斜左下 cursor:sw-resize 漏斗 cursor:wait 光标图案(IE6) p {cursor:url(“光标文件名.cur”),text;} 六、CSS框线一览表 border-top : 1px solid #6699cc; /上框线/ border-bottom : 1px solid #6699cc; /下框线/ border-left : 1px solid #6699cc; /左框线/ border-right : 1px solid #6699cc; /右框线/ 以上是建议书写方式,但也可以使用常规的方式 如下: border-top-color : #369 /设置上框线top颜色/ border-top-width :1px /设置上框线top宽度/ border-top-style : solid/设置上框线top样式/ 其他框线样式 solid /实线框/ dotted /虚线框/ double /双线框/ groove /立体内凸框/ ridge /立体浮雕框/ inset /凹框/ outset /凸框/ 七、CSS表单运用 文字方块 按钮 复选框 选择钮 多行文字方块 下拉式菜单 选项1选项2 八、CSS边界样式 margin-top:10px; /上边界/ margin-right:10px; /右边界值/ margin-bottom:10px; /下边界值/ margin-left:10px; /左边界值/ 九、CSS滤镜属性Filter：在样式中加上滤镜特效。由于此属性内容比较多，我们将到下一章单独对滤镜介绍。 Alpha：设置透明度Alpha(Opacity=?, FinishOpacity=?, Style=?, StartX=?, StartY=?, FinishX=?, FinishY=?)Opacity：透明度级别，范围是0-100，0代表完全透明，100代表完全不透明。FinishOpacity：设置渐变的透明效果时，用来指定结束时的透明度，范围也是0 到 100。Style：设置渐变透明的样式，值为0代表统一形状、1代表线形、2代表放射状、3代表长方形。StartX和StartY：代表渐变透明效果的开始X和Y坐标。 FinishX和FinishY：代表渐变透明效果结束X和Y 的坐标。 BlendTrans：图像之间的淡入和淡出的效果BlendTrans(Duration=?) Duration：淡入或淡出的时间。注意：这个滤镜必须配合JS建立图片序列，才能做出图片间效果。 Blru：建立模糊效果Blur(Add=?, Direction=?, Strength=?) Add：是否单方向模糊，此参数是一个布尔值，true（非0）或false（0）。 Direction：设置模糊的方向，其中0度代表垂直向上，然后每45度为一个单位。 Strength：代表模糊的象素值。 Chroma：把指定的颜色设置为透明Chroma(Color=?) Color：是指要设置为透明的颜色。 DropShadow：建立阴影效果DropShadow(Color=?, OffX=?, OffY=?, Positive=?) Color：指定阴影的颜色。OffX：指定阴影相对于元素在水平方向偏移量，整数。 OffY：指定阴影相对于元素在垂直方向偏移量，整数。 Positive：是一个布尔值，值为true（非0）时，表示为建立外阴影；为false(0)，表示为建立内阴影。 FlipH：将元素水平反转 FlipV：将元素垂直反转8.Glow：建立外发光效效果Glow(Color=?, Strength=?)Color：是指定发光的颜色。Strength：光的强度，可以是1到255之间的任何整数，数字越大，发光的范围就越大。 Gray：去掉图像的色彩，显示为黑白图象 Invert：反转图象的颜色，产生类似底片的效果 Light：放置光源的效果，可以用来模拟光源在物体上的投影效果 注意：此效果需要用JS设置光的位置和强度。 Mask：建立透明遮罩Mask(Color=?) Color：设置底色，让对象遮住底色的部分透明。 RevealTrans：建立切换效果RevealTrans(Duration=?, Transition=?)Duration：是切换时间，以秒为单位。Transtition：是切换方式，可设置为从0到23。注意：如果做页面间的切换效果，可以在&lt;head&gt;区加上一行代码：&lt;Meta http-equiv=Page-enter content=revealTrans(Transition=?,Duration=?) &gt;。如果用在页面里的元素必须配合JS使用。 Shadow：建立另一种阴影效果 Shadow(Color=?, Direction=?) Color：是指阴影的颜色。Direction：是设置投影的方向，0度代表垂直向上，然后每45度为一个单位。 Wave：波纹效果Wave(Add=?, Freq=?, LightStrength=?, Phase=?, Strength=?) Add：表示是否显示原对象，0表示不显示，非0表示要显示原对象。 Freq：设置波动的个数。LightStrength：设置波浪效果的光照强度，从0到100。0表示最弱，100表示最强。 Phase：波浪的起始相角。从0到100的百分数值。（例如：25相当于90度，而50相当于180度。） Strength：设置波浪摇摆的幅度。 Xray：显现图片的轮廓，X光片效果注意：在使用CSS滤镜时，必须使用在有区域的元素，比如表格，图片等。而文本，段落这样没有区域的元素不能使用CSS滤镜，对这样的元素我们可以设置元素的Height和Width样式或坐标来实现。 样式大全字体属性：(font) 大小 {font-size: x-large;}(特大) xx-small;(极小) 一般中文用不到，只要用数值就可以，单位：PX、PD 样式 {font-style: oblique;}(偏斜体) italic;(斜体) normal;(正常) 行高 {line-height: normal;}(正常) 单位：PX、PD、EM 粗细 {font-weight: bold;}(粗体) lighter;(细体) normal;(正常) 变体 {font-variant: small-caps;}(小型大写字母) normal;(正常) 大小写 {text-transform: capitalize;}(首字母大写) uppercase;(大写) lowercase;(小写) none;(无) 修饰 {text-decoration: underline;}(下划线) overline;(上划线) line-through;(删除线) blink;(闪烁) 常用字体： (font-family)“Courier New”, Courier, monospace, “Times New Roman”, Times, serif, Arial, Helvetica, sans-serif, Verdana 背景属性： (background) 色彩 {background-color: #FFFFFF;} 图片 {background-image: url();} 重复 {background-repeat: no-repeat;} 滚动 {background-attachment: fixed;}(固定) scroll;(滚动) 位置 {background-position: left;}(水平) top(垂直); 简写方法 {background:#000 url(..) repeat fixed left top;} /简写·这个在阅读代码中经常出现，要认真的研究/ 区块属性： (Block) /这个属性第一次认识，要多多研究/ 字间距 {letter-spacing: normal;} 数值 /这个属性似乎有用，多实践下/ 对齐 {text-align: justify;}(两端对齐) left;(左对齐) right;(右对齐) center;(居中) 缩进 {text-indent: 数值px;} 垂直对齐 {vertical-align: baseline;}(基线) sub;(下标) super;(下标) top; text-top; middle; bottom; text-bottom; 词间距word-spacing: normal; 数值 空格white-space: pre;(保留) nowrap;(不换行) 显示 {display:block;}(块) inline;(内嵌) list-item;(列表项) run-in;(追加部分) compact;(紧凑) marker;(标记) table; inline-table; table-raw-group; table-header-group; table-footer-group; table-raw; table-column-group; table-column; table-cell; table-caption;(表格标题) /display 属性的了解很模糊/ 方框属性： (Box) width: height: float: clear:both; margin: padding: 顺序：上右下左 边框属性： (Border) border-style: dotted;(点线) dashed;(虚线) solid; double;(双线) groove;(槽线) ridge;(脊状) inset;(凹陷) outset; border-width:; 边框宽度 border-color:#; 简写方法border：width style color; /简写/ 列表属性： (List-style) 类型list-style-type: disc;(圆点) circle;(圆圈) square;(方块) decimal;(数字) lower-roman;(小罗码数字) upper-roman; lower-alpha; upper-alpha; 位置list-style-position: outside;(外) inside; 图像list-style-image: url(..); 定位属性： (Position) Position: absolute; relative; static; visibility: inherit; visible; hidden; overflow: visible; hidden; scroll; auto; clip: rect(12px,auto,12px,auto) (裁切) css属性代码大全字体样式(Font Style)序号 中文说明 标记语法 字体样式 {font:font-style font-variant font-weight font-size font-family} 字体类型 {font-family:”字体1”,”字体2”,”字体3”,…} 字体大小 {font-size:数值|inherit| medium| large| larger| x-large| xx-large| small| smaller| x-small| xx-small} 字体风格 {font-style:inherit|italic|normal|oblique} 字体粗细 {font-weight:100-900|bold|bolder|lighter|normal;} 字体颜色 {color:数值;} 阴影颜色 {text-shadow:16位色值} 字体行高 {line-height:数值|inherit|normal;} 字 间 距 {letter-spacing:数值|inherit|normal} 单词间距 {word-spacing:数值|inherit|normal} 字体变形 {font-variant:inherit|normal|small-cps } 英文转换 {text-transform:inherit|none|capitalize|uppercase|lowercase} 字体变形 {font-size-adjust:inherit|none} 字体 {font-stretch:condensed|expanded|extra-condensed|extra-expanded|inherit|narrower|normal| semi-condensed|semi-expanded|ultra-condensed|ultra-expanded|wider} 文本样式(Text Style)序号 中文说明 标记语法 行 间 距 {line-height:数值|inherit|normal;} 文本修饰 {text-decoration:inherit|none|underline|overline|line-through|blink} 段首空格 {text-indent:数值|inherit} 水平对齐 {text-align:left|right|center|justify} 垂直对齐 {vertical-align:inherit|top|bottom|text-top|text-bottom|baseline|middle|sub|super} 书写方式 {writing-mode:lr-tb|tb-rl} 背景样式序号 中文说明 标记语法 背景颜色 {background-color:数值} 背景图片 {background-image: url(URL)|none} 背景重复 {background-repeat:inherit|no-repeat|repeat|repeat-x|repeat-y} 背景固定 {background-attachment:fixed|scroll} 背景定位 {background-position:数值|top|bottom|left|right|center} 背影样式 {background:背景颜色|背景图象|背景重复|背景附件|背景位置} 框架样式(Box Style)序号 中文说明 标记语法 边界留白 {margin:margin-top margin-right margin-bottom margin-left} 补 白 {padding:padding-top padding-right padding-bottom padding-left} 边框宽度 {border-width:border-top-width border-right-width border-bottom-width border-left-width} 宽度值： thin|medium|thick|数值 边框颜色 {border-color:数值 数值 数值 数值} 数值：分别代表top、right、bottom、left颜色值 边框风格 {border-style:none|hidden|inherit|dashed|solid|double|inset|outset|ridge|groove} 边 框 {border:border-width border-style color}上 边 框 {border-top:border-top-width border-style color}右 边 框 {border-right:border-right-width border-style color}下 边 框 {border-bottom:border-bottom-width border-style color}左 边 框 {border-left:border-left-width border-style color} 宽 度 {width:长度|百分比| auto} 高 度 {height:数值|auto} 漂 浮 {float:left|right|none} 清 除 {clear:none|left|right|both} 分类列表序号 中文说明 标记语法 控制显示 {display:none|block|inline|list-item} 控制空白 {white-space:normal|pre|nowarp} 符号列表 {list-style-type:disc|circle|square|decimal|lower-roman|upper-roman|lower-alpha|upper-alpha|none} 图形列表 {list-style-image:URL} 位置列表 {list-style-position:inside|outside} 目录列表 {list-style:目录样式类型|目录样式位置|url} 鼠标形状 {cursor:hand|crosshair|text|wait|move|help|e-resize|nw-resize|w-resize|s-resize|se-resize|sw-resize} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"整理","slug":"整理","permalink":"http://blog.iwxyi.com/tags/整理/"},{"name":"CSS","slug":"CSS","permalink":"http://blog.iwxyi.com/tags/CSS/"}]},{"title":"PHP时间戳转易读性文本","date":"2019-04-20T08:13:00.000Z","path":"2019/04/20/PHP时间戳转易读性文本/","text":"将两个时间戳的差（秒）转化成字符串 比如“x分钟前”、“x小时前” 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?php/*** 时间转换易读的文字* @author technofiend&lt;2281551151@qq.com&gt;* https://blog.csdn.net/technofiend/article/details/78627161*/function time2Readability($time, $contrastTime = 0){ if ($contrastTime &lt;= 0) { $contrastTime = time(); } if ($time &lt;= 0) { return '未知'; } // 非今年发布的时间 if (date('Y', $time) != date('Y', $contrastTime)) { return date('Y-m-d H:i:s', $time); } // 发布时间的零点 $dateTime1 = new \\DateTime(); $dateTime1-&gt;setTimestamp($time); $dateTime1-&gt;setTime(0, 0, 0); $time1 = $dateTime1-&gt;getTimestamp(); // 今天的零点 $todayObj = new \\DateTime(); $todayObj-&gt;setTimestamp($contrastTime); $todayObj-&gt;setTime(0, 0, 0); $today = $todayObj-&gt;getTimestamp(); // 距离发表时间的秒数 $elapseTime = $contrastTime - $time; // 发表时间等于今天 if ($time1 == $today) { // 今天发表的 if ($elapseTime &lt;= 5 * 60) { // 5分钟内 return '刚刚'; } else if ($elapseTime &lt;= 60 * 60) { // 一个钟头内 return floor($elapseTime / 60) . ' 分钟前'; } else { return floor($elapseTime / (60 * 60)) . ' 小时前'; } } $dateTime3 = new \\DateTime(); $dateTime3-&gt;setTimestamp($contrastTime); $dateTime3-&gt;modify('-1 day'); $dateTime3-&gt;setTime(0, 0, 0); $yesterday = $dateTime3-&gt;getTimestamp(); // 发表时间等于昨天 if ($time1 == $yesterday) { if (($contrastTime - 6 * 60 * 60) &lt; $today) { // 如果当前时间是凌晨 $hourBefore = floor($elapseTime / (60 * 60)); if ($hourBefore &lt;= 9) { return $hourBefore . ' 小时前'; } else { return '昨天：' . date('H:i', $time); } } else { return '昨天：' . date('H:i', $time); } } return date('m-d H:i:s', $time);}?&gt; 12345678$today = new DateTime();$today-&gt;setTime(23, 0, 0);$t = new DateTime();$t-&gt;modify('-1 year -1 day');$t-&gt;setTime(1, 0, 0);echo time2Readability($t-&gt;getTimestamp(), $today-&gt;getTimestamp()); 参考：https://blog.csdn.net/technofiend/article/details/78627161 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.iwxyi.com/tags/PHP/"}]},{"title":"HTML表单即将提交事件","date":"2019-04-20T05:06:00.000Z","path":"2019/04/20/HTML表单即将提交事件/","text":"123456789101112131415&lt;form action=\"insert.php\" onsubmit=\"return onSubmit()\"&gt; &lt;input type=\"text\" name=\"title\" id=\"title\" /&gt;&lt;/form&gt;&lt;script type=\"text/javascript\"&gt; function onSubmit() { if ( $(\"#title\").val(); == \"\" ) { alert(\"请输入标题\"); return false; } return true; }&lt;/script&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"JS","slug":"JS","permalink":"http://blog.iwxyi.com/tags/JS/"},{"name":"HTML","slug":"HTML","permalink":"http://blog.iwxyi.com/tags/HTML/"}]},{"title":"CSS圆角头像","date":"2019-04-20T04:58:00.000Z","path":"2019/04/20/CSS圆角头像/","text":"CSS: 123456789.round_icon{ width: 34px; height: 34px; display: flex; border-radius: 50%; align-items: center; justify-content: center; overflow: hidden;} HTML: 1&lt;img src=\"images/what_ever.jpg\" class=\"round_icon\" /&gt; 参考：https://blog.csdn.net/s1674521/article/details/79731141 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"CSS","slug":"CSS","permalink":"http://blog.iwxyi.com/tags/CSS/"}]},{"title":"C++ new和malloc的10点区别","date":"2019-04-18T00:27:00.000Z","path":"2019/04/18/C-new和malloc的区别/","text":"## 1. 申请的内存所在位置 new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。 那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。 特别的，new甚至可以不为对象分配内存！定位new的功能可以办到这一点： 1new (place_address) type place_address为一个指针，代表一块内存的地址。当使用上面这种仅以一个地址调用new操作符时，new操作符调用特殊的operator new，也就是下面这个版本： 1void * operator new (size_t,void *) //不允许重定义这个版本的operator new 这个operator new不分配任何的内存，它只是简单地返回指针实参，然后右new表达式负责在place_address指定的地址进行对象的初始化工作。 2.返回类型安全性new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图方法自己没被授权的内存区域。关于C++的类型安全性可说的又有很多了。 3.内存分配失败时的返回值new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。在使用C语言时，我们习惯在malloc分配内存后判断分配是否成功： 123456789int *a = (int *)malloc ( sizeof (int ));if(NULL == a){ ...}else { ...} 从C语言走入C++阵营的新手可能会把这个习惯带入C++： 123456789int * a = new int();if(NULL == a){ ...}else{ ...} 实际上这样做一点意义也没有，因为new根本不会返回NULL，而且程序能够执行到if语句已经说明内存分配成功了，如果失败早就抛异常了。正确的做法应该是使用异常机制： 12345678try{ int *a = new int();}catch (bad_alloc){ ...} 如果你想顺便了解下异常基础，可以看http://www.cnblogs.com/QG-whz/p/5136883.htmlC++ 异常机制分析。 4.是否需要指定内存大小使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。 123class A{...}A * ptr = new A;A * ptr = (A *)malloc(sizeof(A)); //需要显式指定所需内存大小sizeof(A); 当然了，我这里使用malloc来为我们自定义类型分配内存是不怎么合适的，请看下一条。 5.是否调用构造函数/析构函数使用new操作符来分配对象内存时会经历三个步骤： 第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。 第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。 第三部：对象构造完成后，返回一个指向该对象的指针。 使用delete操作符来释放对象内存时会经历两个步骤： 第一步：调用对象的析构函数。 第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。 总之来说，new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构。而malloc则不会。如果你不嫌啰嗦可以看下我的例子： 12345678910111213class A{public: A() :a(1), b(1.11){}private: int a; double b;};int main(){ A * ptr = (A*)malloc(sizeof(A)); return 0;} 在return处设置断点，观看ptr所指内存的内容： img 可以看出A的默认构造函数并没有被调用，因为数据成员a,b的值并没有得到初始化，这也是上面我为什么说使用malloc/free来处理C++的自定义类型不合适，其实不止自定义类型，标准库中凡是需要构造/析构的类型通通不合适。 而使用new来分配对象时： 1234int main(){ A * ptr = new A;} 查看程序生成的汇编代码可以发现，A的默认构造函数被调用了： img 6.对数组的处理C++提供了new[]与delete[]来专门处理数组类型: 1A * ptr = new A[10];//分配10个A对象 使用new[]分配的内存必须使用delete[]进行释放： 1delete [] ptr; new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。 至于malloc，它并知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小： 1int * ptr = (int *) malloc( sizeof(int)* 10 );//分配一个10个int元素的数组 7.new与malloc是否可以相互调用operator new /operator delete的实现可以基于malloc，而malloc的实现不可以去调用new。下面是编写operator new /operator delete 的一种简单方式，其他版本也与之类似： 1234567891011void * operator new (sieze_t size){ if(void * mem = malloc(size) return mem; else throw bad_alloc();}void operator delete(void *mem) noexcept{ free(mem);} 8.是否可以被重载opeartor new /operator delete可以被重载。标准库是定义了operator new函数和operator delete函数的8个重载版本： 12345678910//这些版本可能抛出异常void * operator new(size_t);void * operator new[](size_t);void * operator delete (void * )noexcept;void * operator delete[](void *0）noexcept;//这些版本承诺不抛出异常void * operator new(size_t ,nothrow_t&amp;) noexcept;void * operator new[](size_t, nothrow_t&amp; );void * operator delete (void *,nothrow_t&amp; )noexcept;void * operator delete[](void *0,nothrow_t&amp; ）noexcept; 我们可以自定义上面函数版本中的任意一个，前提是自定义版本必须位于全局作用域或者类作用域中。太细节的东西不在这里讲述，总之，我们知道我们有足够的自由去重载operator new /operator delete ,以决定我们的new与delete如何为对象分配内存，如何回收对象。 而malloc/free并不允许重载。 9. 能够直观地重新分配内存使用malloc分配的内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充。realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。 new没有这样直观的配套设施来扩充内存。 10. 客户处理内存分配不足在operator new抛出异常以反映一个未获得满足的需求之前，它会先调用一个用户指定的错误处理函数，这就是new-handler。new_handler是一个指针类型： 1234namespace std{ typedef void (*new_handler)();} 指向了一个没有参数没有返回值的函数,即为错误处理函数。为了指定错误处理函数，客户需要调用set_new_handler，这是一个声明于的一个标准库函数: 1234namespace std{ new_handler set_new_handler(new_handler p ) throw();} set_new_handler的参数为new_handler指针，指向了operator new 无法分配足够内存时该调用的函数。其返回值也是个指针，指向set_new_handler被调用前正在执行（但马上就要发生替换）的那个new_handler函数。 对于malloc，客户并不能够去编程决定内存不足以分配时要干什么事，只能看着malloc返回NULL。 总结将上面所述的10点差别整理成表格： 特征 new/delete malloc/free 分配内存的位置 自由存储区 堆 内存分配成功的返回值 完整类型指针 void* 内存分配失败的返回值 默认抛出异常 返回NULL 分配内存的大小 由编译器根据类型计算得出 必须显式指定字节数 处理数组 有处理数组的new版本new[] 需要用户计算数组的大小后进行内存分配 已分配内存的扩充 无法直观地处理 使用realloc简单完成 是否相互调用 可以，看具体的operator new/delete实现 不可调用new 分配内存时内存不足 客户能够指定处理函数或重新制定分配器 无法通过用户代码进行处理 函数重载 允许 不允许 构造函数与析构函数 调用 不调用 malloc给你的就好像一块原始的土地，你要种什么需要自己在土地上来播种 img 而new帮你划好了田地的分块（数组），帮你播了种（构造函数），还提供其他的设施给你使用: img 当然，malloc并不是说比不上new，它们各自有适用的地方。在C++这种偏重OOP的语言，使用new/delete自然是更合适的。 参考：https://www.cnblogs.com/QG-whz/p/5140930.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"内存管理","slug":"内存管理","permalink":"http://blog.iwxyi.com/tags/内存管理/"}]},{"title":"公众号token服务器配置","date":"2019-04-14T12:30:00.000Z","path":"2019/04/14/公众号token服务器配置/","text":"修改公众号的服务器配置 Token配置代码，文件放在对应的URL路径下 微信会发送GET请求来验证 12345678910111213141516171819202122232425262728&lt;?phpdefine(\"TOKEN\", \"mrxy\"); // 你自己的Token//验证消息$echoStr = $_GET[\"echostr\"];if(checkSignature()){ echo $echoStr; exit;}//检查签名function checkSignature(){ $signature = $_GET[\"signature\"]; $timestamp = $_GET[\"timestamp\"]; $nonce = $_GET[\"nonce\"]; $token = TOKEN; $tmpArr = array($token, $timestamp, $nonce); sort($tmpArr, SORT_STRING); $tmpStr = implode($tmpArr); $tmpStr = sha1($tmpStr); if($tmpStr == $signature){ return true; }else{ return false; }} 微信授权网页登录：https://www.cnblogs.com/whowhere/p/5787247.html 微信扫码登录：https://www.cnblogs.com/0201zcr/p/5133062.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://blog.iwxyi.com/tags/微信小程序/"}]},{"title":"PHP7.0使用数据库","date":"2019-04-14T08:20:00.000Z","path":"2019/04/14/PHP7-0使用数据库/","text":"1234$mysql_server_name='localhost'; //改成自己的mysql数据库服务器$mysql_username=\"root\"; //改成自己的mysql数据库用户名$mysql_password=\"root\"; //改成自己的mysql数据库密码$mysql_database=\"test\"; //改成自己的mysql数据库名 123456789101112131415$conn=new mysqli($mysql_server_name,$mysql_username,$mysql_password); //连接数据库if($conn==false) echo \"数据连接失败！&lt;br/&gt;\";// $conn-&gt;query(\"set names 'utf8'\"); //数据库输出编码 应该与你的数据库编码保持一致$conn-&gt;select_db($mysql_database); //打开数据库$sql =\"select * from biao \"; //SQL语句$result = $conn-&gt;query($sql); //查询成功$data=array();while ($tmp=$result-&gt;fetch_assoc()){ $data[]=$tmp; // 按照下标挨个赋值，$tmp 为一行 echo $tmp['name'] . PHP_EOL;}// var_dump($data); // 输出所有数据，二维数组，例如 $data[0]['id] document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.iwxyi.com/tags/PHP/"},{"name":"MySQL","slug":"MySQL","permalink":"http://blog.iwxyi.com/tags/MySQL/"}]},{"title":"C语言输出代码本身","date":"2019-04-08T12:02:00.000Z","path":"2019/04/08/C语言输出代码本身/","text":"1main(){char *s;printf(s,34,s=\"main(){char *s;printf(s,34,s=%c%s%c,34);}\",34);} 完整版本： 123#include &lt;stdio.h&gt;char*s=\"#include &lt;stdio.h&gt;%cchar*s=%c%s%c;main(){printf(10,s,34,s,34);}\";main(){printf(s,10,34,s,34);} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C语言","slug":"C语言","permalink":"http://blog.iwxyi.com/tags/C语言/"}]},{"title":"Qt获取全球唯一ID","date":"2019-04-02T12:01:00.000Z","path":"2019/04/02/Qt获取全球唯一ID/","text":"123#include &lt;QUuid&gt;QUuid id = QUuid::createUuid();QString strId = id.toString(); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"jQuery+AJAX+Gateway上传文件","date":"2019-03-21T07:49:00.000Z","path":"2019/03/21/jQuery-AJAX-Gateway上传文件/","text":"本例实现了一个用于在线聊天界面发送图片的效果 HTML部分： 新建input标签，隐藏起来 12345&lt;!--隐藏的表单控件--&gt;&lt;input type=\"file\" name=\"pic\" id=\"file\" style=\"displace: none\" /&gt; &lt;!--用来交互的加号按钮--&gt;&lt;i class=\"icon icon-add image_up t-50\" style=\"color: #888;\"&gt;&lt;/i&gt;&lt;/i&gt; JS发送部分： 123456789101112131415161718192021222324252627282930313233343536$(\".image_up\").click(function(){ // 点击加号 $(\".file\").click(); // 模拟点击事件});$(\"#file\").change(function(){ // 内容改变，即选择了图片 formdata = new FormData(); formdata.append('fromid', fromid); formdata.append('toid', toid); formdata.append('online', online); formdata.append('file', $('#file')[0].file[0]); $.ajax({ url: API_URL+\"uploadimg\", type: 'POST', cache: false, data: formdata, // 发送的数据 dataType: 'json', // 收到的数据格式 processData: false, // 不转成对象的形式 contentType: false, // 不转成URLencode编码 success: function(data, status, xhr){ // 上传结果 if (data.status == 'ok') { // 上传成功 // 添加到自己的聊天框中 $(\".chat-content\").append('&lt;div class=\"chat-text section-right flex\"&gt;&lt;span class=\"char-img\"&gt;&lt;i class=\"icon icon-sanjiao3 t-32\"&gt;&lt;/i&gt;&lt;img width=\"120em\" height=\"120em\" src=\"__ROOT__/uploads/'+data.img_name+'\"&gt;&lt;/span&gt; &lt;span class=\"char-img\" style=\"background-image: url('+from_head+');\"&gt;&lt;/span&gt;&lt;/div&gt;'); $(\".chat-content\").scrollTop(3000); // 滚动到底部 // 通过socket发送给聊天对象 var message = '{\"data\":\"'+data.img_name+'\", \"fromid\":\"'+fromid+'\", \"toid\":\"'+toid+'\", \"type\":\"say_img\"}'; ws.send(message); $(\"#file\").val(\"\"); // 清空，以便响应下一次的 change 时间 } else { // 上传失败 } } });}); PHP部分： 123456789101112131415161718192021222324252627282930313233343536/* 上传图片，返回图片地址 */public function uploadimg() { $file = $_FILES['file']; $fromid = input('fromid'); $toid = input('toid'); $online = input('online'); $suffix = strtolower(strrchr($file['name'], '.')); // 获取文件后缀 $type = ['.jpg', '.jpeg', '.png', '.gif']; if (!in_array($suffix, $type)) { return ['status' =&gt; 'img type erroe']; } if ($file['size'] / 1024 &gt; 5*1024) { // 如果大于5M return ['status' =&gt; 'img is too large']; } $filename = uniqid(\"chat_img_\", false); // 生成一个带前缀的唯一的微秒ID $uploadpath = ROOT_PATH . 'public\\\\uploads\\\\'; // 文件夹路径 $file_up = $uploadpath . $filename . $suffix; // 文件路径 $res = move_upload_file($file['tmp_name'], $file_up); if ($res) { $name = $filename . $suffix; $data['content'] = $name; $data['fromid'] = $fromid; $data['toid'] = $toid; $data['time'] = time(); $data['isread'] = $online; $data['type'] = 2; // 表示是图片消息 $message_id = Db::name('message')-&gt;insertGetId($data); if ($message_id) { return ['status' =&gt; 'ok', 'img_name' =&gt; $name]; } else { return ['status' =&gt; 'false']; } } } PHP GatewayWorker部分： 123456789101112131415/*...*/case \"say_img\" :{ $toid = $message_data['toid']; $fromid = $message_data['fromid']; $img_name = $message_data['data']; $data = [ 'type' =&gt; 'say_img', 'fromid' =&gt; $fromid. 'toid' =&gt; $toid, 'img_name' =&gt; $img_name ]; Gateway::sentToUid($toid, json_encode($date)); return ;} JS目标接收部分： 123456case \"say_img\" :{ // 添加到自己的聊天框中 $(\".chat-content\").append('&lt;div class=\"chat-text section-left flex\"&gt;span class=\"char-img\" style=\"background-image: url('+to_head+');\"&gt;&lt;/span&gt;&lt;span class=\"char-img\"&gt;&lt;i class=\"icon icon-sanjiao3 t-32\"&gt;&lt;/i&gt;&lt;img width=\"120em\" height=\"120em\" src=\"__ROOT__/uploads/'+message.img_name+'\"&gt;&lt;/span&gt; &lt;&lt;/div&gt;'); $(\".chat-content\").scrollTop(3000); // 滚动到底部} 参考：网易云课堂 https://study.163.com/course/courseLearn.htm?courseId=1005015012#/learn/video?lessonId=1051354078&amp;courseId=1005015012 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"JS","slug":"JS","permalink":"http://blog.iwxyi.com/tags/JS/"},{"name":"AJAX","slug":"AJAX","permalink":"http://blog.iwxyi.com/tags/AJAX/"},{"name":"jQuery","slug":"jQuery","permalink":"http://blog.iwxyi.com/tags/jQuery/"},{"name":"PHP","slug":"PHP","permalink":"http://blog.iwxyi.com/tags/PHP/"},{"name":"Gateway","slug":"Gateway","permalink":"http://blog.iwxyi.com/tags/Gateway/"}]},{"title":"Android自定义输入对话框，带联网","date":"2019-03-21T03:36:00.000Z","path":"2019/03/21/Android自定义输入对话框，带联网/","text":"自定义输入方式，回调方法，带输入后联网示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 @Overridepublic void onClick(View v) { switch (v.getId()) { case R.id.tv_nickname: inputDialog(\"nickname\", \"修改用户昵称\", User.nickname); break; }}/** * 弹出输入框 * @param aim 目标 * @param title 标题 * @param def 默认值 * @return 输入的字符串 */private String inputDialog(final String aim, String title, String def) { final String[] result = new String[1]; LayoutInflater factory = LayoutInflater.from(PersonActivity.this);//提示框 final View view = factory.inflate(R.layout.edit_box, null);//这里必须是final的 final EditText edit = (EditText) view.findViewById(R.id.editText);//获得输入框对象 edit.setText(def); new AlertDialog.Builder(PersonActivity.this) .setTitle(title)//提示框标题 .setView(view) .setPositiveButton(\"确定\",//提示框的两个按钮 new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { result[0] = edit.getText().toString(); onInputDialog(aim, edit.getText().toString()); } }) .setNegativeButton(\"取消\", null) .create().show(); return result[0];}/** * 输入框结束事件，自定义结果 * @param aim 目标 * @param s 字符串 */private void onInputDialog(String aim, String s) { switch (aim) { case \"nickname\": if (!canMatch(s, \"\\\\S+\")) { App.toast(\"用户名不能有空格\"); return; } mNicknameTv.setText(User.nickname = s); break; } updateContent(aim, s);}/** * 上传用户信息 * @param key 文件名 * @param val 数值 */private void updateContent(final String key, final String val) { String path = Paths.getNetpath(\"updateUserInfo\"); String[] params = new String[]{\"user_id\", User.id(), key, val}; ConnectUtil.Get(path, params, new StringCallback(){ @Override public void onFinish(String result) { if (result.equals(\"OK\")) { Snackbar.make(findViewById(R.id.fab), \"修改成功\", Snackbar.LENGTH_LONG) .setAction(\"Action\", null).show(); } else if (!result.isEmpty()) { Snackbar.make(findViewById(R.id.fab), \"修改失败:\"+ StringUtil.getXml(result, \"result\"), Snackbar.LENGTH_LONG) .setAction(\"Action\", null).show(); } } });}boolean canMatch(String str, String pat) { return StringUtil.canMatch(str, pat);} 布局 edit_box.xml 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\"&gt; &lt;EditText android:id=\"@+id/editText\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\"&gt; &lt;requestFocus&gt;&lt;/requestFocus&gt; &lt;/EditText&gt;&lt;/LinearLayout&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"},{"name":"HTTP","slug":"HTTP","permalink":"http://blog.iwxyi.com/tags/HTTP/"},{"name":"多线程","slug":"多线程","permalink":"http://blog.iwxyi.com/tags/多线程/"}]},{"title":"Android状态栏透明","date":"2019-03-21T03:32:00.000Z","path":"2019/03/21/Android状态栏透明/","text":"Java文件： 123456protected void onCreate(Bundle savedInstanceState) { /* ... */ //透明状态栏&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);} Xml文件： 1android:background=\"@drawable/background\" document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"JS复制字符串到剪贴板","date":"2019-03-16T07:37:00.000Z","path":"2019/03/16/JS复制字符串到剪贴板/","text":"简单原理： 12345document.createElement(\"textarea\");textArea.value = text;textArea.select();document.execCommand('copy');document.body.removeChild(textArea); 具体代码： 123456789101112131415161718192021222324252627282930function copyToClipboard (text) { if(text.indexOf('-') !== -1) { let arr = text.split('-'); text = arr[0] + arr[1]; } var textArea = document.createElement(\"textarea\"); textArea.style.position = 'fixed'; textArea.style.top = '0'; textArea.style.left = '0'; textArea.style.width = '2em'; textArea.style.height = '2em'; textArea.style.padding = '0'; textArea.style.border = 'none'; textArea.style.outline = 'none'; textArea.style.boxShadow = 'none'; textArea.style.background = 'transparent'; textArea.value = text; document.body.appendChild(textArea); textArea.select(); try { var successful = document.execCommand('copy'); var msg = successful ? '成功复制到剪贴板' : '该浏览器不支持点击复制到剪贴板'; alert(msg); } catch (err) { alert('该浏览器不支持点击复制到剪贴板'); } document.body.removeChild(textArea);} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"JS","slug":"JS","permalink":"http://blog.iwxyi.com/tags/JS/"}]},{"title":"Android线性时间选择器","date":"2019-03-16T03:24:00.000Z","path":"2019/03/16/Android线性时间选择器/","text":"build.gradle(Module:app) 1implementation 'net.codecrafted:lineartimepicker:1.0.0' // 线性日期时间选择器 日期选择 .java 1234567891011121314151617181920212223boolean data_tutorial = false; // 是否出现使用帮助if (SettingsUtil.getInt(getApplicationContext(), \"LinearDatePicker_tutorial\") != 1) { data_tutorial = true;}LinearDatePickerDialog.Builder.with(RecordActivity.this) .setYear(addYear) .setMinYear(2000) .setMaxYear(2030) .setShowTutorial(data_tutorial) .setButtonCallback(new LinearDatePickerDialog.ButtonCallback() { @Override public void onPositive(DialogInterface dialog, int year, int month, int day) { SettingsUtil.setVal(getApplicationContext(), \"LinearDataPicker_tutorial\", 1); /*...code...*/ } @Override public void onNegative(DialogInterface dialog) { } }) .build() .show(); 时间选择 .java 1234567891011121314151617181920boolean time_tutorial = false;if (SettingsUtil.getInt(getApplicationContext(), \"LinearTimePicker_tutorial\") != 1) { time_tutorial = true;}LinearTimePickerDialog dialog = LinearTimePickerDialog.Builder.with(RecordActivity.this) .setShowTutorial(time_tutorial) .setButtonCallback(new LinearTimePickerDialog.ButtonCallback() { @Override public void onPositive(DialogInterface dialog, int hour, int minutes) { SettingsUtil.setVal(getApplicationContext(), \"LinearDataPicker_tutorial\", 1); /*...code...*/ } @Override public void onNegative(DialogInterface dialog) { } }) .build();dialog.show(); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Android简单联网应用","date":"2019-03-16T03:17:00.000Z","path":"2019/03/16/Android简单联网应用/","text":"解决Handler问题 1234567891011121314151617181920212223242526272829static class MyHandler extends Handler { //注意下面的“PopupActivity”类是MyHandler类所在的外部类，即所在的activity WeakReference&lt;PopupActivity&gt; mActivity; MyHandler(PopupActivity activity) { mActivity = new WeakReference&lt;PopupActivity&gt;(activity); } @Override public void handleMessage(Message msg) { PopupActivity theActivity = mActivity.get(); switch (msg.what) { //此处可以根据what的值处理多条信息 case 0x0001: //这里可以改变activity中的UI控件的状态 theActivity.textView.setText(R.string.hello_world); break; } case 0x0002: //这里可以改变activity中的UI控件的状态 theActivity.textView.setText(R.string.welcome); break; /*这里可以有多条要处理信息的操作*/ /*... ...*/ } }}; //实例化一个MyHandler对象MyHandler testHandler = new MyHandler(this); private void test1() { //这里发送了一个空消息，空消息的what值是0x0001 testHandler.sendEmptyMessage(0x0001); } private void test2() { //这里发送了一个空消息，空消息的what值是0x0001 testHandler.sendEmptyMessage(0x0002);} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"},{"name":"HTTP","slug":"HTTP","permalink":"http://blog.iwxyi.com/tags/HTTP/"},{"name":"多线程","slug":"多线程","permalink":"http://blog.iwxyi.com/tags/多线程/"}]},{"title":"Android圆形头像控件","date":"2019-03-07T03:27:00.000Z","path":"2019/03/07/Android圆形头像控件/","text":"1、自定义控件方式 自定义类：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204import android.content.Context;import android.content.res.TypedArray;import android.graphics.Bitmap;import android.graphics.Canvas;import android.graphics.Paint;import android.graphics.PorterDuff;import android.graphics.PorterDuffXfermode;import android.graphics.Rect;import android.graphics.drawable.BitmapDrawable;import android.graphics.drawable.Drawable;import android.graphics.drawable.NinePatchDrawable;import android.util.AttributeSet;import android.widget.ImageView; import com.iruiyou.pet.R; /** * * @author sgf * 自定义圆形头像 * */public class RoundImageView extends ImageView { private int mBorderThickness = 0; private Context mContext; private int defaultColor = 0xFFFFFFFF; // 外圆边框颜色 private int mBorderOutsideColor = 0; // 内圆边框颜色 private int mBorderInsideColor = 0; // RoundImageView控件默认的长、宽 private int defaultWidth = 0; private int defaultHeight = 0; public RoundImageView(Context context) { super(context); mContext = context; } public RoundImageView(Context context, AttributeSet attrs) { super(context, attrs); mContext = context; // 设置RoundImageView的属性值，比如颜色，宽度等 setRoundImageViewAttributes(attrs); } public RoundImageView(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); mContext = context; setRoundImageViewAttributes(attrs); } // 从attr.xml文件中获取属性值，并给RoundImageView设置 private void setRoundImageViewAttributes(AttributeSet attrs) { TypedArray a = mContext.obtainStyledAttributes(attrs, R.styleable.round_image_view); mBorderThickness = a.getDimensionPixelSize( R.styleable.round_image_view_border_width, 0); mBorderOutsideColor = a.getColor( R.styleable.round_image_view_border_outcolor, defaultColor); mBorderInsideColor = a.getColor( R.styleable.round_image_view_border_incolor, defaultColor); a.recycle(); } // 具体解释：比如我自定义一个控件，怎么实现呢，以RoundImageView为例，首先是继承ImageView,然后实现其构造函数，在构造函数中，获取attr中的属性值（再次解释：这里获取的具体的这个属性的值是怎么来的呢？比如颜色和宽度，这个在attr.xml中定义了相关的名字，而在使用RoundImageView的xml布局文件中，我们会设置其值，这里需要用的值，就是从那里设置的），并设置在本控件中，然后继承onDraw方法，画出自己想要的图形或者形状即可 /** * 这个是继承的父类的onDraw方法 * * onDraw和下面的方法不用管，基本和学习自定义没关系，就是实现怎么画圆的，你可以改变下面代码试着画三角形头像，哈哈 */ @Override protected void onDraw(Canvas canvas) { Drawable drawable = getDrawable(); if (drawable == null) { return; } if (getWidth() == 0 || getHeight() == 0) { return; } this.measure(0, 0); if (drawable.getClass() == NinePatchDrawable.class) return; Bitmap b = ((BitmapDrawable) drawable).getBitmap(); Bitmap bitmap = b.copy(Bitmap.Config.ARGB_8888, true); if (defaultWidth == 0) { defaultWidth = getWidth(); } if (defaultHeight == 0) { defaultHeight = getHeight(); } int radius = 0; // 这里的判断是如果内圆和外圆设置的颜色值不为空且不是默认颜色，就定义画两个圆框，分别为内圆和外圆边框 if (mBorderInsideColor != defaultColor &amp;&amp; mBorderOutsideColor != defaultColor) { radius = (defaultWidth &lt; defaultHeight ? defaultWidth : defaultHeight) / 2 - 2 * mBorderThickness; // 画内圆 drawCircleBorder(canvas, radius + mBorderThickness / 2, mBorderInsideColor); // 画外圆 drawCircleBorder(canvas, radius + mBorderThickness + mBorderThickness / 2, mBorderOutsideColor); } else if (mBorderInsideColor != defaultColor &amp;&amp; mBorderOutsideColor == defaultColor) {// 这里的是如果内圆边框不为空且颜色值不是默认值，就画一个内圆的边框 radius = (defaultWidth &lt; defaultHeight ? defaultWidth : defaultHeight) / 2 - mBorderThickness; drawCircleBorder(canvas, radius + mBorderThickness / 2, mBorderInsideColor); } else if (mBorderInsideColor == defaultColor &amp;&amp; mBorderOutsideColor != defaultColor) {// 这里的是如果外圆边框不为空且颜色值不是默认值，就画一个外圆的边框 radius = (defaultWidth &lt; defaultHeight ? defaultWidth : defaultHeight) / 2 - mBorderThickness; drawCircleBorder(canvas, radius + mBorderThickness / 2, mBorderOutsideColor); } else {// 这种情况是没有设置属性颜色的情况下，即没有边框的情况 radius = (defaultWidth &lt; defaultHeight ? defaultWidth : defaultHeight) / 2; } Bitmap roundBitmap = getCroppedRoundBitmap(bitmap, radius); canvas.drawBitmap(roundBitmap, defaultWidth / 2 - radius, defaultHeight / 2 - radius, null); } /** * 获取裁剪后的圆形图片 * * @param bmp * @param radius * 半径 * @return */ public Bitmap getCroppedRoundBitmap(Bitmap bmp, int radius) { Bitmap scaledSrcBmp; int diameter = radius * 2; // 为了防止宽高不相等，造成圆形图片变形，因此截取长方形中处于中间位置最大的正方形图片 int bmpWidth = bmp.getWidth(); int bmpHeight = bmp.getHeight(); int squareWidth = 0, squareHeight = 0; int x = 0, y = 0; Bitmap squareBitmap; if (bmpHeight &gt; bmpWidth) {// 高大于宽 squareWidth = squareHeight = bmpWidth; x = 0; y = (bmpHeight - bmpWidth) / 2; // 截取正方形图片 squareBitmap = Bitmap.createBitmap(bmp, x, y, squareWidth, squareHeight); } else if (bmpHeight &lt; bmpWidth) {// 宽大于高 squareWidth = squareHeight = bmpHeight; x = (bmpWidth - bmpHeight) / 2; y = 0; squareBitmap = Bitmap.createBitmap(bmp, x, y, squareWidth, squareHeight); } else { squareBitmap = bmp; } if (squareBitmap.getWidth() != diameter || squareBitmap.getHeight() != diameter) { scaledSrcBmp = Bitmap.createScaledBitmap(squareBitmap, diameter, diameter, true); } else { scaledSrcBmp = squareBitmap; } Bitmap output = Bitmap.createBitmap(scaledSrcBmp.getWidth(), scaledSrcBmp.getHeight(), Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(output); Paint paint = new Paint(); Rect rect = new Rect(0, 0, scaledSrcBmp.getWidth(), scaledSrcBmp.getHeight()); paint.setAntiAlias(true); paint.setFilterBitmap(true); paint.setDither(true); canvas.drawARGB(0, 0, 0, 0); canvas.drawCircle(scaledSrcBmp.getWidth() / 2, scaledSrcBmp.getHeight() / 2, scaledSrcBmp.getWidth() / 2, paint); paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN)); canvas.drawBitmap(scaledSrcBmp, rect, rect, paint); bmp = null; squareBitmap = null; scaledSrcBmp = null; return output; } /** * 画边缘的圆，即内圆或者外圆 */ private void drawCircleBorder(Canvas canvas, int radius, int color) { Paint paint = new Paint(); /* 去锯齿 */ paint.setAntiAlias(true); paint.setFilterBitmap(true); paint.setDither(true); paint.setColor(color); /* 设置paint的 style 为STROKE：空心 */ paint.setStyle(Paint.Style.STROKE); /* 设置paint的外框宽度 */ paint.setStrokeWidth(mBorderThickness); canvas.drawCircle(defaultWidth / 2, defaultHeight / 2, radius, paint); }} 属性文件12345678910&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;declare-styleable name=\"round_image_view\"&gt; &lt;attr name=\"border_width\" format=\"dimension\" /&gt; &lt;attr name=\"border_incolor\" format=\"color\" /&gt; &lt;attr name=\"border_outcolor\" format=\"color\"&gt;&lt;/attr&gt; &lt;/declare-styleable&gt; &lt;/resources&gt; 用法：123456789101112&lt;com.iruiyou.pet.utils.RoundImageView android:id=\"@+id/headIv\" android:layout_width=\"125dp\" android:layout_height=\"125dp\" android:layout_marginTop=\"92dp\" android:src=\"@drawable/head_home\" loonggg:border_incolor=\"#000fff\" loonggg:border_outcolor=\"#fff000\" loonggg:border_width=\"10dp\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\"/&gt; 2、使用开源库见下方网页 参考：https://blog.csdn.net/shenggaofei/article/details/83793536 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"PHP Redis","date":"2019-03-05T08:29:00.000Z","path":"2019/03/05/PHP-Redis/","text":"安装开始在 PHP 中使用 Redis 前， 我们需要确保已经安装了 redis 服务及 PHP redis 驱动，且你的机器上能正常使用 PHP。 接下来让我们安装 PHP redis 驱动：下载地址为:https://github.com/phpredis/phpredis/releases。 PHP安装redis扩展以下操作需要在下载的 phpredis 目录中完成： 12345$ wget https://github.com/phpredis/phpredis/archive/3.1.4.tar.gz$ cd phpredis-3.1.4 # 进入 phpredis 目录$ /usr/local/php/bin/phpize # php安装后的路径$ ./configure --with-php-config=/usr/local/php/bin/php-config$ make &amp;&amp; make install 修改php.ini文件1vi /usr/local/php/lib/php.ini 增加如下内容: 123extension_dir = \"/usr/local/php/lib/php/extensions/no-debug-zts-20090626\"extension=redis.so 安装完成后重启php-fpm 或 apache。查看phpinfo信息，就能看到redis扩展。 连接到 redis 服务12345678&lt;?php //连接本地的 Redis 服务 $redis = new Redis(); $redis-&gt;connect('127.0.0.1', 6379); echo \"Connection to server successfully\"; //查看服务是否运行 echo \"Server is running: \" . $redis-&gt;ping();?&gt; 执行脚本，输出结果为： 12Connection to server sucessfullyServer is running: PONG Redis PHP String(字符串) 实例12345678910&lt;?php //连接本地的 Redis 服务 $redis = new Redis(); $redis-&gt;connect('127.0.0.1', 6379); echo \"Connection to server successfully\"; //设置 redis 字符串数据 $redis-&gt;set(\"tutorial-name\", \"Redis tutorial\"); // 获取存储的数据并输出 echo \"Stored string in redis:: \" . $redis-&gt;get(\"tutorial-name\");?&gt; 执行脚本，输出结果为： 12Connection to server sucessfullyStored string in redis:: Redis tutorial Redis PHP List(列表) 实例1234567891011121314&lt;?php //连接本地的 Redis 服务 $redis = new Redis(); $redis-&gt;connect('127.0.0.1', 6379); echo \"Connection to server successfully\"; //存储数据到列表中 $redis-&gt;lpush(\"tutorial-list\", \"Redis\"); $redis-&gt;lpush(\"tutorial-list\", \"Mongodb\"); $redis-&gt;lpush(\"tutorial-list\", \"Mysql\"); // 获取存储的数据并输出 $arList = $redis-&gt;lrange(\"tutorial-list\", 0 ,5); echo \"Stored string in redis\"; print_r($arList);?&gt; 执行脚本，输出结果为： 12345Connection to server sucessfullyStored string in redisMysqlMongodbRedis Redis PHP Keys 实例12345678910&lt;?php //连接本地的 Redis 服务 $redis = new Redis(); $redis-&gt;connect('127.0.0.1', 6379); echo \"Connection to server successfully\"; // 获取数据并输出 $arList = $redis-&gt;keys(\"*\"); echo \"Stored keys in redis:: \"; print_r($arList);?&gt; 执行脚本，输出结果为： 1234Connection to server sucessfullyStored string in redis::tutorial-nametutorial-list 参考：https://www.runoob.com/redis/redis-php.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.iwxyi.com/tags/PHP/"},{"name":"Redis","slug":"Redis","permalink":"http://blog.iwxyi.com/tags/Redis/"}]},{"title":"AJAX","date":"2019-02-28T07:42:00.000Z","path":"2019/02/28/AJAX/","text":"纯粹的 AJAX 1234567891011121314151617181920212223function saveInfo() { var XHR = null; var FD = new FormData(); var name = document.getElementById(\"name\").value; if (window.XMLHttpRequest) XHR = new XMLHttpRequest(); else if (window.ActiveXObject) XHR = new ActiveXObject(\"Microsoft.XMLHTTP\"); FD.append(\"name\", name); XHR.onreadystatechange = function () { if (XHR.readyState == 4 &amp;&amp; XHR.status == 200) { var text = XHR.responseText; // 返回的文本 } } XHR.open('POST', 'index.php', true) XHR.send(FD);} 以云笺保存信息的函数为例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function saveInfo() { var XHR; var FD = new FormData(); var name = document.getElementById(\"name\").value; var info = document.getElementById(\"info\").value; if (name == \"\") return ; // 去掉首尾空格 var noblank_name = name.replace(/(^\\s*)|(\\s*$)/g,\"\"); if (noblank_name != name){ name = noblank_name; document.getElementById(\"name\").value = name; } XHR = null; if (window.XMLHttpRequest) { XHR = new XMLHttpRequest(); } else if (window.ActiveXObject) { XHR = new ActiveXObject(\"Microsoft.XMLHTTP\"); } FD.append(\"name\", name); FD.append(\"info\", info); XHR.onreadystatechange = function () { if (XHR.readyState == 4 &amp;&amp; XHR.status == 200) { mdui.snackbar({ message: '保存成功', buttonText: '历史', onButtonClick: function() { window.open(\"index.php?h=1&amp;n=\" + encodeURI(name)); }, }); save_time = (new Date()).getTime(); save_text = info; } } XHR.open('POST', 'index.php', true); XHR.send(FD); document.getElementById('info').focus(); return false;} jQuery用法1234567891011// 实时聊天获取头像例子function get_head(fromid, toid) { $.post( API_URL+\"getHead\", // 网址 {\"fromid\":fromid, \"toid\":toid}, // 数据 function(e) { // 返回后 from_head = e.from_head; to_head = e.to_head; }, \"json\" // 格式是 json );} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"JS","slug":"JS","permalink":"http://blog.iwxyi.com/tags/JS/"},{"name":"AJAX","slug":"AJAX","permalink":"http://blog.iwxyi.com/tags/AJAX/"},{"name":"jQuery","slug":"jQuery","permalink":"http://blog.iwxyi.com/tags/jQuery/"}]},{"title":"Java Lambda表达式简写","date":"2019-02-28T05:11:00.000Z","path":"2019/02/28/Java-Lambda表达式简写/","text":"1、取代匿名内部类无参函数简写如果需要新建一个线程，一种常见的写法是这样： 1234567// JDK7 匿名内部类写法new Thread(new Runnable(){// 接口名 @Override public void run(){// 方法名 System.out.println(\"Thread run()\"); }}).start(); 使用lambda进行无参函数的简写： 1234// JDK8 Lambda表达式写法new Thread( () -&gt; System.out.println(\"Thread run()\")// 省略接口名和方法名).start(); 如果函数体有多行，可以用大括号括起来: 123456new Thread( () -&gt; { System.out.print(\"Hello\"); System.out.println(\" Hoolee\"); }).start(); 有参函数简写如果要给一个字符串列表通过自定义比较器，按照字符串长度进行排序，Java 7的书写形式如下： 123456789101112// JDK7 匿名内部类写法List&lt;String&gt; list = Arrays.asList(\"I\", \"love\", \"you\", \"too\");Collections.sort(list, new Comparator&lt;String&gt;(){// 接口名 @Override public int compare(String s1, String s2){// 方法名 if(s1 == null) return -1; if(s2 == null) return 1; return s1.length()-s2.length(); }}); 上述代码通过内部类重载了Comparator接口的compare()方法，实现比较逻辑。采用Lambda表达式可简写如下： 123456789// JDK8 Lambda表达式写法List&lt;String&gt; list = Arrays.asList(\"I\", \"love\", \"you\", \"too\");Collections.sort(list, (s1, s2) -&gt;{// 省略参数表的类型 if(s1 == null) return -1; if(s2 == null) return 1; return s1.length()-s2.length();}); 自定义函数接口自定义函数接口很容易，只需要编写一个只有一个抽象方法的接口即可。 12345// 自定义函数接口@FunctionalInterfacepublic interface ConsumerInterface&lt;T&gt;{ void accept(T t);} 上面代码中的@FunctionalInterface是可选的，但加上该标注编译器会帮你检查接口是否符合函数接口规范。就像加入@Override标注会检查是否重载了函数一样。 有了上述接口定义，就可以写出类似如下的代码： 1ConsumerInterface&lt;String&gt; consumer = str -&gt; System.out.println(str); 进一步的，还可以这样使用： 1234567891011class MyStream&lt;T&gt;{ private List&lt;T&gt; list; ... public void myForEach(ConsumerInterface&lt;T&gt; consumer){// 1 for(T t : list){ consumer.accept(t); } }}MyStream&lt;String&gt; stream = new MyStream&lt;String&gt;();stream.myForEach(str -&gt; System.out.println(str));// 使用自定义函数接口书写Lambda表达式 参考：https://www.cnblogs.com/CarpenterLee/p/5978721.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Lambda","slug":"Lambda","permalink":"http://blog.iwxyi.com/tags/Lambda/"},{"name":"Java","slug":"Java","permalink":"http://blog.iwxyi.com/tags/Java/"}]},{"title":"C++ generate生成","date":"2019-02-27T23:51:00.000Z","path":"2019/02/28/C-generate生成/","text":"根据首地址和尾地址来赋值： 123456template&lt;class ForwardIterator, class Generator&gt;void generate( ForwardIterator _First, ForwardIterator _Last, Generator _Gen); 每次调用该对象，函数为范围的每个元素调用，且不需要返回相同的值。例如，从文件读取或引用和修改本地状态。 生成器的结果类型必须可转换为可用于向前迭代器类型的值范围的。 示例： 1234567891011121314151617#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;ostream&gt;int main( ){ using namespace std; vector &lt;int&gt; v1 ( 5 ); vector &lt;int&gt;::iterator Iter1; generate ( v1.begin ( ), v1.end ( ) , rand ); for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ ) cout &lt;&lt; *Iter1 &lt;&lt; \" \";} // 根据首地址和元素数量来赋值 template&lt;class OutputIterator, class Diff, class Generator&gt; void generate_n( OutputIterator First, Diff Count, Generator Gen); 参见：VS2015https://msdn.microsoft.com/zh-cn/library/46h7chx6.aspx document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"}]},{"title":"Android选取相册图片并压缩","date":"2019-02-27T03:25:00.000Z","path":"2019/02/27/Android选取相册图片并压缩/","text":"现在手机中相机的像素越来越高因,手机照的相片就越来越来大, 我们想通过选择相册中图片来显示在界面中,或者进行分享. 因为图片太大的原因很容易造成手机出现OMM而崩溃,一些分享照片的平台对分享图片的大小也有一定的限制.所以我们就必须对从相册选出来的图片进行压缩. 选取图片1234567891011121314151617181920212223242526/** * 打开系统相册 */public void openAlbum(){ Intent intent = new Intent(Intent.ACTION_GET_CONTENT); intent.setType(\"image/*\"); //设置请求码，以便我们区分返回的数据 startActivityForResult(intent, 100);} @Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) { if (100 == requestCode) { if (data != null) { //获取数据、获取内容解析者对象 try { Bitmap mBitmap = BitmapFactory.decodeStream( getContentResolver().openInputStream(data.getData())); imageview.setImageBitmap(mBitmap); } catch (FileNotFoundException e) { e.printStackTrace(); } } }} 压缩打开的图片下面看具体代码: 1234567891011121314151617181920212223242526272829303132333435/** * 计算位图的采样比例大小 * @param options * @param imageView 控件(根据控件的大小进行压缩) * @return */ private static int calculatInSampleSize(BitmapFactory.Options options, ImageView imageView) { //获取位图的原宽高 final int w = options.outWidth; final int h = options.outHeight; if (imageView!=null){ //获取控件的宽高 final int reqWidth = imageView.getWidth(); final int reqHeight = imageView.getHeight(); //默认为一(就是不压缩) int inSampleSize = 1; //如果原图的宽高比需要的图片宽高大 if (w &gt; reqWidth || h &gt; reqHeight) { if (w &gt; h) { inSampleSize = Math.round((float) h / (float) reqHeight); } else { inSampleSize = Math.round((float) w / (float) reqWidth); } } System.out.println(\"压缩比为:\" + inSampleSize); return inSampleSize; }else { return 1; } } 这里是对图像压缩比的计算,因为我项目的原因,所以我的压缩比计算是通过传入的ImageView的宽高来计算的,如果想根据自己设置的宽高来压缩只要把,传入的参数:ImageView imageView，改成int width,int height 然后再修改方法中相应的代码即可! 这个方法在很多博客中也提到过… 1234567891011121314151617181920212223242526272829303132/** * 将Uri转换成Bitmap * @param context * @param uri * @param options * @return */ public static Bitmap decodeBitmap(Context context, Uri uri, BitmapFactory.Options options) { Bitmap bitmap = null; if (uri != null) { ContentResolver cr = context.getContentResolver(); InputStream inputStream = null; try { /** * 将图片的Uri地址转换成一个输入流 */ inputStream = cr.openInputStream(uri); /** * 将输入流转换成Bitmap */ bitmap = BitmapFactory.decodeStream(inputStream, null, options); assert inputStream != null; inputStream.close(); } catch (Exception e) { e.printStackTrace(); } } return bitmap; } 这个方法是将将Uri地址转换成一个Bitmap. 因为我们从相册选择图片后会在 OnActivityResult返回一个Intent对象data,我们通过这个 data的getdata()方法就可以得到一个Uri 地址… 然后就是最后一个方法了 1234567891011121314151617181920212223/** * 对图片进行重新采样 * @param context * @param uri 图片的Uri地址 * @param imageView * @return */ public static Bitmap compressBitmap(Context context, Uri uri, ImageView imageView) { BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = false; decodeBitmap(context, uri, options); options = new BitmapFactory.Options(); options.inSampleSize = calculatInSampleSize(options, imageView); Bitmap bitmap = null; try { bitmap = decodeBitmap(context, uri, options); } catch (Exception e) { e.printStackTrace(); } return bitmap; } 这个方法是将得到Bitmap 通过计算出来的压缩比 进行重新采样返回一个压缩后的Bitmap对象!,也是我们最终调用的方法,方法简单不必多说! 具体使用:把上面的代码写在一个工具类中,然后在需要使用的地方调用 compressBitmap()即可! 1234567891011if (requestCode == GALLERY_REQUEST_CODE) {//是否是从图库返回 try { Uri originalUri = data.getData(); // 获得图片的uri //对图片进行压缩 Bitmap bitmap = BitmapCompress.compressBitmap(getActivity(),originalUri,ivpapers); ivpapers.setImageBitmap(bitmap); System.out.println(\"压缩后图片的高度:\"+bitmap.getHeight()); System.out.println(\"压缩后图片的宽度:\"+bitmap.getWidth()); } catch (Exception e) { e.printStackTrace(); } 博参考：https://blog.csdn.net/qq_23179075/article/details/52261588 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Android双指触摸放大图片","date":"2019-02-26T03:23:00.000Z","path":"2019/02/26/Android双指触摸放大图片/","text":"View.OnTouchListener，MotionEvent.ACTION_POINTER_DOWN、MotionEvent.ACTION_MOVE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package com.tongzhen.magnify_test;import android.app.Activity;import android.graphics.Matrix;import android.graphics.PointF;import android.os.Bundle;import android.view.MotionEvent;import android.view.View;import android.widget.ImageView;public class MainActivity extends Activity implements View.OnTouchListener { private ImageView img; // 縮放控制 private Matrix savedMatrix = new Matrix(); // 保存按下时的状态 private Matrix matrix = new Matrix(); // 每次和按下的状态进行比较 // 不同状态的表示： private static final int NONE = 0; private static final int DRAG = 1; private static final int ZOOM = 2; private int mode = NONE; // 定义第一个按下的点，两只接触点的中点，以及两指按下的距离： private PointF startPoint = new PointF(); private PointF midPoint = new PointF(); private float oriDis = 1f; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); img = (ImageView) this.findViewById(R.id.main_imgZooming); img.setOnTouchListener(this); } // 计算两个触摸点之间的距离 private float distance(MotionEvent event) { float x = event.getX(0) - event.getX(1); float y = event.getY(0) - event.getY(1); return Float.valueOf(String.valueOf(Math.sqrt(x * x + y * y))) ; } // 计算两个触摸点的中点 private PointF middle(MotionEvent event) { float x = event.getX(0) + event.getX(1); float y = event.getY(0) + event.getY(1); return new PointF(x / 2, y / 2); } @Override public boolean onTouch(View v, MotionEvent event) { if (v == img) { ImageView view = (ImageView) v; switch (event.getAction() &amp; MotionEvent.ACTION_MASK) { // 单指按下 case MotionEvent.ACTION_DOWN: matrix.set(view.getImageMatrix()); savedMatrix.set(matrix); startPoint.set(event.getX(), event.getY()); mode = DRAG; break; // 双指按下 case MotionEvent.ACTION_POINTER_DOWN: oriDis = distance(event); if (oriDis &gt; 10f) { savedMatrix.set(matrix); midPoint = middle(event); mode = ZOOM; } break; // 手指放开 case MotionEvent.ACTION_UP: case MotionEvent.ACTION_POINTER_UP: mode = NONE; break; // 单指滑动事件 case MotionEvent.ACTION_MOVE: if (mode == DRAG) { // 是一个手指拖动 matrix.set(savedMatrix); matrix.postTranslate(event.getX() - startPoint.x, event.getY() - startPoint.y); } else if (mode == ZOOM) { // 两个手指滑动 float newDist = distance(event); if (newDist &gt; 10f) { matrix.set(savedMatrix); float scale = newDist / oriDis; // 压缩比例 matrix.postScale(scale, scale, midPoint.x, midPoint.y); } } break; default : break; } // 设置ImageView的Matrix view.setImageMatrix(matrix); } return true; }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Android动态创建控件","date":"2019-02-26T03:09:00.000Z","path":"2019/02/26/Android动态创建控件/","text":"动态创建绝对布局的控件12345678void initView() { TextView tv = new TextView(this); tv.setText(\"TextView的内容\"); AbsoluteLayout.LayoutParams lp1 = new AbsoluteLayout.LayoutParams( ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, 0,100); absoluteLayout.addView(tv, lp1); //tv.layout(100, 100, 100, 100);} 如果原来是 LinearLayout 等布局，则可以嵌套在一个 AbsoluteLayout 中 控件移动直接 layout 方法就可以，但是有些不能这样移动，于是要用到 LayoutParams： 123// 动态创建AbsoluteLayout.LayoutParams lp = new AbsoluteLayout.LayoutParams( ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, 0,100); 1234LayoutParams layoutParams=tv.getLayoutParams();layoutParams.height=x;layoutParams.width=y;tv.setLayoutParams(layoutParams); 来个复杂一点的网上找的野教程 12345678910111213141516171819202122232425262728293031323334353637public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); &nbsp; //设置界面的布局 RelativeLayout relativeLayout = new RelativeLayout(this); setContentView(relativeLayout); &nbsp; //添加一个AbsoluteLayout子布局,并给这个布局添加一个button AbsoluteLayout abslayout = new AbsoluteLayout (this); abslayout.setId(11); Buttonbtn1 = new Button(this); btn1.setText(”thisis a abslayout button”); btn1.setId(1); AbsoluteLayout.LayoutParams lp0 = new AbsoluteLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, 100, 0); abslayout.addView(btn1, lp0 ); //将这个子布局添加到主布局中 RelativeLayout.LayoutParams lp1 = new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); lp1.addRule(RelativeLayout.ALIGN_PARENT_TOP); lp1.addRule(RelativeLayout.CENTER_HORIZONTAL, RelativeLayout.TRUE); relativeLayout.addView(abslayout , lp1); &nbsp; //再添加一个子布局 RelativeLayout relativeLayout1 = new RelativeLayout(this); Button btn2 = newButton(this); btn2.setText(”thisis a relativeLayout1 button”); btn2.setId(2); RelativeLayout.LayoutParams lp2 = new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT); lp2.addRule(RelativeLayout.ALIGN_PARENT_TOP); lp2.addRule(RelativeLayout.CENTER_HORIZONTAL, RelativeLayout.TRUE); relativeLayout1.addView(btn2 , lp2); &nbsp; //将这个布局添加到主布局中 RelativeLayout.LayoutParams lp11 = new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); lp11.addRule(RelativeLayout.BELOW , 11); relativeLayout.addView(relativeLayout1 , lp11);} 以上代码执行的操作是： 创建一个RelativeLayout relativeLayou创建一个AbsoluteLayout abslayout创建一个Button btn1把btn1添加到abslayout中，然后再把abslayout添加到relativeLayout中然后又创建了一个RelativeLayout relativeLayout1在创建一个Button btn2把btn2添加到relativeLayout1上最后把relativeLayout1添加到了relativeLayout document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Android等待对话框","date":"2019-02-23T03:06:00.000Z","path":"2019/02/23/Android等待对话框/","text":"导入包(自动) 1import android.app.ProgressDialog; 声明全局变量 1private ProgressDialog progressDialog; 显示对话框 1progressDialog = ProgressDialog.show(this, \"请稍等\", \"正在登录\", true, false); 关闭对话框 12if (progressDialog != null) progressDialog.dismiss(); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Android Toast获取全局上下文的静态方法","date":"2019-02-21T02:57:00.000Z","path":"2019/02/21/Android-Toast获取全局上下文的静态方法/","text":"用这个方法，toast即可全局使用…… 因为发现 Log 有时候会打印不出来（强转或出错），所以就改用 toast 在Android的清单文件做如下申明： 123&lt;application android:name=\"com.xyz.MyApplication\"&gt; ...&lt;/application&gt; 然后写这个类： 12345678910111213public class MyApplication extends Application{ private static Context context; public void onCreate(){ super.onCreate(); MyApplication.context = getApplicationContext(); } public static Context getAppContext() { return MyApplication.context; } } 调用MyApplication.getAppContext()来静态的获取你应用程序的context。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Android List BaseAdapter","date":"2019-02-20T02:50:00.000Z","path":"2019/02/20/Android-List-BaseAdapter/","text":"BaseAdapter 12345678910111213141516171819202122232425262728293031323334353637383940414243public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ListView lv = findViewById(R.id.lv); lv.setAdapter(new MyListAdapter()); // 设置 数据适配器 } // 实现 BaseAdapter 方法 private class MyListAdapter extends BaseAdapter { @Override public int getCount() { return 4; } @Override public Object getItem(int position) { return null; } @Override public long getItemId(int position) { return 0; } @Override public View getView(int position, View convertView, ViewGroup parent) { TextView tv; if (convertView == null) { tv = new TextView(MainActivity.this); } else { tv = (TextView) convertView; } tv.setText(\"索引：\" + position); return tv; } }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Android项目精简","date":"2019-02-15T02:37:00.000Z","path":"2019/02/15/Android项目精简/","text":"Build –&gt; Clean Project 可以清理出很大一部分的空间 手动删除以下文件或者目录 Dir : ProjectFolder/build Dir : ProjectFolder/app/build Dir : ProjectFolder/.gradle Dir : ProjectFolder/.idea Dir : ProjectFolder/captures File : ProjectFolder/*.iml File : ProjectFolder/local.properties File : ProjectFolder/.DS_Store File : ProjectFolder/.externalNativeBuild document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"},{"name":"项目管理","slug":"项目管理","permalink":"http://blog.iwxyi.com/tags/项目管理/"}]},{"title":"Android PopupMenu弹出菜单","date":"2019-02-14T02:52:00.000Z","path":"2019/02/14/Android-PopupMenu弹出菜单/","text":"菜单文件 12345678910&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:id=\"@+id/exit\" android:title=\"退出\"/&gt; &lt;item android:id=\"@+id/set\" android:title=\"设置\"/&gt; &lt;item android:id=\"@+id/account\" android:title=\"账号\"/&gt;&lt;/menu&gt; 代码文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.example.menutest03;import android.app.Activity;import android.os.Bundle;import android.view.MenuInflater;import android.view.MenuItem;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.PopupMenu;import android.widget.PopupMenu.OnMenuItemClickListener;import android.widget.Toast;public class MainActivity extends Activity implements OnClickListener,OnMenuItemClickListener{ private Button button1; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button1 = (Button)findViewById(R.id.button1); button1.setOnClickListener(this); } //点击按钮后，加载弹出式菜单 @Override public void onClick(View v) { //创建弹出式菜单对象（最低版本11） PopupMenu popup = new PopupMenu(this, v);//第二个参数是绑定的那个view //获取菜单填充器 MenuInflater inflater = popup.getMenuInflater(); //填充菜单 inflater.inflate(R.menu.main, popup.getMenu()); //绑定菜单项的点击事件 popup.setOnMenuItemClickListener(this); //显示(这一行代码不要忘记了) popup.show(); } //弹出式菜单的单击事件处理 @Override public boolean onMenuItemClick(MenuItem item) { // TODO Auto-generated method stub switch (item.getItemId()) { case R.id.exit: Toast.makeText(this, \"退出\", Toast.LENGTH_SHORT).show(); break; case R.id.set: Toast.makeText(this, \"设置\", Toast.LENGTH_SHORT).show(); break; case R.id.account: Toast.makeText(this, \"账号\", Toast.LENGTH_SHORT).show(); break; default: break; } return false; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Qt生成桌面快捷方式","date":"2019-02-11T09:02:00.000Z","path":"2019/02/11/Qt生成桌面快捷方式/","text":"创建桌面快捷方式1234static void addLinkToDeskTop(const QString&amp; filename,const QString&amp; name){ QFile::link(filename, QStandardPaths::writableLocation(QStandardPaths::DesktopLocation).append(\"/\").append(name+\".lnk\"));} 删除桌面快捷方式1234567static bool delDeskTopLink(const QString&amp; name){ QString fileName = QStandardPaths::writableLocation(QStandardPaths::DesktopLocation).append(\"/\").append(name+\".lnk\"); if(QFile::exists(fileName)) return QFile::remove(fileName); return false;} 其中fileName 为应用程序的程序名 如：C:\\test\\test.exe 参考：https://blog.csdn.net/xzpblog/article/details/75172928 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"Android带数据切换Activity","date":"2019-02-11T03:05:00.000Z","path":"2019/02/11/Android带数据切换Activity/","text":"当前 Activity 传递数据12345Intent activity_change= new Intent(Activityanother.this, MainActivity.class); //切换 Activityanother至MainActivityBundle bundle = new Bundle();// 创建Bundle对象bundle.putInt(\"data\",data );// 放入data值为int型activity_change.putExtras(bundle);// 将Bundle对象放入到Intent上startActivity(activity_change);// 开始跳转 如果要是 不是int型可以自己put可种类型有很多种put 另一个 Activity读取数据12Intent intent = getIntent();data= intent.getExtras().get(\"data\"); 注意别忘了在 AndroidManifest 中声明 activity document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Android Spinner用法","date":"2019-02-11T02:56:00.000Z","path":"2019/02/11/Android-Spinner用法/","text":"常用属性: 12345android:spinnerMode //显示模式 :dropdown和dialog两种android:dropDownWidth=\"230dp\"//显示弹出框的宽度android:popupBackground=\"#66ccff\"//显示弹出框的背景颜色android:entries=\"@array/week\"//添加XML布局android:prompt //当显示模式为dialog时生效,作用为显示dialog的标题内容 android:prompt 属性使用常见问题: 设置之后不起作用:prompt属性只有在dialog状态才有用，所以要在xml中，将style设置为Widget.Spinner prompt属性要用string下资源，不支持字符直接输入，否则会报错误 两种写法XML文件中设置数据源 123456789&lt;Spinner android:id=\"@+id/spinner_arrays\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginBottom=\"50dp\" android:dropDownWidth=\"230dp\" android:entries=\"@array/week\" android:popupBackground=\"#66ccff\" android:spinnerMode=\"dropdown\"&gt;&lt;/Spinner&gt; values/arrays.xml文件 123456789101112&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;string-array name=\"week\"&gt; &lt;item &gt;星期一&lt;/item&gt; &lt;item &gt;星期二&lt;/item&gt; &lt;item &gt;星期三&lt;/item&gt; &lt;item &gt;星期四&lt;/item&gt; &lt;item &gt;星期五&lt;/item&gt; &lt;item &gt;星期六&lt;/item&gt; &lt;item &gt;星期天&lt;/item&gt; &lt;/string-array&gt;&lt;/resources&gt; 代码中设置数据源 12345&lt;Spinner android:id=\"@+id/spinner_code\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:spinnerMode=\"dropdown\"&gt;&lt;/Spinner&gt; 1234567891011121314151617codeSp = (Spinner) findViewById(R.id.spinner_code);final String[] arr={\"深圳\",\"上海\",\"北京\",\"山西\"};//创建ArrayAdapter对象ArrayAdapter&lt;String&gt; adapter=new ArrayAdapter&lt;String&gt;(this,android.R.layout.simple_list_item_multiple_choice,arr);codeSp.setAdapter(adapter);/**选项选择监听*/codeSp.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() { @Override public void onItemSelected(AdapterView&lt;?&gt; parent, View view, int position, long id) { Toast.makeText(SpinnerTestActivity.this, \"点击了\" + arr[position], Toast.LENGTH_SHORT).show(); } @Override public void onNothingSelected(AdapterView&lt;?&gt; parent) { }}); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"JavaScript-学习笔记","date":"2019-02-08T07:46:00.000Z","path":"2019/02/08/JavaScript-学习笔记/","text":"JS 教程JS 简介写入 HTML 输出1document.write(\"&lt;h1&gt;This is a heading&lt;/h1&gt;\"); 您只能在 HTML 输出中使用 document.write。如果您在文档加载后使用该方法，会覆盖整个文档。 对事件作出反应1&lt;button type=\"button\" onclick=\"alert('Welcome!')\"&gt;点击这里&lt;/button&gt; 改变 HTML 内容12x=document.getElementById(\"demo\") //查找元素x.innerHTML=\"Hello JavaScript\"; //改变内容 改变 HTML 图像12x=document.getElementById(\"demo\") //找到元素x.style.color=\"#ff0000\"; //改变样式 验证输入1if isNaN(x) {alert(\"Not Numeric\")}; ##JS 实现 ###&lt;script&gt; 标签 123&lt;script&gt; alert(\"My First JavaScript\");&lt;/script&gt; JavaScript 函数1234567&lt;button type=\"button\" onclick=\"myFunction()\"&gt;Button&lt;/button&gt;&lt;script&gt;function myFunction(){ document.getElementById(\"demo\").innerHTML=\"My First JavaScript Function\";}&lt;/script&gt; 外部的 JavaScript1&lt;script src=\"myScript.js\"&gt;&lt;/script&gt; 在 &lt;head&gt; 或 &lt;body&gt; 中引用脚本文件都是可以的。实际运行效果与您在 &lt;script&gt; 标签中编写脚本完全一致。 提示：外部脚本不能包含 &lt;script&gt; 标签。 ##JS 输出 如需从 JavaScript 访问某个 HTML 元素，您可以使用 document.getElementById(id) 方法。 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;我的第一张网页&lt;/h1&gt;&lt;p id=\"demo\"&gt;我的第一个段落&lt;/p&gt;&lt;script&gt;document.getElementById(\"demo\").innerHTML=\"我的第一段 JavaScript\";&lt;/script&gt;&lt;script&gt;document.write(\"&lt;p&gt;我的第二段 JavaScript&lt;/p&gt;\");&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 访问 id=”demo” 的 HTML 元素，并把它的内容（innerHTML）替换为 “My First JavaScript”。 如果在文档已完成加载后执行 document.write，整个 HTML 页面将被覆盖（例如使用onclick） JS 语句1document.getElementById(\"demo\").innerHTML=\"Hello World\"; 用分号来结束语句是可选的 对大小写是敏感的 会忽略多余的空格 可以在文本字符串中使用反斜杠 \\ 对代码行进行换行 12document.write(\"Hello \\World!\"); JS 注释单行注释以 // 开头 多行注释以 /* 开始，以 */ 结尾 JS 变量12345var a = 0, b = 2;var c = a + b;var name = \"MM\", ID = 110; 数据类型 数字：可以带小数点，也可以不带 极大或极小的数字可以通过科学（指数）计数法来书写： 12var y=123e5; // 12300000var z=123e-5; // 0.00123 字符串：用双引号或单引号包围 布尔：true 或 false 重新声明变量如果重新声明 JavaScript 变量，该变量的值不会丢失 在以下两条语句执行后，变量 carname 的值依然是 “Volvo”： 12var carname=\"Volvo\";var carname; 动态类型相同的变量可用作不同的类型 123var x // x 为 undefinedvar x = 6; // x 为数字var x = \"Bill\"; // x 为字符串 ###数组 1234var cars=new Array();cars[0]=\"Audi\";cars[1]=\"BMW\";cars[2]=\"Volvo\"; 或者 (condensed array): 1var cars=new Array(\"Audi\",\"BMW\",\"Volvo\"); 或者 (literal array): 1var cars=[\"Audi\",\"BMW\",\"Volvo\"]; 数组下标是基于零的 JS 对象对象由花括号分隔。在括号内部，对象的属性以名称和值对的形式 (name : value) 来定义。属性由逗号分隔： 1var person={firstname:\"Bill\", lastname:\"Gates\", id:5566}; 空格和折行无关紧要。声明可横跨多行： 12345var person={firstname : \"Bill\",lastname : \"Gates\",id : 5566}; 对象属性有两种寻址方式： 12name=person.lastname;name=person[\"lastname\"]; 属性和方法对象是数据（变量），拥有属性和方法 1var txt = \"Hello\"; 属性： 1txt.length=5 方法： 123txt.indexOf()txt.replace()txt.search() 创建对象12345person=new Object();person.firstname=\"Bill\";person.lastname=\"Gates\";person.age=56;person.eyecolor=\"blue\"; 访问对象的属性12var message=\"Hello world!\";var x=message.toUpperCase(); Undefined 和 NullUndefined 这个值表示变量不含有值。 可以通过将变量的值设置为 null 来清空变量。 声明变量类型当您声明新变量时，可以使用关键词 “new” 来声明其类型： 12345var carname = new String;var x= new Number;var y= new Boolean;var cars= new Array;var person= new Object; JavaScript 变量均为对象。当您声明一个变量时，就创建了一个新的对象。 下面的所有的代码行均会创初始值为 true 的 Boolean 对象： 12345var myBoolean=new Boolean(1);var myBoolean=new Boolean(true);var myBoolean=new Boolean(\"true\");var myBoolean=new Boolean(\"false\");var myBoolean=new Boolean(\"Bill Gates\"); JS 函数函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块。 12345678&lt;button onclick=\"myFunction('Bill Gates','CEO')\"&gt;点击这里&lt;/button&gt;&lt;script&gt;function myFunction(name,job){ alert(\"Welcome \" + name + \", the \" + job);}&lt;/script&gt; 注意：JavaScript 对大小写敏感 返回值12345function myFunction(){ var x=5; return x * x;} return 后，整个 JavaScript 并不会停止执行，仅仅结束函数。 局部与全局在 JavaScript 函数内部声明的变量（使用 var）是局部变量，所以只能在函数内部访问它。（该变量的作用域是局部的）。 在函数外声明的变量是全局变量，网页上的所有脚本和函数都能访问它。 向未声明的变量赋值如果您把值赋给尚未声明的变量，该变量将被自动作为全局变量声明。 这条语句： 1carname=\"Volvo\"; 将声明一个全局变量 carname，即使它在函数内执行。 JS 运算符算数运算符：+、-、*、/、%、++、– 赋值运算符：= 比较运算符：==、===、!=、&gt;、&lt;、&gt;=、&lt;= 逻辑运算符：&amp;&amp;、||、! 条件运算符： ( ) ? a : b +运算符用于把文本值或字符串变量加起来 === ： x===5 为 true；x===”5” 为 false 如果把数字与字符串相加，结果将成为字符串 JS if-else 与 switch123if ( 条件1 ){ 执行1 }else if ( 条件2 ) { 执行2 }else { 执行3 } 1234567891011switch(n){case 1: 执行1 break;case 2: 执行2 break;default: 执行3} ##JS for 和 while 循环 1234for (var i=0;i&lt;cars.length;i++){ document.write(cars[i] + \"&lt;br&gt;\");} ###for/in 语句循环遍历对象的属性： 123456var person={fname:\"John\",lname:\"Doe\",age:25};for (x in person){ txt=txt + person[x];} ###使用 while 循环来显示 cars 数组中的所有值： 1234567cars=[\"BMW\",\"Volvo\",\"Saab\",\"Ford\"];var i=0;while (cars[i]){ document.write(cars[i] + \"&lt;br&gt;\"); i++;} 123456do{ x=x + \"The number is \" + i + \"&lt;br&gt;\"; i++;}while (i&lt;5); ###break 和 continue break 语句用于跳出循环。 continue 用于跳过循环中的一个迭代。 JS 标签12label: 语句 break 和 continue 语句仅仅是能够跳出代码块的语句 123break labelname;continue labelname; continue 语句（带有或不带标签引用）只能用在循环中。 break 语句（不带标签引用），只能用在循环或 switch 中。 通过标签引用，break 语句可用于跳出任何 JavaScript 代码块。 JS 错误1234567891011try{ var x=document.getElementById(\"demo\").value; // 自定义异常可以是字符串、数字、逻辑值或对象 if (isNaN(x)) throw \"Not a number\"; // 在这里运行代码}catch(err){ //在这里处理错误} 如果 getElementById 函数出错，上面的例子也会抛出一个错误 JS 表单验证必填表单下面的函数用来检查用户是否已填写表单中的必填（或必选）项目。假如必填或必选项为空，那么警告框会弹出，并且函数的返回值为 false，否则函数的返回值则为 true（意味着数据没有问题）： 1234567891011121314151617181920212223242526function validate_required(field, alerttxt){ with (field) { if (value == null || value == \"\" ) { alert(alerttxt); return false } else { return true } }}function validate_form(thisform){ with (thisform) { if (validate_required(email,\"Email must be filled out!\")==false) { email.focus();return false } }} 1234&lt;form action=\"submitpage.htm\" onsubmit=\"return validate_form(this)\" method=\"post\"&gt;Email: &lt;input type=\"text\" name=\"email\" size=\"30\"&gt;&lt;input type=\"submit\" value=\"Submit\"&gt; &lt;/form&gt; Email 验证下面的代码检查输入的数据是否符合电子邮件地址的基本语法。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;html&gt;&lt;head&gt;&lt;script type=\"text/javascript\"&gt;function validate_email(field,alerttxt){ with (field) { apos=value.indexOf(\"@\") dotpos=value.lastIndexOf(\".\") if (apos&lt;1||dotpos-apos&lt;2) { alert(alerttxt); return false } else { return true } }}function validate_form(thisform){ with (thisform) { if (validate_email(email,\"Not a valid e-mail address!\")==false) { email.focus(); return false } }}&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"submitpage.htm\"onsubmit=\"return validate_form(this);\" method=\"post\"&gt;Email: &lt;input type=\"text\" name=\"email\" size=\"30\"&gt;&lt;input type=\"submit\" value=\"Submit\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; JS HTML DOMDOM 简介###HTML DOM （文档对象模型） 当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）。 HTML DOM 模型被构造为对象的树。 ###HTML DOM 树 HTML DOM 树 查找 HTML 元素有三种方法来做这件事： 通过 id 找到 HTML 元素 1var x=document.getElementById(\"intro\"); 如果找到该元素，则该方法将以对象（在 x 中）的形式返回该元素。 如果未找到该元素，则 x 将包含 null。 通过标签名找到 HTML 元素​ 查找 “main” 中的所有 &lt;p&gt; 元素： 12var x=document.getElementById(\"main\");var y=x.getElementsByTagName(\"p\"); 通过类名找到 HTML 元素​ (在 IE 5,6,7,8 中无效) DOM HTML改变 HTML 元素的内容 1、改变 HTML 输出流 document.write() 2、改变 HTML 内容 document.getElementById(id).innerHTML=new HTML 3、改变 HTML 属性 document.getElementById(id).attribute=new valu 12345&lt;img id=\"image\" src=\"smiley.gif\"&gt;&lt;script&gt;document.getElementById(\"image\").src=\"landscape.jpg\";&lt;/script&gt; DOM CSS改变 HTML 元素的样式 document.getElementById(id).style.property=new style 下面的例子会改变 &lt;p&gt; 元素的样式： 12345&lt;p id=\"p2\"&gt;Hello World!&lt;/p&gt;&lt;script&gt;document.getElementById(\"p2\").style.color=\"blue\";&lt;/script&gt; 本例改变了 id=”id1” 的 HTML 元素的样式，当用户点击按钮时： 12345&lt;h1 id=\"id1\"&gt;My Heading 1&lt;/h1&gt;&lt;button type=\"button\" onclick=\"document.getElementById('id1').style.color='red'\"&gt;点击这里&lt;/button&gt; DOM 事件对 HTML 事件做出反应 在本例中，当用户在 元素上点击时，会改变其内容： 1&lt;h1 onclick=\"this.innerHTML='谢谢!'\"&gt;请点击该文本&lt;/h1&gt; HTML 事件属性向 button 元素分配 onclick 事件： 1&lt;button onclick=\"displayDate()\"&gt;点击这里&lt;/button&gt; 使用 HTML DOM 来分配事件向 button 元素分配 onclick 事件： 123&lt;script&gt;document.getElementById(\"myBtn\").onclick=function(){displayDate()};&lt;/script&gt; onload 和 onunload 事件onload 和 onunload 事件会在用户进入或离开页面时被触发。 onload 事件可用于检测访问者的浏览器类型和浏览器版本，并基于这些信息来加载网页的正确版本。 onload 和 onunload 事件可用于处理 cookie。 1&lt;body onload=\"checkCookies()\"&gt; onchange 事件onchange 事件常结合对输入字段的验证来使用。 下面是一个如何使用 onchange 的例子。当用户改变输入字段的内容时，会调用 upperCase() 函数。 1&lt;input type=\"text\" id=\"fname\" onchange=\"upperCase()\"&gt; onmouseover 和 onmouseout 事件onmouseover 和 onmouseout 事件可用于在用户的鼠标移至 HTML 元素上方或移出元素时触发函数。 onmousedown、onmouseup 以及 onclick 事件onmousedown, onmouseup 以及 onclick 构成了鼠标点击事件的所有部分。当点击鼠标按钮时，会触发 onmousedown 事件；当释放鼠标按钮时，会触发 onmouseup 事件；当完成鼠标点击时，会触发 onclick 事件。 onfocus 和 onblur 事件 元素（字段，一般是 input 或 a）获得和失去焦点时 让 div 拥有 tab 并具有 onfucus 和 onblur 属性:给元素创建tab属性：tabindex=参数 (这里和z-index类似，计算tab起点)。 123&gt; &lt;div tabindex=\"0\" hidefocus=\"true\" onfocus='alert(\"得到焦点\");' onblur='alert(\"失去焦点\");' style=\"border:1px solid #ccc;width:200px;height:200px;outline=0;\"&gt;&lt;/div&gt;&gt; &gt; 定义tab属性后，元素是默认会加上焦点虚线的，那么在 IE 中可以通过 hidefocus=”true” 去除！其他浏览器通过 outline=0 进行去除！ HTML DOM 元素（节点）添加和删除节点（HTML 元素） 创建新的 HTML 元素必须首先创建该元素（元素节点），然后向一个已存在的元素追加该元素。 1234567891011121314151617&lt;div id=\"div1\"&gt;&lt;p id=\"p1\"&gt;这是一个段落&lt;/p&gt;&lt;/div&gt;&lt;script&gt;// 创建新的 &lt;p&gt; 元素var para=document.createElement(\"p\");// 创建文本节点var node=document.createTextNode(\"这是新段落。\");// 向 &lt;p&gt; 元素追加这个文本节点para.appendChild(node);// 找到一个已有的元素var element=document.getElementById(\"div1\");// 向这个已有的元素追加新元素element.appendChild(para);&lt;/script&gt; 删除已有的 HTML 元素必须首先获得该元素的父元素 123456789101112&lt;div id=\"div1\"&gt;&lt;p id=\"p1\"&gt;这是一个段落。&lt;/p&gt;&lt;/div&gt;&lt;script&gt;// 找到 id=\"div1\" 的元素var parent=document.getElementById(\"div1\");// 找到 id=\"p1\" 的 &lt;p&gt; 元素var child=document.getElementById(\"p1\");// 从父元素中删除子元素parent.removeChild(child);&lt;/script&gt; 不引用父元素的常用解决方案：找到您希望删除的子元素，然后使用其 parentNode 属性来找到父元素： 12var child=document.getElementById(\"p1\");child.parentNode.removeChild(child); JS 对象JS 对象访问对象属性： 1objectName.propertyName 调用对象方法： 1objectName.methodName() ###创建对象 123person=new Object();person.name=\"HHH\";person.age=55; 替代语法（使用对象 literals）： 1person={name:\"HHH\",age:55}; ###使用对象构造器 ​ 使用函数来构造对象： 12345function person(firstname,lastname,age,eyecolor){ this.name=name; this.age=age;} 一旦您有了对象构造器，就可以创建新的对象实例，就像这样： 1var HHH=new person(\"HHH\",55); 把属性添加到对象向已有对象添加新属性： 1person.age=56; // 直接赋值即可 把方法添加到 JavaScript 对象方法只不过是附加在对象上的函数。 在构造器函数内部定义对象的方法： 1234567891011function person(name,age){ this.name=name; this.age=age; this.changeName=changeName; function changeName(name) { this.name=name; }} JS 数字JS 数字所有 JavaScript 数字均为 64 位 整数（不使用小数点或指数计数法）最多为 15 位。 小数的最大位数是 17，但是浮点运算并不总是 100% 准确 属性： MAX VALUE MIN VALUE NEGATIVE INFINITIVE POSITIVE INFINITIVE NaN prototype constructor 方法： toExponential() toFixed() toPrecision() toString() valueOf() 12var y=0377; // 八进制 前缀 0var z=0xFF; // 十六进制 前缀0x JS 字符串计算长度 str.length 添加样式 str = s.big() + s.small() + s.bold() + s.italics()​ s.blink() 闪动字符串 s.fixed() 打字机文本 strike() 删除线​ s.fontcolor(“Red”) s.fontsize(16)​ s.toLowerCase() s.toUpperCase()​ s.sub() 下标 s.sup() 上标 定位字符串 str.indexOf(s)​ 定位字符串中某一个指定的字符(串)首次出现的位置，没有则返回 -1 查找字符串 str.match(s)​ 查找字符串中特定的字符(串)，如果找到则返回这个字符，否则返回 null 替换字符串 str.replace(/s1/, \"s2\")​ 返回替换后的字符串，原字符串斜杠包裹，新字符串普通 JS 日期当前日期时间 Data() Fri Feb 09 2018 21:21:21 GMT+0800 (中国标准时间) 时间戳（1970/1/1年迄今毫秒数） getTime() 1518183016383 ###定义日期 1var myDate=new Date() ​ 注释：Date 对象自动使用当前的日期和时间作为其初始值。 ###操作日期 ​ 使用 setFullYear() 设置具体的日期​ 注意：表示月份的参数介于 0 到 11 之间。 123var d = new Date()d.setFullYear(1992,10,3)document.write(d) ​ 输出结果：Tue Nov 03 1992 21:32:52 GMT+0800 (中国标准时间) ​ 设置 5 天后的日期 12var myDate=new Date()myDate.setDate(myDate.getDate()+5) 比较日期​ 将当前日期与 2008 年 8 月 9 日做比较: 123456var myDate=new Date();myDate.setFullYear(2008,8,9);var today = new Date();if (myDate&gt;today) { } ###日期转化 使用 toUTCString() 将当日的日期（根据 UTC）转换为字符串 12var d = new Date()document.write (d.toUTCString()) ​ 输出结果：Fri, 09 Feb 2018 13:35:52 GMT 今天是星期几 12var d=new Date();d.getDay() // 星期几（0日，6六） ###网页版动态钟表 1234567891011121314151617181920212223242526272829&lt;html&gt;&lt;head&gt;&lt;script type=\"text/javascript\"&gt;function startTime(){ var today=new Date() var h=today.getHours() var m=today.getMinutes() var s=today.getSeconds() // add a zero in front of numbers&lt;10 m=checkTime(m) s=checkTime(s) document.getElementById('txt').innerHTML=h+\":\"+m+\":\"+s t=setTimeout('startTime()',500)}function checkTime(i){ if (i&lt;10) {i=\"0\" + i} return i}&lt;/script&gt;&lt;/head&gt;&lt;body onload=\"startTime()\"&gt;&lt;div id=\"txt\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; JS 算数Math（算数）对象的作用是：执行常见的算数任务。 四舍五入 Math.round(x) Math.round(0.50) == 1 Math.round(-4.40) == -4 Math.round(-4.60) == -5 随机 0 - 1 之间的数 Math.random() 取最大/小值 Math.max()和 Math.min() 在 ECMASCript v3 之前，该方法只有两个参数。 下面的例子使用了 Math 对象的 floor() 方法和 random() 来返回一个介于 0 和 10 之间的随机数： 1document.write(Math.floor(Math.random()*11)) JavaScript 提供 8 种可被 Math 对象访问的算数值： 常数 Math.E 圆周率 Math.PI 2 的平方根 Math.SQRT2 1/2 的平方根 Math.SQRT1_2 2 的自然对数 Math.LN2 10 的自然对数 Math.LN10 以 2 为底的 e 的对数 Math.LOG2E 以 10 为底的 e 的对数 Math.LOG10E 正则表达式定义 RegExp通过 new 关键词来定义 RegExp 对象。以下代码定义了名为 patt1 的 RegExp 对象，其模式是 “e”： 1var patt1=new RegExp(\"e\"); // 将寻找的是字符 \"e\" RegExp 对象的方法RegExp 对象有 3 个方法：test()、exec() 以及 compile() test() 方法检索字符串中的指定值。返回值是 true 或 false。 12var patt1=new RegExp(\"e\");document.write(patt1.test(\"best life\")); ​ 由于该字符串中存在字母 “e”，以上代码的输出将是：true exec() 方法检索字符串中的指定值。返回值是被找到的值。如果没有发现匹配，则返回 null。 12var patt1=new RegExp(\"e\");document.write(patt1.exec(\"The best things in life are free\")); ​ 由于该字符串中存在字母 “e”，以上代码的输出将是：e 您可以向 RegExp 对象添加第二个参数，以设定检索。例如，如果需要找到所有某个字符的所有存在，则可以使用 “g” 参数 (“global”)。 在使用 “g” 参数时，exec() 的工作原理如下： 找到第一个 “e”，并存储其位置 如果再次运行 exec()，则从存储的位置开始检索，并找到下一个 “e”，并存储其位置 123456var patt1=new RegExp(\"e\",\"g\");do { result=patt1.exec(\"The best things in life are free\"); document.write(result);}while (result!=null) 由于这个字符串中 6 个 “e” 字母，代码的输出将是： 1eeeeeenull compile() 方法用于改变 RegExp。既可以改变检索模式，也可以添加或删除第二个参数。 1234var patt1=new RegExp(\"e\");document.write(patt1.test(\"The best things in life are free\"));patt1.compile(\"d\");document.write(patt1.test(\"The best things in life are free\")); 由于字符串中存在 “e”，而没有 “d”，以上代码的输出是：truefalse JS WindowWindow 尺寸有三种方法能够确定浏览器窗口的尺寸（浏览器的视口，不包括工具栏和滚动条）。 对于Internet Explorer、Chrome、Firefox、Opera 以及 Safari： window.innerHeight - 浏览器窗口的内部高度 window.innerWidth - 浏览器窗口的内部宽度 对于 Internet Explorer 8、7、6、5： document.documentElement.clientHeight document.documentElement.clientWidth 或者 document.body.clientHeight document.body.clientWidth 显示浏览器窗口的高度和宽度：（涵盖所有浏览器，不包括工具栏/滚动条）： 1234567var w=window.innerWidth|| document.documentElement.clientWidth|| document.body.clientWidth;var h=window.innerHeight|| document.documentElement.clientHeight|| document.body.clientHeight; 其他 Window 方法 window.open() - 打开新窗口 window.close() - 关闭当前窗口 window.moveTo() - 移动当前窗口 window.resizeTo() - 调整当前窗口的尺寸 JS Screenwindow.screen 对象在编写时可以不使用 window 这个前缀。 一些属性： screen.availWidth - 可用的屏幕宽度 screen.availHeight - 可用的屏幕高度 123&lt;script&gt;document.write(\"可用宽度：\" + screen.availWidth);&lt;/script&gt; JS Locationwindow.location 对象在编写时可不使用 window 这个前缀。 一些例子： location.href 返回当前页面的 URL location.pathname 属性返回 URL 的路径名和文件名 location.assign() 方法加载新的文档 location.hostname 返回 web 主机的域名 location.port 返回 web 主机的端口 （80 或 443） location.protocol 返回所使用的 web 协议（http:// 或 https://） 1234567891011121314&lt;html&gt;&lt;head&gt;&lt;script&gt;function newDoc(){ window.location.assign(\"http://www.w3school.com.cn\")}&lt;/script&gt;&lt;/head&gt; &lt;body&gt;&lt;input type=\"button\" value=\"加载新文档\" onclick=\"newDoc()\"&gt;&lt;/body&gt;&lt;/html&gt; JS Historywindow.history 对象在编写时可不使用 window 这个前缀。 为了保护用户隐私，对 JavaScript 访问该对象的方法做出了限制。 一些方法： history.back() - 与在浏览器点击后退按钮相同 history.forward() - 与在浏览器中点击按钮向前相同 1234567891011121314&lt;html&gt;&lt;head&gt;&lt;script&gt;function goBack(){ window.history.back()}&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=\"button\" value=\"Back\" onclick=\"goBack()\"&gt;&lt;/body&gt;&lt;/html&gt; JS Navigatorwindow.navigator 对象包含有关访问者浏览器的信息。 123456789101112131415&lt;div id=\"example\"&gt;&lt;/div&gt;&lt;script&gt;txt = \"&lt;p&gt;Browser CodeName: \" + navigator.appCodeName + \"&lt;/p&gt;\";txt+= \"&lt;p&gt;Browser Name: \" + navigator.appName + \"&lt;/p&gt;\";txt+= \"&lt;p&gt;Browser Version: \" + navigator.appVersion + \"&lt;/p&gt;\";txt+= \"&lt;p&gt;Cookies Enabled: \" + navigator.cookieEnabled + \"&lt;/p&gt;\";txt+= \"&lt;p&gt;Platform: \" + navigator.platform + \"&lt;/p&gt;\";txt+= \"&lt;p&gt;User-agent header: \" + navigator.userAgent + \"&lt;/p&gt;\";txt+= \"&lt;p&gt;User-agent language: \" + navigator.systemLanguage + \"&lt;/p&gt;\";document.getElementById(\"example\").innerHTML=txt;&lt;/script&gt; 警告：来自 navigator 对象的信息具有误导性，不应该被用于检测浏览器版本，这是因为： navigator 数据可被浏览器使用者更改 浏览器无法报告晚于浏览器发布的新操作系统 浏览器检测由于 navigator 可误导浏览器检测，使用对象检测可用来嗅探不同的浏览器。 由于不同的浏览器支持不同的对象，您可以使用对象来检测浏览器。例如，由于只有 Opera 支持属性 “window.opera”，您可以据此识别出 Opera。 例子：if (window.opera) {...some action...} JS 消息框警告框 alert(\"文本\") 点击确定按钮才能继续操作 确认框 confirm(\"文本\") 点击确定或者取消按钮才能继续，返回值 true 和 false 提示框 prompt(\"文本\",\"默认值\") 输入后点击确认或取消按钮才能继续 JS 计时var t = setTimeout(\"javascript语句\",毫秒) 未来的某时执行代码 clearTimeout(setTimeout_variable) 取消 setTimeout() 12var t = setTimeout(\"alert('5秒')\",5000) // 5s 后警告框clearTimeout(t) // 取消 5s 后的警告框 JS Cookies创建一个欢迎 Cookies 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;html&gt;&lt;head&gt;&lt;script type=\"text/javascript\"&gt;// 检查 document.cookie 对象中是否存有 cookiefunction getCookie(c_name){ if (document.cookie.length&gt;0) { c_start=document.cookie.indexOf(c_name + \"=\") if (c_start!=-1) { c_start=c_start + c_name.length+1 c_end=document.cookie.indexOf(\";\",c_start) if (c_end==-1) c_end=document.cookie.length return unescape(document.cookie.substring(c_start,c_end)) } } return \"\"}// 将天数转换为有效的日期，然后，我们将 cookie 名称、值及其过期日期存入 document.cookie 对象。function setCookie(c_name,value,expiredays){ var exdate=new Date() exdate.setDate(exdate.getDate()+expiredays) document.cookie=c_name+ \"=\" +escape(value)+ ((expiredays==null) ? \"\" : \";expires=\"+exdate.toGMTString())}// 如果 cookie 已设置则显示欢迎词，否则显示提示框来要求用户输入名字function checkCookie(){ username=getCookie('username') if (username!=null &amp;&amp; username!=\"\") { alert('Welcome again '+username+'!') } else { username=prompt('Please enter your name:',\"\") if (username!=null &amp;&amp; username!=\"\") { setCookie('username',username,365) } }}&lt;/script&gt;&lt;/head&gt;&lt;body onLoad=\"checkCookie()\"&gt;&lt;/body&gt;&lt;/html&gt; JS 库JS 框架（库，helper）一些广受欢迎的 JavaScript 框架： jQuery：使用 CSS 选择器来访问和操作网页上的 HTML 元素（DOM 对象），同时提供 companion UI（用户界面）和插件 Prototype：提供用于执行常见 web 任务的简单 API；提供类和继承 MooTools：提供了可使常见的 JavaScript 编程更为简单的 API，也含有一些轻量级的效果和动画函数 其他一些在上面未涉及的框架： YUI - Yahoo! User Interface Framework，涵盖大量函数的大型库，从简单的 JavaScript 功能到完整的 internet widget。 Ext JS - 可定制的 widget，用于构建富因特网应用程序（rich Internet applications）。 Dojo - 用于 DOM 操作、事件、widget 等的工具包。 script.aculo.us - 开源的 JavaScript 框架，针对可视效果和界面行为。 UIZE - Widget、AJAX、DOM、模板等等。 CDN - 内容分发网络如果许多不同的网站使用相同的 JavaScript 框架，那么把框架库存放在一个通用的位置供每个网页分享就变得很有意义了。 CDN (Content Delivery Network) 解决了这个问题。CDN 是包含可分享代码库的服务器网络。 Google 为一系列 JavaScript 库提供了免费的 CDN，包括： jQuery Prototype MooTools Dojo Yahoo! YUI 如需在您的网页中使用 JavaScript 框架库，只需在 &lt;script&gt; 标签中引用该库即可：见下方例子 JS jQuery引用 jQuery 12&lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js\"&gt;&lt;/script&gt; 主要的 jQuery 函数是 $() 函数（jQuery 函数）。 jQuery 允许您通过 CSS 选择器来选取元素。 示例：分配一个函数以处理窗口加载事件： JavaScript 方式： 123456function myFunction(){ var obj=document.getElementById(\"h01\"); obj.innerHTML=\"Hello jQuery\";}onload=myFunction; jQuery 方式： 12345function myFunction(){ $(\"#h01\").html(\"Hello jQuery\");}$(document).ready(myFunction); 由于在 JavaScript 中函数就是变量，因此可以把 myFunction 作为变量传递给 jQuery 的 ready 方法。 提示：jQuery 返回 jQuery 对象，与已传递的 DOM 对象不同。jQuery 对象拥有的属性和方法，与 DOM 对象的不同。不能在 jQuery 对象上使用 HTML DOM 的属性和方法。 jQuery 允许链接（链式语法） 123456789&lt;script&gt;function myFunction(){ $(\"#h01\").attr(\"style\",\"color:red\").html(\"Hello jQuery\")}$(document).ready(myFunction);&lt;/script&gt;&lt;h1 id=\"h01\"&gt;&lt;/h1&gt; JS Prototype引用 Prototype： 12&lt;script src=\"http://ajax.googleapis.com/ajax/libs/prototype/1.7.1.0/prototype.js\"&gt;&lt;/script&gt; 与 jQuery 类似，Prototype 也有自己的 $() 函数。 $() 函数接受 HTML DOM 元素的 id 值（或 DOM 元素），并会向 DOM 对象添加新的功能。 与 jQuery 不同，Prototype 没有用以取代 window.onload() 的 ready() 方法。相反，Prototype 会向浏览器及 HTML DOM 添加扩展。 示例：分配一个函数以处理窗口加载事件： JavaScript 方式： 123456function myFunction(){ var obj=document.getElementById(\"h01\"); obj.innerHTML=\"Hello Prototype\";}onload=myFunction; Prototype 方式： 12345function myFunction(){ $(\"h01\").insert(\"Hello Prototype!\");}Event.observe(window,\"load\",myFunction); Event.observe() 接受三个参数： 您希望处理的 HTML DOM 或 BOM（浏览器对象模型）对象 您希望处理的事件 您希望调用的函数 与 jQuery 相同，Prototype 允许链式语法： 123456789&lt;script&gt;function myFunction(){ $(\"h01\").writeAttribute(\"style\",\"color:red\").insert(\"Hello Prototype!\");}Event.observe(window,\"load\",myFunction);&lt;/script&gt;&lt;h1 id=\"h01\"&gt;&lt;/h1&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"JS","slug":"JS","permalink":"http://blog.iwxyi.com/tags/JS/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.iwxyi.com/tags/学习笔记/"}]},{"title":"JS判断是否为微信客户端","date":"2019-02-08T07:41:00.000Z","path":"2019/02/08/JS判断是否为微信客户端/","text":"方法一：（微信官方js判断做法） 1234567var ua = navigator.userAgent.toLowerCase();var isWeixin = ua.indexOf('micromessenger') != -1;if (isWeixin) { return true;}else{ return false; } 方法二：（js判断做法） 12345678function is_weixn(){ var ua = navigator.userAgent.toLowerCase(); if(ua.match(/MicroMessenger/i)==\"micromessenger\") { return true; } else { return false; } } 方法三：（js判断做法） 12345678910var is_weixin = (function(){return navigator.userAgent.toLowerCase().indexOf('micromessenger') !== -1})();if(is_weixin){ $(function(){ return true; });}else{ $(function(){ return false; });} 方法四：（利用PHP判断） 123456function is_weixin(){ if ( strpos($_SERVER['HTTP_USER_AGENT'], 'MicroMessenger') !== false ) { //strpos() 函数查找字符串在另一字符串中第一次出现的位置。 return true; } return false; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"JS","slug":"JS","permalink":"http://blog.iwxyi.com/tags/JS/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://blog.iwxyi.com/tags/微信小程序/"}]},{"title":"搭建SSR","date":"2019-02-04T05:53:00.000Z","path":"2019/02/04/搭建SSR/","text":"一键搭建 1234567891011wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssrmu.sh &amp;&amp; chmod +x ssrmu.sh &amp;&amp; bash ssrmu.sh1102n5n 手动搭建SSR12yum -y install wgetwget -N --no-check-certificate https://softs.fun/Bash/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh 备用下载地址1wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssrmu.sh &amp;&amp; chmod +x ssrmu.sh &amp;&amp; bash ssrmu.sh 启动1bash ssr.sh 谷歌BBR加速1234yum -y install wgetwget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.shchmod +x bbr.sh./bbr.sh document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"服务器","slug":"服务器","permalink":"http://blog.iwxyi.com/tags/服务器/"}]},{"title":"Qt on Android 错误整理","date":"2019-01-26T09:44:00.000Z","path":"2019/01/26/Qt-on-Android-错误整理/","text":"stdlib.h: No such file or directory12E:\\Install\\android-ndk-r16b\\sources\\cxx-stl\\gnu-libstdc++\\4.9\\include\\cstdlib:72: error: stdlib.h: No such file or directory #include &lt;stdlib.h&gt; 解决办法：换个版本的 NDK（低版本无用的话，64位换成32位） 例如：Qt-on-android5.7，ant是1.9.11，ndk是r12b 参考：https://q.cnblogs.com/q/106250/ 过程试图写入的管道不存在在编译Android项目时，可能会出现警告提示：​ 过程试图写入的管道不存在。 观察离警告最近一次命令是：C:\\Qt\\Qt5.7.1forAndroid\\5.7\\android_armv7\\bin\\androiddeployqt.exe –input D:/QtWorkspace/Android/build-First-Android_for_armeabi_v7a_GCC_4_9_Qt_5_7_1-Debug/android-libFirst.so-deployment-settings.json –output D:/QtWorkspace/Android/build-First-Android_for_armeabi_v7a_GCC_4_9_Qt_5_7_1-Debug/android-build –deployment bundled –android-platform android-26 –jdk C:/Java/jdk1.8.0_131 –ant C:/apache-ant-1.9.9/bin/ant.bat 为androiddeployqt.exe添加选项–verbose，C:\\Qt\\Qt5.7.1forAndroid\\5.7\\android_armv7\\bin\\androiddeployqt.exe –verbose –input D:/QtWorkspace/Android/build-First-Android_for_armeabi_v7a_GCC_4_9_Qt_5_7_1-Debug/android-libFirst.so-deployment-settings.json –output D:/QtWorkspace/Android/build-First-Android_for_armeabi_v7a_GCC_4_9_Qt_5_7_1-Debug/android-build –deployment bundled –android-platform android-26 –jdk C:/Java/jdk1.8.0_131 –ant C:/apache-ant-1.9.9/bin/ant.bat 将这条命令在PowerShell上运行，会发现离“过程试图写入的管道不存在。”的最近一条命令是：D:/Android/sdk/tools/android.bat update project –path D:/QtWorkspace/Android/build-First-Android_for_armeabi_v7a_GCC_4_9_Qt_5_7_1-Debug/android-build/ –target android-26 –name QtApp 同样在PowerShell上运行这条命令，发现提示： The “android” command is deprecated. For manual SDK, AVD, and project management, please use Android Studio. For command-line tools, use tools\\bin\\sdkmanager.bat and tools\\bin\\avdmanager.bat 意思是，android sdk tools不再支持android.bat这条命令了。 在网上用“The “android” command is deprecated.”搜索，发现 http://forum.cocos.com/t/creator1-4-1-android/45151 这篇帖子，其中蓝色孤舟给出了详细的说明，大意是新版本的android sdk tools不再支持android.bat这条命令，需要将android sdk tools降级。他同时提供了windows和mac上的版本为25.2.3的android sdk tools。下载并覆盖android studio的原有tools，编译就会成功了。 参考：https://blog.csdn.net/jupipe_guanly/article/details/75462085?utm_source=blogxgwz1 No suitable Java found.使用上面方法的第三条，发现： No suitable Java found. In order to properly use the Android DeveloperTools, you need a suitable version of Java JDK installed on your system. We recommend that you install the JDK version of JavaSE, available here: 遇到此问题时，将 你的SDK解压后的文件名\\tools\\lib下的find_java替换为版本r16版中的find_java，下载地址 http://tekeye.biz/download/find_java.zip，原因，网上查找说应该是r17以上的版本重写了find_java.bat 参考：http://blog.sina.com.cn/s/blog_9285741101019m5h.html ‘android–1’ does not exist in SDKWarning: Android platform ‘android–1’ does not exist in SDK. 没有设置 Android SDK （但是我有遇到无法设置 android build SDK 的情况，解决方法是设置里直接换了个 SDK） 参考：https://www.cnblogs.com/okgogo2000/p/9257808.html aidl.exe 系统找不到指定的文件E:\\Install\\sdk\\tools\\ant\\build.xml:564: Execute failed: java.io.IOException: Cannot run program \"E:\\Install\\sdk\\platform-tools\\aidl.exe\" (in directory \"D:\\Qt\\AndroidTest\\RunAndroidx86\\android-build\"): CreateProcess error=2, 系统找不到指定的文件。 sdk/build-tools/28.0.3/ 里面的文件 复制到 platform-tools/ 里面（不知道要不要覆盖，反正结果还是编译出错） 不再支持源选项 5 / 1.5123[javac] Compiling 5 source files to D:\\Qt\\AndroidTest\\RunAndroidx86\\android-build\\bin\\classes[javac] 错误: 不再支持源选项 5。请使用 6 或更高版本。[javac] 错误: 不再支持目标选项 1.5。请使用 1.6 或更高版本。 在 \\sdk\\tools\\ant\\build.xml 文件中搜索 1.5，改成 1.8。1.6 还是会警告过时。 12345&lt;!-- compilation options --&gt;&lt;property name=\"java.encoding\" value=\"UTF-8\" /&gt;&lt;property name=\"java.target\" value=\"1.5\" /&gt;&lt;property name=\"java.source\" value=\"1.5\" /&gt;&lt;property name=\"java.compilerargs\" value=\"\" /&gt; 下载 Gradle 卡住123456Downloading https://services.gradle.org/distributions/gradle-4.6-bin.zipException in thread \"main\" java.net.ConnectException: Connection timed out: connect at java.net.DualStackPlainSocketImpl.connect0(Native Method) at java.net.DualStackPlainSocketImpl.socketConnect(DualStackPlainSocketImpl.java:79) ...... 1、先保证程序在windows下能正常运行，即MinGW编译通过 2、进入“项目-Build Android APK”，点击create templates,对弹出的提示确认。系统会自动建立一些配置文件 3、点开文件build.gradle，做如下修改，即可顺利编译成功。但记得电脑能上网。 修改：屏蔽jcenter() 添加一行maven{ url 'https://maven.aliyun.com/repository/jcenter' }，记住，下面还有一个jcenter(),同样屏蔽处理 Cannot find the androiddeploy Json file123Cannot find the androiddeploy Json file.Error while building/deploying project Bilibili-MagicalDanmaku (kit: Android for x86 (Clang Qt 5.13.1 for Android x86))When executing step \"Deploy to Android device\" 实测无效的： 选项--构建与运行--Qbs--Kit 选择Android for armeabi-v7a (GCC 4.9,Qt5.10.1 for Android armv7) 未找到原因，但发现把一些容易出兼容性问题的模块删掉之后可用。 Android deploy settings file not found, not building an APK. 这是Qt的一个小Bug,安卓配置文件不太稳定。 只需要在左侧项目栏里： 选定你的编译工具（编译平台），右侧选择Disable它， 然后双击激活它，重新载入一下，就OK了。 路径 // 问题12345adb: failed to stat E:/Projects/BilibiliLiveDanmaku_Android/android-build//build/outputs/apk/android-build-debug.apk: No such file or directoryInstalling Android package to device.Running command \"D:/DevKits/SDK/platform-tools/adb.exe -s 192.168.91.101:5555 install -r E:/Projects/BilibiliLiveDanmaku_Android/android-build//build/outputs/apk/android-build-debug.apk\"Performing Streamed InstallInstalling to device failed! 注意到 E:/Projects/BilibiliLiveDanmaku_Android/android-build//build/outputs/apk/android-build-debug.apk: No such file or directory 中间路径有两条 //，表示这个生成的文件夹是空的。 同上面一个解决方案：Disable 编译工具，点击重新激活。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"},{"name":"整理","slug":"整理","permalink":"http://blog.iwxyi.com/tags/整理/"},{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"ASP.NET文件操作","date":"2019-01-24T13:09:00.000Z","path":"2019/01/24/ASP-NET文件操作/","text":"以文件为例,如果对文件夹操作,基本上将File换为Directory即可(例:FileInfo file = new FileInfo(Path);与DirectoryInfo directory = new DirectoryInfo (Path);) 1获取文件信息 在知道文件相对路径的情形,下面代码可以获取文件的详细信息 12345678910public static void fileinfo(string Path){ Path = Server.MapPath(Path);//获取文件的物理路径 FileInfo file = new FileInfo(Path);//实例该路径文件信息 var length=file.Length;//文件大小,字节 var name = file.Name;//文件名 var fullname = file.FullName;//文件路径 var extension = file.Extension;//文件后缀名 ......} 获取的信息还有创建时间,最后访问时间等等,可以自行研究 2新建文件 新建一个文件。（Create 后会一直占用，最好加上 Dispose） 123456789101112public static void NewFile(string filePath){ filePath=Server.MapPath(filePath);//获取想创建文件的物理路径 if (System.IO.File.Exists(newfilepath)) { //判断新建的文件是否已经存在 throw new Exception(\"文件已经存在\") } System.IO.File.Create(newfilepath);//创建 ......} 3复制文件,移动(剪切)文件,重命名文件 复制文件: 123456789101112public static void Copy(string Path,string targetPath){ Path = Server.MapPath(Path);//原文件的物理路径 targetPath = Server.MapPath(targetPath);//复制到的新位置物理路径 //判断到的新地址是否存在重命名文件 if (System.IO.File.Exists(targetPath)) { throw new Exception(\"存在同名文件\");//抛出异常 } System.IO.File.Copy(Path,targetPath);//复制到新位置,不允许覆盖现有文件 .......} 移动文件,重命名: 12345678910111213public static void MoveOrRename(string Path,string targetPath){ Path = Server.MapPath(Path);//原文件的物理路径 targetPath = Server.MapPath(targetPath);//移动到的新位置的物理路径(如果还是当前文件夹,则会重命名文件) //判断到的新地址是否存在重命名文件 if (System.IO.File.Exists(targetPath)) { //判断是新位置是否存在同名(判断重命名是狗和其他文件冲突) throw new Exception(\"已经存在同名文件\"); } System.IO.File.Move(Path,targetPath);//2个文件在不同目录则是移动,如果在相同目录下则是重命名 ......} 复制文件不会删除,移动或者重命名(方法相同,就是目标位置不同)会删除原文件. 4上传文件 12345678910111213141516171819[HttpPost]//通过Post请求接收前台传来的文件数据public ActionResult UploadFile(string dirPath){ var filepath = Server.MapPath(Path);//获取上传的文件存入目录的物理路径 var file = Request.Files[\"file\"];//获取文件内容 if (file == null || file.ContentLength == 0) { throw new Exception(\"文件不存在\");//简单判断下文件 } var newfilepath = Server.MapPath(dirPath + \"\\\\\" + file.FileName);//获取文件名的物理路径 //判断要上传的文件是否与目录中的文件重命名 if (System.IO.File.Exists(newfilepath)) { throw new Exception(\"文件不存在\");//简单判断下文件是否存在 } //文件存放到指定的文件中 ; file.SaveAs(newfilepath); ......} 会自动创建存有该类容和命名的文件,不用多此一举去创建一个新文件再放入内容. 5遍历当前目录和其子目录所有文件 12345678910111213141516171819202122232425262728293031private static string[] GetFiles(string dir, string regexPattern = null, bool recurse = true, bool throwEx = false){ //recurse:是否递归 //throwEx:是否报出异常 List&lt;string&gt; lst = new List&lt;string&gt;(); try { foreach (string item in Directory.GetFileSystemEntries(dir)) { try { bool isFile = (System.IO.File.GetAttributes(item) &amp; FileAttributes.Directory) != FileAttributes.Directory; if (isFile &amp;&amp; (regexPattern == null || Regex.IsMatch(Path.GetFileName(item), regexPattern, RegexOptions.IgnoreCase | RegexOptions.Multiline))) { lst.Add(item); } //递归 if (recurse &amp;&amp; !isFile) { lst.AddRange(GetFiles(item, regexPattern, true)); } } catch { if (throwEx) { throw; } } } } catch { if (throwEx) { throw; } } return lst.ToArray();} 这个不多说,网上找到的代码,亲测有效 System.IO.File.Create 不会自动释放，一定要Dispose这样会导致W3P进程一直占用这个文件 System.IO.File.Create(HttpContext.Current.Server.MapPath(strName)); 最好加上Dispose() System.IO.File.Create(HttpContext.Current.Server.MapPath(strName)).Dispose(); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"http://blog.iwxyi.com/tags/ASP-NET/"},{"name":"文件","slug":"文件","permalink":"http://blog.iwxyi.com/tags/文件/"}]},{"title":"Qt加快编译速度","date":"2019-01-24T08:58:00.000Z","path":"2019/01/24/Qt加快编译速度/","text":"设置多核编译1.查看是否已经安装了jom工具：C:\\Qt\\Qt5.4.1\\Tools\\QtCreator\\bin\\jom.exe 2.项目添加参数-j 4【4是cpu的核数，我的是i5，只有四个核心】 菜单栏-&gt;工具-&gt; 选项-&gt;构建与运行-&gt;构建套件-&gt;点击自动检测内容-&gt;在同一页面找到 Environment -&gt;点击change -&gt;在弹出的窗口 添加 MAKEFLAGS=-j4 即可 -j4:表示 CPU 两个核数进行编译 注：现在最新版 Qt Creator 已经自带满核了 使用预编译头“用Qt写的程序编译比MFC慢”的说法是错误的。单位代码行数编译Qt远比MFC快得多，因为Qt库的头文件设计非常好，尽量都使用了前置声明，避免了头文件嵌套，几乎所有类都使用了公有类和私有类的设计，把没必要公开的声明放到私有头文件里，避免了编译时引入过多代码。而MFC没有这样的设计。至于大家感觉MFC快主要原因是MFC工程默认打开了编译预处理头文件（PCH），但是这是VC编译器的特性，所有C++程序都可以用，不是MFC特有，Qt也可以使用 PCH。方法很简单，在你的 .pro 文件中加入一行 PRECOMPILED_HEADER = stable.h 指定 Stable.h这个头文件作为编译预处理文件，MFC里这个文件一般叫stdafx.h。然后在 stable.h里 包含你所用到的所有 Qt 头文件，如果你用了很多qt的类可以直接包含所有比如 ： #include #include 这两个文件里又包含了几乎所有Qt常用类。不用担心，即使包含了所有头文件也没关系，有了PCH再多头文件也没影响。如果你还想编译再快点，可以在 .pro里加入下面一行 QMAKE_CXXFLAGS += /MP 指定/mp编译选项，编译器将使用并行编译，同时起多个编译进程并行编译不同的cpp而且QT这种引入PCH的方法比MFC的好，由于MFC的PCH选项是每个工程逐个指定的，很容易被某些人搞坏，我曾经无数次修复PCH问题，但是Qt的选项是写在.pro里的，写一次就永远不会错。MFC一旦弄坏了PCH，编译也慢得令人发指。 参考：https://www.cnblogs.com/findumars/p/7220069.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"Qt发送邮件","date":"2019-01-23T10:47:00.000Z","path":"2019/01/23/Qt发送邮件/","text":"太难了，卒 参考博客:http://www.qtcn.org/bbs/read-htm-tid-56050.html 里面有个下载的工具包，包含了api和使用示例。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"Qt多显示器","date":"2019-01-21T10:46:00.000Z","path":"2019/01/21/Qt多显示器/","text":"先放官方文档链接：QDesktopWidget - Qt5 Reference 在只有一个显示器的时候，获得显示器分辨率的方法是 1miRPos = QApplication::desktop()-&gt;screenGeometry().width(); //原来的写法,奇怪的变量名先无视 然而实际发现无论如何这个得到的分辨率都是主显示器的完整分辨率。然后查了Qt的Reference，才发现，这个的原型是 1const QRect QDesktopWidget::screenGeometry(int screen = -1) const 其中的参数就是显示器的id，默认是-1，如果是多个显示器，则显示器编号依次为0（主显示器）,1,2,3…额，这个编号和你在设置里看到的编号没一点关系 :) 如图，这是我目前的显示设置情况，其中标识为2的显示器是主显示器，1则是扩展显示器。而实际上，我们通过 12QDesktopWidget * desktop = QApplication::desktop();int curMonitor = desktop-&gt;screenNumber ( this ); // 参数是一个QWidget* 获得到的当前所在屏幕的编号来看，设置中标识为2的实际上是0，标识为1的实际是1.也就是说，系统设置中标识的编号和这里真的是一点关系都没有啦。 当我们获取到显示器编号后，就可以通过这个来获取当前所在屏幕的分辨率啦。 1QRect rect = desktop-&gt;screenGeometry(curMonitor); 这时rect.width和rect.height就是当前屏幕的分辨率了。而rect.x和rect.y是什么呢？回到刚刚的我的显示器设置情况的图，我们可以用上面的函数获取主(编号为2的)显示器rect.x和rect.y，你会发现rect.x=0,rect.y=0。可见，整个显示器“坐标”是以主显示器左上角为（0,0）点的。在扩展(此处编号为1的)显示器获得到的rect.x=-1366,rect.y=161说明这个就是那个扩展显示器左上角的坐标了。那么我们就很容易通过这个来计算我们所需要的屏幕坐标了。 我的需求是让这个仿osu的mini窗口的最右端和当前屏幕最右侧对齐，上端和当前屏幕上端保持25px的边距。那么就应该这样做。 12miRPos = rect.x() + rect.width(); //当前屏幕最右侧的位置，别吐槽这个变量名了（╯－＿－）╯╧╧this-&gt;setGeometry(miRPos - this-&gt;width() , rect.y() + 25, this-&gt;width(), this-&gt;height()); 然后我突然发现我是个奇葩的例外，因为我在小的显示器上打游戏的时候通常任务栏会挡住游戏窗体，于是我把任务栏拖到右面了…那么上面所得到的结果，窗体则始终会和屏幕的最右面对齐并忽视任务栏的存在，如果翻过reference的话，你会发现这个问题非常好解决，只需要把 screenGeometry() 换成 availableGeometry() 就行了。这个获取到的就是当前显示器的可用部分了，在windows下就是不包括任务栏了。 或许你在没创建widget的时候就想要获取一个分辨率信息用于初始化或者别的作用了，你可以通过 curMonitor = desktop-&gt;primaryScreen(); 初始化显示器编号为主显示器的编号并由此获取主显示器的相关信息，或者通过其他提供的函数来达到你自己的目的。哦对了，好像curMonitor初始化为-1的时候获取到的也始终是主显示器的大小。毕竟默认值嘛。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"Qt窗口出现在屏幕中央（支持多显示器））","date":"2019-01-21T08:55:00.000Z","path":"2019/01/21/Qt窗口出现在屏幕中央（支持多显示器））/","text":"多显示器获取到的是全部屏幕的中央，有时候会卡在两个显示器的中间 用以下方法解决： 12345678int main(int argc, char * argv[]){ QApplication app(argc, argv); Window window;//这个类继承自QWidget window.move((app.desktop()-&gt;width()&nbsp;- window.width())&nbsp;/&nbsp;2,&nbsp;(app.desktop()-&gt;height()&nbsp;- window.height())&nbsp;/&nbsp;2); window.show(); return app.exec();} （实测好像并不能分多个显示器……） 参考：https://blog.csdn.net/u011288190/article/details/78143422 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"Android ToggleButton开关设置图片","date":"2019-01-18T02:58:00.000Z","path":"2019/01/18/Android-ToggleButton开关设置图片/","text":"图片设置开关 准备开关不同状态的两张图片放入drawable中。 xml文件中添加代码： 12345678910&lt;ToggleButton android:id=\"@+id/switch1\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\" android:background=\"@android:color/transparent\" android:button=\"@drawable/btn_backgrounds\" android:checked=\"false\" android:textOff=\"\" android:textOn=\"\" /&gt; 123456android:button=\"@drawable/btn_backgrounds\"是自己定义的android selector文件：&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:state_checked=\"true\" android:drawable=\"@drawable/toggle_btn_on\" /&gt; &lt;item android:drawable=\"@drawable/toggle_btn_off\" /&gt;&lt;/selector&gt; 之后在java文件中声明ToggleButton控件并且实例化，添加点击事件： 1234567891011121314151617/** * 自己出创建的内部类，监听按钮点击事件 * * @author cyf * */class MyOnCheckedChangeListener implements OnCheckedChangeListener { @Override public void onCheckedChanged(CompoundButton arg0, boolean arg1) { if (arg1) { // 开 } else { // 关 } }} 添加监听： 1switch1.setOnCheckedChangeListener((OnCheckedChangeListener) new MyOnCheckedChangeListener()); 参考：https://www.cnblogs.com/yunfang/p/5485390.html 自定义动画Github 项目地址：https://github.com/xiaosong520/SwitchButtonDemo.git 步骤： 1.创建SwitchButton类添加到自己的项目中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304/** * @TODO&lt;自定义选择开关按钮&gt; * @author 小嵩 * @date 2016-8-5 09:57:29 */public class SwitchButton extends View{ /** 圆角大小*/ private float radius; /** 开启颜色*/ private int onColor = Color.parseColor(\"#4ebb7f\"); /** 关闭颜色*/ private int offBorderColor = Color.parseColor(\"#dadbda\"); /** 灰色带颜色*/ private int offColor = Color.parseColor(\"#ffffff\"); /** 手柄颜色*/ private int spotColor = Color.parseColor(\"#ffffff\"); /** 边框颜色*/ private int borderColor = offBorderColor; /** 画笔*/ private Paint paint ; /** 开关状态*/ private boolean toggleOn = false; /** 边框大小*/ private int borderWidth = 2; /** 垂直中心*/ private float centerY; /** 按钮的开始和结束位置*/ private float startX, endX; /** 手柄X位置的最小和最大值*/ private float spotMinX, spotMaxX; /**手柄大小 */ private int spotSize ; /** 手柄X位置*/ private float spotX; /** 关闭时内部灰色带高度*/ private float offLineWidth; /** */ private RectF rect = new RectF(); /** 默认使用动画*/ private boolean defaultAnimate = true; private OnToggleChanged listener; private SwitchButton(Context context) { super(context); } public SwitchButton(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); setup(attrs); } public SwitchButton(Context context, AttributeSet attrs) { super(context, attrs); setup(attrs); } public void setup(AttributeSet attrs) { paint = new Paint(Paint.ANTI_ALIAS_FLAG); paint.setStyle(Style.FILL); paint.setStrokeCap(Cap.ROUND); this.setOnClickListener(new OnClickListener() { @Override public void onClick(View arg0) { toggle(defaultAnimate); } }); TypedArray typedArray = getContext().obtainStyledAttributes(attrs, R.styleable.SwitchButton); offBorderColor = typedArray.getColor(R.styleable.SwitchButton_offBorderColor, offBorderColor); onColor = typedArray.getColor(R.styleable.SwitchButton_onColor, onColor); spotColor = typedArray.getColor(R.styleable.SwitchButton_spotColor, spotColor); offColor = typedArray.getColor(R.styleable.SwitchButton_offColor, offColor); borderWidth = typedArray.getDimensionPixelSize(R.styleable.SwitchButton_borderWidth, borderWidth); defaultAnimate = typedArray.getBoolean(R.styleable.SwitchButton_animate, defaultAnimate); typedArray.recycle(); borderColor = offBorderColor; } public void toggle() { toggle(true); } public void toggle(boolean animate) { toggleOn = !toggleOn; takeEffect(animate); if(listener != null){ listener.onToggle(toggleOn); } } public void toggleOn() { setToggleOn(); if(listener != null){ listener.onToggle(toggleOn); } } public void toggleOff() { setToggleOff(); if(listener != null){ listener.onToggle(toggleOn); } } /** * 设置显示成打开样式，不会触发toggle事件 */ public void setToggleOn() { setToggleOn(true); } /** * @param animate */ public void setToggleOn(boolean animate){ toggleOn = true; takeEffect(animate); } /** * 设置显示成关闭样式，不会触发toggle事件 */ public void setToggleOff() { setToggleOff(true); } public void setToggleOff(boolean animate) { toggleOn = false; takeEffect(animate); } private void takeEffect(boolean animate) { if(animate){ slide(); }else{ calculateEffect(toggleOn ? 1 : 0); } } @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { final int widthMode = MeasureSpec.getMode(widthMeasureSpec); final int heightMode = MeasureSpec.getMode(heightMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); Resources r = Resources.getSystem(); if(widthMode == MeasureSpec.UNSPECIFIED || widthMode == MeasureSpec.AT_MOST){ widthSize = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 50, r.getDisplayMetrics()); widthMeasureSpec = MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.EXACTLY); } if(heightMode == MeasureSpec.UNSPECIFIED || heightSize == MeasureSpec.AT_MOST){ heightSize = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 30, r.getDisplayMetrics()); heightMeasureSpec = MeasureSpec.makeMeasureSpec(heightSize, MeasureSpec.EXACTLY); } super.onMeasure(widthMeasureSpec, heightMeasureSpec); } @Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) { super.onLayout(changed, left, top, right, bottom); final int width = getWidth(); final int height = getHeight(); radius = Math.min(width, height) * 0.5f; centerY = radius; startX = radius; endX = width - radius; spotMinX = startX + borderWidth; spotMaxX = endX - borderWidth; spotSize = height - 4 * borderWidth; spotX = toggleOn ? spotMaxX : spotMinX; offLineWidth = 0; } private void slide(){ Animation animation = new Animation() { @Override protected void applyTransformation(float interpolatedTime, Transformation t) { if(toggleOn){ calculateEffect(interpolatedTime); }else{ calculateEffect(1-interpolatedTime); } } }; animation.setDuration(200); clearAnimation(); startAnimation(animation); } private int clamp(int value, int low, int high) { return Math.min(Math.max(value, low), high); } @Override public void draw(Canvas canvas) { // rect.set(0, 0, getWidth(), getHeight()); paint.setColor(borderColor); canvas.drawRoundRect(rect, radius, radius, paint); if(offLineWidth &gt; 0){ final float cy = offLineWidth * 0.5f; rect.set(spotX - cy, centerY - cy, endX + cy, centerY + cy); paint.setColor(offColor); canvas.drawRoundRect(rect, cy, cy, paint); } rect.set(spotX - 1 - radius, centerY - radius, spotX + 1.1f + radius, centerY + radius); paint.setColor(borderColor); canvas.drawRoundRect(rect, radius, radius, paint); final float spotR = spotSize * 0.5f; rect.set(spotX - spotR, centerY - spotR, spotX + spotR, centerY + spotR); paint.setColor(spotColor); canvas.drawRoundRect(rect, spotR, spotR, paint); } /** * @param value */ private void calculateEffect(final double value) { final float mapToggleX = (float) mapValueFromRangeToRange(value, 0, 1, spotMinX, spotMaxX); spotX = mapToggleX; float mapOffLineWidth = (float) mapValueFromRangeToRange(1 - value, 0, 1, 10, spotSize); offLineWidth = mapOffLineWidth; final int fb = Color.blue(onColor); final int fr = Color.red(onColor); final int fg = Color.green(onColor); final int tb = Color.blue(offBorderColor); final int tr = Color.red(offBorderColor); final int tg = Color.green(offBorderColor); int sb = (int) mapValueFromRangeToRange(1 - value, 0, 1, fb, tb); int sr = (int) mapValueFromRangeToRange(1 - value, 0, 1, fr, tr); int sg = (int) mapValueFromRangeToRange(1 - value, 0, 1, fg, tg); sb = clamp(sb, 0, 255); sr = clamp(sr, 0, 255); sg = clamp(sg, 0, 255); borderColor = Color.rgb(sr, sg, sb); postInvalidate(); } public interface OnToggleChanged{ /** * @param on */ public void onToggle(boolean on); } public void setOnToggleChanged(OnToggleChanged onToggleChanged) { listener = onToggleChanged; } public boolean isAnimate() { return defaultAnimate; } public void setAnimate(boolean animate) { this.defaultAnimate = animate; } /** * Map a value within a given range to another range. * @param value the value to map * @param fromLow the low end of the range the value is within * @param fromHigh the high end of the range the value is within * @param toLow the low end of the range to map to * @param toHigh the high end of the range to map to * @return the mapped value */ public static double mapValueFromRangeToRange( double value, double fromLow, double fromHigh, double toLow, double toHigh) { double fromRangeSize = fromHigh - fromLow; double toRangeSize = toHigh - toLow; double valueScale = (value - fromLow) / fromRangeSize; return toLow + (valueScale * toRangeSize); }} 2.在项目res - values目录下 - 找到 attrs.xml 文件，在resource中间添加如下代码：（文件名好像无所谓） 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;declare-styleable name=\"SwitchButton\"&gt; &lt;attr name=\"borderWidth\" format=\"dimension\"&gt; &lt;/attr&gt; &lt;attr name=\"offBorderColor\" format=\"reference|color\"&gt; &lt;/attr&gt; &lt;attr name=\"offColor\" format=\"reference|color\"&gt; &lt;/attr&gt; &lt;attr name=\"onColor\" format=\"reference|color\"&gt; &lt;/attr&gt; &lt;attr name=\"spotColor\" format=\"reference|color\"&gt; &lt;/attr&gt; &lt;attr name=\"animate\" format=\"reference|boolean\"&gt; &lt;/attr&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 以及 colors.xml 文件： 123456&lt;!-- 白色 --&gt;&lt;color name=\"common_white\"&gt;#FFFFFF&lt;/color&gt;&lt;!-- 浅灰色 --&gt;&lt;color name=\"light_gray\"&gt;#DDDDDD&lt;/color&gt;&lt;!-- 浅蓝色 --&gt;&lt;color name=\"common_light_blue\"&gt;#039AE3&lt;/color&gt; 3.在XML布局文件中使用控件（路径引用需改成SwitchButton类所在目录）： 1234567891011&lt;com.yourpath.SwitchButton android:id=\"@+id/switchButton\" android:layout_width=\"45dp\" android:layout_height=\"25dp\" app:borderWidth=\"0.8dp\" app:offBorderColor=\"@color/light_gray\" app:offColor=\"@color/common_white\" app:onColor=\"@color/common_light_blue\" app:spotColor=\"@color/common_white\" app:animate=\"true\" android:layout_margin=\"20dp\" /&gt; 控件的属性介绍： borderWidth 描边宽度 offBorderColor 关闭状态下描边的颜色 offColor 关闭状态的颜色 onColor 打开状态的颜色 spotColor 控件中间的圆点的颜色 animate 是否打开动画效果 4.在Activity中使用： 4.1绑定控件：如果使用ButterKinfe库的话： 1@Bind(R.id.switchButton) SwitchButton switchButton; findViewById的方式: 1SwitchButton switchButton = (SwitchButton)findViewById(R.id.switchButton); 4.2使用控件： 12345678switchButton.setToggleOn(false);//默认打开。如果参数传false,则打开页面初始化时不会有动画效果(改变状态还是会有动画) switchButton.setOnToggleChanged(new SwitchButton.OnToggleChanged(){ @Override public void onToggle(boolean isOn) { //处理自己的逻辑 showToast( \"SwitchButton\"+isOn); } }); 参考：https://blog.csdn.net/qq_22393017/article/details/52198453 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"ASP.NET-学习笔记","date":"2019-01-15T13:11:00.000Z","path":"2019/01/15/ASP-NET-学习笔记/","text":"ASP.NET 简介ASP.NET 是新一代的 ASP。它无法兼容经典 ASP，但 ASP.NET 可以引用 ASP。 ASP.NET 页面需要编译，因此比经典 ASP 更快。 ASP.NET 拥有更好的语言支持，大量用户控件，基于 XML 的组件，以及对用户认证的整合。 ASP.NET 页面的扩展名是 .aspx，通常由 VB (Visual Basic) 或 C# (C sharp) 编写。 ASP.NET 中的用户控件可以通过不同的语言进行编写，包括 C++ 和 Java。 当浏览器请求 ASP.NET 文件时，ASP.NET 引擎读取该文件，编译并执行文件中的脚本，然后以纯 HTML 向浏览器返回结果。 扩展名 ASP 文件的文件扩展名是 .asp ASP.NET 文件的文件扩展名是 .aspx ASP.NET 文件使用 C# 语法的文件扩展名是 .cshtml ASP.NET 文件使用 Razor VB 语法的文件扩展名是 .vbhtml WP 教程Web Pages 是三种 ASP.NET 编程模型中的一种，用于创建 ASP.NET 网站和 web 应用程序。 其他两种编程模型是 Web Forms 和 MVC (Model, View, Controller)。 Web Pages 是最简单的 ASP.NET 网页开发编程模型。它提供了一种简单的方法将 HTML、CSS、JavaScript 以及服务器代码结合起来。 WP Razor Razor 是一种向网页添加基于服务器的代码的标记语法 Razor 拥有传统 ASP.NET 标记的能力，但是更易学习，更易使用 Razor 是一种类似 ASP 和 PHP 的服务器端标记语法 Razor 支持 C# 和 Visual Basic 编程语言 1&lt;p&gt;The time is @DateTime.Now&lt;/p&gt; 包含常规的 HTML 标记，此外还包含：由 @ 标记的 Razor 代码。 C# 的主要 Razor 语法规则 Razor 代码块由 @{ … } 包围 行内表达式（变量和函数）以 @ 开始 代码语句以分号结束 变量通过 var 关键词进行声明 字符串用引用来包围 C# 代码对大小写敏感 C# 文件的扩展名是 .cshtml 实例 12345678910111213&lt;!-- 单行代码块 --&gt;@{ var myMessage = \"Hello World\"; }&lt;!-- 行内表达式或变量 --&gt;&lt;p&gt;The value of myMessage is: @myMessage&lt;/p&gt; &lt;!-- 多行代码块 --&gt;@{var greeting = \"Welcome to our site!\";var weekDay = DateTime.Now.DayOfWeek;var greetingMessage = greeting + \" Today is: \" + weekDay;}&lt;p&gt;The greeting is: @greetingMessage&lt;/p&gt; VB 的主要 Razor 语法规则 Razor 代码块由 @Code … End 包围 行内表达式（变量和函数）以 @ 开始 变量通过 Dim 关键词进行声明 字符串用引用来包围 C# 代码对大小写不敏感 C# 文件的扩展名是 .vbhtml 实例 1234567891011121314&lt;!-- 单行代码块 --&gt;@Code dim myMessage = \"Hello World\" End Code &lt;!-- 行内表达式或变量 --&gt;&lt;p&gt;The value of myMessage is: @myMessage&lt;/p&gt; &lt;!-- 多行代码块 --&gt;@Codedim greeting = \"Welcome to our site!\" dim weekDay = DateTime.Now.DayOfWeek dim greetingMessage = greeting &amp; \" Today is: \" &amp; weekDayEnd Code &lt;p&gt;The greeting is: @greetingMessage&lt;/p&gt; WP 布局###内容快 使用 @RenderPage() 方法从不同的文件导入内容。 内容块（来自另一个文件）能够被输入网页中的任意位置，并可包含文本、标记和代码，就像任何常规的网页那样。 12345678&lt;html&gt;&lt;body&gt; @RenderPage(\"header.cshtml\") &lt;h1&gt;Hello Web Pages&lt;/h1&gt; &lt;p&gt;This is a paragraph&lt;/p&gt; @RenderPage(\"footer.cshtml\")&lt;/body&gt;&lt;/html&gt; 布局页面创建一致外观的另一种方法是使用布局网页。布局网页包含网页的结构，而不是内容。当网页（内容页）链接到布局页时，它会根据布局页（模板）来显示。 布局页类似普通的网页，但是会在引用内容页的位置调用 @RenderBody() 方法。 每个内容页必须以 Layout 指令开头。 布局网页：Layout.cshtml 1234567&lt;html&gt;&lt;body&gt; &lt;p&gt;This is header text&lt;/p&gt; @RenderBody() &lt;p&gt;© 2012 W3School. All rights reserved.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 任意网页：（被包含在布局网页中） 123456789@{Layout=\"Layout.cshtml\";}&lt;h1&gt;Welcome to W3Schools&lt;/h1&gt;&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit,sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laborisnisi ut aliquip ex ea commodo consequat.&lt;/p&gt; 防止代码泄露名称以下划线开头的文件无法通过 web 来浏览。 隐藏敏感信息（数据库密码、电邮密码等）的常用方法是把这些信息保存在名为 “_AppStart” 的独立文件中 _AppStart.cshtml1234567@{ WebMail.SmtpServer = \"mailserver.example.com\"; WebMail.EnableSsl = true; WebMail.UserName = \"username@example.com\"; WebMail.Password = \"your-password\"; WebMail.From = \"your-name-here@example.com\";} WP 文件夹ASP.NET 网页的典型文件夹结构： “Account” 文件夹包含登录和安全文件 “App_Data” 文件包含数据库和数据文件 “Images” 文件夹包含图片 “Scripts” 文件夹包含浏览器脚本 “Shared” 文件夹包含通用文件（比如布局和样式文件） 物理文件结构类似：C:\\Johnny\\Documents\\MyWebSites\\Demo\\Images URL 和路径URL 用于从 web 访问文件： http://www.w3school.com.cn/html5/html5_intro.asp URL 在服务器上对应的文件是： C:\\MyWebSites\\htm5\\html5_intro.asp 1234URL http://www.w3school.com.cn/html/html5_intro.asp服务器名 w3school虚拟路径 /html/html5_intro.asp物理路径 C:\\MyWebSites\\w3school\\/html/html5_intro.asp ~ 操作符如需在编程代码中规定虚拟根目录，请使用 ~ 操作符。 如果您使用 ~ 操作符，而不是路径，就能够在不改变任何代码的情况下，将网站移动到不同的文件夹或位置： 12var myImagesFolder = \"~/images\";var myStyleSheet = \"~/styles/StyleSheet.css\"; Server.MapPath 方法Server.MapPath 方法将虚拟路径 (/default.cshtml) 转换为服务器能够理解的物理路径 (C:\\Johnny\\MyWebSited\\Demo\\default.cshtml)。 当需要打开位于服务器上的数据文件时，您就会用到该方法（数据文件只能通过完整的物理路径来访问）： 12var pathName = \"~/dataFile.txt\";var fileName = Server.MapPath(pathName); Href 方法Href 方法把代码中的路径转换为浏览器能够理解的路径（浏览器无法理解 ~ 操作符）。 您使用 Href 方法来创建指向资源（比如图片和 CSS 文件）的路径。 您会经常在 HTML 、&lt;a&gt;、&lt;img&gt; 以及 &lt;link&gt; 元素中用到该方法： 123456@{var myStyleSheet = \"~/Shared/Site.css\";}&lt;!-- 创建指向 CSS 文件的链接 --&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"@Href(myStyleSheet)\" /&gt;&lt;!-- 同上 : --&gt; WP 全局Web 启动之前：_AppStart假如站点根目录中名为 _AppStart 的页面存在，ASP.NET 会在站点内的任何页面被请求之前首先运行这个页面。 通常 _AppStart 用于启动代码和全局值的初始化，比如计数器和全局名称。 注释 1：_AppStart 的文件扩展名应与网页相同，比如 _AppStart.cshtml。 注释 2：_AppStart 有下划线前缀。正因如此，用户才无法直接查看该文件 每张页面之前：_PageStart就像在站点启动前运行 _AppStart 那样，您能够在每个文件夹中的任意页面之前运行代码。 对于 web 中的每个文件夹，您能够添加名为 _PageStart 的文件。 通常 _PageStart 用于设置文件夹中所有页面的布局文件，或者在运行页面之前检查用户登录。 当请求到来时，ASP.NET 检查 _AppStart 是否存在。如果存在，并且这是对站点的第一次请求，则运行 _AppStart。 然后 ASP.NET 检查 _PageStart 是否存在。如果存在，则运行 _PageStart，在被请求的页面之前。 如果您在 _PageStart 内部引用了对 RunPage() 的调用，那么您可以规定在何处运行被请求的页面。否则，_PageStart 在被请求页面之前运行。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"http://blog.iwxyi.com/tags/ASP-NET/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.iwxyi.com/tags/学习笔记/"}]},{"title":"Qt QtextEdit高度自适应","date":"2019-01-15T12:03:00.000Z","path":"2019/01/15/Qt-QtextEdit高度自适应/","text":"1QTextEdit *editor = new QTextEdit(this); 1connect(editor-&gt;document(),SIGNAL(contentsChanged()),this,SLOT(textAreaChanged())); 1234567891011121314private slots:void textAreaChanged(){QTextDocument *document=qobject_cast&lt;QTextDocument*&gt;(sender()); document-&gt;adjustSize(); if(document){ QTextEdit *editor=qobject_cast&lt;QTextEdit*&gt;(document-&gt;parent()-&gt;parent()); if (editor){ int newheight = document-&gt;size().rheight()+10; if (newheight != editor-&gt;height()){ editor-&gt;setFixedHeight(newheight); } } } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"安装Workerman","date":"2019-01-15T08:40:00.000Z","path":"2019/01/15/安装Workerman/","text":"首先通过 composer 安装，切换到项目根目录，输入命令 composer require topthink/think-worker 如果遇见错误： 12345Using version ^6.3 for guzzlehttp/guzzle./composer.json has been updatedLoading composer repositories with package informationUpdating dependencies (including require-dev)Your requirements could not be resolved to an installable set of packages. 解决办法：在composer.json中添加以下“minimum-stability”: “dev”, //这个遇上require时完全可以用上 如果需要在window下做服务端，还需要 composer require workerman/workerman-for-win 首先要明白composer之后workerman是安装到哪去了，安装到tp5项目下vendor目录中 运行出现错误PHP Fatal error: Call to undefined function Workerman\\Lib\\pcntl_signal()，需要删除vendor\\workerman\\workerman，防止命名覆盖 参考：https://www.100txy.com/index.php/article/139.html常见错误解决方法：https://blog.csdn.net/qq_32642039/article/details/78292685composer 安装速度太慢：https://packagist.laravel-china.org/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.iwxyi.com/tags/PHP/"},{"name":"Workerman","slug":"Workerman","permalink":"http://blog.iwxyi.com/tags/Workerman/"}]},{"title":"Qt打包发布应用","date":"2019-01-14T09:48:00.000Z","path":"2019/01/14/Qt打包发布应用/","text":"Windows以release方式编译出可执行文件 路径：D:\\IDE\\Qt5.12.3\\5.12.3\\mingw73_32\\bin 命令：windeployqt.exe app.exe 写作天下打包命令： 1D:\\IDE\\Qt5.13.1\\5.13.1\\mingw73_32\\bin\\windeployqt.exe WriterFly.exe exe尽量使用英文，否则可能出现Cannot find GCC installation directory. g++.exe must be in the path错误 使用 UPX 压缩工具减小体积 使用 Enigma Virtual Box 打包成单独一个文件 Linuxlinuxdeployqt安装去GitHub上下载编译好的 linuxdeployqt-x86_64.AppImage 应用程序文件。 最简单的安装方式：将其改名为 linuxdeployqt，并 chmod +x，然后复制到 /usr/local/bin/。然后命令行输入 linuxdelpoyqt –version，查看是否安装成功，若输出版本信息表示安装成功。 打包成 AppImage创建一个文件夹，然后将编译的可执行程序（此处为myAPP）复制到此文件夹下；2、在文件夹内使用 linuxdeployqt 进行打包，一定要加上-appimage选项，命令如下： $ linuxdeployqt myAPP -appimage在完成第二部操作之后，就可以在其他机器上愉快的使用我们发布的程序了。 打包成AppRun若 qmake 存放路径也是 /home/wu/Qt5.10.1/5.10.1/gcc_64/bin/qmake 程序名是 UbuntuApp 的话，cd 到你 deployqt 的路径 执行 ./linuxdeployqt UbuntuApp -qmake=\"/home/wu/Qt5.10.1/5.10.1/gcc_64/bin/qmake\" 例如： 123cd ~/Projects/build-MyApp-Release/usr/local/bin/linuxdeployqt MyApp -qmake=\"~/Qt5.13.1/5.13.1/gcc_64/bin/qmake\" -unsupported-allow-new-glibc 生成一个 AppRun 文件。 环境库注意ldd命令没有拷贝的环境库，也就是platforms文件夹及两个链接文件 https://blog.csdn.net/lusanshui/article/details/84988017 ln -s $PWD/libQt5XcbQpa.so.5.13.1 libQt5XcbQpa.so.5 ln -s $PWD/libQt5DBus.so.5.13.1 libQt5DBus.so.5 中文输入法将安装在 /usr/lib/x86_64-linux-gnu/qt5/plugins/platforminputcontexts/ 下的库文件 libfcitxplatforminputcontextplugin.so 拷贝到以下路径： ~/Qt5.13.1/Tools/QtCreator/bin/plugins/platforminputcontexts/ ~/Qt5.13.1/5.13.1/gcc_64/plugins/platforminputcontexts/ 之后再重新编译、打包部署 打包成DEBhttps://blog.csdn.net/weixin_39083202/article/details/106817151 Mac直接打包成dmg文件即可。 写作天下打包命令： 12cd ~/Qt5.13.1/5.13.1/clang_64/bin./macdeployqt ~/Projects/WriterFly_v2.1.0/WriterFly.app -dmg 遇到错误： 1ERROR: Bundle creation error: \"hdiutil: create failed - \\xE6\\x96\\x87\\xE4\\xBB\\xB6\\xE5\\xB7\\xB2\\xE7\\xBB\\x8F\\xE5\\xAD\\x98\\xE5\\x9C\\xA8\\n\" 把原先生成的 dmg 文件删除即可。 Android直接编译成APK document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"项目管理","slug":"项目管理","permalink":"http://blog.iwxyi.com/tags/项目管理/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"Qt使用HTTPS（SSL）","date":"2019-01-13T11:03:00.000Z","path":"2019/01/13/Qt使用HTTPS（SSL）/","text":"一、简述在使用Qt发送HTTP请求中一般使用的链接都是http://前缀，而有的服务器支持 https://前缀的链接，而Qt本身是支持https的，但是https访问需要用到SSL认证，而QT默认是不支持SSL认证，所以在Qt中使用https需要进行SSL认证。实现非常容易，简单几步即可完成。 二、HTTPS和HTTP的区别1、简介 超文本传输协议HTTP被用于在Web浏览器和网站服务器之间传递信息。HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息，比如信用卡号、密码等。 为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS。为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。 2、区别 https协议需要到ca申请证书，一般免费证书很少，需要交费。 http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 三、如何进行SSL认证1、首先，因为需要Openssl支持，使用SSL进行认证，所以需要对应的库文件 libeay32.dll和ssleay32.dll。需要下载libeay32.dll 和 ssleay32.dll两个库文件，将这两个库文件拷贝到程序生成目录下（即生成exe的同级目录）或者拷贝到QtNetwork模块的库文件目录中。 2、在发送HTTP请求之前加上如下代码 1234567891011121314151617181920212223242526272829303132333435void onSendHttpsRequest(QString url){ QNetworkAccessManager* pManager = new QNetworkAccessManager(this); QNetworkRequest request; // 发送https请求前准备工作; QSslConfiguration config; QSslConfiguration conf = request.sslConfiguration(); conf.setPeerVerifyMode(QSslSocket::VerifyNone); conf.setProtocol(QSsl::TlsV1SslV3); request.setSslConfiguration(conf); request.setUrl(QUrl(url)); // \"https://www.temp.com\" QNetworkReply *pReply = pManager-&gt;post(request, bytePost); connect(pReply , SIGNAL(finished()) , this , SLOT(onFinished()); connect(pReply , SIGNAL(error(QNetworkReply::NetworkError)) , this , SLOT(onError(QNetworkReply::NetworkError)));}// 请求完成;void onFinished(){ QNetworkReply *pReplay = qobject_cast&lt;QNetworkReply*&gt;(sender()); // 保存接受的数据; QByteArray replyContent = pReplay-&gt;readAll();}// 请求失败;void onError(QNetworkReply::NetworkError errorCode){ QNetworkReply *pReplay = qobject_cast&lt;QNetworkReply*&gt;(sender()); // 输出错误码及错误信息; qDebug()&lt;&lt; errorCode; qDebug()&lt;&lt; pReplay-&gt;errorString();} 关于两个库文件下载1、在 http://slproweb.com/products/Win32OpenSSL.html 中下载 Win32 OpenSSL进行安装，将bin目录下面的库拷贝出来放到生成程序exe同级目录下即可。 2、 libeay32.dll 、 ssleay32.dll动态链接库 直接在我的资源中进行下载。 3、使用everything本地搜索，很多程序可能都有……建议用Qt的MinGW自带的。 参考：http://blog.csdn.net/goforwardtostep/article/details/53588961 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"},{"name":"HTTPS","slug":"HTTPS","permalink":"http://blog.iwxyi.com/tags/HTTPS/"}]},{"title":"Qt使用HTTP","date":"2019-01-13T11:01:00.000Z","path":"2019/01/13/Qt使用HTTP/","text":"一、HTTP协议Qt网络模块提供的API可以实现基于HTTP(Hyper Text Transport Protocol)协议的应用程序。此外, Qt还可以实现多种基于协议的应用程序, 如位于OSI 7层应用层的FTP、DNS、SNMP。 Qt4.x版本提供了QHttp和QFtp类以支持HTTP和FTP协议。从Qt 5.0 版本开始, 删除了QHttp 和 QFtp 类, 通过QNetworkReply、QNetworkAccessManager、QNetworkRequest类实现基于HTTP和FTP协议的应用程序。除了HTTP和FTP协议外, 该类还可以实现高层(OSI 7层中的上层)网络应用程序。 ① QNetworkRequest类, 通过网络请求是使用。而且, 可以请求包含头信息和加密(encryption)的头信息。 QNetworkRequest可以通过URL上传和下载HTTP、FTP的本地文件。 ② QNetworkAccessManager 类用于管理网络请求和响应, 可以在网络上管理请求 和 响应的设置, 使用代理和缓存,处理网络请求和响应过程中触发的信号。 ③ QNetworkReply类用于在网络上处理响应, 它是QIODevice的子类, 支持同步异步的方式。 二、代码示例头文件： 1234567891011121314151617181920212223242526272829303132/*头文件*/#ifndef NETWORKWIDGET_H#define NETWORKWIDGET_H#include &lt;QtNetwork/QNetworkAccessManager&gt;#include &lt;QtNetwork/QNetworkRequest&gt;#include &lt;QtNetwork/QNetworkReply&gt;#include &lt;QtWidgets/QWidget&gt;#include &lt;QTextCodec&gt;#include &lt;QString&gt;#include &lt;QUrl&gt;#include \"ui_networkWidget.h\"class networkWidget : public QWidget{ Q_OBJECTpublic: networkWidget(QWidget *parent = 0); ~networkWidget();private Q_SLOTS: void slot_replayFinished(QNetworkReply *reply);private: Ui::networkWidgetClass ui; QNetworkAccessManager *m_manager; //QNetworkReply *m_replay;};#endif // NETWORKWIDGET_H 源文件： 1234567891011121314151617181920212223242526/*实现文件*/#include \"networkWidget.h\"networkWidget::networkWidget(QWidget *parent) : QWidget(parent){ ui.setupUi(this); this-&gt;setWindowFlags(Qt::FramelessWindowHint); m_manager = new QNetworkAccessManager(this);//新建QNetworkAccessManager对象 connect(m_manager, SIGNAL(finished(QNetworkReply *)), this, SLOT(slot_replayFinished(QNetworkReply*))); //关联信号和槽 m_manager-&gt;get(QNetworkRequest(QUrl(\"http://apistore.baidu.com/microservice/weather?cityid=成都\")));//发送请求}networkWidget::~networkWidget(){ }void networkWidget::slot_replayFinished(QNetworkReply *reply){ QTextCodec *codec = QTextCodec::codecForName(\"utf8\"); //使用utf8编码, 这样可以显示中文 QString str = codec-&gt;toUnicode(reply-&gt;readAll()); ui.textBrowser-&gt;setText(str); reply-&gt;deleteLater();//最后要释放replay对象} main 文件 12345678910#include \"networkWidget.h\"#include &lt;QtWidgets/QApplication&gt;int main(int argc, char *argv[]){ QApplication a(argc, argv); networkWidget w; w.show(); return a.exec();} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://blog.iwxyi.com/tags/HTTP/"},{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"Qt连接MySQL","date":"2019-01-13T10:59:00.000Z","path":"2019/01/13/Qt连接MySQL/","text":"复制文件： libmysql.dlllibmysql.libmysqlclient.lib 到： D:\\Qt\\Qt5.6.1\\5.6\\mingw49_32\\bin 到 MySQL 安装文件夹里面可以找到这些文件 如果出现问题，那就是版本（32/64）不对……去 https://dev.mysql.com/downloads/connector/c/ 上下载对应版本 Pro 文件加上： QT += core gui sql Main 文件： 123456789101112131415161718192021222324252627#include \"mainwindow.h\"#include &lt;QApplication&gt;#include &lt;QDebug&gt;#include &lt;QtSql/QSqlDatabase&gt;#include &lt;QtSql/QSqlQuery&gt;#include &lt;QtSql/QSql&gt;#include &lt;QStringList&gt;int main(int argc, char *argv[]){ QApplication a(argc, argv); QStringList drivers = QSqlDatabase::drivers(); qDebug() &lt;&lt; \"支持的数据库驱动：\" &lt;&lt; drivers; QSqlDatabase db = QSqlDatabase::addDatabase(\"QMYSQL\"); db.setHostName(\"localhost\"); db.setDatabaseName(\"test\"); db.setUserName(\"root\"); db.setPassword(\"root\"); if (db.open()) qDebug() &lt;&lt; \"连接成功\"; else qDebug() &lt;&lt; \"连接失败\"; return a.exec();} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"MySQL","slug":"MySQL","permalink":"http://blog.iwxyi.com/tags/MySQL/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"Qt主线程中联网","date":"2019-01-13T09:05:00.000Z","path":"2019/01/13/Qt主线程中联网/","text":"在主线程中联网，不使用多线程 （不会卡主线程） 1234567891011121314151617QUrl url(ui-&gt;lineEdit-&gt;text());QNetworkAccessManager manager;QEventLoop loop;QTextCodec* codec;QNetworkReply* reply;reply = manager.get(QNetworkRequest(url));//请求结束并下载完成后，退出子事件循环connect(reply, SIGNAL(finished()), &amp;loop, SLOT(quit()));//开启子事件循环loop.exec();QString codeContent = reply-&gt;readAll();//一定要注意编码问题，否则很容易出现乱码的 //codec = QTextCodec::codecForHtml(codeContent.toAscii());//codeContent = codec-&gt;toUnicode(codeContent.toAscii()); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://blog.iwxyi.com/tags/HTTP/"},{"name":"多线程","slug":"多线程","permalink":"http://blog.iwxyi.com/tags/多线程/"},{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"PHP取网页源码","date":"2019-01-13T08:11:00.000Z","path":"2019/01/13/PHP取网页源码/","text":"取HTTP网页源码123456789101112$ret = file_get_contents('要采集的网页URL');// 若需要从页面中获取内容，可以用正则匹配$begin=change_match_string('匹配开头的字符串');$end=change_match_string('匹配结尾的字符串');$p = \"{$begin}(.*){$end}\";// 使用正则进行匹配，[0]是全部，1开始是括号的if (preg_match($p,$ret,$rs)) return $rs[1];else return false; 乱码编码转换（网址表单）： 1$getcontent = iconv(\"gb2312\", \"utf-8\",$contents); 乱码网页编码 1$html = iconv('gb2312', 'utf-8//IGNORE',$html); 取HTTPS网页源码若用 file_get_contents() 函数会报错： file_get_contents(): Unable to find the wrapper “https” - did you forget to enable it when you configured PHP 所以用函数：curl_setopt() 1234567891011121314151617181920212223&lt;?php header(\"Content-Type: text/html;charset=utf-8\"); function getHttps($url){ //初始化 $ch = curl_init(); //设置选项，包括URL curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_HEADER, 0); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE); // https请求 不验证证书和hosts curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE); $output = curl_exec($ch); //执行并获取HTML文档内容 $str = htmlspecialchars($output);//转换为源代码形式 //释放curl句柄 curl_close($ch); return $str ;} $url ='https://www.hao123.com/index.html'; echo getHttps($url);?&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.iwxyi.com/tags/PHP/"},{"name":"HTTP","slug":"HTTP","permalink":"http://blog.iwxyi.com/tags/HTTP/"}]},{"title":"Spring框架入门-学习笔记","date":"2019-01-13T05:23:00.000Z","path":"2019/01/13/Spring框架入门/","text":"介绍 Spring框架是个轻量级的Java EE框架。所谓轻量级，是指不依赖于容器就能运行的。Struts、Hibernate也是轻量级的。 Spring以IoC、AOP为主要思想，其中IoC，Inversion of Control 指控制反转或反向控制。在Spring框架中我们通过配置创建类对象，由Spring在运行阶段实例化、组装对象。AOP，Aspect Oriented Programming，面向切面编程，其思想是在执行某些代码前执行另外的代码，使程序更灵活、扩展性更好，可以随便地添加、删除某些功能。Servlet中的Filter便是一种AOP思想的实现。 Spring同时也是一个“一站式”框架，即Spring在JavaEE的三层架构[表现层（Web层）、业务逻辑层（Service层）、数据访问层（DAO层）]中，每一层均提供了不同的解决技术。如下： 表现层（Web层）：Spring MVC 业务逻辑层（Service层）：Spring的IoC 数据访问层（DAO层）：Spring的jdbcTemplate Spring中的IoC操作 将对象的创建交由Spring框架进行管理。 IoC操作分为：IoC配置文件方式和IoC的注解方式。 IoC入门案例（1）导入Spring框架中的相关jar包，这里只导入Spring的Core模块（Core模块是框架的核心类库）下的jar包（使用IoC的基本操作，并不需要导入Spring的所有jar包，只导入spring-beans、spring-core、spring-context、spring-expression这4个jar包），以及 支持日志输出的 commons-logging 和 log4j 的jar包；（2）创建一个普通的Java类，并在该类中创建方法，如下： User.java 123456789101112131415package com.wm103.ioc;/** * Created by DreamBoy on 2018/3/17. */public class User { public void add() { System.out.println(\"User Add Method.\"); } @Override public String toString() { return \"This is a user object.\"; }}123456789101112131415 （3）创建Spring的配置文件，进行Bean的配置 Spring的核心配置文件名称和位置不是固定的。但官方件建议将该核心配置文件放在src目录下，且命名为 applicationContext.xml。 这里为了方便，将核心配置文件放在src目录下，并命名为 applicationContext.xml，内容如下： 123456&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"user\" class=\"com.wm103.ioc.User\"&gt;&lt;/bean&gt;&lt;/beans&gt;123456 （４）编写测试类进行测试，通过配置文件创建类对象 TestIoC.java 123456789101112131415161718192021package com.wm103.ioc;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * Created by DreamBoy on 2018/3/17. */public class TestIoc { @Test public void runUser() { // 1. 加载Spring配置文件，根据创建对象 ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); // 2. 得到配置创建的对象 User user = (User) context.getBean(\"user\"); System.out.println(user); user.add(); }}123456789101112131415161718192021 Spring的bean管理（配置文件）Bean实例化的方式 在Spring中通过配置文件创建对象。 Bean实例化三种方式实现：（1）使用类的无参数构造创建，如： 12&lt;!-- 等同于 user = new com.wm103.ioc.User(); --&gt;&lt;bean id=\"user\" class=\"com.wm103.ioc.User\"&gt;&lt;/bean&gt;12 （2）使用静态工厂创建 如果一个Bean不能通过new直接实例化，而是通过工厂类的某个静态方法创建的，需要把&lt;bean&gt;的class属性配置为工厂类。如： 12&lt;!-- 等同于 user = com.wm103.ioc.UserFactory.createInstance(); --&gt;&lt;bean id=\"user\" class=\"com.wm103.ioc.UserFactory\" factory-method=\"createInstance\"&gt;&lt;/bean&gt;12 （3）使用实例工厂创建 如果一个Bean不能通过new直接实例化，而是通过工厂类的某个实例方法创建的，需要先配置工厂的&lt;bean&gt;标签，然后在需要创建的对象的bean标签的factory-bean属性配置为工厂类对象，factory-method属性配置为产生实例的方法。如： 1234&lt;!-- 等同于 userFactory = new com.wm103.ioc.UserFactory(); --&gt;&lt;bean id=\"userFactory\" class=\"com.wm103.ioc.UserFactory\"&gt;&lt;/bean&gt;&lt;!-- 等同于 user = userFactory.createInstance(); --&gt;&lt;bean id=\"user\" factory-bean=\"userFactory\" factory-method=\"createInstance\"&gt;&lt;/bean&gt;1234 Bean标签的常用属性（1）id属性：用于指定配置对象的名称，不能包含特殊符号。（2）class属性：创建对象所在类的全路径。（3）name属性：功能同id属性一致。但是在name属性值中可以包含特殊符号。（4）scope属性 singleton：默认值，单例单例模式下，在程序下只有一个实例。非单态模式下，每次请求该Bean，都会生成一个新的对象。 prototype：多例 request：创建对象后将对象存放到request域 session：创建对象后将对象存放到session域 globalSession：创建对象后将对象存放到globalSession域 属性注入 属性注入指创建对象时，向类对象的属性设置属性值。 在Spring框架中支持set方法注入和有参构造函数注入，即创建对象后通过set方法设置属性或采用有参构造函数创建对象并初始化属性。 使用有参构造函数注入属性 案例： Student.java 提供有参的构造方法 12345678910111213141516package com.wm103.ioc;public class Student { private String name; public Student(String name) { this.name = name; } @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + '}'; }}12345678910111213141516 bean的配置： 123&lt;bean id=\"student\" class=\"com.wm103.ioc.Student\"&gt; &lt;constructor-arg name=\"name\" value=\"DreamBoy\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;123 创建Student对象进行测试： 12345678@Testpublic void runStudent() { // 1. 加载Spring配置文件，根据创建对象 ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); // 2. 得到配置创建的对象 Student student = (Student) context.getBean(\"student\"); System.out.println(student);}12345678 使用set方法注入属性 案例： Teacher.java 提供属性的set方法 123456789101112131415package com.wm103.ioc;public class Teacher { private String name; public void setName(String name) { this.name = name; } @Override public String toString() { return \"Teacher{\" + \"name='\" + name + '\\'' + '}'; }}123456789101112131415 bean的配置： 123&lt;bean id=\"teacher\" class=\"com.wm103.ioc.Teacher\"&gt; &lt;property name=\"name\" value=\"Teacher Wu\"&gt;&lt;/property&gt;&lt;/bean&gt;123 创建Teacher对象进行测试： 12345678@Testpublic void runTeacher() { // 1. 加载Spring配置文件，根据创建对象 ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); // 2. 得到配置创建的对象 Teacher teacher = (Teacher) context.getBean(\"teacher\"); System.out.println(teacher);}12345678 注入对象类型属性 以三层架构中的service层和dao层为例，为了让service层使用dao层的类创建的对象，需要将dao对象注入到service层类中。具体实现过程中如下：（1）创建service类、dao层接口、dao类，如下：UserService.java 12345678910111213package com.wm103.exp;public class UserService { private UserDao userDao; // 声明为接口类型，降低service层与dao层的耦合度，不依赖于dao层的具体实现 public void setUserDao(UserDao userDao) { this.userDao = userDao; } public void add() { System.out.println(\"UserService Add...\"); this.userDao.add(); }}12345678910111213 UserDao.java 123456789package com.wm103.exp;/** * 暴露给service层的接口 * Created by DreamBoy on 2018/3/17. */public interface UserDao { void add();}123456789 UserDaoImpl.java 123456789101112package com.wm103.exp;/** * 接口UserDao的具体实现 * Created by DreamBoy on 2018/3/17. */public class UserDaoImpl implements UserDao { @Override public void add() { System.out.println(\"UserDaoImpl Add...\"); }}123456789101112 （2）在配置文件中注入关系，如下： 1234567891011&lt;!-- 配置service和dao对象 --&gt;&lt;!-- 因为service依赖于dao，所以先进行dao对象的bean配置 --&gt;&lt;bean id=\"userDaoImpl\" class=\"com.wm103.exp.UserDaoImpl\"&gt;&lt;/bean&gt;&lt;bean id=\"userService\" class=\"com.wm103.exp.UserService\"&gt; &lt;!-- 注入dao对象 name属性值为：service中的某一属性名称 ref属性值为：被引用的对象对应的bean标签的id属性值 --&gt; &lt;property name=\"userDao\" ref=\"userDaoImpl\"&gt;&lt;/property&gt;&lt;/bean&gt;1234567891011 （3）创建测试方法进行测试，如下： 12345678@Testpublic void runUserService() { // 1. 加载Spring配置文件，根据创建对象 ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); // 2. 得到配置创建的对象 UserService userService = (UserService) context.getBean(\"userService\"); userService.add();}12345678 p名称空间注入属性 之前提到了一种set方法的属性注入方式，这里将介绍另一种属性注入的方式，名为 p名称空间注入。对比set方法的属性注入方式，核心配置文件配置修改如下： 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"teacher\" class=\"com.wm103.ioc.Teacher\" p:name=\"Teacher Wu\"&gt;&lt;/bean&gt;&lt;/beans&gt;1234567 注入复杂类型属性 对象注入复杂类型属性，如数组、List、Map、Properties。 案例： PropertyDemo.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.wm103.ioc;import java.util.List;import java.util.Map;import java.util.Properties;public class PropertyDemo { private String[] arrs; private List&lt;String&gt; list; private Map&lt;String, String&gt; map; private Properties properties; public String[] getArrs() { return arrs; } public void setArrs(String[] arrs) { this.arrs = arrs; } public List&lt;String&gt; getList() { return list; } public void setList(List&lt;String&gt; list) { this.list = list; } public Map&lt;String, String&gt; getMap() { return map; } public void setMap(Map&lt;String, String&gt; map) { this.map = map; } public Properties getProperties() { return properties; } public void setProperties(Properties properties) { this.properties = properties; }}1234567891011121314151617181920212223242526272829303132333435363738394041424344 bean配置文件，内容如下： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"prop\" class=\"com.wm103.ioc.PropertyDemo\"&gt; &lt;!-- 注入数组 --&gt; &lt;property name=\"arrs\"&gt; &lt;list&gt; &lt;value&gt;Value 1 of Array&lt;/value&gt; &lt;value&gt;Value 2 of Array&lt;/value&gt; &lt;value&gt;Value 3 of Array&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 注入List集合 --&gt; &lt;property name=\"list\"&gt; &lt;list&gt; &lt;value&gt;Value 1 of List&lt;/value&gt; &lt;value&gt;Value 2 of List&lt;/value&gt; &lt;value&gt;Value 3 of List&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 注入Map集合 --&gt; &lt;property name=\"map\"&gt; &lt;map&gt; &lt;entry key=\"key1\" value=\"Value 1 of Map\"&gt;&lt;/entry&gt; &lt;entry key=\"key2\" value=\"Value 2 of Map\"&gt;&lt;/entry&gt; &lt;entry key=\"key3\" value=\"Value 3 of Map\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- 注入Properties --&gt; &lt;property name=\"properties\"&gt; &lt;props&gt; &lt;prop key=\"username\"&gt;root&lt;/prop&gt; &lt;prop key=\"password\"&gt;123456&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;1234567891011121314151617181920212223242526272829303132333435363738 创建PropertyDemo对象进行测试： 12345678910@Testpublic void runPropertyDemo() { ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); PropertyDemo pd = (PropertyDemo) context.getBean(\"prop\"); System.out.println(pd); System.out.println(Arrays.toString(pd.getArrs())); System.out.println(pd.getList()); System.out.println(pd.getMap()); System.out.println(pd.getProperties());}12345678910 IoC和DI的区别 IoC，控制反转，将传统的对象创建流程转变为交由框架进行创建和管理。在Spring中，对象的创建交给Spring进行配置。它包括依赖注入。 DI，依赖注入，向类的属性设置值。 IoC与DI的关系：依赖注入不能单独存在，需要在IoC基础之上完成操作。 Spring的bean管理（注解） 注解是代码中特殊的标记，使用注解可以完成特定的功能。注解可以使用在类、方法或属性上，写法如：@注解名称(属性名称=属性值)。 Spring的bean管理注解方式，案例如下。 Spring注解开发准备（1）导入jar包： 导入基本的jar包：commons-logging、log4j、spring-beans、spring-context、spring-core、spring-expression相关jar包。 导入AOP的jar包：spring-aopjar包。 （2）创建类、方法 User.java 123456789package com.wm103.anno;import org.springframework.stereotype.Component;public class User { public void add() { System.out.println(\"User Add Method.\"); }}123456789 （3）创建Spring配置文件，引入约束；并开启注解扫描 bean1.xml 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 开启注解扫描 （1）到包中扫描类、方法、属性上是否有注解 --&gt; &lt;context:component-scan base-package=\"com.wm103\"&gt;&lt;/context:component-scan&gt; &lt;!-- （2）只扫描属性上的注解 --&gt; &lt;!--&lt;context:annotation-config&gt;&lt;/context:annotation-config&gt;--&gt;&lt;/beans&gt;123456789101112131415161718 注解创建对象 在创建对象的类上面使用注解实现，如： 12@Component(value=\"user\")public class User {12 创建测试类 TestAnno.java和测试方法，如： 123456789101112131415package com.wm103.anno;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestAnno { @Test public void runUser() { ApplicationContext context = new ClassPathXmlApplicationContext(\"bean1.xml\"); User user = (User) context.getBean(\"user\"); user.add(); }}123456789101112131415 除了上述提到的 @Component注解外，Spring中还提供了@Component的3个衍生注解，其功能就目前来说是一致的，均是为了创建对象。 @Controller ：WEB层 @Service ：业务层 @Repository ：持久层 以单例或多实例方式创建对象，默认为单例，多例对象设置注解如下： 123@Component(value=\"user\")@Scope(value=\"prototype\")public class User {123 注解注入属性 案例：创建Service类和Dao类，并在Service中注入Dao对象。如下：（1）创建Dao和Service对象 UserDao.java 12345678910package com.wm103.anno;import org.springframework.stereotype.Repository;@Repository(value=\"userDao\")public class UserDao { public void add() { System.out.println(\"UserDao Add Method.\"); }}12345678910 UserService.java 12345678910111213package com.wm103.anno;import org.springframework.stereotype.Service;import javax.annotation.Resource;@Service(value=\"userService\")public class UserService { public void add() { System.out.println(\"UserService Add Method.\"); userDao.add(); }}12345678910111213 （2）在Service类中定义UserDao类型的属性，并使用注解完成对象的注入@Autowired：自动注入或自动装配，是根据类名去找到类对应的对象来完成注入的。 12@Autowiredprivate UserDao userDao;12 或者 @Resource 12@Resource(name=\"userDao\")private UserDao userDao;12 其中该注解的name属性值为注解创建Dao对象的value属性的值。 这两种注解方式都不一定要为需要注入的属性定义set方法。（3）创建测试方法 123456@Testpublic void runUserService() { ApplicationContext context = new ClassPathXmlApplicationContext(\"bean1.xml\"); UserService userService = (UserService) context.getBean(\"userService\"); userService.add();}123456 注：配置文件和注解混合使用1）创建对象的操作一般使用配置文件方式实现；2）注入属性的操作一般使用注解方式实现。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.iwxyi.com/tags/学习笔记/"},{"name":"Spring","slug":"Spring","permalink":"http://blog.iwxyi.com/tags/Spring/"}]},{"title":"Qt调用DLL","date":"2019-01-10T09:49:00.000Z","path":"2019/01/10/Qt调用DLL/","text":"静态链接库（.lib+.dll）声明：** 事先我已经自己动手写了一个简单的dll文件(myDLL.dll),C版接口的。首先，从dll中导出了导入库(.lib)文件，dll中有两个函数，原型如下： void HelloWorld(); //函数内部调用Win32 API,功能是弹出一个helloworld提示框 int add(int a,int b); //实现两个数相加，并返回结果 下面分别通过显示调用和隐式调用两种方法，来模拟Qt如何调用外部dll文件中的功能函数，follow me…. 预备知识： ​ 1、如果在没有导入库文件(.lib)，而只有头文件(.h)与动态链接库(.dll)时，我们才需要显示调用，如果这三个文件都全的话，我们就可以使用简单方便的隐式调用。 ​ 2、通常Windows下程序显示调用dll的步骤分为三步(三个函数)：LoadLibrary()、GetProcAdress()、FreeLibrary() 其中，LoadLibrary() 函数用来载入指定的dll文件，加载到调用程序的内存中(DLL没有自己的内存！) ​ GetProcAddress() 函数检索指定的动态链接库(DLL)中的输出库函数地址，以备调用 ​ FreeLibrary() 释放dll所占空间 *1、显式调用 * ​ Qt提供了一个 QLibrary 类供显示调用。下面给出一个完整的例子： 123456789101112131415161718192021222324252627#include &lt;QApplication&gt;#include &lt;QLibrary&gt;#include &lt;QDebug&gt;#include &lt;QMessageBox&gt;#include \"dll.h\" //引入头文件typedef int (*Fun)(int,int); //定义函数指针，以备调用int main(int argc,char **argv){ QApplication app(argc,argv); QLibrary mylib(\"myDLL.dll\"); //声明所用到的dll文件 int result; if (mylib.load()) //判断是否正确加载 { QMessageBox::information(NULL,\"OK\",\"DLL load is OK!\"); Fun open=(Fun)mylib.resolve(\"add\"); //援引 add() 函数 if (open) //是否成功连接上 add() 函数 { QMessageBox::information(NULL,\"OK\",\"Link to Function is OK!\"); result=open(5,6); //这里函数指针调用dll中的 add() 函数 qDebug()&lt;&lt;result; } else QMessageBox::information(NULL,\"NO\",\"Linke to Function is not OK!!!!\"); } else QMessageBox::information(NULL,\"NO\",\"DLL is not loaded!\"); return 0; //加载失败则退出28} myDLL.dll为自定义的dll文件，将其复制到程序的输出目录下就可以调用。显然，显示调用代码书写量巨大，实在不方便。 2、隐式调用 ​ 这个时候我们需要三个文件，头文件(.h)、导入库文件(.lib)、动态链接库(.dll)，具体步骤如下： 1、首先我们把 .h 与 .lib/.a 文件复制到程序当前目录下，然后再把dll文件复制到程序的输出目录， 2、下面我们在pro文件中，添加 .lib 文件的位置： LIBS+= -L D:/hitempt/api/ -l myDLL ​ -L 参数指定 .lib/.a 文件的位置 ​ -l 参数指定导入库文件名(不要加扩展名) （注：这是小写的L，不是hijk的大写i） ​ 另外，导入库文件的路径中，反斜杠用的是向右倾斜的 3、在程序中include头文件(我试验用的dll是用C写的，因此要用 extern “C” { #include “dll.h” } ) 下面是隐式调用的实例代码： 1234567891011121314#include &lt;QApplication&gt;#include &lt;QDebug&gt;extern \"C\" //由于是C版的dll文件，在C++中引入其头文件要加extern \"C\" {},注意{ #include \"dll.h\"} int main(int argv ,char **argv){ QApplication app(argv,argv); HelloWordl(); //调用Win32 API 弹出helloworld对话框 qDebug()&lt;&lt;add(5,6); // dll 中我自己写的一个加法函数 return 0; //完成使命后，直接退出，不让它进入事件循环} 动态链接库（.a+.dll）只需要修改 .pro 文件即可 首先是链接libcurl.dll，格式如下： LIBS +=-L E:/1/web/bin -llibcurl 这里要注意的是语句最后要先加上 -l 如何再加上动态链接库的名字，不要带后缀。 接着是链接libcurldll.a，格式如下： LIBS +=E:/1/web/lib/libcurldll.a 代码里面依旧需要 include 对应库的头文件 问题imcompact：32位和64位不兼容（至少是不兼容），用对应的QT重新编译库的源代码一遍 can find：找不到，名字错了 运行直接崩溃：用同一套 .a 和 .dll document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"Qt Socket通信","date":"2019-01-08T09:46:00.000Z","path":"2019/01/08/Qt-Socket通信/","text":"QT的TCP Socket通信仍然有服务端、客户端之分。服务端通过监听某个端口来监听是否有客户端连接到来，如果有连接到来，则建立新的SOCKET连接；客户端通过IP和PORT连接服务端，当成功建立连接之后，就可进行数据的收发了。需要注意的是，在QT中，QT把SOCKET当成输入输出流来对待的，数据的收发是通过read()和write()来进行的，需要与我们常见的send()与recv()进行区分。 要在QT进行SOCKET通信，需要在 工程名.pro 文件中输入 QT += network 服务端在服务端，建立SOCKET通信需要用到两个类QTcpServer和QTcpSocket。其中QTcpServer是用来建立QT的Server端对象，QTcpSocket是用来建立SOCKET通信的Socket套接字对象。通信建立流程如下所示。 1.建立QTcpServer类的对象12QTcpServer* mp_TCPServer ;mp_TCPServer = new QTcpServer(); 2.监听QT中，通过listen()建立对端口的监听。使用方式如下：mp_TCPServer-&gt;listen(地址类型， 端口号); 123456int port = ui-&gt;m_portLineEdit-&gt;text().toInt(); //获得端口号if(!mp_TCPServer-&gt;listen(QHostAddress::Any, port)){ QMessageBox::information(this, \"QT网络通信\", \"服务器端监听失败！\"); return;} 其中，QHostAddress定义了集中特殊的IP地址，如 QHostAddress::Null表示一个空地址； QHostAddress::LocalHost表示IPv4的本机地址127.0.0.1； QHostAddress::LocalHostIPv6表示IPv6的本机地址； QHostAddress::Broadcast表示广播地址255.255.255.255； QHostAddress::Any表示IPv4的任意地址； QHostAddress::AnyIPv6表示IPv6的任意地址。 3.关联接收连接信号与槽函数服务端通过信号 SIGNAL:newConnection() 来判断是否接收到了新的连接，当服务端接收到一个客户端的连接时，就会触发信号newConnection()，此时调用相应的槽函数（如自定义函数：ServerNewConnection()）保存新接收到的连接；所以需要在服务端监听端口之后建立信号与槽函数的连接。通过connect函数建立联系： 1connect(mp_TCPServer, SIGNAL(newConnection()), this, SLOT(ServerNewConnection())); 在ServerNewConnection()函数中，通过nextPendingConnection()函数获得连接客户端的SOCKET套接字： 1mp_TCPSocket = mp_TCPServer-&gt;nextPendingConnection(); 4.接收数据在QT中QT通过信号SIGNAL:readyRead()来判断是否有数据传入，当客户端向服务端成功发送数据之后，就会在服务端触发readyRead()信号，此时通过调用相应的自定义的槽函数（如：ServerReadData()）保存接收到的数据；通过connect函数建立信号readyRead()与槽函数ServerReadData()的连接： 1connect(mp_TCPSocket, SIGNAL(readyRead()), this, SLOT(ServerReadData())); 在接收函数ServerReadData()函数中通过read()函数获取数据： 1mp_TCPSocket-&gt;read(buffer, 1024); 需要注意的是read()函数有多个重载函数，保存接收数据的数据类型可以是QByteArray也可以是char类型，根据个人习惯或者任务需求选择合适的read()函数。不过，为了保持一致性，建议选择char类型，一是因为数据类型容易识别；二是因为熟悉C\\C++语言开发的对char*应该比较熟悉，防止使用上的错误。 5.发送数据在QT中，通过write函数向外部发送数据： 12345int sendRe = mp_TCPSocket-&gt;write(sendMsgChar, strlen(sendMsgChar));if( -1 == sendRe){ QMessageBox::information(this, \"QT网络通信\", \"服务端发送数据失败！\");} 客户端1.建立QTcpSocket类的对象建立Socket的套接字： 12QTcpSocket* mp_clientSocket;mp_clientSocket = new QTcpSocket(); 2.连接服务端客户端通过connectToHost(IP, Port)函数连接服务端 1mp_clientSocket-&gt;connectToHost(ip, port); 3.接收数据客户端接收数据与服务端接收数据的机制是相同的。通过readyRead()信号是否被触发来判断是否有数据传入，如果该信号被触发，则调用自定义函数（如：ClientRecvData()）来保存接收到的数据。通过connect()函数，将信号readyRead()与槽函数ClientRecvData()建立映射关系。 在槽函数ClientRecvData()中通过read()函数接收数据，具体使用方法请参考服务端接收数据。 4.发送数据客户端发送数据也是通过write()函数来实现，具体使用方法请参考服务端发送数据 实例服务端示例1.在sockettcpserver.h中添加具体如下代码：123456789101112private: Ui::SocketTCPServer *ui; QTcpServer *mp_TCPServer; QTcpSocket *mp_TCPSocket;private slots: void OnBtnInitSocket(); void OnBtnSendData(); void ServerReadData(); void ServerNewConnection(); void sServerDisConnection(); 2.在构造函数中添加如下代码：123ui-&gt;m_portLineEdit-&gt;setText(\"5550\"); connect(ui-&gt;m_initSocketBtn, SIGNAL(clicked()), this, SLOT(OnBtnInitSocket())); connect(ui-&gt;m_sendData, SIGNAL(clicked()), this, SLOT(OnBtnSendData())); 3.ServerNewConnection()具体实现：12345678910111213//获取客户端连接 mp_TCPSocket = mp_TCPServer-&gt;nextPendingConnection(); if(!mp_TCPSocket) { QMessageBox::information(this, \"QT网络通信\", \"未正确获取客户端连接！\"); return; } else { QMessageBox::information(this, \"QT网络通信\", \"成功接受客户端的连接\"); connect(mp_TCPSocket, SIGNAL(readyRead()), this, SLOT(ServerReadData())); connect(mp_TCPSocket, SIGNAL(disconnected()), this, SLOT(sServerDisConnection())); } 4.ServerReadData()具体实现：123456789101112char buffer[1024] = {0}; mp_TCPSocket-&gt;read(buffer, 1024); if( strlen(buffer) &gt; 0) { QString showNsg = buffer; ui-&gt;m_recvDataTextEdit-&gt;append(showNsg); } else { QMessageBox::information(this, \"QT网络通信\", \"未正确接收数据\"); return; } 5.OnBtnInitSocket()具体实现：123456789101112mp_TCPServer = new QTcpServer(); int port = ui-&gt;m_portLineEdit-&gt;text().toInt(); if(!mp_TCPServer-&gt;listen(QHostAddress::Any, port)) { QMessageBox::information(this, \"QT网络通信\", \"服务器端监听失败！\"); return; } else { QMessageBox::information(this, \"QT网络通信\", \"服务器监听成功！\"); } connect(mp_TCPServer, SIGNAL(newConnection()), this, SLOT(ServerNewConnection())); 6.OnBtnSendData()具体实现：1234567891011121314151617181920char sendMsgChar[1024] = {0}; QString sendMsg = ui-&gt;m_inputTextEdit-&gt;toPlainText(); if(sendMsg.isEmpty()) { QMessageBox::information(this, \"QT网络通信\", \"发送数据为空，请输入数据\"); return; } strcpy_s(sendMsgChar, sendMsg.toStdString().c_str()); if(mp_TCPSocket-&gt;isValid()) { int sendRe = mp_TCPSocket-&gt;write(sendMsgChar, strlen(sendMsgChar)); if( -1 == sendRe) { QMessageBox::information(this, \"QT网络通信\", \"服务端发送数据失败！\"); } } else { QMessageBox::information(this, \"QT网络通信\", \"套接字无效！\"); } 7.sServerDisConnection()具体实现：12QMessageBox::information(this, \"QT网络通信\", \"与客户端的连接断开\"); return; 客户端示例1.在sockettcpclient.h中添加如下代码：1234567891011private slots: void on_m_connectServerBtn_clicked(); void on_pushButton_2_clicked(); void ClientRecvData(); private: Ui::SocketTCPClient *ui; QTcpSocket *mp_clientSocket; 2.在构造函数中添加如下代码：12ui-&gt;m_serverIPLineEdit-&gt;setText(\"127.0.0.1\"); ui-&gt;m_serverPortLineEdit_2-&gt;setText(\"5550\"); 3.on_m_connectServerBtn_clicked()函数具体实现如下：12345678910mp_clientSocket = new QTcpSocket(); QString ip = ui-&gt;m_serverIPLineEdit-&gt;text();\\ int port = ui-&gt;m_serverPortLineEdit_2-&gt;text().toInt(); mp_clientSocket-&gt;connectToHost(ip, port); if(!mp_clientSocket-&gt;waitForConnected(30000)) { QMessageBox::information(this, \"QT网络通信\", \"连接服务端失败！\"); return; } connect(mp_clientSocket, SIGNAL(readyRead()), this, SLOT(ClientRecvData())); 4.on_pushButton_2_clicked()函数具体实现如下：12345678910//获取TextEdit控件中的内容 QString sendMsg = ui-&gt;m_sendTextEdit-&gt;toPlainText(); char sendMsgChar[1024] = {0}; strcpy_s(sendMsgChar, sendMsg.toStdString().c_str()); int sendRe = mp_clientSocket-&gt;write(sendMsgChar, strlen(sendMsgChar)); if(sendRe == -1) { QMessageBox::information(this, \"QT网络通信\", \"向服务端发送数据失败！\"); return; } 5.ClientRecvData()函数具体实现如下：12345678910//将接收内容存储到字符串中 char recvMsg[1024] = {0}; int recvRe = mp_clientSocket-&gt;read(recvMsg, 1024); if(recvRe == -1) { QMessageBox::information(this, \"QT网络通信\", \"接收服务端数据失败！\"); return; } QString showQstr = recvMsg; ui-&gt;m_recvTextEdit_2-&gt;setText(showQstr); 总结 连接服务器m_tcpSocket-&gt;connectToHost(“127.0.0.1”, 9877);connected = m_tcpSocket-&gt;waitForConnected();只有使用waitForConnected()后,QTcpSocket才真正尝试连接服务器，并返回是否连接的结果。 写数据m_tcpSocket-&gt;write(str.toStdString().c_str(), strlen(str.toStdString().c_str()));m_tcpSocket-&gt;waitForBytesWritten();当使用waitForBytesWritten()后，QTcpSocket才真正发送数据。m_tcpSocket-&gt;write(str1.toStdString().c_str(), strlen(str1.toStdString().c_str()));m_tcpSocket-&gt;write(str2.toStdString().c_str(), strlen(str2.toStdString().c_str()));的结果是发送了str1str2 断开与服务器的连接m_tcpSocket-&gt;disconnectFromHost()m_tcpSocket-&gt;waitForDisconnected() 善于使用QTcpSocket的SIGNAL：connected()，disconnected()，error(QAbstractSocket::SocketError)配合自定义私有开关变量 bool connected，QTimer可以实现自动重连接等逻辑。 参考：https://blog.csdn.net/bailang_zhizun/article/details/78327974 总结：https://blog.csdn.net/u011125673/article/details/50474491 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"},{"name":"Socket","slug":"Socket","permalink":"http://blog.iwxyi.com/tags/Socket/"}]},{"title":"Android切换Activity并返回数据","date":"2019-01-03T03:19:00.000Z","path":"2019/01/03/Android切换Activity/","text":"切换Activity12Intent intent = new Intent(LoginActivity.this, MainActivity.class);startActivity(intent); 给子Activity传递数据如果给新启动的子Activity传递数据，只需要在Intent对象中加入key-value，key为准备传递数据的字符指示名称，value为准备传递的数据 12intent.putExtra(\"KEY\",data);startActivity(intent); 12345@Overrideprotected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); int data= getIntent().getIntExtra(\"KEY\"); // DataType用需要的数据类型} 从子Activity返回数据1234Intent intent = new Intent();intent.putExtra(“KEY”, data);setResult(RESULT_OK, intent);this.finish(); setResult(RESULT_OK, intent) 设置子Activity要返回父Activity（打开新Activity的Activity）的信息，RESULT_OK为int值，表子Activity成功执行完毕，intent里面就是包含要返回的数据。 记得要关闭哦 finish()在父Activity中如果要接收子Activity的返回结果，需要使用 startActivityForResult(intent, requestCode)打开子Activity，并且要重写 onActivityResult方法 12345678910/*............*/Intent intent = new Intent(this, DrugLibActivity.class);startActivityForResult(intent, 10);/*............*/@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) { if (10 == requestCode) { int index = data.getIntExtra(KEY,0); } } 如果在同一个Activity中有多个地方可调用 startActivityForResult 打开多个子 Activity 的情况，那你应该在 onActivityResult 返回时判断 requestCode，这样你就能搞清楚是哪个子Activity返回了数据。 参考：https://www.cnblogs.com/dw039/p/7411210.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Qt QPlainTextEdit用法","date":"2018-12-31T09:40:00.000Z","path":"2018/12/31/Qt-QPlainTextEdit用法/","text":"QTextEditor 和 QPlainTextEditor 在一定程度上通用的 获取文本1toPlainText(); 设置文本1setPlainText(QString); 获取行数12num = QString::number(plainTextEdit-&gt;document()-&gt;lineCount()); // 获取行数str = plainTextEdit-&gt;document()-&gt;findBlockByLineNumber(2).text(); // 获取某一行 获取光标所在行文本12345QTextCursor cursor = textEditor-&gt;textCursor();int lineNumber = cursor.blockNumber();//获取光标所在列用cursor.columnNumber();QTextBlock textBlock = QTextEdit::document()-&gt;findBlockByLineNumber(lineNumber);//通过行号找到指定行 数据块QString selectLine = textBlock.text();//将得到的数据存入一个字符串。 内容改变信号1textChanged() 在setText()时也会触发，如果要屏蔽，在setText()前调用QObject::blockSignals(true),setText()后调用QObject::blockSignals(false) 光标位置改变信号1cursorPositionChanged() 设置光标行列123456789101112void setCursorPos(int row,int col){ const QTextBlock block = QTextEdit::document()-&gt;findBlockByLineNumber(row-1); if(block.isValid()) { QTextCursor cursor = QTextEdit::textCursor(); cursor.setPosition(block.position()+col-1); setTextCursor(cursor); ensureCursorVisible(); } setFocus();} 光标在一行中的(字符?)位置这里的nCursor其实就是我们一个文本在一行中的位置 12QTextCursor tc = myTextEdit-&gt;textCursor();int nCurpos = tc.position() - tc.block().position(); 光标移动123QTextCursor textCursor= ui.translationInput-&gt;textCursor(); // 获取光标/* 这里是针对光标的修改操作 */ui.translationInput-&gt;setTextCursor(textCursor); // 修改光标后设置成编辑框光标 移动到行首123QTextCursor textCursor= ui.translationInput-&gt;textCursor();textCursor.movePosition(QTextCursor::Left, QTextCursor::MoveAnchor, 4); // 行首ui.translationInput-&gt;setTextCursor(textCursor); 移动到文末1textCursor.movePosition(QTextCursor::Left, QTextCursor::MoveAnchor, 4); // 全文尾 移动到指定字符1textCursor.setPosition(20); 右移一个单词1textCursor.movePosition(QTextCursor::NextWord, QTextCursor::KeepAnchor); 删除光标前一个字符12345678910QTextEdit editer; // 这个是目标 EditorQTextCursor cursor = editer.textCursor(); // 获取当前文本光标//判断当前是否选中了文本，如果选中了文本则取消选中的文本，再删除前一个字符if(cursor.hasSelection()) cursor.clearSelection();cursor.deletePreviousChar(); //删除前一个字符editer.setTextCursor(cursor); //设置当前的光标为更改后的光标 设置行高和行间距12345678QTextCursor textCursor = ui-&gt;textEdit-&gt;textCursor();QTextBlockFormat textBlockFormat;textBlockFormat.setLineHeight(40, QTextBlockFormat::FixedHeight); // 设置固定行高textBlockFormat.setBottomMargin(10); // 设置两行之间的空白高度textCursor.setBlockFormat(textBlockFormat);ui-&gt;textEdit-&gt;setTextCursor(textCursor); 文字进行加粗操作12345678910111213QTextCursor currentTextCursor = currentTextEdit-&gt;textCursor();if (!currentTextCursor.hasSelection()){ currentTextCursor.insertText(\"**\" + tr(\"Boldface\") + \"**\"); currentTextCursor.movePosition (QTextCursor::Left, QTextCursor::MoveAnchor, 2); currentTextCursor.movePosition (QTextCursor::WordLeft, QTextCursor::KeepAnchor, 1); currentTextEdit-&gt;setTextCursor (currentTextCursor);}else{ currentTextCursor.insertText (\"**\" +currentTextCursor.selectedText() + \"**\");} 高亮光标所在行使用到qtextedit中的cursorPostionChanged（），这个信号将会在光标移动时实时发送。 123456789101112131415161718QTextEdit *edit = (QTextEdit *)tab-&gt;widget(tab-&gt;currentIndex());connect(edit,SIGNAL(cursorPositionChanged()), this,SLOT(onCurrentLineHighLight()));void MainWindow::onCurrentLineHighLight(){ QTextEdit *edit = (QTextEdit *)tab-&gt;currentWidget(); QList&lt;QTextEdit::ExtraSelection&gt; extraSelection; QTextEdit::ExtraSelection selection; QColor lineColor = QColor(Qt::gray).lighter(150); selection.format.setBackground(lineColor); selection.format.setProperty( QTextFormat::FullWidthSelection,true); selection.cursor = edit-&gt;textCursor(); selection.cursor.clearSelection(); //将刚设置的 selection追加到链表当中 extraSelection.append(selection); edit-&gt;setExtraSelections(extraSelection);} 设置部分字体颜色只能设置选中区域的字体颜色 123456789QTextCursor textCursor = ui-&gt;plainTextEdit-&gt;textCursor();if (textCursor.hasSelection()){ int start = textCursor.selectionStart(); int end = textCursor.selectionEnd(); QTextCharFormat f;// = textCursor.charFormat(); // 返回前一个字的格式（没必要） f.setForeground(QBrush(QColor(128,128,128, 20))); textCursor.setCharFormat(f);} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"SSR+FCM","date":"2018-12-27T06:03:00.000Z","path":"2018/12/27/SSR-FCM/","text":"SSR+FCMSSR+BBRBBR 加速因为安装BBR重启后SSR会失效，需要重新安装，所以先安装BBR 实测 vultr 使用 BBR 加速的话，会经常出现连不上的情况 1234yum -y install wgetwget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.shchmod +x bbr.sh./bbr.sh （回车） （任意按键重启） SSR1wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssrmu.sh &amp;&amp; chmod +x ssrmu.sh &amp;&amp; bash ssrmu.sh 数字：1 IP ：（回车） 用户：（回车） 端口：（回车） 密码：（回车） 加密：10 协议：2 旧版：n 混淆：5 原版：n 设备：（回车） 限速：（回车） 总速：（回车） 流量：（回车） 禁端：（回车） 确认：y 搭建参数123456789101102n5n FCM-for-Mojo::WebQQ先进行一键安装，装好大体环境 然后再分布安装，去除bug 别忘了后面修复错误的命令 一键安装12yum install git -ygit clone https://github.com/null-ecp/FFM-one-step.git &amp;&amp; source ~/FFM-one-step/GCM.sh 1 y 1 1 分步安装123456789101112systemctl stop firewalldsystemctl disable firewalldyum install -y perl-Crypt-OpenSSL-RSA perl-Crypt-OpenSSL-Bignumcpanm Webqq::Encryptioncurl -sL https://rpm.nodesource.com/setup_9.x | bash -yum -y install nodejsgit clone https://github.com/RikkaApps/FCM-for-Mojo-Server.gitcd FCM-for-Mojo-Servercp config.example.js config.jsnpm installscreen -S qqnpm start 修复12月6日1234git clone https://github.com/sjdy521/Mojo-Webqqcd Mojo-Webqqperl Makefile.PLmake install document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"服务器","slug":"服务器","permalink":"http://blog.iwxyi.com/tags/服务器/"}]},{"title":"Qt小技巧","date":"2018-12-24T11:11:00.000Z","path":"2018/12/24/Qt小技巧/","text":"鼠标点击 QListWidget 的 item 1currentItem = this-&gt;itemAt(mapFromGlobal(QCursor::pos())); // 不管左键右键都能获取 判断点击区域是否在某个控件里面 1NameEdit-&gt;rect().contains(event-&gt;pos()) QMap插入同样key，会覆盖原来的 Lambda 临时函数 1connect(ui-&gt;listWidget,&amp;QListWidget::currentRowChanged,[=](int curindex){ qDebug()&lt;&lt;curindex&lt;&lt;endl; }); QLabel设置字体颜色 1234QLabel *label = new QLabel(tr(\"Hello Qt!\"));QPalette pe;pe.setColor(QPalette::WindowText,Qt::white); // 这两行不能合并（构造函数能接受这样的参数）label-&gt;setPalette(pe); 1setStyleSheet(\"color:red;\"); QSettings 无法保存 出于效率的原因，setValue 不会立既写入（如注册表，INI, XML）, 要立既写入可以用sync()函数。 判断按键修饰符 12345bool isShortcut = ((e-&gt;modifiers() &amp; Qt::ControlModifier) &amp;&amp; e-&gt;key() == Qt::Key_E);bool ctrlOrShift = e-&gt;modifiers() &amp; (Qt::ControlModifier | Qt::ShiftModifier);bool hasModifier = (e-&gt;modifiers() != Qt::NoModifier) &amp;&amp; !ctrlOrShift; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"整理","slug":"整理","permalink":"http://blog.iwxyi.com/tags/整理/"},{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"Qt QCompleter用法","date":"2018-12-24T09:33:00.000Z","path":"2018/12/24/Qt-QCompleter用法/","text":"在光标后面弹出1234QRect cr = cursorRect();cr.setWidth(c-&gt;popup()-&gt;sizeHintForColumn(0) + c-&gt;popup()-&gt;verticalScrollBar()-&gt;sizeHint().width());c-&gt;complete(cr); TAG在自动补全的后面添加一个用来标志类别的小tag 12345678910QStandardItemModel *m = new QStandardItemModel(words.count(), 2, completer); // 设置为两列for (int i = 0; i &lt; words.count(); ++i) { QModelIndex countryIdx = m-&gt;index(i, 0); QModelIndex symbolIdx = m-&gt;index(i, 1); QString country = words[i].mid(0, words[i].length() - 2).trimmed(); QString symbol = words[i].right(2); m-&gt;setData(countryIdx, country); m-&gt;setData(symbolIdx, symbol);}completer-&gt;setModel(m); Model 示例文件路径全部显示的model 123456class FileSystemModel : public QFileSystemModel{public: FileSystemModel(QObject *parent = 0); QVariant data(const QModelIndex &amp;index, int role = Qt::DisplayRole) const Q_DECL_OVERRIDE;}; 123456789101112131415FileSystemModel::FileSystemModel(QObject *parent) : QFileSystemModel(parent){}QVariant FileSystemModel::data(const QModelIndex &amp;index, int role) const{ if (role == Qt::DisplayRole &amp;&amp; index.column() == 0) { QString path = QDir::toNativeSeparators(filePath(index)); if (path.endsWith(QDir::separator())) path.chop(1); return path; } return QFileSystemModel::data(index, role);} 焦点设置12345void TextEdit::focusInEvent(QFocusEvent *e){ if (c) c-&gt;setWidget(this); QTextEdit::focusInEvent(e);} 选中事件12345678910void MainWindow::sloHighlight(const QModelIndex &amp;index){ QAbstractItemModel *completionModel = completer-&gt;completionModel(); QAbstractProxyModel *proxy = qobject_cast&lt;QAbstractProxyModel *&gt;(completionModel); if (!proxy) return; QModelIndex sourceIndex = proxy-&gt;mapToSource(index); treeView-&gt;selectionModel()-&gt;select(sourceIndex, QItemSelectionModel::ClearAndSelect | QItemSelectionModel::Rows); treeView-&gt;scrollTo(index);} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"解决Ubuntu安装包不存在问题","date":"2018-12-23T05:56:00.000Z","path":"2018/12/23/解决Ubuntu安装vim的Package-vim-has-no-installation-candidate问题/","text":"解决Ubuntu安装vim的Package vim has no installation candidate问题当输入sudo apt-get install vim-gtk时出现了下面问题： 12345678nigel@yq-ubuntu:~/worksp$ sudo apt-get install vim-gtkReading package lists... DoneBuilding dependency tree Reading state information... DonePackage vim-gtk is not available, but is referred to by another package.This may mean that the package is missing, has been obsoleted, oris only available from another sourceE: Package 'vim-gtk' has no installation candidate 解决办法就是修改软件源设置 备份源文件，cp -i /etc/apt/sources.list /etc/apt/sources.list_backup 打开sources.list，root@ubuntu:/etc/apt# gedit sources.list 在源文件中加入如下阿里巴巴的阿里云服务器的地址并保存。（当然也可以是其他公司的地址） 1234567891011deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse 更新：apt-get update 更新后，再安装vim，sudo apt-get install vim 这样问题就解决了。 163源12345678910deb http://mirrors.163.com/ubuntu/ trusty main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ trusty-security main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ trusty-updates main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ trusty-proposed main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ trusty-backports main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ trusty main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ trusty-security main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ trusty-updates main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ trusty-proposed main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ trusty-backports main restricted universe multiverse document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.iwxyi.com/tags/Linux/"}]},{"title":"MySQL百万级以上数据常识","date":"2018-12-20T05:33:00.000Z","path":"2018/12/20/MySQL百万级以上数据常识/","text":"最近的项目需要用到实现节点的管理规模达到百万规模，需要用数据库对中间数据以及最后的结果进行存储，存储规模可以达到千万级别。初步实现了10万节点数据的存储，但是访问速度实在太慢，查阅相关的资料，发现导致节点插入时间非常慢的原因： 连接数据库的问题：建立连接和关闭连接的次数太多，导致IO访问次数太频繁。 应该使用批量插入和批量修改的方法，而不是有一条数据就进行插入，这样会导致访问数据库的实际特别的慢。 在建立库的时候要建立适当的索引：如主键、外键、唯一等，优化查询效率。 ​ 具体的讨论见此处的链接：http://www.oschina.net/question/1859_62586?sort=default&amp;p=3#answers ​ 该链接中的一些讨论可以提供思路~ ​ 另外转载的内容如下： 最近一段时间参与的项目要操作百万级数据量的数据，普通SQL查询效率呈直线下降，而且如果where中的查询条件较多时，其查询速度简直无法容忍。之前数据量小的时候，查询语句的好坏不会对执行时间有什么明显的影响，所以忽略了许多细节性的问题。 经测试对一个包含400多万条记录的表执行一条件查询，其查询时间竟然高达40几秒，相信这么高的查询延时，任何用户都会抓狂。因此如何提高sql语句查询效率，显得十分重要。以下是结合网上流传比较广泛的几个查询语句优化方法： 索引不会生效的情况首先，数据量大的时候，应尽量避免全表扫描，应考虑在 where 及 order by 涉及的列上建立索引，建索引可以大大加快数据的检索速度。 但是，有些情况索引是不会起效的： 应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：​ select id from t where num is null可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：​ select id from t where num=0 尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：​ select id from t where num=10 or num=20可以这样查询：​ select id from t where num=10 ​ union all ​ select id from t where num=20 下面的查询也将导致全表扫描： select id from t where name like ‘%abc%’ ​ 若要提高效率，可以考虑全文检索。 in 和 not in 也要慎用，否则会导致全表扫描，如：​ select id from t where num in(1,2,3)对于连续的数值，能用 between 就不要用 in 了：​ `select id from t where num between 1 and 3 如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：​ select id from t where num=@num可以改为强制查询使用索引：​ select id from t with(index(索引名)) where num=@num 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：​ select id from t where num/2=100应改为:​ select id from t where num=100*2 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：​ select id from t where substring(name,1,3)=’abc’–name以abc开头的id​ select id from t where datediff(day,createdate,’2005-11-30′)=0–’2005-11-30′生成的id​ 应改为:​ select id from t where name like ‘abc%’​ select id from t where createdate&gt;=’2005-11-30′ and createdate&lt;’2005-12-1′ 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。 不要写一些没有意义的查询，如需要生成一个空表结构：​ select col1,col2 into #t from t where 1=0这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：​ create table #t(…) 很多时候用 exists 代替 in 是一个好的选择：​ select num from a where num in(select num from b)用下面的语句替换：​ select num from a where exists(select 1 from b where num=a.num) 建索引需要注意的地方 并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段 sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。 应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。 其他需要注意的地方 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。 任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。 尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。 避免频繁创建和删除临时表，以减少系统表资源的消耗。 临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。 尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。 使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。 与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。 在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。 尽量避免大事务操作，提高系统并发能力。 参考：https://blog.csdn.net/lynnucas/article/details/50265325 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.iwxyi.com/tags/MySQL/"}]},{"title":"C语言CRC校验算法","date":"2018-12-20T00:20:00.000Z","path":"2018/12/20/C语言CRC校验算法/","text":"CRC32 C语言版 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879static const unsigned int crc32tab[] = { 0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L, 0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L, 0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L, 0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL, 0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L, 0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L, 0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L, 0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL, 0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L, 0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL, 0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L, 0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L, 0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L, 0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL, 0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL, 0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L, 0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL, 0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L, 0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L, 0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L, 0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL, 0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L, 0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L, 0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL, 0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L, 0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L, 0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L, 0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L, 0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L, 0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL, 0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL, 0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L, 0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L, 0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL, 0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL, 0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L, 0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL, 0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L, 0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL, 0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L, 0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL, 0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L, 0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L, 0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL, 0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L, 0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L, 0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L, 0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L, 0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L, 0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L, 0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL, 0x2d02ef8dL}; static unsigned int crc32( const unsigned char *buf, unsigned int size){ unsigned int i, crc; crc = 0xFFFFFFFF; for (i = 0; i &lt; size; i++) crc = crc32tab[(crc ^ buf[i]) &amp; 0xff] ^ (crc &gt;&gt; 8); return crc^0xFFFFFFFF;} 参考：https://blog.csdn.net/gongmin856/article/details/77101397 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C语言","slug":"C语言","permalink":"http://blog.iwxyi.com/tags/C语言/"},{"name":"密码学","slug":"密码学","permalink":"http://blog.iwxyi.com/tags/密码学/"}]},{"title":"Android漂亮的对话框sweet-alert","date":"2018-12-19T03:17:00.000Z","path":"2018/12/19/Android漂亮的对话框sweet-alert/","text":"首先在app的build.gradle中添加依赖compile 'com.github.f0ris.sweetalert:library:1.5.1' 这个时候同步一下项目会报一个错误，解决办法 在AndroidManifest.xml中manifest根标签添加xmlns:tools=\"http://schemas.android.com/tools\" 在application标签下添加tools:replace=\"android:icon,android:theme,android:allowBackup\" 使用代码 12345SweetAlertDialog pDialog = new SweetAlertDialog(this, SweetAlertDialog.PROGRESS_TYPE);pDialog.getProgressHelper().setBarColor(Color.parseColor(\"#A5DC86\"));pDialog.setTitleText(\"Loading\");pDialog.setCancelable(false);pDialog.show(); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113//你可以通过SweetAlertDialog.getProgressHelper()调用materialish-progress中下面这些方法，来动态改变进度条的样式 resetCount()isSpinning()spin()stopSpinning()getProgress()setProgress(float progress)setInstantProgress(float progress)getCircleRadius()setCircleRadius(int circleRadius)getBarWidth()setBarWidth(int barWidth)getBarColor()setBarColor(int barColor)getRimWidth()setRimWidth(int rimWidth)getRimColor()setRimColor(int rimColor)getSpinSpeed()setSpinSpeed(float spinSpeed) //只显示标题： new SweetAlertDialog(this) .setTitleText(\"Here's a message!\") .show();//显示标题和内容： new SweetAlertDialog(this) .setTitleText(\"Here's a message!\") .setContentText(\"It's pretty, isn't it?\") .show();//显示异常样式： new SweetAlertDialog(this, SweetAlertDialog.ERROR_TYPE) .setTitleText(\"Oops...\") .setContentText(\"Something went wrong!\") .show();//显示警告样式： new SweetAlertDialog(this, SweetAlertDialog.WARNING_TYPE) .setTitleText(\"Are you sure?\") .setContentText(\"Won't be able to recover this file!\") .setConfirmText(\"Yes,delete it!\") .show();//显示成功完成样式： new SweetAlertDialog(this, SweetAlertDialog.SUCCESS_TYPE) .setTitleText(\"Good job!\") .setContentText(\"You clicked the button!\") .show();//自定义头部图像： new SweetAlertDialog(this, SweetAlertDialog.CUSTOM_IMAGE_TYPE) .setTitleText(\"Sweet!\") .setContentText(\"Here's a custom image.\") .setCustomImage(R.drawable.custom_img) .show();//确认事件绑定： new SweetAlertDialog(this, SweetAlertDialog.WARNING_TYPE) .setTitleText(\"Are you sure?\") .setContentText(\"Won't be able to recover this file!\") .setConfirmText(\"Yes,delete it!\") .setConfirmClickListener(new SweetAlertDialog.OnSweetClickListener() { @Override public void onClick(SweetAlertDialog sDialog) { sDialog.dismissWithAnimation(); } }) .show();//显示取消按钮及事件绑定： new SweetAlertDialog(this, SweetAlertDialog.WARNING_TYPE) .setTitleText(\"Are you sure?\") .setContentText(\"Won't be able to recover this file!\") .setCancelText(\"No,cancel plx!\") .setConfirmText(\"Yes,delete it!\") .showCancelButton(true) .setCancelClickListener(new SweetAlertDialog.OnSweetClickListener() { @Override public void onClick(SweetAlertDialog sDialog) { sDialog.cancel(); } }) .show();//确认后切换对话框样式： new SweetAlertDialog(this, SweetAlertDialog.WARNING_TYPE) .setTitleText(\"Are you sure?\") .setContentText(\"Won't be able to recover this file!\") .setConfirmText(\"Yes,delete it!\") .setConfirmClickListener(new SweetAlertDialog.OnSweetClickListener() { @Override public void onClick(SweetAlertDialog sDialog) { sDialog .setTitleText(\"Deleted!\") .setContentText(\"Your imaginary file has been deleted!\") .setConfirmText(\"OK\") .setConfirmClickListener(null) .changeAlertType(SweetAlertDialog.SUCCESS_TYPE); } }) .show(); 参考：https://blog.csdn.net/taa1007/article/details/79551928 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Android-学习笔记","date":"2018-12-19T02:29:00.000Z","path":"2018/12/19/Android-学习笔记/","text":"基础工具adb 命令 adb kill-server 杀死模拟器 adb start-server 启动模拟器 cd desktop 进入桌面文件夹 adb install path/x.apk 安装应用 adb uninstall com.xxx 卸载应用 adb shell 进入linux指令（ctrl+C退出） # ls 列出目录下所有文件（夹）清单 adb pull a.txt 从手机中导出文件 adb push a.txt /mnt/sdcard 把一个文件导入到手机 monkey 1000 随机点模拟器1000次（冒烟测试（压力测试）） 简易拨号应用设置按钮点击事件的四种方式1、内部类使用 onClickListener() 类 12345678910btn = (Button) findViewById(R.id.button1); // 找到按钮btn.setOnClickListener(new MyClickListener()); // 设置按钮点击事件// 在 MainActivity 里面再定义一个类去实现 按钮需要的接口类型private class MyClickListener implements OnClickListener{ @Override public void onClick(View v) { // 当按钮被单击的时候调用 System.out.println(\"按钮被点击了\"); }} 2、匿名内部类123456btn.setOnClickListener(new OnClickListener(){ @Override public void onClick(View v){ // code process }}); 3、setOnClickListener(this)1234567891011121314151617public class MainActivity extends Activity implements onClickListener{ // 注意:接口所属的包名有多个，不能选错：onClickListener - android.view.View public void onCreate() { btn.setOnClickListener(this); // 适用于多个按钮使用同一个事件的情况 } @Override public void onClick(View v){ switch (v.getID()){ // 可根据参数来判断按钮 case R.id.btn1 : break; case R.id.btn2 : break; } }} 4、布局中的 onClick在 AndroidManiFest 中设置 attribute（属性） 1234567&lt;Button //…… android:onClick=\"myClick\" /&gt;public void myClick(View v){ // 方法名必须和 attribute 的 onClick 属性一致 // Kabloey} 获取 EdiText 文本内容12345ed = (EditText) findViewById(R.id.editText1);String str = ed.getText().toString().trim(); // trim()去空格if (str.equals(\"\")){ // 如果文本为空 Toast.makeText(MainActivity.this, \"文本不能为空\", 1).show(); // 弹出吐司} 判断文本是否为空的API：TextUtils.isEmpty(str) 吐司 Toast12Toast.makeText(context/*上下文，可用 this,指当前的activity,即context*/, text, duration).show(); 注意：如果是在自定义的类例如 MyClickListener 中，context 不能是 thiscontext 可以改成：MainActivity.thisduration 弹出时长，参数有： Toast.LENGTH_LONG 值为1 Toast.LENGTH_SHORT值为0 最后别忘了弹出吐司： .show() 意图 Intent1234Intent intent = new Intent(); // 创建一个意图对象intent.setAction(Intent.ACTION_CALL); // 设置动作：打电话intent.setData(Uri.parse(\"tel:\" + num)); // 设置数据：tel:119startActivity(intent); // 开启意图：调用电话进行拨号（注意：权限 android.permission.CALL_PHONE） 布局1、线性布局123456android:orientation=\"horizontal\" // 水平的（默认）android:orientation=\"vertitcal\" // 竖直的android:layout_width=\"match_parent\" // 填充父android:layout_height=\"wrap_content\" // 自适应android:paddingBottom=\"@dimen/activity_vertical_margin\" // 控件内部内容（文字）位置android:marginLeft=\"10dp\" // 控件整体左边留空 10 像素 123456789&lt;!-- 总体布局 --&gt;&lt;LinearLaout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:toos=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\".MainActivity\" &gt; &lt;!-- 内部控件布局 --&gt;&lt;/LinearLaout&gt; 2、相对布局控件默认左上角，需手动确定相对关系 12345android:id=\"@+id/btn2\" // 添加一个 IDandroid:layout_below=\"@id/btn1\" // 在 btn1 的下面（即当前控件的的上面）android:layout_toRightOf=\"@id/btn3\" // 在 btn3 的右边android:layout_alignParentRgiht=\"true\" // 在布局的最右边android:layout_alignBottom=\"@id/bt4\" // 与 bt4 底部对齐 123&lt;RelativeLayout xmlns=\"\"&gt; &lt;!-- 控件布局 --&gt;&lt;/RelativeLayout&gt; 3、帧布局一层一层显示，后面的Frame在前面的Frame上面（默认窗口左上角） 1android:layout_gravity=\"center\" center 居中 center_vertical 垂直居中 center_horizontal 水平居中 4、表格布局123456789101112131415161718192021222324252627282930&lt;TableLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &lt;!--代表一行--&gt; &lt;TableRow android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" &gt; &lt;!--加入第一个控件--&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"所有控件开头都是大写的\" android:textColoe=\"#ff0000\" /&gt; &lt;!--加入第二个控件--&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"10dp\" android:text=\"这是第二列\" android:textSize=\"18sp\" /&gt; &lt;/TableRow&gt; &lt;TableRow&gt; &lt;!-- 第二行 --&gt; &lt;/TableRow&gt; &lt;TableRow&gt; &lt;!-- 第三行 --&gt; &lt;/TableRow&gt; &lt;/TableLayout&gt; 5、绝对布局 absolution 已经废弃了 权重只能在线性布局中使用，平分布局。 1234&lt;LinearLayout&gt; &lt;TextView android:layout_weight=\"2\"/&gt; &lt;!--占三分之二--&gt; &lt;TextView android:layout_weight=\"1\"/&gt; &lt;!--占三分之一--&gt;&lt;/LinearLayout&gt; 单位 px 像素（不适配屏幕，不建议使用） dp自动适应屏幕的单位（px的替代单位） sp控件文字大小 textSize 调试单元测试 定义一个类继承 AndroidTestCase 123456789101112import android.test.AndroidTestCasepublic class CalcTest extends AndroidTestCase { // 写测试方法 public void testAdd() { Calc calc = new Calc(); // 这时已经写好的待测试类 int result = calc.add(5, 3); assertEquals(8/*expected*/, result/*actual*/); // 期望与实际进行对比 }} 在清单文件（AndroidManifest） 中加入 uses-library 和 instrumentation： 12345678910111213&lt;manifest xmlns:android...&gt; &lt;application android:icon=\"@drawable/icon\"...&gt; &lt;!-- 配置函数库 （application 里面） --&gt; &lt;uses-library android:name=\"android.test.runner\" /&gt; ... &lt;/application&gt; &lt;uses-sdk android:minSdkVersion=\"6\" /&gt; &lt;!-- 测试指令集 （application 外面） --&gt; &lt;instrumentation android:name=\"android.test.InstrumentationTestRunner\" android:targetPackage=\"应用包名\" android:lable=\"标题（可省）\" /&gt;&lt;/manifest&gt; \\&lt;application android:icon=\"@drawable/icon\"...&gt; ***\\&lt;uses-library android:name=\"android.test.runner\" /&gt;*** \\&lt;/application&gt; ***&lt;instrumentation android:name=\"android.test.InstrumentationTestRunner\"*** ***android:targetPackage=\"cn.itcast.action\" android:lable=\"Tests for My APP\" /&gt;*** Run As : Android JUnit Test 加入误相减，console 会出现：junit.framework.AssertionFailedError: expected:&lt;8&gt; but was &lt;2&gt; 可根据不同的错误级别来显示 日志猫12345Log.v(tag/*一般是 类名*/, msg); // v 级别（和 println 一样） 绿Log.i(tag/*一般是 类名*/, msg); // info 级别 ---- 绿Log.d(tag/*一般是 类名*/, msg); // debug 级别 ---- 蓝Log.w(tag/*一般是 类名*/, msg); // warn 级别 ---- 黄Log.e(tag/*一般是 类名*/, msg); // error 级别 ---- 红 文件存储操作过程：File -&gt; FileStream -&gt; write / read &amp; read_buffer -&gt; close 向SD卡写数据需要存储权限AndroidManiFest 增加权限：android.permission.WRITE_EXTERNAL_STORAGE txt读写例程：绝对路径1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.FileInputStream;public class UserInfoUtiles{ // 写入到文件 public static boolean saveInfo(String username, String password) { try { String result = username + \"&amp;\" + password; // 创建 File类 指定数据存储的位置 File file = new File(\"/data/data/包名/info.txt\"); // 创建一个文件输出流 FileOutputStream fos = new FileOutputStream(file); fos.write(result.getBytes()); fos.close(); return true; } catch (Exception e) { e.printStackTrace(); return false; } } // 从文件读出 public static Map&lt;String, String&gt; readInfo() { try { Map&lt;String, String&gt; maps = new HashMap&lt;String, String&gt;(); File file = new File(\"/data/data/包名/info.txt\"); FileInputStream fis = new FileInputStream(file); BufferedReader bufr = new BufferedReader(new InputStreamReader(fis)); String content = bufr.readLine(); // 读取一行 // 分割文本 String[] splits = content.split(\"&amp;\"); String name = splits[0]; String pwd = splits[1]; // 把数据放到 Map 中 maps.put(\"username\", name); maps.put(\"password\", pwd); fis.close(); return maps; } catch (Exception e) { e.printStackTrace(); } return null; }}// 调用存入if (UserInfoUtils.saveInfo(username, password)){ ...}// 调用取出Map&lt;String, String&gt; maps = UserInfoUtils.readInfo();if (maps != null){ String name = maps.get(\"username\"); String pwd = maps.get(\"password\"); ...} API 获取内部路径12345678910111213141516171819// 使用API获取路径public static boolean saveInfo(Context context, String username, String password){ // path = \"/data/data/包名/files/\" String path = context.getFilesDir().getpath(); // 用 path/info.txt 代替原来的 路径常量 File file = new File(path, \"info.txt\"); // 和前面一样的 FileOutputStream fos = new FileOutputStream(file); fos.write(result.getBytes()); fos.close();}// 调用UserInfoUtils.saveInfo(MainActivity.this, username, password);UserInfoUtils.readInfo(MainActivity.this); context 获取内部路径12345// 使用上下文直接获取 FileOutputStream （类似API）FileOutputStream fos = context.openFileOutput(\"info,txt\", 0/*模式，4种*/);fos.write(result.getBytes());fos.close(); Environment 获取SD卡路径123// sdPath = \"/mnt/sdcard\"String sdPath = Environment.getExternalStorageDirectory().getPath();File file = new File(sdPath, \"info.txt\"); 判断SD卡是否可用123if ( Environment.MEDIA_MOUNTED.equals( Environment.getExternalStorageState() ) ) { Toast.makeText(getApplicationContext(), \"SD卡可用\", 1).show();} 获取SD卡的可用空间1234567File file = Envirinment.getExternalStorageDirectory();long total = file.getTotalSpace(); // 总空间（单位：byte）long usable = file.getUsableSpace(); // 可用空间（单位：byte）//转换数据格式为可视化文本String Total = Formatter.formatFileSize(this, total); // this 是当前的 MainActivityString Usable = Formatter.formatFileSize(this, usable); // 每大于900则除以1024 文件权限四种模式 MODE_PRIVATE — 值为0 MODE_APPEND — MODE_WORLD_READABLE r– MODE_WORLD_WRITEABLE -w- Linux文件权限表示：十位数 第一位：文件的类型 ( 例如：文件夹 d ) 2-4位：用户的权限 5-7位：用户所在的组的权限 8-10位：其他用户的权限 r w x r 可读 w 可写 x 可执行 rw- &lt;=&gt; 110 &lt;=&gt; 6 改变文件权限 Linux下的chhmod命令：chmod 764 a.txt // 文件权限为：rwx rw- r–​ 111 110 100 == 7 6 4 XML保存设置文件 SharedPreferences（必须得会） Sharedpreferences setting = getSharedPreferences(name, mode);name:任意 mode:同上，4种模式会自动生成：/data/data/包名/shared_prefs/name.xml 文件 1234567891011SharedPreferences sp = new SharedPreferences(\"config\", 0); // 文件名为 config.xml 模式为 private 0// 若改成\"config.txt\", 则会生成 config.txt.xml 文件// 获取 sp 的编辑器Editor edit = sp.edit();edit.putString(\"username\", username); // key, valueedit.putInt(\"Age\", age); // edit.putXXX 有多种类型可选edit.putFloat(\"PI\", 3.14);// 记得关闭 edit （提交）edit.commit(); SharedPreferences.getString(key, defaultValue /*默认的，找不到时*/ ); 12SharedPreferences sp = getSharedPreferences(\"config\", 0);sp.getString(\"username\", \"\"); 对应的 xml 内容 123456&lt;?xml version=\"1.0\" encodeing=\"UTF-8\" standalone=\"true\"?&gt;&lt;map&gt; &lt;string name=\"username\"&gt;myname&lt;/string&gt; &lt;string name=\"Age\"&gt;20&lt;/string&gt; ...&lt;/map&gt; 手动构建 xml 文件12345678910111213141516171819202122232425262728293031323334353637383940414243public void build_xml(){ // 声明数组（其中 Sms 是自定义 class） List&lt;Sms&gt; smsLists = new ArrayList&lt;Sms&gt;(); //创建 sb 对象 StringBuffer sb = new StringBuffer(); // 开始组拼 xml 文件头(注意转移双引号) sb.append(\"&lt;?xml version=\\\"1.0\\\" encodeing=\\\"UTF-8\\\" ?&gt;\"); // 开始组拼 xml 根节点 sb.append(\"&lt;smss&gt;\"); // 开始组建 xml 节点 （任意循环增加） for (Sms sms : smsLists) { sb.append(\"&lt;num&gt;\"); sb.append(\"110\"); sb.append(\"&lt;/num&gt;\"); sb.append(\"&lt;people&gt;\"); sb.append(\"小明\"); sb.append(\"&lt;/people&gt;\"); } sb.append(\"&lt;/smss&gt;\"); // 保存到 SD卡 上 try { File file = new File(Environment.getExternalStorageDirectory().getPath(), \"backup.xml\"); FileOutputStream fos = new FileOutputStream(file); fos.write(sb, .toString().getBytes()); fos.close(); // 关闭流 // 注意写入到SD卡权限：WRITE_EXTERNAL_STORAGE } catch ( Exception e) { e.printStackTrace(); }} xml序列化器 xmlSerializer12345678910111213141516171819202122232425262728293031323334353637try{ // 通过 Xml 类获取 XmlSerializer 类的实例 XmlSerializer sl = Xml.newSerializer(); // 设置参数：XML文件路径 File file = new File(Environment.getExternalStorageDirectory().getPath(), \"backup2.xml\"); FileOutputStream fos = new FileOutputStream(file); sl.setOutput(fos, \"utf-8\"); // 文件流与编码 // 开始写 xml 文档开头 sl.startDocument(\"utf-8\", true/*standalone, 表示是一个独立的xml文件，没有其他文件的约束*/); // xml 的根节点，namespace = null sl.startTag(null, \"smss\"); // 循环写xml数据 for (Sms sms : smsLists) { sl.startTag(null, \"sms\"); sl.startTag(null, \"num\"); sl.text(\"110\"); sl.endTag(null, \"num\"); sl.startTag(null, \"people\"); sl.text(\"小明\"); sl.endTag(null, \"people\"); sl.endTag(null, \"sms\"); } sl.endTag(numll, \"smss\"); // 写文档结尾 sl.endDocument(); fos.close(); // 关闭流} xml的解析12345678910111213&lt;!-- 目标 xml 文件 --&gt;&lt;weather&gt; &lt;channel id=\"1\"&gt; &lt;city&gt;背景&lt;/cith&gt; &lt;temp&gt;25&lt;/temp&gt; &lt;/channel&gt; &lt;channel&gt; ... &lt;/channel&gt; ...&lt;/weather&gt; 1234567891011121314151617// 调用：try{ // 获取 Assets 的文件 InputStream inputStream = getAssets().open(\"weather.xml\"); List&lt;Channel&gt; weatherlists = WeatherParser.parserXml(inputstream); StringBuffer sb = new StringBuffer(); for (Channel channel : weatherlists) { sb.append(channel.toString()); } System.out.println(sb.toString());} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// WeatherParser类的parserXml方法：public static List&lt;Channel&gt; parserXml(InputStream in){ try { List&lt;Channel&gt; weather: ists = null; Channel channel = null; // 获取解析的实例 XmlPullParser parser = Xml.newPullParser(); // 设置解析参数(in是输入流) parser.setInput(in, \"utf-8\"); // 获取事件类型 int type = parser.getEventType(); while (type != XmlPullParser.END_DOCUMENT /*==1*/) { // 具体判断解析到哪个节点 switch (type) { // 具体判断一下 解析到哪个开始标志 case XmlPullParser.START_TAG : // 解析开始标志 if (\"weather\".equals(parser.getName())) { // 创建一个集合对象 weatherLists = new ArrayList&lt;Channel&gt;(); } else if (\"channel\".equals(parser.getName())) { // 创建Channel对象 channel = new Channel(); // 获取ID：第1个数，下标0 String id = parser.getAttributeValue(0) channel.setId(id); // 自定义类的方法 } else if (\"city\".equals(parser.getName())) { // 获取city的数据 String city = parser.getText(); channel.setCity(city); } else if (\"temp\".equals(parser.getName())) { // 获取temp的数据 String temp = parser.getText(); channel.setTemp(temp); } break; case XmlPullParser.END_TAG : // 解析结束标志 // 判断要解析的结束标签 if (\"channel\".equals(parser.getName())) { // 把 Javabean 对象存到集合中 weatherLists.add(channel); } break; } // 不停地向下解析 parser.next(); } return weatherLists; } catch ( Exception e ) { }} 数据库sqlite 数据库初始化SQLiteOpenHelperSQLiteOpenHelper类 用来管理数据库的创建 ，创建子类来继承它 db.execSQL(string sql) 执行SQL语句 12345678910111213141516171819202122232425262728import android.content.Context;import android.database.sqlite.SQLiteDababase;import android.database.sqlite.SQLiteOpenHelper;public class MyOpenHelper extends SQLiteOpenHelper { // 需要添加无参构造方法 public MyOpenHelper(Context context) { // 创建数据库，上下文、名字、cursor对象（结果集/游标）、数据库版本（从1开始） super(context, \"test.db\", null, 1); } // 数据库第一次创建的时候用（仅一次），特别适合做表结构的初始化 @Override public void onCreate(SQLiteDatabase db) { // 创建表的结构 db.execSQL(\"create table info( _id integer primary key autoincrement, name varchar(20) )\"); // SQLite数据库底层不区分数据类型，但是SQL语句还是得照写声明类别（所有SQL语句都一样） // integer 也是用 string 来存储，varchar(20) 可以存更长的 string } // 数据库升级的时候调用（不能降级，会出错） @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) { //例如：升级 info表 添加 phone字段 db.execSQL(\"alter table info add phone varchar(20)\"); } } MainActivity部分数据库路径：/data/data/包名/databases/数据库名字.db 123456789101112131415161718public class MainActivity extends Activity{ private MyOpenHelp myOpenHelper; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 创建数据库（包名），触发 构造方法、onCreate() 事件 myOpenHelper = new MyOpenHelper(getApplicationContext()); // 创建（第一次）或打开数据库 SQLiteDatabase sqLiteDatabase = myOpenHelper.getWriteableDatabase(); // 创建（第一次）或打开数据库；如果磁盘已满则返回只读 // SQLiteDatabase readableDatabase = myOpenHelper.getReadableDatabase(); }} 执行SQL语句execSQLvoid execSQL(sql, bindArgs); // 修改语句，无返回值 SQLiteDatabase execSQL(sql); // 查找语句，有返回值 lite1234insert into info(name, phone) values(\"Tom\", \"110\"); -- 两个斜杠表示注释delete from info where name = \"Tom\"lupdate info set phone = \"120\" where name = \"Tom\";select name, phone from info; 1234567891011121314// 执行 SQL语句public void onClick(View v){ // 获取数据库对象 SQLiteDatabase db = myOpenHelper.getWritableDatabase(); // 执行增加一条的SQL语句 db.execSQL(\"insert into info (name, phone) values(?, ?)\", new Object[] {\"Tim\", \"119\"}); // 执行删除语句 db.execSQL(\"delete from info where name=?\", new Object[] {\"Tom\"}/*bindArgs*/); // 数据库用完需关闭（官方建议关闭，但是不关可提升效率） db.close();} Cursor int getCount() 行数 getColumnCount() 列数 String getString(int columnIndex) boolean moveToNext() moveToFirst() moveToLast() moveToPosition(int position) moveToPrevious() String[] getColumnNames() 所有列的名字 1234567891011121314public void onClick(View v){ SQLiteDatabase db = myOpenHelper.getReadableDatabase(); // 只读就行了 Cursor cursor = db.rawQuery(\"select * from info\", null); if (cursor != null &amp;&amp; cursor.getCount() &gt; 0) { while (cursor.moveToNext()) { String name = cursor.getString(1); // 这一行第二列的值 System.out.println(\"name:\" + name); } }} SQL优缺点缺点 SQL语句容易写错 没有返回值，结果不容易判断 优点 多表查询（自由、功能强） sqlite3命令行SQL语句开启shell adb shell 定位到目录 # cd /data/data/包名/databases 打开数据库 # sqlite3 数据库名字.db sqlite&gt; SQL语句 （不包括前面的sqlite&gt;） 改变DOS编码 如果中文乱码，点击cmd属性，看编码是否为UTF-8（默认GBK） 改成GBK chcp 936 改成UTF-8 chcp 65001 chcp: char change page 谷歌封装好的数据库API原理是组拼SQL语句 1234567891011121314151617181920212223242526272829303132public void onClick(View v){ SQLiteDatabase db = myOpenHelper.getWritableDatabase(); ContentValues values = new ContentValues(); values.put(\"name\", \"Tom\"); values.put(\"phone\", \"110\"); // 添加记录：表名、null、map数组：名字=&gt;值。返回 long -1失败 或 行号（1开始） long num = db.insert(\"info\", null, values); // 删除记录：表名、条件、条件值。返回 int 影响的行数， 0 为没有删除 int num = db.delete(\"info\", \"name=?\", new String[] {\"Tom\"}); // 更新记录：表名、map数组、条件、条件值。 返回 int 影响的行数 int num = db.update(\"info\", values, \"name=?\", new String[] {\"Tom\"}); // 查询：表名、查询的列String[]（null为全部列）、条件、条件值String[]、分组、过滤条件、排序 // 选择查询的列（参数二）：new String[]{\"name\", \"phone\"} Cursor cursor = db.query(\"info\", null, \"name=?\", new String[] {\"Tom\"}, null, null, null); if (cursor != null &amp;&amp; cursor.getCount() &gt; 0) { while(cursor.moveToNext()) { String name = cursor.getString(0); // 第一列（name） String phone = cursor.getString(1); // 第二列（phone） System.out.println(\"name=\" + name + \" phone=\" + phone); } } db.close();} 优点 写法简单 有返回值 缺点 多张表不容易查询 数据库的事物例如：转账，需要取出、存入同时成功 12345678910111213141516171819public void onClick(Veiw v){ SQLiteDatabase db = myOpenHelper.getReadableDatabase(); // 使用事物进行操作 db.beginTransaction(); try{ // 实现逻辑，即SQL语句 db.execSQL(\"update ac_mon set money = money - 100 where name = ?\", new String[]{\"userA\"}); /* int i = 10 / 0; // 运行中断 */ db.execSQL(\"update ac_mon set money = money + 100 where name = ?\", new String[]{\"userB\"}); // 给当前事物设置一个成功的标记 db.setTansactionSuccessful(); } catch (Exception e) { Toast.makeText(getApplicationContext(), \"服务器忙，请稍后再试\", 1).show(); } finally { db.endTransaction(); // 关闭事物 }} ListView使用方法1、布局：activity_main123456&lt;ListView android:id=\"@+id/lv\" android:layout_witdh=\"match_parent\" android:layout_height=\"match_parent\" android:fastScrollEnabled=\"true\"&gt; &lt;!--快速滚动条--&gt;&lt;/ListView&gt; 2、设置Adapter连接到数据适配器：setAdapter() 12345678910111213public class MainActivity extends Activity { @Override protected void onCreate(Bundle saveInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 找到控件 ListView lv = (ListView) findViewById(R.id.lv); // 显示数据（数据来源于数据适配器） lv.setAdapter(new MyListAdapter()); }} 3、实现BaseAdapter方法BaseAdapter 可以放到上面的 MainActivity 类的代码里面，作为类中类 12345678910111213141516171819202122232425262728private class MyListAdapter extends BaseAdapter { // 项目数量 @Override public int getCount() { return 4; /*item数量，自定义*/ } // 对应的对象 @Override public Object getItem(int position) { return null; } // 对应的ID @Override public long getItemID(int position) { return 0; } //获取一个view，用来显示每个item的数据 @Override public View getView(int position, View convertView, ViewGroup parent) { TextView tv = new TextView(MainActivity.this/*当前类*/); tv.setText(\"索引：\" + position); return tv; // return null 的话会报错 }} 错误提示Attempt to invoke virtual method 'int android.view.View.getImportantForAccessibility()' on a null object reference 原因是 getView() 返回值为空…… 结果示例getCount()控制条目数量。当数量=4时： 1public int getCount() { return 4; } 结果： 1索引：0 1索引：1 1索引：2 1索引：3 每个item都是一个TextView，其由getView()方法决定 显示数据的原理MVC Javaweb: m : mode 数据 v : view 视图 jsp c : controller 控制 sevlet Android: m : mode 数据(javabean) v : listview c : adapter ListView优化getView() 方法说明只有在屏幕上显示（包括只显示一点点）的item才会触发getView()方法。滚动时新显示的条目也会触发。快速滚动加载大量View可能会导致内存溢出（Out Of Memory）。 convertView 缓存机制item并不是滚动完就销毁。使用 convertView 历史缓存可避免内存溢出。 123456789101112131415161718192021@Overridepublic View getView(int position, View convertView, ViewGroup parent){ TextView tv; if (convertView == null) { // 缓存对象为空，创建新的 view 对象 tv = new TextView(MainActivity.this); } else { // 使用历史缓存对象 tv = (TextView) convertView; } tv.setText(\"索引：\" + position); return tv;} 复用历史缓存对象：一开始时是真的创建可见范围内的对象，滚动上去后，新出现（底部）的对象实际上是复用已经加载好但是看不见了的（顶部）的对象。根据 position 调用 getView() 方法。 例如，快速滚动时加载100个item，不用缓存需要创建100个TextView。使用 convertView 后，只需要设置TextView的值就好了。 List高度设置能否设置成 layout_height=\"wrap_content\" ？ 123&lt;ListView android:layout_height=\"match_parent\"&gt; &lt;!--这是正常的--&gt;&lt;/ListView&gt; 改成android:layout_height=\"wrap_content\"后，无法确定高度，校验很多次，重复调用 getView() 方法，严重影响性能。 复杂的ListView┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑│ ┌───────┐ 这里是项目标题，字… ││ │ Image │ 这个部分是项目相对应 ││ └───────┘ 的信息内容 │┕━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┙ 1、Layout：activity_main12345&lt;ListView android:id=\"@+id/lv\" android:layout_witdh=\"match_parent\" android:layout_height=\"match_parent\"&gt;&lt;/ListView&gt; 2、Layout : item（xml）1234567891011121314151617181920212223242526272829303132333435&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_witdh=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;ImageView android:id=\"@+id/iv_icon\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:src=\"@drawable/ic_launcher\" /&gt; &lt;TextView android:id=\"@+id/tv_title\" android:layout_width=\"match_parent\" // 左边与父容器右边的距离 android:layout_height=\"wrap_content\" android:layout_toRightOf=\"@id/iv_icon\" // 图片右边 android:layout_marginTop=\"3dp\" // 顶部留空 android:singleLine=\"true\" // 单行显示 android:ellipsize=\"end\" // 显示开头，末尾三个点。start值相反 androi:textColor=\"#000000\" android:textsize=\"20sp\" android:text=\"这个里项目标题，字体加粗加黑\" /&gt; &lt;TextView android:id=\"@+id/tv_message\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_toRightOf=\"@id/iv_icon\" // 图片右边 android:layout_below=\"@id/tv_text\" // 标题下面 android:singleLine=\"true\" android:ellipsize=\"end\" androi:textColor=\"#666666\" android:textsize=\"15sp\" android:text=\"这个里项目标题，字体加粗加黑\" /&gt;&lt;/RelativeLayout&gt; 3、BaseAdapter：打气筒View View.inflate(context, resource, root) 方法（打气筒）介绍：创建新的View对象，把布局资源（xml 文件）折换成一个 View 对象，放到父容器中，并返回这个 View 对象 context : getApplicationContext()，或 this resource : 定义的布局文件 R.id.xxx root : null，或者待放入的容器(ViewGroup) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class MainActivity extends Activity{ @Override protected void onCreate(Bundle saveInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 找到控件 ListView lv = (ListView) findViewById(R.id.lv); // 显示数据（数据来源于数据适配器） lv.setAdapter(new MyListAdapter); } private class MyListAdapter extends BaseAdapter { // 项目数量 @Override public int getCount() { return 4; /*item数量，自定义*/ } // 对应的对象 @Override public Object getItem(int position) { return null; } // 对应的ID @Override public long getItemID(int position) { return 0; } //获取一个view，用来显示每个item的数据 @Override public View getView(int position, View convertView, ViewGroup parent) { View view; if (convertView == null) { // 获取打气筒服务 view = View.inflate(getApplicationContext, R.id.item, null); } else { // 复用历史缓存对象 view = (TextView) convertView; } //根据列表设置控件数据 //TextView tv = (TextView) view.findViewById(R.id.tv); //view.setText(xxLists.get(position).getXx()); return view; } }} 获取 XML 布局里面的控件：view.findViewById()，不能直接 findViewById() 打气筒的三种写法打气筒写法一：View.inflate() 1view = View.inflate(getApplicationContext, R.id.item, null); // 用法见上 打气筒写法二：LayoutInflater.from() 1view = LayoutInflater.from(getApplicationContext()).inflate(R.layout.item, null); 打气筒写法三：getSystemService()据说实际上用得比较多 12LayoutInflater inflater = (LayoutInflater) getSystemService(LAYOUT_INFLATER_SERVICE);view = inflater.inflate(R.layout.item, null); 其他写法：不常见 ArrayAdapter布局：activity_main 1234&lt;ListView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"&gt;&lt;/ListView&gt; 布局：item 1234&lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"&gt;&lt;/TextView&gt; MainActivity ArraryAdapter&lt;String&gt;(context, resource, objects) 123456789101112131415161718192021222324import android.R.array;public class MainAcitivity extends Activity{ String names[] = { \"111\", \"222\", \"333\", \"444\" }; @Override protected void onCreat(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 找到控件 ListView lv = (ListView) findViewById(R.id.lv); // 创建 ArrayAdapter : context, resource(只有TextView的xml文件), 数据数组 ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this, R.id.item, names); // 设置数据适配器 lv.setAdapter(adapter); }} 结果 1234111222333444 重载的四个参数的ArrayAdapter用法： ArraryAdapter&lt;String&gt;(context, resource, textViewResourceId, objects) textViewResourceId 为 resource 布局文件里面的某个特定的 TextView 的 ID 1ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this, R.id.item, R.id.tv, names); 1234&lt;RelativeLayout ...&gt; &lt;TextView android:id=\"@+id/tv\" ... /&gt;&lt;/RelativeLayout&gt; SimpleAdapter┍━━━━━━━━━━━━━━━━━━━━━┑│┌───────┐┌───────┐│││ name │ │ phone │││└───────┘└───────┘│┕━━━━━━━━━━━━━━━━━━━━━┙ 布局：activity_main 123&lt;RelativeLayout ...&gt; &lt;ListView ... /&gt;&lt;/RelativeLayout&gt; 布局：item 123456789101112131415161718&lt;LinearLayout xmlns=\"...\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"horizental\"&gt; &lt;TextView android:id=\"@+id/tv_name\" android:layout_width=\"0dp\" android:layout_weight=\"1\" android:layout_height=\"wrap_content\" /&gt; &lt;TextView android:id=\"@+id/tv_phone\" android:layout_width=\"0dp\" android:layout_weight=\"1\" android:layout_height=\"wrap_content\" /&gt;&lt;/LinearLayout&gt; 代码：MainActivity SimpleAdapter adapter = new SimapleAdapter(context, data, resource, from, to); // 参数长的那个 data 是 List&lt;Map&lt;String, String&gt;&gt; 类型数据 resource 是 布局文件（上面的 item） from 是 String[] 类型，表示 Map&lt;String, String&gt; 的键 to 是 int[] 类型数组，与from 对应的布局文件中的 TextView 的 ID 123456789101112131415161718192021// 找到控件ListView lv = (ListView) findViewById(R.id.lv);// 准备数据List&lt;Map&lt;String, String&gt;&gt; data = new ArrayList&lt;Map&lt;String, String&gt;&gt;();Map&lt;String, String&gt; map1 = new HashMap&lt;String, String&gt;();map1.put(\"name\", \"Tom\");map1.put(\"phone\", \"110\");Map&lt;String, String&gt; map2 = new HashMap&lt;String, String&gt;();map2.put(\"name\", \"Alice\");map2.put(\"phone\", \"120\");data.add(map1);data.add(map2);// 设置数据适配器SimpleAdapter adapter = new SimapleAdapter(getApplicationContext(), data, R.id.item, new String[]{ \"name\", \"phone\" }, new String[]{ R.id.tv_name, R.id.tv_phone });lv.setAdapter(adapter); 用ListView展示数据库的数据┍━━━━━━━━━━━━━━━━━━━━━┑│┌───────┐┌───────┐│││ name │ │ phone │││└───────┘└───────┘│┕━━━━━━━━━━━━━━━━━━━━━┙ 布局：activity_main 1略 布局：item 123456789101112131415161718&lt;LinearLayout xmlns=\"...\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"horizental\"&gt; &lt;TextView android:id=\"@+id/tv_name\" android:layout_width=\"0dp\" android:layout_weight=\"1\" android:layout_height=\"wrap_content\" /&gt; &lt;TextView android:id=\"@+id/tv_phone\" android:layout_width=\"0dp\" android:layout_weight=\"1\" android:layout_height=\"wrap_content\" /&gt;&lt;/LinearLayout&gt; 类：Person 12String name, phone;略 MainActivity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596public class MainAcitivity extends Activity{ // 找到控件 ListView lv = (ListView) findViewById(R.id.lv); // 整理数据 List&lt;Person&gt; lists = new ArrayList&lt;Person&gt;(); @Override protected void onCreat(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } public void onClick(View v) { SQLiteDatabase db = myOpenHelper.getWritableDatabase(); // 查询：表名、查询的列String[]（null为全部列）、条件、条件值String[]、分组、过滤条件、排序 //Cursor cursor = db.query(\"info\", null, \"name=?\", new String[]{\"Tom\"}, null, null, null); Cursor cursor = db.query(\"info\", null, null, null, null, null, null); // 查询所有 if (cursor != null &amp;&amp; cursor.getCount() &gt; 0) // 如果有数据 { while(cursor.moveToNext()) { String name = cursor.getString(0); // 第一列（name） String phone = cursor.getString(1); // 第二列（phone） Person person = new Person(name, phone); lists.add(person); } // 设置数据适配器 lv.setAdapter(new MyListAdapter); } db.close(); } private class MyListAdapter extends BaseAdapter { // 项目数量 @Override public int getCount() { return lists.size(); // 返回列表（数据库）中的数据数量 } // 对应的对象 @Override public Object getItem(int position) { return null; } // 对应的ID @Override public long getItemID(int position) { return 0; } //获取一个view，用来显示每个item的数据 @Override public View getView(int position, View convertView, ViewGroup parent) { TextView view; if (convertView == null) { // 缓存对象为空，创建新的 view 对象 view = View.inflate(getApplicationContext, R.id.item, null); } else { // 使用历史缓存对象 view = (TextView) convertView; } Person person = lists.get(position); // 获取从数据库中取出的列表对象 // findViewById() 从当前 activity 中获取 ID，无法直接取到 layout/item 里面的 ID， // 所以需要先用 inflate() 获取到 R.id.item 的 view，再通过 view 获取 ID TextView tv_name = (TextView) view.findViewById(R.id.tv_name); TextView tv_phone = (TextView) view.findViewById(R.id.tv_phone); tv_name.setText(person.getName()); // 设置名字 tv_phone.setText(person.getPhone()); // 设置电话 return view; } }} 网络网页源码查看器联网权限android.permission.INTERNET HttpUrlConnection 类用于发送或者接受数据，取网页源代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 设置网址String path = \"http://www.baidu.com\";URL url = new URL(path);try{ // HttpURLConnection对象，用于发送或者接受数据 HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection(); // 设置发送 get 请求（默认），注意要求【大写】 urlConnection.setRequestMethod(\"GET\"); // 设置请求超时 urlConnection.setConnectTimeout(5000); // 5 秒 // 获取服务器返回的状态码，例如 404 int code = urlConnection.getResponseCode(); if (code == 200) { // 获取服务器返回的数据流 InputStream in = urlConnection.getInputStream(); // 数据流转换成文本，最终的网页源代码 String content = StreamTools.readStream(in); }}// 流转文本的方法public static class StreamTools{ public static String readStream(InputStream in) { int len = -1; byte[] buffer = new byte[1024]; // 1 kb // 定义一个内存输出流 ByteArrayOutputStream baos = new ByteArrayOutputStream(); while ( ( len = in.read(buffer) ) != -1 ) { baos.write(buffer, 0, len); } in.close(); String content = new String(baos.toByteArray()); return content; }} ScrollViewscrollview 只能有一个子控件 布局 12345678&lt;ScrollView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:id=\"@+id/tv\"/&gt;&lt;/ScrollView&gt; 如果要多个子控件，可以将这些子控件包裹在 &lt;LinearLayout&gt; 里面，orientation=\"vertical\" 消息机制的写法主线程（UI线程）ANR Application not response 应用无响应 耗时的操作放到子线程当中 Android 4.0 之后，谷歌强制要求连接网络不能再主线程进行访问 只有主线程（UI线程）才可以更新UI Handler 使用步骤1、在主线程定义一个 Handler 1private Handler handler = new Handler(); 2、使用 Handler，重写里面的 handlerMessage 方法 1public void handleMessage(android.os.Message msg) { } 3、用 Handler 去子线程发消息 1handler.sendMessage(msg); 4、handleMessage 方法就会执行，更新UI 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class MainActivity extends Activity{ TextView tv = (TextView) findVIewById(R.id.tv); // 在主线程中定义一个Handler，类后跟{}表示重写类的方法 private Handler handler = new Handler() { // 收到消息。这个方法是在主线程里执行的，可以更新 UI public void handleMessage(android.os.Message msg) { String content = (String) msg.obj; tv.setText(content); }; } public void click(View v) { // 创建一个子线程 new Thread() { public void run() { try { // 设置网址 String path = \"http://www.baidu.com\"; URL url = new URL(path); // 发送、接收数据的对象 HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection(); // 设置GET请求 urlConnection.setRequestMethod(\"GET\"); // 设置超时时间 urlConnection.setConnectTimeout(5000); // 获取服务器返回的状态码 int code = urlConnection.getResponseCode()； if (code == 200) { // 输入流 InputStream in = conn.getInputStream(); // 流转字符串 String content = StreamTools.readStream(in); // 创建 Message 对象 Message msg = new Message(); msg.obj = content; // Handler 发送msg(包含数据)于更新UI handler.sendMessage(msg); } //if } //try } } .start(); //thread run } //function} 消息机制的原理消息队列，有一个Looper不断读取队列，然后 handlerMessage(msg) Handler 完善：what1234567891011121314151617181920212223242526272829303132333435363738protected final int REQUESTSUCESS = 0;protected final int REQUESTNOTFOUND = 1;protected final int REQUESTEXCEPTION = 2;public void handleMessage(android.os.Message msg) { switch (msg.what) { case REQUESTSUCESS : // 代表请求成功 String content = (String) msg.obj; tv.setText(content); break; case REQUESTNOTFOUND : // 代表请求失败 Toast.makeText(getApplicationContext(), \"请求资源不存在\", 0).show(); break; case REQUESTEXCEPTION : // 代表产生异常 Toast.makeText(getApplicationContext(), \"服务器忙，请稍后再访问\", 0).show(); break; }}try{ //... if (code == 200) { Mseeage msg = new Message(); msg.what = REQUESTSUCESS; // 代表哪条消息 handler.sendMessage(msg); } else { Mseeage msg = new Message(); msg.what = REQUESTNOTFOUND; // 代表哪条消息 handler.sendMessage(msg); }} catch (Exception e) { Mseeage msg = new Message(); msg.what = REQUESTEXCEPTION; // 代表哪条消息 handler.sendMessage(msg);} 程序运行错误，尽量提示用户：服务器忙，请稍后访问 而不是：程序运行错误，让用户担忧 图片查看器ImageView 显示网络图片123&lt;manifest&gt; &lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;&lt;/manifest&gt; 123456&lt;EditView /&gt;&lt;Button /&gt;&lt;ImageView android:id=\"@+id/iv\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private Handler handler = new Handler(){ //收到消息，设置图片 public void handleMessage(android.os.Message msg) { bitmap bitmap = (Bitmap) msg.obj; iv.setImageBitmap(bitmap); }}public void click(View v){ new Thread() { public void run() { try { // 使用路径创建 URL 对象 String path = ev.getText().toString().trim(); URL url = new URL(path); // 获取 HttpURLConnection（用户发送或者接收数据） HttpURLConnection conn = (HttpURLConnection) url.openConnection(); // 设置请求的方式、超时时间 conn.setRequestMethond(\"GET\"); conn.setConnectTimeout(5000); int code = conn.getResponseCode(); if (code == 200) { // 获取图片的数据（流 的形式） InputStream in = conn.getInputStream(); // 通过位图工厂 获取 bitmap Bitmap bitmap = BitmapFactory.decodeStream(in); // 发送消息用于更新UI Message msg = Message.obtain(); // 使用 Message 的静态方法 可以减少对象的创建 msg.obj = bitmap; handler.sendMessage(msg); } else { // ... } } catch (Exception e) { e.printStackTrace(); } } } .start();} 使用 Message 的静态方法 可以减少对象的创建 Message msg = Message.obtain(); 效果等同于：Message msg = new Message() 但是效率快 图片缓存到本地1234567891011121314if (code == 2) { //图片的数据流 InputStream in = conn.getInputStream(); File file = new File(getCacheDir(), \"test.png\"); // 谷歌提供的缓存目录 FileOutputStream fos = new FileOutputStream(file); int len = -1; byte[] buffer = new byte[1024]; // 1kb while ((len = in.read(buffer)) != -1) { fos.write(buffer, 0, len); } fos.close(); in.close();} 使用缓存图片123456789101112131415161718192021222324252627282930313233343536373839404142434445new Thread(){ public void run() { try { // 谷歌提供的缓存目录：/data/data/包名/cache/ + test.png File file = new File(getCacheDir(), \"test.png\"); if (file.exists() &amp;&amp; file.length() &gt; 0) { // 使用缓存的图片 Bitmap cacheBitmap = BitmapFactory.decodeFile(file.getAbsolutePath()); // 把 cacheBitmap 显示到 ImageView 上 Message msg = Message.obtain(); msg.obj = cacheBitmap; handler.sendMessage(msg); } else { // 第一次访问，联网获取数据 String path = ev.getText().toString().trim(); URL url = new URL(path); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethond(\"GET\"); conn.setConnectTimeout(5000); int code = conn.getResponseCode(); if (code == 200) { InputStream in = conn.getInputStream(); FileOutputStream fos = new FileOutputStream(file); int len = -1; byte[] buffer = new byte[1024]; // 1kb while ((len = in.read(buffer)) != -1) { fos.write(buffer, 0, len); } fos.close(); in.close(); } } } }} 对图片进行加密Base64加密： Base64.encodeToString(byte[] input, int flags); 1File file = new File(getCacheDir(), Base64.encodeToString(path.getBytes[], Base64.DEFAULT)); 上述代码针对文件路径进行加密，文件名为URL路径加密后的密文 cache 和 filedir 区别写出文件示例1234567891011try { // firledir：/data/data/包名/files/info.txt FileOutputStream fos = openFileOutput(\"info.txt\", 0); // cache：/data/data/包名/cache/info.txt File file = new File(getCacheDir(), \"info.txt\"); FileOutputStream fos = new FileOutputStream(file); fos.write(\"haha\".getByte()); fos.close();} Thread APIrunOnUiThread 写法runOnUiThread(Runable action) 不管在什么位置，里面运行的语句都运行在 UI 线程上。 123456789new Thread() { public void run() { // ... runOnUiThread(new Runnable() { public void run() { tv.setText(\"HHH\"); } }); // ...} } Handler API延迟线程 new Handler().postDelayed(Runnable r, int delayMillis); 效果等同于 Sleep() 这个方法执行在 UI 线程里，可更新 UI 1234567891011public void f() { // 2秒后执行 run 方法 new Handler().postDelayed( new Runnable(){ @Override public run() { // ...code... } }, 2000);} 定时器 TimerTimer.schedule(TimerTask task, long delay); 延迟后执行 Timer.schedule(TimerTask task, long delay, long period); 指定的延迟后进行重复的固定延迟执行 还有其它重载的 schedule 函数 相当于子线程，不能用来更新 UI。可以用 runOnUiThread 来执行 UI 操作 1234567891011121314public void click() { Timer timer = new Timer(); TimerTask task = new TimerTask() { @Override public void run() { // ... code... // 这相当于子线程，不能更新 UI } } timer.schedule(task, 5000);} Timer.cancel(); Task.cancel(); 销毁一个执行 123456// 当 Activity 销毁时 会执行这个方法protected void onDestroy() { timer.cancel(); task.cancel(); super.onDestroy();} 网络基础网络图片 SmartImageView123&lt;com.loopj.android.image.SmartImageView android:id=\"@+id/siv\" ... /&gt; 12345678imageUrl = \"...\";view = View.inflate(...);SmartImageView svi = (SmartImageView) view.findViewById(R.id.siv);siv.setImageUrl(imageUrl); // 设置加载网络图片siv.setImageUrl(String imageUrl, Integer fallbackResource); // 参数2为加载失败的内容 R.drawable.xxxsiv.setImageView(String imageUrl, Integer OnCompleteListener completeListener); // 结束后回调事件siv.setImageView(String imageUrl, Integer fallbackResource, OnCompleteListener completeListener);siv.setImageView(String imageUrl, Integer fallbackResource, Integer loadingResource, OnCompleteListener completeListener); GitHub 开源项目网址：github.com 导入开源项目：下载 zip 后，把解压出来后的 com 文件夹（源码包）复制到项目的 src 中 源码：在 com 文件夹内，.java 后缀名的 布局：用的时候，需要用开源项目的完整包名 HttpURLConnextion联网的基类。 如果连接要求不是很高，只是用来发发数据的话，可以用下面的开源项目。 封装 toast 方法通用方法，获取数据后立即弹出提示 12345678public void showToast(final String content) { runOnUiThread(enw Runnable() { @Override public void run() { Toast.makeText(getApplicationContext(), content, 1).show(); } })} GET 和 POST 的区别 URL路径不同：GET 拼接 网址 和 数据 POST 通过请求体（流）的形式把数据发送给服务器 POST 比 GET 多了两个头信息：content-length 和 content-type 使用 POST1234567891011121314151617181920String path = \"http://xxx\";String data = \"name=\" + name + \"&amp;pass=\" + pass;URL url = new URL(path);HttpURLConnextion conn = (HttpURLConnection) url.openConnection();conn.setRequestMethond(\"POST\");conn.setConnextTimeout(5000);//比GET方式多的两个头信息conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-url\");conn.setRequestProperty(\"Content-Length\", data.length()+\"\"); // 参数二要求字符串，故 数字+空字符串//以流的形式提交数据con.setDoOutput(true); // 设置一个标记，允许输出conn.getOutputStream().write(data.getBytes());//判断结果int code = conn.getReponseCode();if (code == 200) { // 获取返回的数据流 -&gt; 转化成字符串 -&gt; 操作字符串数据 InputStream inputStream = conn.getInputStream(); String content = StreamTools.readStream(inputStream); showToast(content);} 乱码问题Android 编码：UTF-8 服务器编码：本地服务器的编码，一般为 iso-859-1 （类似 GBK） 改变服务器编码（Java）：返回中文乱码 System.out.prrintln(\"ans : \" + new String(ans.getBytes(\"utf-8\"))); 发送中文乱码：先以 iso-8859-1 编码，再以 UTF-8 解码 `System.out.prrintln(\"ans : \" + new String(ans.getBytes(\"iso-8859-1\"), \"utf-8\"));`改变 Android 编码123456789101112131415161718public class StreamTools{ //把输入流转换成字符串 public static String readStream(InputStream in) throws Exception { //定义一个内存输出流 ByteArrayOutputStream baos = new ByteArrayOutStream(); int len = -1; byte[] buffer = new byte[1024]; // 1 kb while ( (len = in.read(buffer)) != -1 ) { baos.write(buffer, 0, len); } in.close(); String content = new String(baos.toByteArray(), \"gbk\"); // 指定 GBK 编码 return content; }} URLEncode 类encode方法： URLEncode.encode(String s, String charseName); path = path + \"?username=\" + URLEncode(name, \"utf-8\") + \"&amp;password=\" + URLEncode(pass, \"utf-8\"); HttpClient 方式提交数据HttpClient 是一个接口，而不是类。（没有人用这个，了解） GET123456789101112131415161718192021222324252627new Thread(){ public void run() { try { String path = \"http://xxx?id=\" + URLEncoder.encode(id); // 获取 httpclient 实例 DefaultHttpClient client = new DefaultHttpClient(); // 准备 get 请求，定义一个 httpget 实现 HttpGet get = new HttpGet(path); // 执行一个 get 请求 HttpResponse response = client.execute(get); // 获取服务器返回的状态码 int code = response.getStatusLine().getStatusCode(); if (code == 200) { // 获取服务器返回的数据，以流的形式 InputStream inputstream = response.getEntity().getContent(); // 把流转换成字符串 String content = StreamTools.readStream(inputStream); showToast(content); } } }} .start(); POSTEntity、BasicNameValuePair 等也都是接口 1234567891011121314151617181920212223242526String name = \"...\", pwd = \"...\";String path = \"...\";DefaultHttpClient client = new DefaulthttpClient();HttpPost post = new HttpPost(path);// 准备 parameters 集合List&lt;NameValuePair&gt; lists = new ArrayList&lt;NameValuePair&gt;();// 准备 NameValuePair，键值对数据BasicNameValuePair nameValuePair = new BasicNameValuePair(\"username\", name);BasicNameValuePair pwdValuePair = new BasicNameValuePair(\"password\", pwd);// 把 name 和 pwd 加入到集合中lists.add(nameValuePair);lists.add(pwdValuePair);// 准备 entityUrlEncodeFormEntity entity = new UrlEncodeFormEntity(parameters);// 准备 post，以实体 Entity 的形式post.setEntity(entity);HttpResponse response = client.execute(post);int code = response.getStatusLine().getStatusCode();if (code == 200) { InputStream inputStream = response.getEntity().getContent(); String content = StreamTools.readStream(inputStream); showToast(content);} asyncHttpClient 开源项目GitHub 上下载，把 com 包复制到 src 中。 GET12345678910111213141516171819202122232425String path = \"...\";AsyncHttpClient client = new AsyncHttpClient();client.get(path, new AcynchttpResponseHandler(){ // 请求成功的回调方法0 /*@Override public void onSuccess(String response) { showToast(response); }*/ // 请求成功的回调方法 @Override public onSuccess(int statusCode, Header[] headers, byte[] responseBody) { showToast(new String(responseBody, \"gbk\")); } // 请求失败的回调方法 @Override public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) { // ...code... }}); POST1234567891011121314151617181920212223242526String path = \"...\";AsyncHttpClient client = new AsyncHttpClient();// 准备请求体的内容RequestParams params = new RequestParams();params.put(\"username\", \"admin\");params.put(\"password\", \"123\");params.put(\"email\", \"my@email.com\");params.put(\"profile_picture\", new FIle(\"pic.jpg\")); // 上传文件params.put(\"profile_picture2\", someInputStream); // 上传输入流params.put(\"profile_picture\", new ByteArrayInputStream(someBytes)); // 上传字节集client.post(path, params, new AcynchttpResponseHandler() { // 请求成功的回调方法 @Override public onSuccess(int statusCode, Header[] headers, byte[] responseBody) { showToast(new String(responseBody, \"gbk\")); } // 请求失败的回调方法 @Override public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error){ // ...code... }}); 多线程下载原理分段下载 服务器没有限速的话，线程并不是越多越好 获取一部分文件，返回的状态码是206，而不是200。 RandomAccessFile 类随机读取和写入文件，使用见下方代码 代码test.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.io.*;import java.net.*;class test{ private static String path = \"http://download.dcloud.net.cn/HBuilder.9.0.1.windows.zip\"; private static int threadCount = 3; // 线程数 public static void main(String[] args) { try { URL url = new URL(path); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod(\"GET\"); conn.setConnectTimeout(5000); int code = conn.getResponseCode(); if (code == 200) { // 获取服务器文件的大小(B) int length = conn.getContentLength(); // 创建一个和下载文件一样大的文件，提前申请空间 RandomAccessFile raf = new RandomAccessFile(getFileName(path), \"rw\"); raf.setLength(length); // 算出每个线程下载的大小 int blockSize = length / threadCount; // 计算每个线程开始位置和结束位置 for (int i = 0; i &lt; threadCount; i++) { int startIndex = i * blockSize; // 开始位置 int endIndex = (i + 1) * blockSize - 1; if (i == threadCount - 1) // 最后一个线程 { endIndex = length - 1; } // 开启线程去下载 DownLoadThread dlt = new DownLoadThread(path, startIndex, endIndex, i); dlt.start(); } } } catch (Exception e) { e.printStackTrace(); } } public static String getFileName(String path) { int start = path.lastIndexOf(\"/\") + 1; return path.substring(start); }} DownLoadThread.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.io.*;import java.net.*;// 定义下载文件的线程public class DownLoadThread extends Thread{ private String path; private int startIndex; private int endIndex; private int threadId; DownLoadThread(String path, int startIndex, int endIndex, int threadId) { this.path = path; this.startIndex = startIndex; this.endIndex = endIndex; this.threadId = threadId; } @Override public void run() { try { URL url = new URL(path); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod(\"GET\"); conn.setConnectTimeout(5000); // 设置一个请求头Range，获取每个线程下载的开始位置和结束位置 conn.setRequestProperty(\"Range\", \"bytes=\" + startIndex + \"-\" + endIndex); int code = conn.getResponseCode(); // 状态码 206 表示请求部分资源成功（一部分文件） if (code == 206) { // 创建随机读写文件对象 RandomAccessFile raf = new RandomAccessFile(getFileName(path), \"rw\"); // 每个线程从自己的位置开始写 raf.seek(startIndex); InputStream in = conn.getInputStream(); int len = -1; byte[] buffer = new byte[1024]; while ((len = in.read()) != -1) { raf.write(buffer, 0, len); } System.out.println(\"下载完毕\"); raf.close(); } } catch (Exception e) { e.printStackTrace(); } } // 获取文件名 public static String getFileName(String path) { int start = path.lastIndexOf(\"/\")+1; return path.substring(start); }} 断点续传下载过程中保存每个线程的下载位置到文件 保存的间隔越短（缓冲区越小）则越卡顿 12// 正在运行的线程数runningThread = threadCount; 下载类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/*...code...*/// 读取上次断开的位置继续下载File file = new File(threadId + \".txt\");if (file.exists() &amp;&amp; file.length() &gt; 0){ FileInputStream fis = new FileInputStream(file); BufferedReader bufr = new BufferedReader(new InputStream(fis)); String lastPositions = bufr.readLine(); // 读出来的是上次下载的位置 int lastPosition = Integer.parseInt(lastPositions); // 改变一下 startIndex 的位置 startIndex = lastPosition; fis.close();}if (code == 206){ // 创建随机读写文件对象 RandomAccessFile raf = new RandomAccessFile(\"file.exe\", \"rw\"); // 每个线程从自己的位置开始写 raf.seek(startIndex); InputStream in = conn.getInputStream(); int len = -1; byte[] buffer = new byte[1024 * 1024]; // 缓冲区每 1M 保存一次文件 int total = 0; // 当前线程已下载的大小 while ((len = in.read) != -1) { raf.write(buffer, 0, len); // 保存下载位置到文件 total += len; int currentThreadPosition = startIndex + total; RandomAccessFile raff = new RandomAccessFile(threadId + \".txt\", \"rwd\"); // rwd 同步写入到底层文件中 raff.write(String.valueOf(currentThreadPosition).getBytes()); raff.close(); } raf.close(); System.out.println(\"下载完毕\"); // 下载完毕后判断并删除保存下载位置的文件 synchronized (DownLoadThread.class) // 加锁？ { runningThread--; if (runningThread == 0) // 全部下载完毕 { for (int i = 0; i &lt; threadCount; i++) { File file = new File(threadId + \".txt\") file.delete(); // 删除文件 } } }} 安卓动态添加进度条进度条布局 12345&lt;progressBar xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/progressBar1\" style=\"?android:attr/progressBarStyleHorizontal android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt; 动态添加进度条 1234567891011121314List&lt;ProgressBar&gt; pbLists = new ArrayList&lt;ProgressBar&gt;(); // 进度条集合，用来取对象barLayout = (LinearLayout) findViewById(R.id.barLayout); // 进度条线性布局barLayout.removeAllViews(); // 先移除上次的进度条pbLists.clear(); // 清除上次的进度条实例// 添加线程数量的进度条int threadCount = Integer.parseInt(threadCount);for (int i = 0; i &lt; threadCount; i++){ View pbView = View.inflate(getApplicationContext(), R.id.barItem, null) pbLists.add(pbView); barLayout.addView(pbView);} 安卓多线程下载与进度相关的控件都可以在子线程更新UI 123456789101112131415161718192021222324252627282930private int PbMax; // 线程下载的最大值private int pbPos; // 当前线程的进度pbMax = endIndex - startIndex;pbPos = 0; // 进度条当前进度，如果中断过，则要从上次的位置开始// 每个线程设置对应进度条的进度if (code == 206){ // 创建随机读写文件对象 RandomAccessFile raf = new RandomAccessFile(getFileName(path), \"rw\"); // 每个线程从自己的位置开始写 raf.seek(startIndex); InputStream in = conn.getInputStream(); int len = -1; byte[] buffer = new byte[1024]; while ((len = in.read()) != -1) { raf.write(buffer, 0, len); } System.out.println(\"下载完毕\"); raf.close(); // 设置进度条进度（注：进度条可以直接在子线程中更新UI） pbLists.get(threadId).setMax(pbMax); pbLists.get(threadId).setProgress(pbPos);} 多线程下载开源项目xUtils 123456789101112131415161718192021222324252627282930// 点击按钮开始下载public void click(View v){ String path = \"...\"; HttpUtils http = new HttpUtils(); //下载路径, 目标路径, 是否支持断点续传, 回调); http.download(path, \"/mnt/sdcard/haha.exe\", true, new RequstCallBack&lt;File&gt;() { // 下载成功 @Override public void onSucess(RequestInfo&lt;File&gt; responseInfo) { Toast.makeText(getApplicationContext(), \"下载成功\", 1).show(); } // 下载失败 public void onFailure(HttpException error, String msg) { ; } // 下载进度 @Override public void onLoading(long total, long current, boolean isUploading) { pb.setMax((int) total); pb.setProgress((int) current); } })} Android 四大组件Activity创建新的 Activity创建新的 Class 继承 Activity 新的 Activity 12345678910public class TestActivity extends Activity{ @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // 加载布局 setContentView(R.layout.activity_test) }} 清单文件 AndroidManifest 12345678910111213141516171819202122232425262728293031&lt;!-- 代表当前应用 --&gt;&lt;!-- 两个 Activity 入口 --&gt;&lt;application ... &gt; &lt;activity android:name=\"com.包名.MainActivity\" android:label=\"第一个页面\" android:icon=\"@drawable/icon1\" /&gt; &lt;!-- main 主入口 --&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;!-- 配置入口 --&gt; &lt;activity android:name=\"com.包名.TestActivity\" /&gt; android:label=\"第二个页面\" android:icon=\"@drawable/icon2\" /&gt; &lt;!-- main 主入口 --&gt; &lt;intent-filter&gt; &lt;!-- 第二个入口（要 .MAIN 和 .LAUNCHER） --&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;!-- 如果是 .category.DEFAULT 则不会有入口 --&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt;&lt;/application&gt; Android 四大组件都要在清单文件里面配置 如果要多个入口（启动图标），则 intent-filter 必须要 .MAIN 和 .LAUNCHER。（一般就一个启动图标） Activity 下的 label 和 icon 属性可以和 Application 节点的属性不一样默认使用 Application 节点下的属性。 隐式意图12345678// 创建 意图对象Intent intent = new Intent();// 设置 跳转的动作intent.setAction(\"com.包名.活动名\");// 设置 categoryintent.addCategory(\"android.intent.category.DEFALT\");// 开启 ActivitystartActivity(intent); 意图过滤器12345&lt;intent-filter&gt; &lt;!-- 传递的数据 、 约束 --&gt; &lt;data android:mimetype=\"audio/mp4\" android:scheme=\"wxy\"/&gt;&lt;/intent-filter&gt; 可以配置多个 filter，只要匹配到完整的一个（setData 和 .setType）就行mimetype 和 scheme 都可以不写 mimetypeJava 代码中设置 Date 也为 wxy（只要和约束相同就行）intent.setData(Uri.parse(\"wxy:\" + 110));不设置约束，其实效果相同。 scheme设置 setType 会自动把 setData 方法的数据清除。反之亦然……intent.setType(\"audio/mp4\");谷歌自定义了很多数据类型，开发者也可以用自己定义的例如aa/bb。 两个要一起使用时，可以用下面的方法：intent.setDataAndType(data, type);例如：intent.setDataAndType(Uri.parse(\"wxy:\" + 110), \"audio/mp4\"); ####显式意图 通过制定具体的包名和类名来切换窗口 1234567public void click(View v){ Intent intent = new Intent(); //参数：packageName 包名, className 类名 intent.setClassName(\"com.wxy.hello\", \"com.wxy.hello.HelloActivity2\"); startActivity(intent);} 12// 更简洁的 切换窗口startActivity(new Intent(this, HelloActivity.class)); 开启自己应用的界面用显示意图，开启其他应用用隐式意图。 显式意图更加安全一些（仅自己能调用） ####传递数据切换 Activity 时传递数据 获取传递过来的数据 Uri getIntent(); 1Uri data = intent.getData(); // 例如 wxy:110 Intent.putExtra(name, value); value 支持Android八大类型的数据 存入数据 123Intent intent = new Intent(this, SecondActivity.class);intent.putExtra(\"name\", \"hhh\");intent.putExtra(\"sex\", 0); 取出数据 1234Intent intent = getIntent(); // 获取开启此Activity放入意图对象String name = intent.getStringExtra(\"name\");int sex = intent.getIntExtra(\"sex\", 0); // 参数二为默认值，可省textView.setTex(name); ####人品计算器 12345678910111213byte[] bytes = NULL;int total = 0;if (sex == 1) bytes = name.getBytes(\"GBK\");else bytes = name.getBytes(\"UTF-8\");for (byte b : bytes) { // 有多少个1 int number = b &amp; 0xff; // 1111 1111 total += number;}int score = Math.abs(total) % 100;if (score &gt; 90) { toast(\"您的人品爆棚！\"); break;} #####RadioGroup 12345&lt;RadioGroup ... &gt; &lt;Radio ... /&gt; &lt;Radio android:checked=\"checked\" /&gt;&lt;/RadioGroup&gt; 123RadioGroup rg = (RadioGroup) findViewByUd(R.id.rg);int res = rg.getCheckedRadioButtonId(); // 获取选中的单选框ID(可不选)if (res == NULL) { ; } 短信发送器制作一个能够发送短信模板的小应用。 ####简单的 ListView 1234String msgs[] = {\"短信1\", \"短信2\", \"短信3\", ...};ListView lv = (ListView) findViewById(R.id.lv);ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this, R.layout.item, msg); // layout/item 里面就只有一个 TextViewlv.setAdapter(adapter); ####设置 ListView 事件 12345678910111213141516171819// 给 ListView 设置事件lv.setonItemClickListener(new onItemClickListener(){ // 点击列表发送短信 // 参数一：&lt;?&gt;ListView；参数二：每个条目（这里是TextView） @Override public void onItemClickListener(AdapterView&lt;?&gt; parent, View view, int position, long id) { // 条目内容 String content = msgs[position]; // 跳转到短信发送页面 Intent intent = new Intent(); intent.setAction(\"android.intent.action.SEND\"); intent.addCategory(\"android.intent.category.DEFAULT\"); intent.setType(\"text/plain\"); intent.putExtra(\"sms_body\", content); // 设置短信内容 startActivity(intent); } }); ####请求码和结果码 自定义短信模板页面并插入 123456789101112131415161718192021222324252627// 跳转到发送短信模板页面public void addTemplate(View v){ Intent intent = new Intent(this, SmsActivity.class); startActivityForResult(intent, 1); // 请求码 = 2}// 当开启的 Activity 页面关闭的时候，调用这个方法@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data){ if (requestCode == 1) // 请求码 { ; // 代表请求的是哪个页面的数据 } if (resultCode == 10) // 结果码 { // 说明数据是从短信模板页面返回的 String msg = data.getStringExtra(\"msg\"); edit_num.setText(\"msg\"); } super.onActivityResult(requestCode, resultCode, data);} 选择模板页面 12345678910111213lv.setOnItemClickListener(newOnItemClickListener(){ @Overridepublic void onItemClickListener(AdapterView&lt;?&gt; parent, View view, int position, long id) { String msg = msgs.get(position).getPhone(); Intent intent - new Intent(); intent.putExtra(\"msg\", msg); setResult(10, intent); // 返回的结果码 = 10 // 关闭当前页面 finish(); }}) ####发送短信 SmsManager 类添加权限 android.permission.SEND_SMS 1234String number, content;SmsManager sm = SmsManager.getDefault(); // 静态方法// 参数二：服务中心号码，NULL 则使用默认；参数四：广播(成功失败的结果)sm.sendTextMessage(number, null, content, NULL); 注：这个API有限制，英文70字符，中文140。太多不会发送，需要划分成多个片段。 ###Activity 生命周期 onCreate​ onResuart​ onStart 变成可视界面时​ onResume 允许获取焦点（按钮能点击等）​ onPause 不允许获取焦点​ onStop 界面不可见时onDestroy 打开其他 Activity：onPause onStart返回当前 Activity：onRestart onStart onResume ####设置横屏横竖屏切换时，会Destroy再Create。竖屏：portrait横屏：landscape&lt;activity android:screenOrientation=\"portrait\"&gt; ###任务栈 任务栈和 Activity 有关 进栈：打开一个 Activity出栈：关闭一个 Activity操作的 Activity 永远是栈顶的 任务栈是用来维护操作体验的 应用程序退出完是任务栈清空了 一般情况一个应用程序对应一个任务栈 ###Activity 的四种启动模式 &lt;activity android:launchMode=\"stander\" ... &gt; stander 每创建一次 Activity 就一个任务栈 singletop 若Activity在栈顶则复用原Activity，否则创建Activity singletask 一个 Activity 单一任务栈。浏览器。 singleinstance 有专属的任务栈，仅一个实例，不会重复创建。任务栈和任务栈之间再形成顺序。来电页面。 广播广播接收类名一般是 xxReceiver 格式退出程序后，进程还在，广播接受器还能收到广播 IP拨号器（加特定前缀能省话费） 权限：android.permission.OUTGONG_CALL 清单文件配置 123456789&lt;application&gt; ...... &lt;receiver android:name=\"com.包名.OutGoingCallReceiver\"&gt; &lt;intent-filter&gt; &lt;!-- 要接受的广播频道 --&gt; &lt;action android:name=\"android.intent.action.NEW_OUTGONG_CALL\" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt;&lt;/application&gt; 定义广播接受者（java类）若没有界面的话，可以不用编辑 MainActivity 1234567891011121314151617181920import android.content.BroadcastReceiver;public class OutGoingCallReceiver extends BroadcastReceiver { // 当进行外拨电话的时候调用 @Override public void onReceiver(Context context, Intent intent) { // 使用参数里的上下文来读取设置 SharedPreferences sp = context.getSharedPreferences(\"config\", 0); String IPnumber = sp.getString(\"IPnumber\", \"\"); // 获取当前拨打的电话号码 String number = getResultData(); // 判断当前号码是否是长途，在当前的号码前面加上前缀 if (currentNumber.startsWith(\"0\")) { setResultData(IPnumber + number); // 一般是能变更的前缀 } }} 主函数 设置用户手动输入的 IPnumber 1234567public void click(View v) { EditText et = (EditText) findViewById(R.id.et); String IPnumber = et.getText().toString().trim(); // 用户编辑的前缀好吗 SharedPreferences sp = getSharedPreferences(\"cinfig\", 0); sp.edit().putString(\"IPnumber\", IPnumber).commit(); Toast.makeText(getApplicationContext, \"保存成功\", 1).show();} SD卡状态的监听12345678&lt;receiver android:name=\"包名.AdcardStateReceiver\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MEDIA_MOUNTED\" /&gt; &lt;action android:name=\"android.intent.action.MEDIA_UNMOUNTED\" /&gt; &lt;!-- 必须指定一个叫 file 的约束，否则不生效 --&gt; &lt;data android:scheme=\"file\" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 小细节：SD卡里面存的数据类型是 file，所以需要 file 约束。另一个要配置data的广播事件是 安装应用 12345678910111213141516import android.content.BroadcastReceiver;public class SdcardStateReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { // 获取当前广播的事件类型 Strning action = intent.getAction(); if (\"android.intent.action.MEDIA_MOUNTED\".equals(action)) { // SD卡挂在 } else if (\"android.intent-filter.action.MEDIA_UNMOUNTED\".equals(action)) { // SD卡卸载 } }} 短信监听器权限：android.permission.RECEIVE_SMS 1&lt;action android:name=\"android.provider.Telephony.SMS_RECEIVED\" /&gt; 123456789101112@Overridepublic void onReceive(Context context, Intent intent) { // 获取发送的号码和内容 Object[] objects = (Objectp[]) intent.getExtras().get(\"pdus\"); for (Object obj : objects) { // 获取 smsmessage 实例：这是调用静态方法而不是 new 出来的 SmsMessage smsMessage = SmsMessage.createFromPdu((byte[]) boj); // 获取短信内容 String messageBody = smsMessage.getMessageBody(); String address = smsMessage.getOriginatingAddress(); }} 卸载安装实例这个也要配置 data 1234&lt;action android:name=\"android.intent.action.PACKAGE_INSTALL\" /&gt;&lt;action android:name=\"android.intent.action.PACKAGE_ADDED\" /&gt;&lt;action android:name=\"android.intent.action.PACKAGE_REMOVED\" /&gt;&lt;data android.scheme=\"package\" /&gt; 1234567891011121314public void onReceive(Context context, Intent intent) { String action = intent.getAction(); if (\"android.intent.action.PACKAGE_INSTALL\".equals(action)) { // 应用安装（预留的字符串，并没有什么用） } else if (\"android.intent.action.PACKAGE_ADDED\".equals(action)) { // 应用安装了 String packageName = intent.getData(); // 应用包名 } else if (\"android.intent.action.PACKAGE_REMOVED\".equals(action)) { // 应用卸载了 }} 手机重启实例不能在广播接收者里面开启 activity需要添加一个任务栈的标记 权限：anroid.permission.RECEIVE_BOOT_COMPLETED 1&lt;action android:name=\"android.intent.action.BOOT_COMPLETED\" /&gt; 12345678910111213public class BootReceiver extends BroadcastReceiver { // 当手机重新启动的时候调用 @Override public void onReceive(Context context, Intent intent) { // 在这个方法里面开启 activity Intent intent2 = new Intent(context, MainActivity.class); intent2.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); // 开启 activity context.startActivity(intent2); }} 12345// Activity 里屏蔽返回键@Overridepublic void onBackPressed() { ; // 覆盖父类返回方法} 广播类型有序广播：按照一定的优先级进行接收，在接收的过程中可以被修改或者终止 无序广播：不可以被修改或者终止 特殊广播：不能在清单文件中注册，需要动态注册 无序广播发送无序广播 123456789public void click(View v) { Intent intent = new Intent(); intent.setAction(\"com.HHH\"); intent.putExtra(\"name\", \"HHH\"); sendBroadcast(intent); // 发送无序广播} 接收无序广播 1&lt;action name=\"com.HHH\" /&gt; 1234// 当接收到自定义广播public onReceive(Context context, Intent intent) { String context = intent.getStringExtra(\"name\"); // 广播内容} 有序广播发送有序广播 12// 参数：Intent, 权限，最终的receiver，scheduler，初始码，初始化数据，额外的数据sendOrderedBroadcast(intent, null, null, null, 1, \"这是广播\", null); 123456789101112131415161718192021222324&lt;application ... &gt; &lt;activity&gt; ... &lt;/activity&gt; &lt;!-- 配置广播接受优先级 范围 -1000~1000 --&gt; &lt;receiver android:name=\"包名.FirstReceiver\"&gt; &lt;intent-filter android:priority=\"1000\"&gt; &lt;action android:name=\"myReceiver\" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;receiver android:name=\"包名.SecondReceiver\"&gt; &lt;intent-filter android:priority=\"0\"&gt; &lt;action android:name=\"myReceiver\" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;receiver android:name=\"包名.LastReceiver\"&gt; &lt;intent-filter android:priority=\"-200\"&gt; &lt;action android:name=\"myReceiver\" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt;&lt;/application&gt; 按顺序接收广播 123456789101112131415161718192021public class FirstReceiver extends BroadcastReceiver { @Override public onReceive(Context context, Intent intent) { String content = getResultData(); setResultData(\"哈哈哈\"); // 修改广播内容，后面接收到的就是这个内容 }}public class SecondReceiver extends BroadcastReceiver { @Override public onReceive(Context context, Intent intent) { abortBroadcast(); // 直接终止广播，下面接收不到了 }}public class LastReceiver extends BroadcastReceiver { @Override public onReceive(Context context, Intent intent) { }} 特殊广播接收者操作特别频繁的广播事件，比如 屏幕的锁屏和解锁、电池电量的变化，这种事件的广播在清单文件里面是注册无效的，可以动态注册广播 注册广播接受者的两种方式： 在清单文件通过 receiver tag 节点 动态注册：代码方式（即清单方式注册无效，并且无需注册） 类似于android.intent.action.SCREEN_ON 或 android.intent.action.SCREEN_OFF 这种，注册是无效的 12345678910111213141516171819202122232425262728293031323334public class MainActivity extends Activity { // 动态的去注册广播接收者，设为全局方便销毁 ScreenReceiver screenreceiver = new ScreenReceiver(); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 创建 Intent-Filter 对象 IntentFilter filter = new IntentFilter(); // 动态注册广播（可以添加多个） filter.addAction(\"android.intent.action.SCREEN_OFF\"); filter.addAction(\"android.intent.action.SCREEN_ON\"); registerReceiver(screenReceiver, filter); } @Override protected void onDestory() { // activity 销毁时要取消注册广播 unregisterReceiver(screenreceiver); }}public class ScreenReceiver extends BroadcastReceiver { @Override public onReceive(Context context, Intent intent) { } 样式和主题样式样式一般作用在控件上 style 文件 12345&lt;style name=\"myStyle\"&gt; &lt;item name=\"android:layout_height\"&gt;match_parent&lt;/item&gt; &lt;item name=\"android:textSize\"&gt;20SP&lt;/item&gt; &lt;item name=\"android:textColor\"&gt;#ff000&lt;/item&gt;&lt;/style&gt; layout 文件 123&lt;TextView style=\"@style/mystyle\" android:text=\"哈哈哈\" /&gt; 主题样式一般作用在 Activity 或 Application 节点下 style 文件 123&lt;style name=\"myStyle\"&gt; &lt;item name=\"android:background\"&gt;#ff0000&lt;/item&gt;&lt;/style&gt; manifest 文件 12&lt;application android:theme=\"@style/mystyle\"&gt; 区别两者定义的方式是一样的。 样式的作用范围比较窄，主题比较大。 不一定要在 style.xml 上定义，其他类似 txt 上也行。 Android 国际化国际化：i18n 类似于android:text=\"你好世界\"这种硬编码的字符串，一般都是放到string.xml里面 多国语言文件：res目录下的values-语言代码文件夹里面的string.xml （固定写法）语言代码：en英语，zh中文简体，zh-Hant中文繁体……例如：/res/values-zh/string.xml 表示中文资源 对话框常见对话框 Toast 普通对话框 单选对话框 多选对话框 进度条对话框 普通对话框1234567891011121314151617// 通过 builder 构建器来构造AlertDialog.Builder builder = new Builder(this); // 不能用 getApplicationContext()builder.setTitle(\"提示\");builder.setMessage(\"这里是提示内容\");builder.setPositiveButton(\"确定\", new OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { System.out.println(\"点击了确定按钮\"); } });builder.setNegativeButton(\"取消\", new OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { System.out.println(\"点击了取消按钮\"); } });builder.show(); // 一定要 show 出来 如果报错，则把new OnClickListener(){} 改成new DialogInterface.OnClickListener(){} 两种上下文的区别 this （即：类名.this） getApplicationContext() 返回的是 Context 对象 getApplicationContext() 获取的是整个应用上下文，this 是其子类，子类有的父类不一定有。 this 多了token（令牌）。 就对话框来说，必须要用 this，否则会报错。 单选对话框12345678910111213AlertDialog.Builder builder = new Builder(this);builder.setTitle(\"请选择\");String items[] = { \"item1\", \"item2\"};// 参数二：checked 选中索引，-1 为没有选中builder.setSingleChoiceItems(items, -1, new OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { System.out.println(\"您选择了\" + items[which]); // 关闭对话框：点一下就关掉，不需要确定按钮 dialog.dismiss(); } }); builder.show(); 多选对话框注意：listener 是OnMultiChoiceClickListener 1234567891011121314151617181920212223242526272829AlertDialog.Builder builder = new Builder(this);String items[] = {\"item1\", \"item2\", \"item3\"};Boolean[] checkedItems = {true, false, true};builder.setMultiChoiceItems(items, checkedItems, new OnMultiChoiceClickListener() { @Override public void onClick(DialogInterface dialog, int which, boolean isChecked) { System.out.println(\"您点击了\" + items[which]); // 关闭对话框：点一下就关掉，不需要确定按钮 dialog.dismiss(); } });builder.setPositiveButton(\"确定\", new OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { // 把选中的条目数据取出来 StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; checkedItems.length; i++) { if (checkedItems[i]) { sb.append(items[i] + \" \"); } } Toast.makeText(getApplicationContext(), sb.toString(), 1).show(); // 关闭对话框 dialog.dismiss(); } });builder.show(); 进度条对话框12345ProgressDialog dialog = new ProgressDialog(this);dialog.setTitle(\"正在加载中\");// 设置进度条样式dialog.setProgressStyle(style);dialog.show(); style 属性有： ProgressDialog.STYLE_HORIZONTAL 横向进度条，0% 和进度相关的控件，都能在子线程中更新UI 1234567891011121314151617181920212223242526ProgressDialog dialog = new ProgressDialog(this);dialog.setTitle(\"正在加载中\");// 设置进度条样式dialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);dialog.show();// 创建一个子线程new Thread() { public void run() { // 设置最大值 dialog.setMax(100); // 耗时操作，设置进度 for (int i = 0; i &lt; 100; i++) { // 睡眠 50 ms SystemClock.sleep(50); // 设置当前进度 dialog.setProgress(i); } // 关闭对话框 dialog.dismiss(); }}.start(); 帧动画Android 中动画 帧动画 View 动画（补间动画） 属性动画 帧动画：加载一系列的图片资源 xml 文件在res/drawable/directory目录下，标签是&lt;animation-list&gt; res/drawable/myanim.xml 文件 1234567891011121314151617&lt;animation-list xmlns:android=\"...\" androidLoneshot=\"true\"&gt; &lt;!-- true 表示只执行一次，false 循环播放 --&gt; &lt;item android:drawable=\"@drawable/pic_1\" android:duration=\"200\" /&gt; &lt;item android:drawable=\"@drawable/pic_2\" android:duration=\"200\" /&gt; &lt;item android:drawable=\"@drawable/pic_3\" android:duration=\"200\" /&gt; &lt;item android:drawable=\"@drawable/pic_4\" android:duration=\"200\" /&gt;&lt;/animation-list&gt; java文件 12345678910ImageView rocketImage = (ImageView) findViewById(R.id.rocketImage);// 设置背景资源rocketImage.setBackgroundResource(R.drawable.myanim);// 获取 AnimationDrawable 类型AnimationDrawable rocketAnimation = (AnimationDrawable) rocketImage.getBackground();// 开启动画rocketAnimation.start(); 兼容低版本 2.3 因为数据并未准备好，这个 API 是 2.3 之后出的 1234567891011121314151617ImageView rocketImage = (ImageView) findViewById(R.id.rocketImage);// 设置背景资源rocketImage.setBackgroundResource(R.drawable.myanim);// 兼容低版本的写法new Thread(){ public void run() { SystemClock.sleep(100); // 获取 AnimationDrawable 类型 AnimationDrawable rocketAnimation = (AnimationDrawable) rocketImage.getBackground(); // 开启动画 rocketAnimation.start(); }}.start(); 服务服务在后台运行，没有界面 Service extends CpntextWrapper implements ... 进程 前台进程 可视进程 服务进程 后台进程 空进程 start方式开启服务清单文件 1234&lt;application ...&gt; &lt;activity ...&gt; ... &lt;/activity&gt; &lt;service android:name=\"包名.服务名\"&gt;&lt;/service&gt;&lt;/application&gt; MyService.java 12345678910111213141516171819202122232425public class MyService extends Service { @Override public Ibinder onBind(Intent intent) { return null; } // 服务第一次创建的时候调用 @Override public void onCreate() { super.onCreate(); } // 服务运行 @Override public int onStartCommand(Intent intent, int flags, int startId) { return super.StartCommand(intent, flags, startId); } // 服务销毁 @Override public void onDestroy() { super.onDestroy; }} MainActivity.java 12345// 开启服务，一直后台运行直到用户手动关闭startService(new Intent(this, MyService.class));// 结束服务stopService(new Intent(this, MyService.class)); start方式开启服务的特点 定义四大组件的方式是一样的 定义一个类继承Service 第一次开启服务，会执行 onCreate 和 onStart 方案 第二次开启服务，会执行 onStart 方法 服务一定开启，就会长期后台运行，直到用户手动停止 电话监听器 定义一个服务，开启服务。（记得在清单文件中配置服务） 在服务的 onCreate 里面获取 TelephonyManager 注册电话的监听 定义一个类用来判断电话的状态 TelephoneManager 监视电话的状态的改变 权限：&lt;uses-permission android:name=\"android.permission.READ_PHONE_STATE\" /&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class PhoneService extends Service { @Override Ibinder onBind(Intent intent) { return null; } @Override public void onCreate() { // 获取 telephonemanager 的实例 TelephonyManager tm = (TelephonyManager)getSystemService(TELEPHONY_SERVICE); // 注册电话的监听 tm.listen(new MyPhoneStateListener(), PhoneStateListener.LISTEN_CALL_STAT) super.onCreate(); } @Override public void onDestroy() { super.onDestroy(); } private class MyPhoneStateListener extends PhoneStateListener { // 当电话设备状态发生改变的时候调用 @Override public void onCallStateChanged(int state, String incomingNumber) { // 具体判断一下电话的状态 switch (state) { case TelephonyManager.CALL_STATE_IDLE: // 空闲 // 停止录音 break; case TelephonyManager.CALL_STATE_OFFHOOK: // 接听 // 开始录音 break; case TelephonyManager.CALL_STATE_RINGING: // 响铃 // 准备一个录音机 break; } } } {}} 录音机录音需要权限：&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt;&lt;uses-permission android:name=\"android.permission.RECORD_AUDIO\" /&gt; 1234567891011121314151617181920212223242526272829// 创建实例，全局MediaRecorder recorder = new MediaRecorder();// 设置音频来源（麦克风MIC、外置声音VOICE_CALL)recorder.setAudioSource(MediaRecorder.AudioSource.MIC); // 外国违法// 设置输出格式 3GP(THREE_GPP)、MPEG_4 等recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);// 设置音频编码方式recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);// 设置存放路径recorder.setOutputFile(\"/mnt/sdcard/luyin.3gp\");// 准备录try { recorder.prepare();}// 开始录recorder.start();// 停止录if (recorder != null){ recorder.stop(); recorder.reset(); recorder.release();} 使用服务注册特殊的广播接收者 定义广播接收者 写个服务用来注册广播接收者 在MainActivity里面开启服务 一定要记得配置服务 MainActivity.java 1234onCreate() { Intent intent = newe Intent(this, ScreenService.class); startService(intent);} ScreenService.java 1234567891011121314151617181920// 动态注册和销毁广播private ScreenReceiver receiver = new ScreenReceiver();public void onCreate() { // 服务创建时注册广播接收者 IntentFilter filter = new IntentFilter(); filter.addAction(\"android.intent.action.SCREEN_OFF\"); filter.addAction(\"android.intent.action.SCREEN_ON\"); registerReceiver(receiver, filter) super.onCreate();}onDestroy() { // 服务销毁的时候取消广播接收者 unregisterReceiver(receiver); super.onDestroy();} ScreenReceiver.java 12345678910111213public class ScreenReceiver extends BroadcastReceiver{ @Override public void onReceive(Context context, Intent intent) { // 获取当前的事件类型 String acation = intent.getAction(); if (\"android.intent.action.SCREEN_OFF\".equals(action)) ; // 锁屏 else if (\"android.intent.action.SCREEN_ON\".equals(action)) ; // 解锁 }} bind 方式开启服务bindService(service, conn, flags); 点击按钮绑定服务 MainActivity.java 1234567891011121314151617181920212223242526272829303132MyConn conn;public void click(View v){ // 或者放到 onCreate 方法里面 Intent intent = new Intent(this, MyService.class); conn = new MyConn(); bindService(intent, conn, BIND_AUTI_CREATE);// 只能绑定一次}// 定义一个类，用来监视服务的状态private void MyConn extends ServiceConnection{ // 当服务连接成功 @Override public void onServiceConnected(ComponentName name, IBinder serviec) { ; } // 失去连接 @Override public void onServiceDisconnected(ComponentName name) { ; }}// 服务和活动绑定，销毁的时候必须手动解绑（同样不可以多次解绑）protected void onDestroy() { unbindService(conn); super.onDestroy();} MyService.java 123456// 当绑定服务的时候public IBinder onBinder(Intent intent) { // 当这个方法返回值为null的时候，onServiceConnected方法一不执行的 // return null;} bind方法开启服务的特点 点击按钮（或执行操作）后，会此项服务的onCreate方法和onBind方法 当onBind方法返回null的时候，onServiceConnected方法是不执行的 第二次点击按钮，服务没有响应 activity和service之间，不求同时生，但求同时死…… 服务多次解绑会报异常 设置页面里面不能找到bind方式开启的服务，相当于隐形的服务 为什么要引入 bindService在 Activity 里面调用 Service 的方法 Binder 是一个接口。 MyService.java 12345678910111213141516@Overridepublic IBinder onbind(Intent intent) { return new MyBinder;}// 要调用的方法public void f() { ;}public class MyBinder extends Binder() { public void callF() { // 调用 f 的方法 f(); }} MainActivity.java 123456789101112131415161718192021222324252627282930313233343536MyConn conn;private MyBinder myBinder; // （中间对象）public void onCreate(...){ Intent intent = new Intent(this, MyService.class); conn = new MyConn(); bindService(intent, conn, BIND_AUTI_CREATE);// 只能绑定一次}// 定义一个类，用来监视服务的状态private void MyConn extends ServiceConnection{ // 当服务连接成功 @Override public void onServiceConnected(ComponentName name, IBinder serviec) { myBinder = (MyBinder) service; // 拿到中间对象，从而可以调用服务里的某个方法 } // 失去连接 @Override public void onServiceDisconnected(ComponentName name) { ; }}public void click() { myBinder.callF(); // 间接调用服务的方法}// 服务和活动绑定，销毁的时候必须手动解绑（同样不可以多次解绑）protected void onDestroy() { unbindService(conn); super.onDestroy();} 通过接口调用服务里面的方法接口可以隐藏代码内部的细节，让程序员只暴露自己想暴露的方法 把想暴露的方法都定义在接口里面 Binder对象实现我们定义的方法 把获取到的IBinder对象转换成暴露部分方法的接口 Iservice.java （I 开头表示是一个接口） 1234public interface Iservice { // 只暴露一个 f1，没有 f2 public void callF1();} MyService.java 12345678910public void f1() { }public void f2() { }// 把 public 改成 privateprivate class MyBinder extends Binder implements Iservice { public void callF1() { } public void callF2() { }} MainActivity.java 12345678910111213141516private MyConn conn;private Iservice myBinder; // 中间对象private calss MyConn implements ServiceConnection { @Override public void onServiceConnected(ComponentName name, IBinder service) { // 类型转换成 Iservice myBinder = (Iservice) service; }}public void click(View v) { myBinder.callF1(); // 可以 // myBinder.callF2(); // 不可以} 混合方式开启服务既能在后台长期运行，又能调用服务里面的方法 start 方法开启服务 调用 bindService 获取中间对象 调用 unbindService 解绑服务 彻底退出时 stopService 百度音乐盒框架123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/* ==== MainActivity.java ==== */public void MainActivity extends Activity { private MyConn conn; private Iservice iservice; // 定义的 Binder 对象 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentVIew(R.layout.activity_main); // 混合方式开启服务 Intent intent = new Intent(this, MusicService.class); startService(intent); conn = new MyConn(); bindService(intent, conn, BIND_AUTO_CREATE); } // 监听服务状态 private class MyConn { @Override public void onServiceConnected(ComponentName name, IBinder service) { // 获取定义的 Binder 对象 iservice = (Iservice) service; } } public void playButton(View v) { // 播放音乐 iservice.callPlayMusic(); } public void pauseButton(View v) { // 暂停音乐 iservice.callPauseMusic(); } public void rePlayButton(View v) { // 继续播放音乐 iservice.callRePlayMusic(); } @Override protected void onDestroy() { unbindService(conn); super.onDestroy(); }}/* ==== MusicService.java ==== */public class MusicService extends Service { @Override public Ibinder onBind(Intent intent) { return null; } // 服务第一次创建的时候调用 @Override public void onCreate() { super.onCreate(); } // 服务运行 @Override public int onStartCommand(Intent intent, int flags, int startId) { return super.StartCommand(intent, flags, startId); } // 服务销毁 @Override public void onDestroy() { super.onDestroy; } // 播放音乐 public void playMusic() { ; } // 暂停音乐 @Override public void pauseMusic() { ; } // 继续播放 @Override public void rePlayMusic() { ; } // 在服务内部定义一个 IBinder 类的实现 private class MyBinder extends Binder implements Iservice{ @Override public void callPlayMusic() { playMusic(); } @Override public void callPauseMusic() { pauseMusic(); } @Override public void callRePlayMusic() { rePlayMusic(); } }}/* ==== Iservice.java ==== */public interface Iservice { // 想暴露的方法 public void callPlayMusic(); public void callPauseMusic(); public void callRePlayMusic();} AIDL 介绍 本地服务：运行在自己应用里面的服务 远程服务：运行在其他应用里面的服务 实现进程间通讯（IPC） AIDL：安卓接口定义语言，专门用来解决进程间通讯 每个应用都要配置服务。其中一个定义 IBinder 把 Iservice.java 文件重命名为 Iservice.aidl。 aidl 不认识 public，所以这个关键词要去掉 会自动生成Iservice.java，里面有个类叫 Stub MyBinder 直接继承 Stub 两个应用的 aidl 文件包名相同 Stub.asInterface(service); 1234567891011121314151617181920Iservice iservice;onCreate() { Intent intent = new Intent(); Intent.setAction(\"目标应用的包名\"); MyConn conn = new MyConn(); bindService(intent, conn, BIND_QUTO_CREATE);}private class MyConn implements ServiceConnection { @Override public void onServiceConnected(ComponentName name, IBinder service) { iservice = Stub.asInterface(service); }}public void click(View v) { iservice.callF();} 1234567private class MyBinder extends Stub { // ... public void callF() { f(); }} Iservice.aidl 123interface Iservice { void f();} AIDL 的应用场景类似调用支付宝进行支付 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import android.os.Bundle;public class MainActivity extends Activity { private MyCon conn; private Iservice iservice; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Intent intent = new Intent(); intent.setAction(\"com.test.pay\"); conn = new MyConn(); bindService(intent, conn, BIND_AUTO_CREATE); } public void payClick() { try { boolean result = iservice.callPay(\"abc\", \"123\", 1000); if (result) { Toast.makeText(getApplicationContext(), \"支付成功\", 1).show(); } else { Toast.makeText(getApplicationContext(), \"支付失败\", 1).show(); } } catch (RemoteException e) { e.printStackTrace(); } } private class MyConn implements ServiceConnection { @Override public void onServiceConnected(ComponentName name, IBinder service) { iservice = Stub.asInterface(service); } @Override public void onServiceDisconnected(ComponentName name) { ; } } @Override protected void onDestroy() { unbinderService(conn); super.onDestroy() }}// =================PayService.java===================import android.app.Service;public class PayService extends Service { @Override publci IBinder onBind(Intent intent) { return new MyBinder(); } // 支付的方法 publci void pay(String username, String pwd, int money) { // 检查账号密码安全性等 if (\"abc\" . equals(username) &amp;&amp; \"123\" . equals(pwd) &amp;&amp; money &lt;= 5000) { return true; } else { return false; } }}private class MyBinder extends Stub /*Binder implements Iservice*/ { @Override public boolean callPay(String username, String pwd, int money) { return pay(username, pwd, money); }}// ==============Iservice.aidl===================// 用来支付的应用也要 Iservice.aidl/*public*/ interface Iservice { /*public*/ boolean callPay(String username, String pwd, int money) { pay(); }}// ====================Manifest==================&lt;service android:name=\"com.test.pay.PayService\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.test.pay\" /&gt; &lt;/intent-filter&gt;&lt;/service&gt; 内容提供者(contentProvider)作用：在app2中读取app1的数据库(暴露私有的数据库) 使用： 建一个类，继承 contentProvider。 在清单文件中配置 添加静态代码块 暴露你想暴露的方法（增删改查） 其他应用就能用内容解析者去操作数据库 暴露方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import android.content.ContentProvider;public class MyProvider extends ContentProvider { // 定义一个 UriMather 路径匹配器 private static final UriMather sURIMather = new UriMather(UriMather.NO_MATH); private static final int QUERYSUCCESS = 0; private MyOpenHelper myOpenHelper; // 定义静态代码块，添加匹配规则 static { // sURIMather.addURI(authority/*清单文件里的自定义字符串*/, path, code/*int常量*/) // URI 路径：content://mystr/query sURIMather.addURI(\"mystr\", \"query\", QUERYSUCCESS); } @Override public boolean onCreate() { myOpenHelper = new MyOpenHelper(getContext()); return false; } @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) { int code = sURIMather.math(uri); if (code == QUERYSUCCESS) { // 路径匹配成功。不成功返回-1 // 对数据库进行查询的操作 SQLiteDatabase db = myOpenHelper.getReadableDatabase(); // db.query(table, columns/*别人能访问的列*/, selection, selectionArgs, groupBy, having, orderBy) Cursor cursor = db.query(\"info\", projection, selection, selectionArgs, null, null. sortOrder); // 注意：cursor 不能管 return cursor; } else { // 路径不匹配 throw new IlleagalArgumentException(\"路径不匹配\"); } } @Override public String getType(Uri uri) { return null; } @Override public Uri insert(Uri uri, ContentValues values) { return null; }} 123&lt;provider android:name=\"com.app1.MyProvider\" android:authorities=\"mystr\"&gt;&lt;/provider&gt; app2读取app1的数据库由于app1里面的私有数据库已经通过内容提供者的方式暴露出来了，所以app2可以直接通过内容的解析这进行访问 12345678910111213// 拿到内容的解析者// getContentResolver().query(uri, projection, selection, selectionArgs, sortOrder)Uri uri = Uri.parse(\"content://mystr/query\"); // 和app1定义的路径一样// Cursor cursor = db.query(\"info\", null, null, null, null, null, null, null);Cursor cursor = getContentResolver().query(uri, null, null, null, null);if (cursor != null &amp;&amp; cursor.getCount() &gt; 0) { while (cursor.moveToNext()) { String name = sursor.getString(1); String phone = cursor.getString(2); System.out.println(\"app2 name:\"+name+\";phone:\"+phone); }} 暴露增删改查app1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import android.content.ContentProvider;public class MyProvider extends ContentProvider { // 定义一个 UriMather 路径匹配器 private static final UriMather sURIMather = new UriMather(UriMather.NO_MATH); private static final int QUERYSUCCESS = 0; private static final int INSERTSUCCESS = 1; private static final int UPDATESUCCESS = 2; private static final int DELETESUCCESS = 3; private MyOpenHelper myOpenHelper; // 定义静态代码块，添加匹配规则 static { // sURIMather.addURI(authority/*清单文件里的自定义字符串*/, path, code/*int常量*/) // URI 路径：content://mystr/query sURIMather.addURI(\"mystr\", \"query\", QUERYSUCCESS); sURIMather.addURI(\"mystr\", \"insert\", INSERTSUCCESS); sURIMather.addURI(\"mystr\", \"update\", UPDATESUCCESS); sURIMather.addURI(\"mystr\", \"delete\", DELETESUCCESS); } @Override public boolean onCreate() { myOpenHelper = new MyOpenHelper(getContext()); return false; } @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) { int code = sURIMather.math(uri); if (code == QUERYSUCCESS) { // 路径匹配成功。不成功返回-1 // 对数据库进行查询的操作 SQLiteDatabase db = myOpenHelper.getReadableDatabase(); // db.query(table, columns/*别人能访问的列*/, selection, selectionArgs, groupBy, having, orderBy) Cursor cursor = db.query(\"info\", projection, selection, selectionArgs, null, null. sortOrder); // 注意：cursor 不能管 return cursor; } else { // 路径不匹配 throw new IlleagalArgumentException(\"路径不匹配\"); } } @Override public String getType(Uri uri) { return null; } @Override public Uri insert(Uri uri, ContentValues values) { int code = sURIMather.match(uri); if (code == INSERTSUCCESS) { // 路径匹配成功，操作数据库 SQLiteDatabase db = myOpenHelper.getReadableDatabase(); long ins = db.insert(\"info\"/*表名*/, null, values/*map&lt;String, String&gt;类型*/); // 返回插入的行数ID Uri uri2 = Uri.parse(\"插入的行号：\" + ins); return uri2; } else { // 路径不匹配 throw new IlleagalArgumentException(\"路径不匹配\"); } return null; } @Override public int delete(Uri uri, String selection, String[] selectionArgs) { int code = sURIMather.match(uri); if (code == DELETESUCCESS) { // 路径匹配成功，操作数据库 SQLiteDatabase db = myOpenHelper.getReadableDatabase(); int del = db.delete(\"info\", selection, selectionArgs); // 返回删除的行数 return del; // 返回的类型就是 int } else { // 路径不匹配 throw new IlleagalArgumentException(\"路径不匹配\"); } return null; } @Override public int delete(Uri uri, ContentValues values, String selection, String[] selectionArgs) { int code = sURIMather.match(uri); if (code == DELETESUCCESS) { // 路径匹配成功，操作数据库 SQLiteDatabase db = myOpenHelper.getReadableDatabase(); int upd = db.delete(\"info\", values, selection, selectionArgs); // 返回影响的行数 return upd; // 返回的类型就是 int } else { // 路径不匹配 throw new IlleagalArgumentException(\"路径不匹配\"); } return null; }} app2 12345678910111213141516171819202122public void toInsert() { Uri uri = Uri.parse(\"cintent://mystr/insert\"); ContentValues values = new ContentValues(); values.put(\"name\", \"123\"); values.put(\"money\", \"100\"); Uri ins = getContentResolver().insert(uri, values); System.out.println(\"insert:\"+ins);}public void toDelete() { Uri uri = Uri.parse(\"cintent://mystr/delete\"); int del = getContentResolver().insert(uri, \"name=?\", new String[]{\"asd\"}); Toast.makeText(getApplicationContext(), \"delete:\"+del, 1).show();}public void toUpdate() { Uri uri = Uri.parse(\"cintent://mystr/insert\"); ContentValues values = new ContentValues(); values.put(\"money\", \"100\"); int upd = getContentResolver().update(uri, values, \"nname=?\", new String[]{\"asd\"}); Toast.makeText(getApplicationContext(), \"update:\"+upd, 1).show();} 备份短信权限：WRITE_SMS READ_SMS READ_EXTERNAL_STORAGE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 短信数据库已经通过内容提供者暴露出来了public sms_backup() { // 获取 xml 序列化实例 XmlSerializer serializer = Xml.newSerializer(); // 设置序列化参数 File file = new File(Environment.getExternalStorageDirectory().getPath(), \"smsBackup.xml\"); FileOutputStream fos = new FileOutputStream（file); serializer.setOutput(fos, \"utf-8\"); // 开始写 xml 文档的开头 serializer.startDocument(\"utf-8\", true); { // 开始写根节点 serializer.startTag(null, \"smss\"); { Uri uri = Uri.parse(\"content://sms/\") // 不写后面的参数表示查询所有 Cursor cursor = getContentResolver().query(uri, new String[]{\"address\", \"date\", \"body\"}, null, null, null); while (cursor.moveToNext()) { String address = cursor.getString(0); String date = cursor.getString(1); String body = cursor.getString(2); // 写 sms 节点 serializer.startTag(null, \"sms\"); { // 写 address 节点 serializer.startTag(null, \"address\"); serializer.text(address); serializer.endTag(null, \"address\"); // 写 body 节点 serializer.startTag(null, \"body\"); serializer.text(body); serializer.endTag(null, \"body\"); // 写 date 节点 serializer.startTag(null, \"date\"); serializer.text(date); serializer.endTag(null, \"date\"); } serializer.endTag(null, \"sms\"); } } serializer.endTag(null, \"smss\"); } serializer.endDocument();} 插入短信通过内容提供者在短信的私有数据库中插入一条短信 权限：WRITE_SMS READ_SMS 123456Uri uri = Uri.parse(\"content://sms\");ContentValues values = new ContentValues();values.put(\"address\", \"110\");values.put(\"body\", \"报警\");values.put(\"date\", System.currentTimeMillis());getContentResolver().insert(uri, values); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.iwxyi.com/tags/学习笔记/"}]},{"title":"PHP-学习笔记","date":"2018-12-18T08:21:00.000Z","path":"2018/12/18/PHP-学习笔记/","text":"[TOC] PHP 基础教程入门输出 echo123&lt;?php echo \"Hello World!\"; ?&gt; 注释1234567&lt;?php // 这是单行注释 /*这是多行注释块* *它横跨了多行*/?&gt; 在 PHP 中，所有用户定义的函数、类和关键词（例如 if、else、echo 等等）都对大小写不敏感。在 PHP 中，所有变量都对大小写敏感。 支持中文1header(\"Content-type: text/plain\"); 库文件、或者一些class文件等只有纯php代码的文件不推荐加结束标签 但是如果和 HTML 结合，不加结束标签的话会报错（PHP无法执行HTML代码）。 变量以 $ 符号开头，其余规则同C语言PHP 没有创建变量的命令，变量会在首次为其赋值时被创建 函数之外声明的变量拥有 Global 作用域，只能在函数以外进行访问，函数内不能访问。函数内部声明的变量拥有 LOCAL 作用域，只能在函数内部进行访问。global 关键词用于访问函数内的全局变量，在（函数内部）变量前面使用 global 关键词： 12345678910&lt;?php $x=5; $y=10; function myTest() { global $x,$y; $y=$x+$y; } myTest(); echo $y; // 输出 15?&gt; 全局变量PHP 同时在名为 $GLOBALS[index] 的数组中存储了所有的全局变量。下标存有变量名。这个数组在函数内也可以访问，并能够用于直接更新全局变量。上面的例子也可以这样写： 123function myTest() { $GLOBALS['y']=$GLOBALS['x']+$GLOBALS['y'];} echo - 能够输出一个以上的字符串 print - 只能输出一个字符串，并始终返回 1 echo 是一个语言结构，有无括号均可使用：echo 或 echo() 12345$cars=array(\"Volvo\",\"BMW\",\"SAAB\");echo \"&lt;h1&gt;My car \", \"is a {$cars[0]}&lt;/h1&gt;\";print \"Hello world!&lt;br&gt;\"; 宏定义 define1define(\"username\", \"OK\"); 数据类型同C系语言（但是不用声明类型，直接使用）三种格式规定整数：十进制、十六进制（前缀是 0x）或八进制（前缀是 0）浮点数是有小数点或指数形式的数字。其余：略 PHP对象：class（类）123456789101112131415&lt;?php class Car { var $color; function Car($color=\"green\") { $this-&gt;color = $color; } function what_color() { return $this-&gt;color; } }?&gt; 可以通过把值设置为 NULL，将变量清空。 字符串strlen1echo strlen(\"Hello world!\"); //12 字符串长度 strpos1echo strpos(\"Hello world!\",\"world\"); //6 字符串检索，位置从0开始，没找到则返回false 字符串参考手册：http://www.w3school.com.cn/php/php_ref_string.asp stripos 不区分大小写寻找 注：由于strpos查找开头字符返回值为 0，且 false 的值也是 0，所以判断是否失败要用 === 1if (strpos(\"Hello\", \"h\") === false) echo \"查找失败\"; str_replace1$s = str_replace(\"原字符\", \"新字符\", $str); 正则表达式正则替换1$s = preg_replace(\"/原文本/\", \"新文本\", $str); 正则匹配123$pat = \"/待匹配文本/iU\"; // i 忽略大小写, U 禁止贪婪匹配if (preg_match($pat, 待匹配文本, $ans)) $result = format_sql(trim($ans[1])); 字符串中变量用单引号括住的输出，并没有解析字符串变量，而使用双引号括住的输出，则解析了变量了，输出变量的值。 效率问题 普遍认为，在不需要变量解析的字符串输出，用单引号速度可能会快一些。 字符串中的表达式用花括号括起来 ${$row[0]} 常量设置常量，使用 define() 函数。三个参数：变量名，值，大小写不敏感（默认false，即区分大小写） 1234&lt;?php define(\"GREETING\", \"Welcome to W3School!\"); echo GREETING;?&gt; 1var_dump(x) // 输出类型以及数值 rand() 随机数1rand(min, max); 如果没有确定 min 和 max ，rand() 将返回 0 到 RAND_MAX 之间的随机数 编码ord() 函数：字符转ASCII chr() 函数：ASCII转字符 PHP 运算符：同C系 包括==、=+-*/%、+=、&gt;=、++自增 等=== 完全相等，包括键值对的顺序相同类型相同!== 不全等!=和&lt;&gt;不等于. 串接： $txt1 = “Hello” $txt2 = $txt1 . “ world!” 现在 $txt2 包含 “Hello world!”.= 串接赋值： $txt1 = “Hello” $txt1 .= “ world!” 现在 $txt1 包含 “Hello world!” and &amp;&amp; 与or || 或xor 异或! 非 if…else… 同C系语言switch()…同C系语言（同样有case、break、default等），但是支持字符串while(), do…while, for(;;)… 同C系语言 1234&lt;?php for ($x=0; $x&lt;=10; $x++) { echo \"数字是：$x &lt;br&gt;\"; } ?&gt; foreach语句123foreach ($array as $value) { …$value…} 函数（函数名对大小写不敏感）1function 函数名($参数) { 代码; } 可选参数12function 函数名($参数=默认值) { return 返回值; }function format_input($s, $blank = 0) { } 可变参数1234567891011121314151617function seize(){ $args = func_get_args(); // 取参数列表 if (func_num_args() == 1) // 取参数数量 if (isset($_REQUEST[$args[0]])) // 第一个参数：$args[0] return format_input($_REQUEST[$args[0]], 1); else return NULL; else // 多个参数 { $num = func_num_args(); for ($i = 0; $i &lt; $num; $i++) if (!isset($_REQUEST[$args[$i]])) // 有一个参数不存在与表单中 return NULL; return 1; }} 数组三种数组类型 索引数组 - 带有数字索引的数组 关联数组 - 带有指定键的数组 多维数组 - 包含一个或多个数组的数组 1$cars=array(\"Volvo\",\"BMW\",\"SAAB\"); 1count(数组名) 数组长度 12$age=array(\"Peter\"=&gt;\"35\",\"Ben\"=&gt;\"37\",\"Joe\"=&gt;\"43\"); // 关联数组$age['Peter']=\"35\"; foreach 遍历123foreach($age as $x=&gt;$x_value) { echo \"Key=\" . $x . \", Value=\" . $x_value, \"&lt;br&gt;\";} 数组排序函数 sort() - 以升序对数组排序 rsort() - 以降序对数组排序 asort() - 根据值，以升序对关联数组进行排序 ksort() - 根据键，以升序对关联数组进行排序 arsort() - 根据值，以降序对关联数组进行排序 krsort() - 根据键，以降序对关联数组进行排序 超全局变量$GLOBALS $GLOBALS $_SERVER $_REQUEST $_POST $_GET $_FILES $_ENV $_COOKIE $_SESSION PHP 在名为 $GLOBALS[index] 的数组中存储了所有全局变量。变量的名字就是数组的键。 123456789&lt;?php $x = 75; $y = 25; function addition() { $GLOBALS['z'] = $GLOBALS['x'] + $GLOBALS['y']; } addition(); echo $z; // 100?&gt; $_SERVER保存关于报头、路径和脚本位置的信息。 1234&lt;?php echo $_SERVER['PHP_SELF']; echo \"&lt;br&gt;\"; ?&gt; ​ 元素/代码 描述 $_SERVER[‘PHP_SELF’] 返回当前执行脚本的文件名。 $_SERVER[‘GATEWAY_INTERFACE’]返回服务器使用的 CGI 规范的版本。 $_SERVER[‘SERVER_ADDR’]返回当前运行脚本所在的服务器的 IP 地址。 $_SERVER[‘SERVER_NAME’]返回当前运行脚本所在的服务器的主机名（比如 www.w3school.com.cn）。 $_SERVER[‘SERVER_SOFTWARE’]返回服务器标识字符串（比如 Apache/2.2.24）。 $_SERVER[‘SERVER_PROTOCOL’]返回请求页面时通信协议的名称和版本（例如，“HTTP/1.0”）。 $_SERVER[‘REQUEST_METHOD’]返回访问页面使用的请求方法（例如 POST）。 $_SERVER[‘REQUEST_TIME’]返回请求开始时的时间戳（例如 1577687494）。 $_SERVER[‘QUERY_STRING’]返回查询字符串，如果是通过查询字符串访问此页面。 $_SERVER[‘HTTP_ACCEPT’]返回来自当前请求的请求头。 $_SERVER[‘HTTP_ACCEPT_CHARSET’]返回来自当前请求的 Accept_Charset 头（ 例如 utf-8,ISO-8859-1） $_SERVER[‘HTTP_HOST’]返回来自当前请求的 Host 头。 $_SERVER[‘HTTP_REFERER’]返回当前页面的完整 URL（不可靠，因为不是所有用户代理都支持）。 $_SERVER[‘HTTPS’]是否通过安全 HTTP 协议查询脚本。 $_SERVER[‘REMOTE_ADDR’]返回浏览当前页面的用户的 IP 地址。 $_SERVER[‘REMOTE_HOST’]返回浏览当前页面的用户的主机名。 $_SERVER[‘REMOTE_PORT’]返回用户机器上连接到 Web 服务器所使用的端口号。 $_SERVER[‘SCRIPT_FILENAME’]返回当前执行脚本的绝对路径。 $_SERVER[‘SERVER_ADMIN’]该值指明了 Apache 服务器配置文件中的 SERVER_ADMIN 参数。 $_SERVER[‘SERVER_PORT’]Web 服务器使用的端口。默认值为 “80”。 $_SERVER[‘SERVER_SIGNATURE’]返回服务器版本和虚拟主机名。 $_SERVER[‘PATH_TRANSLATED’]当前脚本所在文件系统（非文档根目录）的基本路径。 $_SERVER[‘SCRIPT_NAME’]返回当前脚本的路径。 $_SERVER[‘SCRIPT_URI’]返回当前页面的 URI。 $_REQUEST用于收集 HTML 表单提交的数据。 例：输入name，点提交，下方出现输入的name 123456789101112&lt;html&gt; &lt;body&gt; &lt;form method=\"post\" action=\"&lt;?php echo $_SERVER['PHP_SELF'];?&gt;\" &gt; Name: &lt;input type=\"text\" name=\"fname\"&gt; &lt;input type=\"submit\"&gt; &lt;/form&gt; &lt;?php $name = $_REQUEST['fname']; //$name = $_POST['fname']; //$_POST，等效 echo $name; ?&gt;&lt;/body&gt; &lt;/html&gt; 使用isset()函数判断表单是否提交 1if(isset($_post['submit']) $_POST广泛用于收集提交 method=”post” 的 HTML 表单后的表单数据。也常用于传递变量。实例见上。 $_GET 也可用于收集提交 HTML 表单 (method=”get”) 之后的表单数据。 $_GET 也可以收集 URL 中的发送的数据。 12345678910&lt;html&gt;&lt;body&gt; &lt;a href=\"test_get.php?subject=PHP&amp;web=W3school.com.cn\"&gt; 测试 $GET&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;&lt;html&gt;&lt;body&gt; &lt;?php echo \"Study \" . $_GET['subject'] . \" at \" . $_GET['web']; ?&gt;&lt;/body&gt;&lt;/html&gt; 常用数组函数 取数组长度：count(array) 增加一个元素到结尾：array_push(array, val) 是否存在某个元素：in_array(val, array) PHP 高级教程PHP 多维数组两维数组 123456$cars = array ( array(\"Volvo\",22,18), array(\"BMW\",15,13), array(\"Saab\",5,2), array(\"Land Rover\",17,15)); 这是一个 4 行 3 列 的数组 $cars[3][2]用法：$cars[1][2] = 13 1echo $cars[0][0].\": 库存：\".$cars[0][1].\", 销量：\".$cars[0][2].\".&lt;br&gt;\"; 打印两维数组表格： 1234567891011&lt;?php for ($row = 0; $row &lt; 4; $row++) { echo \"&lt;p&gt;&lt;b&gt;Row number $row&lt;/b&gt;&lt;/p&gt;\"; echo \"&lt;ul&gt;\"; for ($col = 0; $col &lt; 3; $col++) { echo \"&lt;li&gt;\".$cars[$row][$col].\"&lt;/li&gt;\"; } echo \"&lt;/ul&gt;\"; }?&gt; PHP 日期date() 函数用于对日期或时间进行格式化 1date(format,timestamp) format 必需，规定时间戳的格式，见下面。timestamp可选，规定时间戳，默认当前时间日期。 时间戳是一种字符序列，它表示具体事件发生的日期和事件。 d - 表示月里的某天（01-31） m - 表示月（01-12） Y - 表示年（四位数） 1 - 表示周里的某天 h - 带有首位零的 12 小时小时格式 i - 带有首位零的分钟 s - 带有首位零的秒（00 -59） a - 小写的午前和午后（am 或 pm） 123echo \"今天是 \" . date(\"Y-m-d\") . \"&lt;br&gt;\";echo \"今天是 \" . date(\"l\"); // 这是小写的字母Lecho \"当前时间是 \" . date(\"h:i:sa\"); 自动版权年份1© 2010-&lt;?php echo date(\"Y\")?&gt; 请注意：date() 会返回服务器的当前日期/时间！ 获得时区默认是服务器所在地点 1date_default_timezone_set(\"Asia/Shanghai\"); mktime() 函数返回日期的 Unix 时间戳。Unix 时间戳包含 Unix 纪元（1970 年 1 月 1 日 00:00:00 GMT）与指定时间之间的【秒数】，不考虑闰秒 mktime(hour,minute,second,month,day,year) 123456&lt;?php $d=mktime(9, 12, 31, 6, 10, 2015); echo \"创建日期是 \" . date(\"Y-m-d h:i:sa\", $d);?&gt; strtotime() 函数用于把人类可读的字符串转换为 Unix 时间。 1strtotime(time,now) time：转化格式now：对比的时候（当前时间可省略） 1234&lt;?php $d=strtotime(\"10:38pm April 15 2015\"); echo \"创建日期是 \" . date(\"Y-m-d h:i:sa\", $d);?&gt; PHP 在将字符串转换为日期这方面非常聪明，所以您能够使用各种值（strtotime() 并不完美）： 123$d=strtotime(\"tomorrow\");$d=strtotime(\"next Saturday\");$d=strtotime(\"+3 Months\"); 输出七月四日之前的天数： 12345&lt;?php $d1=strtotime(\"December 31\"); $d2=ceil(($d1-time())/60/60/24); echo \"距离十二月三十一日还有：\" . $d2 .\" 天。\";?&gt; PHP Includeinclude （或 require）语句会获取指定文件中存在的所有文本/代码/标记，并【复制】到使用 include 语句的文件中。 include 和 require 是相同的，除了错误处理方面： require 会生成致命错误（E_COMPILE_ERROR）并停止脚本（必需文件） include 只生成警告（E_WARNING），并且脚本会继续（不必需文件） 用法： 1&lt;?php include 'footer.php';?&gt; 可以直接使用引用文件的变量（尽量使用安全的require，否则文件及其变量可能不存在） PHP 文件读取文件1echo readfile(\"a.txt\"); fopen() 的第一个参数包含被打开的文件名，第二个参数规定打开文件的模式。 如果 fopen() 函数未能打开指定的文件，下面的例子会生成一段消息： 12345&lt;?php $myfile = fopen(\"a.txt\", \"r\") or die(\"Unable!\"); echo fread($myfile,filesize(\"a.txt\")); fclose($myfile);?&gt; 文件会以如下模式之一打开： r 只读。文件指针在文件的开头开始。 w 只写。删除文件的内容或创建一个新的文件，如果它不存在。文件指针在文件的开头开始。 a只写。文件中的现有数据会被保留。文件指针在文件结尾开始。创建新的文件，如果文件不存在。 x创建新文件为只写。返回 FALSE 和错误，如果文件已存在。 r+读/写、文件指针在文件开头开始。 w+ 读/写。删除文件内容或创建新文件，如果它不存在。文件指针在文件开头开始。 a+读/写。文件中已有的数据会被保留。文件指针在文件结尾开始。创建新文件，如果它不存在。 x+读/写。返回 FALSE 和错误，如果文件已存在。 fread() 的第一个参数包含待读取文件的文件名，第二个参数规定待读取的最大字节数。 读取单行文件 - fgets()1echo fgets($myfile); 调用 fgets() 函数之后，文件指针会移动到下一行。 检查 End-Of-File - feof()12345678&lt;?php $myfile = fopen(\"a.txt\", \"r\") or die(\"Unable!\"); // 输出单行直到 end-of-file while(!feof($myfile)) { echo fgets($myfile) . \"&lt;br&gt;\"; } fclose($myfile);?&gt; 读取单字符 - fgetc()用法同fgets() 写入文件 - fwrite()fwrite() 的第一个参数包含要写入的文件的文件名，第二个参数是被写的字符串。 123456$myfile = fopen(\"new.txt\", \"w\") or die(\"Unable!\");$txt = \"Bill Gates\\n\";fwrite($myfile, $txt);$txt = \"Steve Jobs\\n\";fwrite($myfile, $txt);fclose($myfile); 写出的文件是这样的： 12Bill GatesSteve Jobs PHP 文件上传文件上传 网页端1234567&lt;html&gt;&lt;body&gt; &lt;form action=\"upload_file.php\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;label for=\"file\"&gt;Filename:&lt;/label&gt; &lt;input type=\"file\" name=\"file\" id=\"file\" /&gt; &lt;br /&gt; &lt;input type=\"submit\" name=\"submit\" value=\"Submit\" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; &lt;form&gt; 标签的 enctype 属性规定了在提交表单时要使用哪种内容类型。在表单需要二进制数据时，比如文件内容，请使用 “multipart/form-data”。 &lt;input&gt; 标签的 type=”file” 属性规定了应该把输入作为文件来处理。 上传脚本 服务端12345678910111213&lt;?php if ($_FILES[\"file\"][\"error\"] &gt; 0) { echo \"Error: \" . $_FILES[\"file\"][\"error\"] . \"&lt;br /&gt;\"; } else { echo \"Upload: \" . $_FILES[\"file\"][\"name\"] . \"&lt;br /&gt;\"; echo \"Type: \" . $_FILES[\"file\"][\"type\"] . \"&lt;br /&gt;\"; echo \"Size: \" . ($_FILES[\"file\"][\"size\"] / 1024) . \" Kb&lt;br /&gt;\"; echo \"Stored in: \" . $_FILES[\"file\"][\"tmp_name\"]; }?&gt; 使用 PHP 的全局数组 $_FILES，第二个下标可以是 “name“, “type“, “size“, “tmp_name“ 或 “error“。 在服务器的 PHP 临时文件夹创建了一个被上传文件的临时副本，会在脚本结束时消失。拷贝到另外的位置： 123456789if (file_exists(\"upload/\" . $_FILES[\"file\"][\"name\"])){echo $_FILES[\"file\"][\"name\"] . \" already exists. \";}else{ move_uploaded_file($_FILES[\"file\"][\"tmp_name\"], \"upload/\" . $_FILES[\"file\"][\"name\"]); echo \"Stored in: \" . \"upload/\" . $_FILES[\"file\"][\"name\"];} PHP Cookiessetcookie() 函数用于设置 cookie。 注释：setcookie() 函数必须位于 标签之前。 setcookie(name, value, expire, path, domain); 一小时后过期： 123setcookie(\"user\", \"Alex Porter\", time()+3600);&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; cookie会自动URL编码、解码。为防止 URL 编码，使用 setrawcookie() $_COOKIE 变量用于取回 cookie 的值。 1echo $_COOKIE[\"user\"]; 12// A way to view all cookiesprint_r($_COOKIE); isset() 函数确认是否已设置了 cookie 123456&lt;?php if (isset($_COOKIE[\"user\"])) echo \"Welcome \" . $_COOKIE[\"user\"] . \"!&lt;br /&gt;\"; else echo \"Welcome guest!&lt;br /&gt;\";?&gt; 删除 cookie使过期日期变更为过去的时间点。 1setcookie(\"user\", \"\", time()-3600); PHP Sessionssession_start()在您把用户信息存储到 PHP session 中之前，首先必须启动会话。注释：session_start() 必须位于 标签之前： 12&lt;?php session_start(); ?&gt;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 上面的代码会向服务器注册用户的会话，以便您可以开始保存用户信息，同时会为用户会话分配一个 UID。 $_SESSION 变量存储和取回 session 变量 1234session_start();$_SESSION['views']=1;echo \"Pageviews=\". $_SESSION['views']; isset() 函数检测是否已设置 session 变量。 1234if(isset($_SESSION['views'])) $_SESSION['views']=$_SESSION['views']+1;else $_SESSION['views']=1; unset() 函数用于释放指定的 session 变量： 123&lt;?php unset($_SESSION['views']);?&gt; session_destroy() 函数彻底终结 session (清空)： 123&lt;?php session_destroy();?&gt; PHP E-mailmail() 发送邮件1mail(to,subject,message,headers,parameters) 接收者、主题、消息、[附加的标题]、[参数] 防止 email 注入（使用 PHP 过滤器）123456789101112function spamcheck($field){ $field=filter_var($field, FILTER_SANITIZE_EMAIL); if(filter_var($field, FILTER_VALIDATE_EMAIL)) return TRUE; else return FALSE;}if (spamcheck($_REQUEST['email'])==FALSE) echo \"Invalid input\"; PHP Errordie() 函数：基本的错误处理1die(\"Error&lt;br&gt;\"); 1die(); set_error_handler()：修改错误处理程序:1set_error_handler(\"customError\"); 1set_error_handler(\"customError\",E_USER_WARNING); // 加上错误级别 12345678910&lt;?php function customError($errno, $errstr) { echo \"&lt;b&gt;Error:&lt;/b&gt; [$errno] $errstr\"; } set_error_handler(\"customError\"); echo($test);?&gt; 如果异常没有被捕获，而且又没用使用 set_exception_handler() 作相应的处理的话，那么将发生一个严重的错误（致命错误），并且输出 “Uncaught Exception” （未捕获异常）的错误消息。 Try - 使用异常的函数应该位于 “try” 代码块内。如果没有触发异常，则代码将照常继续执行。但是如果异常被触发，会抛出一个异常。 Throw - 这里规定如何触发异常。每一个 “throw” 必须对应至少一个 “catch” Catch - “catch” 代码块会捕获异常，并创建一个包含异常信息的对象 创建一个自定义的 Exception 类可以使用 exception 类的方法，比如 getLine() 、 getFile() 以及 getMessage()。 123456789101112131415161718192021&lt;?phpclass customException extends Exception{ public function errorMessage() { $errorMsg = 'Error on line '.$this-&gt;getLine().' in '.$this-&gt;getFile().': &lt;b&gt;'.$this-&gt;getMessage().'&lt;/b&gt; is not a valid E-Mail address'; return $errorMsg; }}$email = \"someone@example...com\";try{ if(filter_var($email, FILTER_VALIDATE_EMAIL) === FALSE) throw new customException($email);}catch (customException $e) echo $e-&gt;errorMessage();?&gt; 设置顶层异常处理器 （Top Level Exception Handler）set_exception_handler() 函数可设置处理所有未捕获异常的用户定义函数。 12345678910&lt;?php function myException($exception) { echo \"&lt;b&gt;Exception:&lt;/b&gt; \" , $exception-&gt;getMessage(); } set_exception_handler('myException'); throw new Exception('Uncaught Exception occurred');?&gt; PHP Exception 过滤器函数和过滤器 filter_var() - 通过一个指定的过滤器来过滤单一的变量 filter_var_array() - 通过相同的或不同的过滤器来过滤多个变量 filter_input - 获取一个输入变量，并对它进行过滤 filter_input_array - 获取多个输入变量，并通过相同的或不同的过滤器对它们进行过滤 验证整数1filter_var($int, FILTER_VALIDATE_INT) Validating 过滤器 用于验证用户输入严格的格式规则（比如 URL 或 E-Mail 验证）如果成功则返回预期的类型，如果失败则返回 FALSE Sanitizing 过滤器 用于允许或禁止字符串中指定的字符无数据格式规则始终返回字符串 选项和标志用于向指定的过滤器添加额外的过滤选项。不同的过滤器有不同的选项和标志。 1234567891011121314&lt;?php $var=300; $int_options = array( \"options\"=&gt;array ( \"min_range\"=&gt;0, \"max_range\"=&gt;256 ) ); if(!filter_var($var, FILTER_VALIDATE_INT, $int_options)) echo(\"Integer is not valid\"); // 300，输出 else echo(\"Integer is valid\");?&gt; 验证表单12if (!filter_input(INPUT_GET, \"email\", FILTER_VALIDATE_EMAIL)) { echo \"E-Mail is not valid\"; } // Email不可用 通过 “GET” 方法传送的输入变量，1、检测是否存在 “GET” 类型的 “email” 输入变量2、如果存在，检测它是否是有效的邮件地址 净化输入1234if(!filter_has_var(INPUT_POST, \"url\")){ echo(\"Input type does not exist\"); }else{ $url = filter_input(INPUT_POST, \"url\", FILTER_SANITIZE_URL); } 通过 “POST” 方法传送的输入变量 (url)，1、检测是否存在 “POST” 类型的 “url” 输入变量2、如果存在此输入变量，对其进行净化（删除非法字符），并将其存储在 $url 变量中 输入变量：”http://www.W3非o法ol.com.c字符n/“，则净化后的 $url 变量：http://www.W3School.com.cn/ 过滤多个输入12345678910111213141516171819202122232425&lt;?php$filters = array ( \"name\" =&gt; array ( \"filter\"=&gt;FILTER_SANITIZE_STRING ), \"age\" =&gt; array ( \"filter\"=&gt;FILTER_VALIDATE_INT, \"options\"=&gt;array ( \"min_range\"=&gt;1, \"max_range\"=&gt;120 ) ), \"email\"=&gt; FILTER_VALIDATE_EMAIL, );$result = filter_input_array(INPUT_GET, $filters);if (!$result[\"age\"]){ echo(\"Age must be a number between 1 and 120.&lt;br /&gt;\"); }elseif(!$result[\"email\"]){ echo(\"E-Mail is not valid.&lt;br /&gt;\"); }else{ echo(\"User input is valid\"); }?&gt; 自定义数据过滤函数12345678&lt;?php function convertSpace($string) { return str_replace(\"_\", \" \", $string); } $string = \"Peter_is_a_great_guy!\"; echo filter_var($string, FILTER_CALLBACK, array(\"options\"=&gt;\"convertSpace\"));?&gt; PHP 表单 注意：在处理 PHP 表单时请关注安全！ 表单是否存在1234if (isset($_REQUEST[$s])) { }if (isset($_COOKIE[$s])) { }if (isset($_POST[$s])) { }if (isset($_GET[$s])) { } GET 和 POST者都创建数组（例如，array( key =&gt; value, key2 =&gt; value2, …)）。此数组包含键/值对，其中的键是表单控件的名称，而值是来自用户的输入数据。 1&lt;form method=\"post\" action=\"&lt;?php echo htmlspecialchars($_SERVER[\"PHP_SELF\"]);?&gt;\"&gt; 作用：$_SERVER[“PHP_SELF”] 返回当前执行脚本的文件名，将表单数据发送到页面本身 htmlspecialchars() 函数把特殊字符转换为 HTML 实体。这意味着 &lt; 和 &gt; 之类的 HTML 字符会被替换为 &lt; 和 &gt; 。这样可防止攻击者通过在表单中注入 HTML 或 JavaScript 代码（跨站点脚本攻击）对代码进行利用。 $_SERVER[“PHP_SELF”] 变量能够被黑客利用！ 假设我们的一张名为 “test_form.php” 的页面中有如下表单： 1&lt;form method=\"post\" action=\"&lt;?php echo $_SERVER[\"PHP_SELF\"];?&gt;\"&gt; URL：”http://www.example.com/test_form.php\" 上面的代码会转换为： 1&lt;form method=\"post\" action=\"test_form.php\"&gt; 如果输入URL：http://www.example.com/test_form.php/%22%3E%3Cscript%3Ealert('hacked')%3C/script%3E 在这种情况下，上面的代码会转换为： 1&lt;form method=\"post\" action=\"test_form.php\"/&gt;&lt;script&gt;alert('hacked')&lt;/script&gt; 这段代码加入了一段脚本和一个提示命令。并且当此页面加载后，就会执行 JavaScript 代码（用户会看到一个提示框）。 &lt;script&gt; 标签内能够添加任何 JavaScript 代码！ 使用 htmlspecialchars() 函数能够避免 $_SERVER[“PHP_SELF”] 被利用。 表单代码是这样的： 1&lt;form method=\"post\" action=\"&lt;?php echo htmlspecialchars($_SERVER[\"PHP_SELF\"]);?&gt;\"&gt; htmlspecialchars() 函数把特殊字符转换为 HTML 实体。现在，如果用户试图利用 PHP_SELF 变量，会导致如下输出： 1&lt;form method=\"post\" action=\"test_form.php/\"&gt;&lt;script&gt;alert('hacked')&lt;/script&gt;\"&gt; 无法利用，没有危害！ htmlspecialchars() 函数可以使提交的代码字段不会被执行，因为会被保存为转义代码，当作普通的文本，就像这样： 1&lt;script&gt;location.href('http://www.hacked.com')&lt;/script&gt; 转义后的： 1&amp;lt;script&amp;gt;location.href('http://www.hacked.com')&amp;lt;/script&amp;gt; 现在这条代码显示在页面上或 e-mail 中是安全的。 检查函数在用户提交该表单时，我们还要做两件事：1.（通过 PHP trim() 函数）去除用户输入数据中不必要的字符（多余的空格、制表符、换行）2.（通过 PHP stripslashes() 函数）删除用户输入数据中的反斜杠（\\） 12345678910111213141516171819&lt;?php// 定义变量并设置为空值$name = $email = $gender = $comment = $website = \"\";if ($_SERVER[\"REQUEST_METHOD\"] == \"POST\") { // 提交类型是否POST或未提交 $name = test_input($_POST[\"name\"]); $email = test_input($_POST[\"email\"]); $website = test_input($_POST[\"website\"]); $comment = test_input($_POST[\"comment\"]); $gender = test_input($_POST[\"gender\"]);}function test_input($data) { $data = trim($data); // 去空格 $data = stripslashes($data); // 去转义 $data = htmlspecialchars($data); // 防注入 return $data;}?&gt; 输入提示（必填项未输入/格式错误等）1234Name: &lt;input type=\"text\" name=\"name\" value=\"&lt;?php echo $name;?&gt;\"&gt;&lt;span class=\"error\"&gt; &lt;?php echo $Msg;?&gt;&lt;/span&gt; 格式验证（正则表达式）名字是否包含空格123$name = test_input($_POST[\"name\"]);if (!preg_match(\"/^[a-zA-Z ]*$/\",$name)){ $nameErr = \"只允许字母和空格！\"; } 邮箱1preg_match(\"/([\\w\\-]+\\@[\\w\\-]+\\.[\\w\\-]+)/\",$email) URL（允许斜杠 /，需转义）1preg_match(\"/\\b(?:(?:https?|ftp):\\/\\/|www\\.)[-a-z0-9+&amp;@#\\/%?=~_|!:,.;]*[-a-z0-9+&amp;@#\\/% =~_|]/i\",$website) PHP 数据库连接数据库1mysql_connect(servername,username,password); servername 默认是 “localhost:3306”username 默认值是拥有服务器进程的用户的名称password 默认为”” 创建数据库1CREATE DATABASE database_name 选择数据库1mysql_select_db(\"database_name\", $con); 建表、添加、选取等之前必须选择数据库 创建表1234567CREATE TABLE table_name( column_name1 data_type, column_name2 data_type, column_name3 data_type, .......) 12345678910111213141516171819202122232425262728293031&lt;?php// 连接数据库$con = mysql_connect(\"localhost\",\"peter\",\"123\");if (!$con){ die('Could not connect: ' . mysql_error()); }// 创建数据库if (mysql_query(\"CREATE DATABASE my_db\",$con)){ echo \"Database created\"; }else{ echo \"Error creating: \" . mysql_error(); }// 选择数据库后才能建表mysql_select_db(\"my_db\", $con);// 创建栏位$sql = \"CREATE TABLE Persons ( // 主键 personID，不为空，自增 personID int NOT NULL AUTO_INCREMENT, PRIMARY KEY(personID), FirstName varchar(15), LastName varchar(15), Age int)\";// 选择数据库后创建表mysql_query($sql,$con);mysql_close($con);?&gt; 修改表名1mysql_query(\"ALTER TABLE `$old_tablename` RENAME TO `$tablename`\"); // 注意：是 ` ` 而不是 单引号 删除表1mysql_query(\"DROP TABLE `$tablename`\"); 插入数据（不分大小写）：INSERT INTO1mysql_query(\"INSERT INTO Persons (FirstName, LastName, Age) VALUES ('Glenn', 'Quagmire', '33')\"); 注意values里面的单引号，必须要加上去。 表单数据到数据库12$sql=\"INSERT INTO Persons (FirstName, LastName, Age) VALUES ('$_POST[firstname]','$_POST[lastname]','$_POST[age]')\";mysql_query($sql,$con); 选取数据：SELECT1$result = mysql_query(\"SELECT * FROM Persons\"); 按行读取选取的数据1mysql_fetch_array(data,array_type); mysql_fetch_array() 是 mysql_fetch_row() 的扩展，不会慢很多。 array_type 规定返回哪种结果。可能的值： MYSQL_ASSOC - 关联数组 MYSQL_NUM - 数字数组 MYSQL_BOTH - 默认。同时产生关联和数字数组 12345while($row = mysql_fetch_array($result)){ echo $row['FirstName'] . \" \" . $row['LastName']; echo \"&lt;br /&gt;\";} 匹配指定条件：WHERE运算符： = != &lt; &gt; &lt;= &gt;= BETWEEN 介于一个包含范围内 LIKE 搜索匹配的模式 1$result = mysql_query(\"SELECT * FROM Persons WHERE FirstName='Peter'\"); ###排序 排序：ORDER BYSELECT * FROM Persons ORDER BY age 默认升序，DESC 关键词降序。ORDER BY column_name DESC 多列排序时，只有第一列相同时才使用第二列：ORDER BY column_name1, column_name2 修改数据：UPDATE1mysql_query(\"UPDATE Persons SET Age = '36' WHERE FirstName = 'Peter' AND LastName = 'Griffin'\"); 删除数据：DELETE FROM1mysql_query(\"DELETE FROM Persons WHERE LastName='Griffin'\"); ODBC不多说，直接看下面的实例吧！ 12345678910111213141516171819202122232425262728293031&lt;html&gt;&lt;body&gt; &lt;?php // 名为 northwind 的 DSN 的连接，无帐号、密码 $conn=odbc_connect('northwind','',''); if (!$conn) {exit(\"Connection Failed: \" . $conn);} $sql=\"SELECT * FROM customers\"; $rs=odbc_exec($conn,$sql); // 查询 if (!$rs) {exit(\"Error in SQL\");} echo \"&lt;table&gt;&lt;tr&gt;\"; echo \"&lt;th&gt;Companyname&lt;/th&gt;\"; echo \"&lt;th&gt;Contactname&lt;/th&gt;&lt;/tr&gt;\"; while (odbc_fetch_row($rs)) // 取出 { $compname=odbc_result($rs,\"CompanyName\"); $conname=odbc_result($rs,\"ContactName\"); echo \"&lt;tr&gt;&lt;td&gt;$compname&lt;/td&gt;\"; echo \"&lt;td&gt;$conname&lt;/td&gt;&lt;/tr&gt;\"; } odbc_close($conn); // 关闭 echo \"&lt;/table&gt;\"; ?&gt;&lt;/body&gt;&lt;/html&gt; AJAX创建 XMLHttpRequest 对象1234567891011121314151617function GetXmlHttpObject(){ var xmlHttp=null; try { // Firefox, Opera 8.0+, Safari xmlHttp=new XMLHttpRequest(); } catch (e) { // Internet Explorer try { xmlHttp=new ActiveXObject(\"Msxml2.XMLHTTP\"); } catch (e) { xmlHttp=new ActiveXObject(\"Microsoft.XMLHTTP\"); } } return xmlHttp;} 实时搜索前端 HTML1234567891011121314151617&lt;html&gt;&lt;head&gt;&lt;script src=\"clienthint.js\"&gt;&lt;/script&gt; &lt;/head&gt;&lt;body&gt;&lt;form&gt; First Name:&lt;input type=\"text\" id=\"txt1\"onkeyup=\"showHint(this.value)\"&gt;&lt;/form&gt;&lt;p&gt;Suggestions: &lt;span id=\"txtHint\"&gt;&lt;/span&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 后端 JavaScript123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657var xmlHttp// 每当在输入域中输入一个字符，该函数就会被执行一次function showHint(str){ if (str.length==0) { document.getElementById(\"txtHint\").innerHTML=\"\" return } xmlHttp=GetXmlHttpObject() if (xmlHttp==null) { alert (\"Browser does not support HTTP Request\") return } var url=\"gethint.php\" url=url+\"?q=\"+str url=url+\"&amp;sid=\"+Math.random() xmlHttp.onreadystatechange=stateChanged xmlHttp.open(\"GET\",url,true) xmlHttp.send(null)} // 每当 XMLHTTP 对象的状态发生改变，则执行该函数function stateChanged() { // 在状态变成 4 （或 \"complete\"）时，用响应文本填充 txtHint 占位符 txtHint 的内容 if (xmlHttp.readyState==4 || xmlHttp.readyState==\"complete\") { document.getElementById(\"txtHint\").innerHTML=xmlHttp.responseText } }// 为不同浏览器创建不同 XMLHTTP 对象的问题function GetXmlHttpObject(){ var xmlHttp=null; try { // Firefox, Opera 8.0+, Safari xmlHttp=new XMLHttpRequest(); } catch (e) { // Internet Explorer try { xmlHttp=new ActiveXObject(\"Msxml2.XMLHTTP\"); } catch (e) { xmlHttp=new ActiveXObject(\"Microsoft.XMLHTTP\"); } } return xmlHttp;} 其他取网页源码123456$ret = file_get_contents(\"http://acm.hdu.edu.cn/showproblem.php?pid=1000\"); // 取网页源码$ret = iconv(\"gb2312\", \"utf-8//IGNORE\",$ret); // 避免乱码$pat = \"/&lt;h1 style='color:#1A5CC8'&gt;(.+)&lt;\\/h1&gt;/\"; // 后缀：i 忽略大小写, U 禁止贪婪匹配if (preg_match($pat, $ret, $ans)) $title = format_sql(trim($ans[1])); 网址重定向1header(\"Location:\" . $_SERVER['PHP_SELF']); // 默认页面 获取 IP1234567891011121314151617181920212223242526272829function getIP() // 获取真实的IP{ $ip = \"\"; if (getenv('HTTP_CLIENT_IP')) { $ip = getenv('HTTP_CLIENT_IP'); } elseif (getenv('HTTP_X_FORWARDED_FOR')) { $ip = getenv('HTTP_X_FORWARDED_FOR'); } elseif (getenv('HTTP_X_FORWARDED')) { $ip = getenv('HTTP_X_FORWARDED'); } elseif (getenv('HTTP_FORWARDED_FOR')) { $ip = getenv('HTTP_FORWARDED_FOR'); } elseif (getenv('HTTP_FORWARDED')) { $ip = getenv('HTTP_FORWARDED'); } else { $ip = $_SERVER['REMOTE_ADDR']; } return $ip;} 获取时间文本时间戳：time() 123456function gettime() // 获取当前时间文本{ date_default_timezone_set('PRC'); // 临时设置成中国时区 $time = date(\"y-m-d h:i:s\", time()); return $time;} 自制数据库模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556define(\"MySQL_servername\", \"localhost\");define(\"MySQL_username\", \"root\");define(\"MySQL_password\", \"root\");define(\"MySQL_detabase\", \"数据库名\");$con = NULL;$is_connected = 0;function connect_sql() // 连接数据库{ global $con, $is_connected; if ($is_connected) // 避免多次连接 { return NULL; } $con = mysql_connect(MySQL_servername, MySQL_username, MySQL_password); if (!$con) { die(\"数据库连接失败\"); } $is_connected = 1; mysql_select_db(MySQL_database, $con); return $con;}function query_sql($sql) // 查询语句{ global $con, $is_connected; if (!$is_connected) { connect_sql(); $is_connected = 1; } $result = mysql_query($sql, $con); return $result;}function row_sql($sql) // 查询一行，数据是否存在{ global $con, $is_connected; if (!$is_connected) { connect_sql(); $is_connected = 1; } if ($result = mysql_query($sql)) { $row = mysql_fetch_array($result); return $row; } else { return NULL; }} 自制表单操作模板12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182function seize() // 函数重载吧……{ $args = func_get_args(); if (func_num_args() == 1) // 一个，直接取值（可为空字符串） if (isset($_REQUEST[$args[0]])) return format_input($_REQUEST[$args[0]], 1); else return NULL; else // 多个，仅判断存不存在 { $num = func_num_args(); for ($i = 0; $i &lt; $num; $i++) if (!isset($_REQUEST[$args[$i]])) // 有一个没有值 return NULL; return 1; }}function seizeor() // 多个表单有一个就行了{ $args = func_get_args(); if (func_num_args() == 1) // 一个，存在并返回值 if (isset($_REQUEST[$args[0]])) return format_input($_REQUEST[$args[0]], 1); else return NULL; else // 多个，仅判断存不存在 { $num = func_num_args(); for ($i = 0; $i &lt; $num; $i++) if (isset($_REQUEST[$s])) // 有一个没有值 { return format_input($_REQUEST[$args[$i]], 1); } return NULL; }}function seize0($s, $blank = 0) // 获取必须存在且非空的表单，如果没有则强制退出{ if (isset($_REQUEST[$s]) &amp;&amp; $_REQUEST[$s] != \"\") return format_input($_REQUEST[$s], $blank); else die ;}function seize1($s, $blank = 0) // 获取一个表单{ if (isset($_REQUEST[$s])) return format_input($_REQUEST[$s], $blank); else return NULL;}function seize2($s, &amp;$a, $blank = 0) // 获取表单并引用赋值{ if (isset($_REQUEST[$s])) return ($a = format_input($_REQUEST[$s], $blank)); /*else if (isset($_COOKIE[$s])) return ($a = $s);*/ else return ($a = NULL);}function seizeval($s, $blank = 0) // 获取一个非空表单，否则为NULL{ if (isset($_REQUEST[$s]) &amp;&amp; $_REQUEST[$s] != \"\") return format_input($_REQUEST[$s], $blank); /*else if (isset($_COOKIE[$s])) return $s;*/ else return NULL;}function format_input($s, $blank = 0) // 格式化输入内容{ if (!$blank) $s = trim($s); // 去空格 $s = stripslashes($s); // 去转义 $s - htmlspecialchars($s); // 防注入 return $s;} END恭喜您，看完了整篇文章！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.iwxyi.com/tags/学习笔记/"},{"name":"PHP","slug":"PHP","permalink":"http://blog.iwxyi.com/tags/PHP/"}]},{"title":"Android使用高德地图","date":"2018-12-15T03:22:00.000Z","path":"2018/12/15/Android使用高德地图/","text":"1、要实现高德地图的定位，首先要下载高德地图的SDK 下载地址：http://lbs.amap.com/api/android-location-sdk/download/ 然后在高德地图官网上登录你注册的账号并且去控制台—–&gt;应用管理—–&gt;添加新key获取到自己的key值获取key的具体方法的官网地址 ：http://lbs.amap.com/ 2、通过解压得到.Jar文件并放到libs文件中，手动添加到依赖库中（右键Add—-） 3、如果你的地图SDK是3D的需要在main中创建 jniLibs 文件夹并把你解压出来的其他文件放到此处 4、开发环境已经配置好了，接下来就是敲代码了 导入高德SDK：https://lbs.amap.com/api/android-sdk/guide/create-project/android-studio-create-project 先下载所需要的SDK，然后把 jar 放进去。（只有 3D 地图才需要 so 库，其余不用放） 在工程的“ AndroidManifest.xml ”清单文件中添加key和Service 123&lt;meta-data android:name=\"com.amap.api.v2.apikey\"android:value=\"你申请的key\" /&gt;&lt;service android:name=\"com.amap.api.location.APSService\"&gt;&lt;/service&gt; 添加权限 1234567891011121314151617181920212223242526272829303132&lt;!--允许程序打开网络套接字--&gt; &lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt; &lt;!--允许程序设置内置sd卡的写权限--&gt; &lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt; &lt;!--允许程序获取网络状态--&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /&gt; &lt;!--允许程序访问WiFi网络信息--&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" /&gt; &lt;!--允许程序读写手机状态和身份--&gt; &lt;uses-permission android:name=\"android.permission.READ_PHONE_STATE\" /&gt; &lt;!--用于进行网络定位--&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\"&gt;&lt;/uses-permission&gt; &lt;!--用于访问GPS定位--&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\"&gt;&lt;/uses-permission&gt; &lt;!--用于获取wifi的获取权限，wifi信息会用来进行网络定位--&gt; &lt;uses-permission android:name=\"android.permission.CHANGE_WIFI_STATE\"&gt;&lt;/uses-permission&gt; &lt;!--用于读取手机当前的状态--&gt; &lt;uses-permission android:name=\"android.permission.READ_PHONE_STATE\"&gt;&lt;/uses-permission&gt; &lt;!--用于申请调用A-GPS模块--&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_LOCATION_EXTRA_COMMANDS\"/&gt; &lt;!--获取运营商信息，用于支持提供运营商信息相关的接口--&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /&gt; &lt;!--用于访问wifi网络信息，wifi信息会用于进行网络定位--&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" /&gt; &lt;!--这个权限用于获取wifi的获取权限，wifi信息会用来进行网络定位--&gt; &lt;uses-permission android:name=\"android.permission.CHANGE_WIFI_STATE\" /&gt; &lt;!--用于访问网络，网络定位需要上网--&gt; &lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt; &lt;!--用于读取手机当前的状态--&gt; &lt;uses-permission android:name=\"android.permission.READ_PHONE_STATE\" /&gt; &lt;!--写入扩展存储，向扩展卡写入数据，用于写入缓存定位数据--&gt; &lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt; acticity_main.xml布局文件 1234&lt;com.amap.api.maps.MapView android:id=\"@+id/map\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt;&lt;/com.amap.api.maps.MapView&gt; MainActivity代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.widget.Toast; import com.amap.api.location.AMapLocation;import com.amap.api.location.AMapLocationClient;import com.amap.api.location.AMapLocationClientOption;import com.amap.api.location.AMapLocationListener;import com.amap.api.maps.AMap;import com.amap.api.maps.CameraUpdateFactory;import com.amap.api.maps.LocationSource;import com.amap.api.maps.MapView;import com.amap.api.maps.UiSettings;import com.amap.api.maps.model.LatLng; import java.text.SimpleDateFormat;import java.util.Date; public class MainActivity extends AppCompatActivity implements LocationSource, AMapLocationListener { //AMap是地图对象 private AMap aMap; private MapView mapView; //声明AMapLocationClient类对象，定位发起端 private AMapLocationClient mLocationClient = null; //声明mLocationOption对象，定位参数 public AMapLocationClientOption mLocationOption = null; //声明mListener对象，定位监听器 private OnLocationChangedListener mListener = null; //标识，用于判断是否只显示一次定位信息和用户重新定位 private boolean isFirstLoc = true; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //获取地图控件引用 mapView = (MapView) findViewById(R.id.map); //在activity执行onCreate时执行mMapView.onCreate(savedInstanceState)，实现地图生命周期管理 mapView.onCreate(savedInstanceState); if (aMap == null) { aMap = mapView.getMap(); //设置显示定位按钮 并且可以点击 UiSettings settings = aMap.getUiSettings(); aMap.setLocationSource(this);//设置了定位的监听 // 是否显示定位按钮 settings.setMyLocationButtonEnabled(true); aMap.setMyLocationEnabled(true);//显示定位层并且可以触发定位,默认是flase } //开始定位 location(); } private void location() { //初始化定位 mLocationClient = new AMapLocationClient(getApplicationContext()); //设置定位回调监听 mLocationClient.setLocationListener(this); //初始化定位参数 mLocationOption = new AMapLocationClientOption(); //设置定位模式为Hight_Accuracy高精度模式，Battery_Saving为低功耗模式，Device_Sensors是仅设备模式 mLocationOption.setLocationMode(AMapLocationClientOption.AMapLocationMode.Hight_Accuracy); //设置是否返回地址信息（默认返回地址信息） mLocationOption.setNeedAddress(true); //设置是否只定位一次,默认为false mLocationOption.setOnceLocation(false); //设置是否强制刷新WIFI，默认为强制刷新 mLocationOption.setWifiActiveScan(true); //设置是否允许模拟位置,默认为false，不允许模拟位置 mLocationOption.setMockEnable(false); //设置定位间隔,单位毫秒,默认为2000ms mLocationOption.setInterval(2000); //给定位客户端对象设置定位参数 mLocationClient.setLocationOption(mLocationOption); //启动定位 mLocationClient.startLocation(); } @Override protected void onDestroy() { super.onDestroy(); //在activity执行onDestroy时执行mMapView.onDestroy()，实现地图生命周期管理 mapView.onDestroy(); mLocationClient.stopLocation();//停止定位 mLocationClient.onDestroy();//销毁定位客户端。 } @Override protected void onResume() { super.onResume(); //在activity执行onResume时执行mMapView.onResume ()，实现地图生命周期管理 mapView.onResume(); } @Override protected void onPause() { super.onPause(); //在activity执行onPause时执行mMapView.onPause ()，实现地图生命周期管理 mapView.onPause(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); //在activity执行onSaveInstanceState时执行mMapView.onSaveInstanceState (outState)，实现地图生命周期管理 mapView.onSaveInstanceState(outState); } @Override public void onLocationChanged(AMapLocation aMapLocation) { if (aMapLocation != null) { if (aMapLocation.getErrorCode() == 0) { //定位成功回调信息，设置相关消息 aMapLocation.getLocationType();//获取当前定位结果来源，如网络定位结果，详见官方定位类型表 aMapLocation.getLatitude();//获取纬度 aMapLocation.getLongitude();//获取经度 aMapLocation.getAccuracy();//获取精度信息 SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); Date date = new Date(aMapLocation.getTime()); df.format(date);//定位时间 aMapLocation.getAddress();//地址，如果option中设置isNeedAddress为false，则没有此结果，网络定位结果中会有地址信息，GPS定位不返回地址信息。 aMapLocation.getCountry();//国家信息 aMapLocation.getProvince();//省信息 aMapLocation.getCity();//城市信息 aMapLocation.getDistrict();//城区信息 aMapLocation.getStreet();//街道信息 aMapLocation.getStreetNum();//街道门牌号信息 aMapLocation.getCityCode();//城市编码 aMapLocation.getAdCode();//地区编码 // 如果不设置标志位，此时再拖动地图时，它会不断将地图移动到当前的位置 if (isFirstLoc) { //设置缩放级别 aMap.moveCamera(CameraUpdateFactory.zoomTo(17)); //将地图移动到定位点 aMap.moveCamera(CameraUpdateFactory.changeLatLng(new LatLng(aMapLocation.getLatitude(), aMapLocation.getLongitude()))); //点击定位按钮 能够将地图的中心移动到定位点 mListener.onLocationChanged(aMapLocation); //添加图钉 // aMap.addMarker(getMarkerOptions(amapLocation)); //获取定位信息 StringBuffer buffer = new StringBuffer(); buffer.append(aMapLocation.getCountry() + \"\" + aMapLocation.getProvince() + \"\" + aMapLocation.getCity() + \"\" + aMapLocation.getProvince() + \"\" + aMapLocation.getDistrict() + \"\" + aMapLocation.getStreet() + \"\" + aMapLocation.getStreetNum()); Toast.makeText(getApplicationContext(), buffer.toString(), Toast.LENGTH_LONG).show(); isFirstLoc = false; } } else { //显示错误信息ErrCode是错误码，errInfo是错误信息，详见错误码表。 Log.e(\"AmapError\", \"location Error, ErrCode:\" + aMapLocation.getErrorCode() + \", errInfo:\" + aMapLocation.getErrorInfo()); Toast.makeText(getApplicationContext(), \"定位失败\", Toast.LENGTH_LONG).show(); } } } @Override public void activate(OnLocationChangedListener onLocationChangedListener) { mListener = onLocationChangedListener; } @Override public void deactivate() { mListener = null; }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Android取时间戳","date":"2018-12-14T03:21:00.000Z","path":"2018/12/14/Android取时间戳/","text":"取13位时间戳都是毫秒级的（13位），用long存 123456//方法 一System.currentTimeMillis();//方法 二（速度最慢）Calendar.getInstance().getTimeInMillis();//方法 三new Date().getTime(); 取当前时间12SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");//设置日期格式String date = df.format(new Date());// new Date()为获取当前系统时间，也可使用当前时间戳 date类型转换为String类型12345// formatType格式为yyyy-MM-dd HH:mm:ss//yyyy年MM月dd日 HH时mm分ss秒// data Date类型的时间public static String dateToString(Date data, String formatType) { return new SimpleDateFormat(formatType).format(data);} long类型转换为String类型12345678// currentTime要转换的long类型的时间// formatType要转换的string类型的时间格式public static String longToString(long currentTime, String formatType) throws ParseException { Date date = longToDate(currentTime, formatType); // long类型转成Date类型 String strTime = dateToString(date, formatType); // date类型转成String return strTime;} string类型转换为date类型12345678910// strTime要转换的string类型的时间，formatType要转换的格式yyyy-MM-dd HH:mm:ss//yyyy年MM月dd日 // HH时mm分ss秒， // strTime的时间格式必须要与formatType的时间格式相同 public static Date stringToDate(String strTime, String formatType) throws ParseException { SimpleDateFormat formatter = new SimpleDateFormat(formatType); Date date = null; date = formatter.parse(strTime); return date; } long转换为Date类型123456789// currentTime要转换的long类型的时间 // formatType要转换的时间格式yyyy-MM-dd HH:mm:ss//yyyy年MM月dd日 HH时mm分ss秒 public static Date longToDate(long currentTime, String formatType) throws ParseException { Date dateOld = new Date(currentTime); // 根据long类型的毫秒数生命一个date类型的时间 String sDateTime = dateToString(dateOld, formatType); // 把date类型的时间转换为string Date date = stringToDate(sDateTime, formatType); // 把String类型转换为Date类型 return date; } String类型转换为long类型12345678910111213// strTime要转换的String类型的时间// formatType时间格式// strTime的时间格式和formatType的时间格式必须相同public static long stringToLong(String strTime, String formatType) throws ParseException { Date date = stringToDate(strTime, formatType); // String类型转成date类型 if (date == null) { return 0; } else { long currentTime = dateToLong(date); // date类型转成long类型 return currentTime; }} date类型转换为long类型1234// date要转换的date类型的时间public static long dateToLong(Date date) { return date.getTime();} 获取日期时间数值123456789101112131415public static void main(String[] args) { Calendar c = Calendar.getInstance();// mYear = c.get(Calendar.YEAR); // 获取当前年份 mMonth = c.get(Calendar.MONTH) + 1; // 获取当前月份 mDay = c.get(Calendar.DAY_OF_MONTH); // 获取当日期 mWay = c.get(Calendar.DAY_OF_WEEK); // 获取当前日期的星期 mHour = c.get(Calendar.HOUR_OF_DAY); //时 mMinute = c.get(Calendar.MINUTE); //分 System.out.println(mYear); System.out.println(mMonth); System.out.println(mDay); System.out.println(mWay); System.out.println(mHour); System.out.println(mMinute);} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Markdown-讲解","date":"2018-12-07T13:05:00.000Z","path":"2018/12/07/正则表达式-讲解/","text":"Markdown 简介Markdown 是一种轻量级的「标记语言」，通常为程序员群体所用，适用于泡技术论坛、写博客日志、技术文稿、记录代码片段、起草邮件等场景。 可以通过简单、易读易写的文本格式生成结构化的 HTML 网页，以及 Word 和 pdf 文档。目前 知乎、简书、github、Stackoverflow、以及绝大多数博客论坛 均支持这种格式。 为什么要学 Markdown？因为简单；因为好用；因为这篇教程就是用 Markdown 写的。 让“码字的归码字，排版的归排版”，专注写作，效率快速提升； 除此之外基础的任务管理、项目管理、逻辑梳理、公式协作等等，都可以用基本的Markdown来完成…… 优点：简单符号排版，15 分钟上手。 纯键盘操作，写作时少调用鼠标，效率能提升很多。 使用 Markdown 的 h1、h2、h3 标题，列表、分列表，结构和逻辑都很清晰。排版成同样的效果，md 与 word 比起来简直毫不费力气。另外，还有插入图片、链接、粗体、斜体等功能。 纯文本编辑，轻量级。纯文本有很多好处，例如占用空间小、移植方便快捷、可以用 git 比较版本、编辑时不需要软件支持等。 目前支持将 md 转换为多种格式，包括 html、tex、pdf 等。 缺点： 语法不是很统一，不同的编辑器语法有区别 不能对文档进行精细调整，或者个性化调整。 据说过于程序员友好。 对话式红楼梦曹雪芹写的效果如下：贾芸听声音像是熟人，仔细一看，原来是紧邻倪二。这倪二是个泼皮，专放重利债，在赌博场吃饭，专爱喝酒打架。此时正从欠钱人家索债归来，已在醉乡，不料贾芸碰了他，就要动手。贾芸叫道：“老二！住手！是我冲撞了你。”倪二一听他的语音，将醉眼睁开一看，见是贾芸，忙松了手，趔趄著笑道：“原来是贾二爷。这会子那里去？”贾芸道：“告诉不得你，平白的又讨了个没趣儿！”倪二道：“不妨。有什么不平的事，告诉我，我替你出气。这三街六巷，凭他是谁，若得罪了我醉金刚倪二的街坊，管叫他人离家散！”贾芸道：“老二，你别生气，听我告诉你这缘故。”便把卜世仁一段事告诉了倪二。倪二听了，大怒道：“要不是二爷的亲戚，我就骂出来，真真把人气死！－－也罢，你也不必愁，我这里现有几两银子，你要用只管拿去。我们好街坊，这银子是不要利钱的。”一头说，一头从搭包内掏出一包银子来。 Markdown 的效果 用Markdown简单处理一下的话，这段的排版就变了： 贾芸听声音像是熟人，仔细一看，原来是紧邻倪二。这倪二是个泼皮，专放重利债，在赌博场吃饭，专爱喝酒打架。此时正从欠钱人家索债归来，已在醉乡，不料贾芸碰了他，就要动手。贾芸叫道： “老二！住手！是我冲撞了你。” 倪二一听他的语音，将醉眼睁开一看，见是贾芸，忙松了手，趔趄著笑道： “原来是贾二爷。这会子那里去？” 贾芸道： “告诉不得你，平白的又讨了个没趣儿！” 倪二道： “不妨。有什么不平的事，告诉我，我替你出气。这三街六巷，凭他是谁，若得罪了我醉金刚倪二的街坊，管叫他人离家散！” 贾芸道： “老二，你别生气，听我告诉你这缘故。” 便把卜世仁一段事告诉了倪二。倪二听了，大怒道： “要不是二爷的亲戚，我就骂出来，真真把人气死！－－也罢，你也不必愁，我这里现有几两银子，你要用只管拿去。我们好街坊，这银子是不要利钱的。” 一头说，一头从搭包内掏出一包银子来。 开始撰写 Markdown标题Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。（部分编辑器不支持） 类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如： 12345This is an H1=============This is an H2------------- 类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如： 12345# 这是 H1## 这是 H2###### 这是 H6 你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 #，而行尾的 # 数量也不用和开头一样（行首的井字符数量决定标题的阶数）： 12345# 这是 H1 ### 这是 H2 ##### 这是 H3 ###### 区块引用BlockquotesMarkdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 &gt; ： 123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse&gt; id sem consectetuer libero luctus adipiscing. Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; ： 123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. 区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ： 12345 This is the first level of quoting.&gt;&gt; &gt; This is nested blockquote.&gt;&gt; Back to the first level. 引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等： 12345678&gt; ## 这是一个标题。&gt; &gt; 1. 这是第一行列表项。&gt; 2. 这是第二行列表项。&gt; &gt; 给出一些例子代码：&gt; &gt; return shell_exec(\"echo $input | $markdown_script\"); 任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择增加引用阶层。 列表Markdown 支持有序列表和无序列表。 无序列表使用星号、加号或是减号作为列表标记： 123* Red* Green* Blue 等同于： 123+ Red+ Green+ Blue 也等同于： 123- Red- Green- Blue 有序列表则使用数字接着一个英文句点（word里面也是这样）： 1231. Bird2. McHale3. Parish 列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。 要让列表看起来更漂亮，你可以把内容用固定的缩进整理好： 12345* Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.* Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 但是如果你懒，那也行： 12345* Lorem ipsum dolor sit amet, consectetuer adipiscing elit.Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,viverra nec, fringilla in, laoreet vitae, risus.* Donec sit amet nisl. Aliquam semper ipsum sit amet velit.Suspendisse id sem consectetuer libero luctus adipiscing. 列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符： 1234567891. This is a list item with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit.2. Suspendisse id sem consectetuer libero luctus adipiscing. 如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许： 1234567* This is a list item with two paragraphs. This is the second paragraph in the list item. You'reonly required to indent the first line. Lorem ipsum dolorsit amet, consectetuer adipiscing elit.* Another item in the same list. 如果要在列表项目内放进引用，那 &gt; 就需要缩进： 1234* A list item with a blockquote: &gt; This is a blockquote &gt; inside a list item. 如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符：（有些编辑器不支持） 123* 一列表项包含一个列表区块： &lt;代码写在这&gt; 当然，项目列表很可能会不小心产生，像是下面这样的写法 11986. What a great season. 换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠。 11986\\. What a great season. 待办事项用 - [ ] 来表示一个待办事项列表（注意有三个空格） 12- [ ] 未完成列表- [x] 已完成列表 代码区块和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 &lt;pre&gt; 和 &lt;code&gt; 标签来把代码区块包起来。 要在 Markdown 中建立代码区块很简单，只要用一对12345~~~C++```C++ for (int i = 0; i &lt; 10; i++) printf(\"%d\\n\", i); ~ 上面的123456### 分隔线你可以在一行中用三个以上的短横杠来建立一个分隔线，行内不能有其他东西。 123456### 链接链接文字用 [方括号] 来标记，要建立一个行内的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，例如： This is an example inline link. This link has no title attribute. 12如果你是要链接到同样主机的资源，你可以使用相对路径： See my About page for details. 123456### 强调Markdown 使用星号（*）和底线（_）作为标记强调字词的符号 。一对是斜体，两对是粗体。 single asterisks single underscores double asterisks double underscores 123456789101112*single asterisks*_single underscores_**double asterisks**__double underscores__你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。强调也可以直接插在文字中间： unfriggingbelievable 1234但是**如果你的 \\* 和 _ 两边都有空白的话，它们就只会被当成普通的符号。**如果要在文字前后直接插入普通的星号或底线，你可以用反斜线： *this text is surrounded by literal asterisks* 123456### 删除线使用两对波浪线 ~~ 来给文字加上~~删除线~~。注意波浪线和文字之间不能有空格。 删除线 123456### 代码如果要标记一小段行内代码，你可以用反引号把它包起来（`），例如： Use the printf() function. 12如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段： There is a literal backtick (`) here. 12345678910### 图片很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。行内式的图片语法看起来像是： Alt text 1234567891011121314详细叙述如下：- 一个惊叹号 !- 接着一个方括号，里面放上图片的替代文字- 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 'title' 文字。到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 `&lt;img&gt;` 标签。### 反斜杠Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果，你可以在星号的前面加上反斜杠： *literal asterisks* 12Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \\ 反斜线` 反引号 星号_ 底线{} 花括号[] 方括号() 括弧井字号 加号 减号. 英文句点! 惊叹号123456### 自动链接Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如： http://example.com/ 12邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如： address@example.com 123456### 表格表格是Markdown语法中比较复杂的一个，其语法如下： 表头 条目一 条目二 项目 项目一 项目二 ``` 以上标记显示效果如下： 表头 条目一 条目二 项目 项目一 项目二 注：三个短斜杠左右的冒号用于控制对齐方式，只放置左边冒号表示文字居左，只放置右边冒号表示文字居右，如果两边都放置冒号表示文字居中。不加冒号默认左对齐。 文字上色使用Markdown的同学最郁闷的地方恐怕就是不能给文字添加颜色了。事实上，Markdown的最初目标就是为纯写作而生的。因此，它并没有考虑文字颜色这一点。所以，单纯使用Markdown设置文字颜色已经做不到了。但你可以这样做： 先用Markdown编辑完成 导出为html，在需要上色的部分手动添加标签&lt;font color='#ff0000'&gt; &lt;/font&gt;保存即可。 Latex数学公式1.行内公式：使用两个”$”符号引用公式: $公式$ 2.行间公式：使用两对“$$”符号引用公式： $$公式$$ 输例如$\\sqrt{x^{2}}$ 上标下标在$ $ 公式中，用 ^p 表示上标。若有多个，用 { } 括起来。 下标符号为 _，用法同上标。 Typora 的扩展语法中，可以用^上标^与~下标~来表示（需要先到设置中开启） 结语在文档中，内容远远比工具和格式重要。但适当的格式和工具也会增强文字的渲染力。 Markdown 是纯文本和富文本之间最恰当的选择。 博客来源：整理，网络，主要是 http://www.markdown.cn/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"语法","slug":"语法","permalink":"http://blog.iwxyi.com/tags/语法/"},{"name":"讲解","slug":"讲解","permalink":"http://blog.iwxyi.com/tags/讲解/"}]},{"title":"栈与队列-讲解","date":"2018-12-07T12:50:00.000Z","path":"2018/12/07/栈与队列-讲解/","text":"介绍栈栈是一种特殊的线性表。其特殊性在于限定插入和删除数据元素的操作只能在线性表的一端进行。如下所示： 结论：先进后出 &amp;&amp; 后进先出（Last In First Out），简称为LIFO线性表。 例子：手机任务的返回栈、食堂餐盘从下到上叠起来，送给洗盘子的人，从上到下洗 队列队列(Queue)也是一种运算受限的线性表，它的运算限制与栈不同，是两头都有限制，插入只能在表的一端进行(只进不出)，而删除只能在表的另一端进行(只出不进)，允许删除的一端称为队尾(rear)，允许插入的一端称为队头 (Front),如图所示： 结论：队列的操作原则是先进先出的，所以队列又称作FIFO表(First In First Out) 例子：各种排队 纯 C 用法（函数）栈123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#define MAX_SIZE 1000int _data[MAX_SIZE], _size = 0;bool empty() { return _size != 0;}void push(int x) { if (_size &lt; MAX_SIZE-1) { _data[_size++] = x; }}void pop() { if (_size) { _data[--_size] = 0; }}int size() { return _size;}int front() { return _size ? _data[0] : 0;}int back() { return _size ? _data[_size-1] : 0;}int main(){ push(100); printf(\"%d\\n\", back()); push(20); printf(\"%d\\n\", back());} 数组转指针： _data\\[([^M].*)\\]替换*(_data + \\1) 纯C用法（结构体）栈12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;struct Stack { int _data[1000]; int _size; Stack() { // 初始化 _size = 0; } Stack(Stack&amp; q) { // 拷贝（引用） _size = q.size(); for (int i = 0; i &lt; _size; i++) _data[i] = q.at(i); } bool empty() { // 是否为空 return !_size; } int size() { // 尺寸 return _size; } int at(int x) { // 数据 return (x&gt;=0 &amp;&amp; x &lt; _size) ? _data[x] : 0; } void push(int x) { // 放入一个 if (_size &lt; 1000) _data[_size++] = x; } void pop() { // 取出一个 if (_size) { for (int i = 0; i &lt; _size-1; i++) _data[i] = _data[i+1]; --_size; } } int front() { // 获取最新进入的 return _size?_data[0] : 0; } int back() { // 获取最后进入的 return _size?_data[_size-1] : 0; } void clear() { _size = 0; }};int main(){ Stack s; s.push(100); printf(\"%d\\n\", s.back()); s.push(20); printf(\"%d\\n\", s.back()); Stack s2(s); printf(\"%d\\n\", s.back()); s2.clear();} C++ 用法头文件12#include &lt;queue&gt;#include &lt;stack&gt; 定义方式12queue&lt;int&gt; q;statck&lt;int&gt; q; 常用操作栈12345s.empty() //如果栈为空返回true，否则返回false s.size() //返回栈中元素的个数 s.pop() //删除栈顶元素但不返回其值 s.top() //返回栈顶的元素，但不删除该元素 s.push(x) //在栈顶压入新元素 ，参数X为要压入的元素 队列123456q.empty() // 如果队列为空返回true，否则返回false q.size() // 返回队列中元素的个数 q.pop() //删除队列首元素但不返回其值 q.front() // 返回队首元素的值，但不删除该元素 q.push(x) //在队尾压入新元素 ，X为要压入的元素q.back() //返回队列尾元素的值，但不删除该元素 智能指针迭代器 iterator 123stack&lt;int&gt;::iterator i;for (i = s.begin(); i != s.end(); ++i) cout &lt;&lt; *i &lt;&lt; endl; 例子12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;int main(){ queue&lt;int&gt; q; stack&lt;char&gt; s; char a = 'a', b = 'b'; q.push(1); cout &lt;&lt; \"push 1\" &lt;&lt; endl; cout &lt;&lt; \"empty:\" &lt;&lt; q.empty() &lt;&lt; endl; cout &lt;&lt; \"push 2\" &lt;&lt; endl; q.push(2); cout &lt;&lt; \"front:\" &lt;&lt; q.front() &lt;&lt; endl; q.pop(); cout &lt;&lt; \"pop\" &lt;&lt; endl; cout &lt;&lt; \"front:\" &lt;&lt; q.front() &lt;&lt; endl; q.pop(); cout &lt;&lt; \"pop\" &lt;&lt; endl; cout &lt;&lt; \"empty:\" &lt;&lt; q.empty() &lt;&lt;endl; cout &lt;&lt; \"-----\" &lt;&lt; endl; s.push(a); cout &lt;&lt; \"push \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"size:\" &lt;&lt; s.size() &lt;&lt; endl; cout &lt;&lt; \"top:\" &lt;&lt; s.top() &lt;&lt; endl; s.push(b); cout &lt;&lt; \"push \" &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; \"top:\" &lt;&lt; s.top() &lt;&lt; endl; s.pop(); cout &lt;&lt; \"pop\" &lt;&lt; endl; cout &lt;&lt; \"top:\" &lt;&lt; s.top() &lt;&lt; endl;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"算法","slug":"算法","permalink":"http://blog.iwxyi.com/tags/算法/"},{"name":"讲解","slug":"讲解","permalink":"http://blog.iwxyi.com/tags/讲解/"}]},{"title":"正则表达式-讲解","date":"2018-12-06T12:56:00.000Z","path":"2018/12/06/正则表达式教程/","text":"介绍正则表达式(Regular Expression，简称 RegExp)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。它使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。 为什么使用正则表达式？典型的搜索和替换操作要求您提供与预期的搜索结果匹配的确切文本。虽然这种技术对于对静态文本执行简单搜索和替换任务可能已经足够了，但它缺乏灵活性，若采用这种方法搜索动态文本，即使不是不可能，至少也会变得很困难。 例1：文件匹配data(\\w)?\\.dat 匹配下列所有文件 12345data.datdata1.datdata2.datdatax.datdataN.dat 使用 * 字符代替 ? 字符扩大了找到的文件的数量。data.*\\.dat 匹配下列所有文件： 123456data.datdata1.datdata2.datdata12.datdatax.datdataXYZ.dat 例2：colou?r同时匹配 color与colour 例3：特定格式^[0-9]+abc$ ^ 为匹配输入字符串的开始位置 [0-9]+匹配多个数字， [0-9] 匹配单个数字，+ 匹配一个或者多个。 abc$匹配字母 abc 并以 abc 结尾，$ 为匹配输入字符串的结束位置。 我们在写用户注册表单时，只允许用户名包含字符、数字、下划线和连接字符(-)，并设置用户名的长度，我们就可以使用这一类正则表达式来设定。 ()() 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \\( 和 \\)。 特殊字符所谓特殊字符，就是一些有特殊含义的字符。 许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符\\ 放在它们前面。下表列出了正则表达式中的特殊字符： 特别字符 描述 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\\n’ 或 ‘\\r’。要匹配 $ 字符本身，请使用 \\$。 ( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。 * 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 *。 + 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。 . 匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 . 。 [ 标记一个中括号表达式的开始。要匹配 [，请使用 [。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。 \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\\n’ 匹配换行符。序列 ‘\\‘ 匹配 “\"，而 ‘(‘ 则匹配 “(“。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 ^。 { 标记限定符表达式的开始。要匹配 {，请使用 {。 | 指明两项之间的一个选择。要匹配 |，请使用 |。 限定符限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。 正则表达式的限定符有： 字符 描述 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 定位符定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。 定位符用来描述字符串或单词的边界，^ 和 $ 分别指字符串的开始与结束，\\b 描述单词的前或后边界，\\B 表示非单词边界。 正则表达式的定位符有： 字符 描述 ^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。 $ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。 \\b 匹配一个单词边界，即字与空格间的位置。 \\B 非单词边界匹配。 注意：不能将限定符与定位符一起使用。 选择用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。 其中 ?: 是非捕获元之一，还有两个非捕获元是 ?= 和 ?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。 反向引用对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 \\n 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。 可以使用非捕获元字符 ?:、?= 或 ?! 来重写捕获，忽略对相关匹配的保存。 反向引用的最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。 例如：(asd)\\1能匹配asdasd 所有元字符 字符 描述 \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\\n’ 匹配一个换行符。序列 ‘\\‘ 匹配 “\" 而 “(“ 则匹配 “(“。 ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\\n’ 或 ‘\\r’ 之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\\n’ 或 ‘\\r’ 之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。 . 匹配除换行符（\\n、\\r）之外的任何单个字符。要匹配包括 ‘\\n’ 在内的任何字符，请使用像”(.|\\n)“的模式。 (pattern) 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。 (?:pattern) 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。 (?=pattern) 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，”Windows(?=95|98|NT|2000)”能匹配”Windows2000”中的”Windows”，但不能匹配”Windows3.1”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如”Windows(?!95|98|NT|2000)”能匹配”Windows3.1”中的”Windows”，但不能匹配”Windows2000”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?&lt;=pattern) 反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，”`(?&lt;=95 (?&lt;!pattern) 反向否定预查，与正向否定预查类似，只是方向相反。例如”`(?&lt;!95 x|y 匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。 [xyz] 字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \\B 匹配非单词边界。’er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \\cx 匹配由 x 指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \\d 匹配一个数字字符。等价于 [0-9]。 \\D 匹配一个非数字字符。等价于 [^0-9]。 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 \\w 匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。 \\W 匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。 \\xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\\x41’ 匹配 “A”。’\\x041’ 则等价于 ‘\\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。 \\num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\\1’ 匹配两个连续的相同字符。 \\n 标识一个八进制转义值或一个向后引用。如果 \\n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 \\nm 标识一个八进制转义值或一个向后引用。如果 \\nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \\nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \\nm 将匹配八进制转义值 nm。 \\nml 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 \\un 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \\u00A9 匹配版权符号 (?)。 等价字符?, *, +, \\d, \\w 都是等价字符?等价于匹配长度{0,1}*等价于匹配长度{0,}+等价于匹配长度{1,}\\d等价于[0-9]\\w等价于[A-Za-z_0-9] 常用运算符与表达式^ 开始() 域段[] 包含,默认是一个字符长度[^] 不包含,默认是一个字符长度{n,m} 匹配长度. 任何单个字符(. 字符点)| 或\\ 转义$ 结尾[A-Z] 26个大写字母[a-z] 26个小写字母[0-9] 0至9数字[A-Za-z0-9] 26个大写字母、26个小写字母和0至9数字 贪婪模式*、+限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。 字符簇略吧，目前作用不大 实例应用 验证用户名和密码：（”^[a-zA-Z]\\w{5,15}$“）正确格式：”[A-Z][a-z]_[0-9]“组成,并且第一个字必须为字母6~16位； 验证电话号码：（”^(\\\\d{3,4}-)\\\\d{7,8}$“）正确格式：xxx/xxxx-xxxxxxx/xxxxxxxx； 验证手机号码：”^1[3|4|5|7|8][0-9]\\\\d{8}$“； 验证身份证号（15位或18位数字）：”\\\\d{14}[[0-9],0-9xX]“； 验证Email地址：(“^\\\\w+([-+.]\\\\w+)*@\\\\w+([-.]\\\\w+)*\\.\\\\w+([-.]\\\\w+)*$“)； 只能输入由数字和26个英文字母组成的字符串：(“^[A-Za-z0-9]+$“) ; 整数或者小数：^[0-9]+([.]{0,1}[0-9]+){0,1}$ 只能输入数字：”^[0-9]*$“。 只能输入n位的数字：”^\\\\d{n}$“。 只能输入至少n位的数字：”^\\\\d{n,}$“。 只能输入m~n位的数字：”^\\\\d{m,n}$“。 只能输入零和非零开头的数字：”^(0|[1-9][0-9]*)$“。 只能输入有两位小数的正实数：”^[0-9]+(.[0-9]{2})?$“。 只能输入有1~3位小数的正实数：”^[0-9]+(\\.[0-9]{1,3})?$“。 只能输入非零的正整数：\"^\\+?[1-9][0-9]*$\"。 只能输入非零的负整数：\"^\\-[1-9][0-9]*$\"。 只能输入长度为3的字符：”^.{3}$“。 只能输入由26个英文字母组成的字符串：”^[A-Za-z]+$“。 只能输入由26个大写英文字母组成的字符串：”^[A-Z]+$“。 只能输入由26个小写英文字母组成的字符串：”^[a-z]+$“。 验证是否含有^%&amp;',;=?$\\\"等字符：\"[^%&amp;',;=?$\\x22]+\"。 只能输入汉字：”^[\\u4e00-\\u9fa5]{0,}$“。 验证URL：”^http://([\\\\w-]+\\.)+[\\\\w-]+(/[\\\\w-./?%&amp;=]*)?$“。 验证一年的12个月：”^(0?[1-9]|1[0-2])$“正确格式为：”01”～”09”和”10”～”12”。 验证一个月的31天：”^((0?[1-9])|((1|2)[0-9])|30|31)$“正确格式为；”01”～”09”、”10”～”29”和“30”~“31”。 获取日期正则表达式：\\d{4}[年|\\-|\\.]\\d{1-12}[月|\\-|\\.]\\d{1-31}日? 评注：可用来匹配大多数年月日信息。 匹配双字节字符(包括汉字在内)：[^\\x00-\\xff] 评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1） 匹配空白行的正则表达式：\\n\\s*\\r 评注：可以用来删除空白行 匹配HTML标记的正则表达式：&lt;(\\S*?)[^&gt;]*&gt;.*?&lt;/&gt;|&lt;.*? /&gt; 评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力 匹配首尾空白字符的正则表达式：^\\s*|\\s*$ 评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式 匹配网址URL的正则表达式：[a-zA-z]+://[^\\s]* 评注：网上流传的版本功能很有限，上面这个基本可以满足需求 匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 评注：表单验证时很实用 匹配腾讯QQ号：[1-9][0-9]\\{4,\\} 评注：腾讯QQ号从10 000 开始 匹配中国邮政编码：[1-9]\\\\d{5}(?!\\d) 评注：中国邮政编码为6位数字 匹配ip地址：((2[0-4]\\\\d|25[0-5]|[01]?\\\\d\\\\d?)\\.){3}(2[0-4]\\\\d|25[0-5]|[01]?\\\\d\\\\d?)。 C++示例1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;regex.h&gt; int main(int argc,char** argv){ int status ,i; int cflags = REG_EXTENDED; regmatch_t pmatch[1]; const size_t nmatch = 1; regex_t reg; const char * pattern = \"^\\\\w+([-+.]\\\\w+)*@\\\\w+([-.]\\\\w+)*.\\\\w+([-.]\\\\w+)*$\"; char * buf = \"chenjiayi@126.com\"; regcomp(&amp;reg,pattern,cflags);//编译正则模式 status = regexec(&amp;reg,buf,nmatch,0);//执行正则表达式和缓存的比较 if(status == REG_NOMATCH) printf(\"No match\\n\"); else if (0 == status) { printf(\"比较成功:\"); for(i = pmatch[0].rm_so;i&lt;pmatch[0].rm_eo;++i)putchar(buf[i]); printf(\"\\n\"); } regfree(&amp;reg); return 0;} 博客来源：https://blog.csdn.net/chenjiayi_yun/article/details/43375201 菜鸟教程：http://www.runoob.com/regexp/regexp-tutorial.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"RegExp","slug":"RegExp","permalink":"http://blog.iwxyi.com/tags/RegExp/"},{"name":"讲解","slug":"讲解","permalink":"http://blog.iwxyi.com/tags/讲解/"}]},{"title":"Android小知识","date":"2018-12-01T02:28:00.000Z","path":"2018/12/01/Android小知识/","text":"1234&lt;EditText &lt;!-- 设置密码框 --&gt; android:password=\"true\"&lt;/EditText&gt; 12CheckBox cb;if (cb.isChecked()) { ... } 12//获取文本((EditText)findViewById(R.id.editText2)).getText().toString() 123456789101112131415//设置按钮事件b1=(Button)findViewById(R.id.button);b1.setOnClickListener( new View.OnClickListener() { @Override public void onClick(View v) { // 用浏览器打开网址 Intent i = new Intent(android.content.Intent.ACTION_VIEW, Uri.parse(\"http://www.uprogrammer.cn\")); // 拨号 //Intent i = new Intent(android.content.Intent.ACTION_VIEW,Uri.parse(\"tel:9510300000\")); startActivity(i); }}); 1234567&lt;!-- 通过Launch或者Intent调用 --&gt;&lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.VIEW\" /&gt; &lt;action android:name=\"com.example.MyApplication.LAUNCH\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;data android:scheme=\"http\" /&gt;&lt;/intent-filter&gt; 12345678910 &lt;!-- 监听网址的打开（Manifest） --&gt;&lt;activity android:name=\"cn.uprogrammer.intentfilter.CustomActivity\" android:label=\"@string/app_name\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.VIEW\" /&gt; &lt;action android:name=\"cn.uprogrammer.intentfilter.LAUNCH\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;data android:scheme=\"http\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 123456789101112// 监听打开网址后（显示网址）public class CustomActivity extends Activity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.custom_view); TextView label = (TextView) findViewById(R.id.show_data); Uri url = getIntent().getData(); label.setText(url.toString()); }} 文本框属性详解 http://www.runoob.com/w3cnote/android-tutorial-textview.html 1Drawable drawable = MainActivity.this.getResources().getDrawable(R.drawable.picture1); 1234// 格式化文本，\"常量%1常量\"textView.setText(getString(R.string.section_format, 123));&lt;string name=\"section_format\"&gt;Hello World %1$d&lt;/string&gt; 12// 规定ImageView最大值无效，需要加上下面这句：android:adjustViewBounds 12// 判断版本号if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.M) 1234567891011121314151617181920212223242526272829303132// 是否拥有联系人权限，没有就尝试获取private boolean mayRequestContacts() { if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.M) { return true; } if (checkSelfPermission(READ_CONTACTS) == PackageManager.PERMISSION_GRANTED) { return true; } if (shouldShowRequestPermissionRationale(READ_CONTACTS)) { Snackbar.make(mEmailView, R.string.permission_rationale, Snackbar.LENGTH_INDEFINITE) .setAction(android.R.string.ok, new View.OnClickListener() { @Override @TargetApi(Build.VERSION_CODES.M) public void onClick(View v) { requestPermissions(new String[]{READ_CONTACTS}, REQUEST_READ_CONTACTS); } }); } else { requestPermissions(new String[]{READ_CONTACTS}, REQUEST_READ_CONTACTS); } return false;}@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { if (requestCode == REQUEST_READ_CONTACTS) { if (grantResults.length == 1 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) { populateAutoComplete(); } }} 123456789// 设置 Spinner 下拉菜单String[] ctype = new String[]{\"全部\", \"游戏\", \"电影\", \"娱乐\", \"图书\"};//创建一个数组适配器ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_spinner_item, ctype);//设置下拉列表框的下拉选项样式adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);Spinner spinner = super.findViewById(R.id.spinner);spinner.setAdapter(adapter); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"},{"name":"整理","slug":"整理","permalink":"http://blog.iwxyi.com/tags/整理/"}]},{"title":"Android Fragment回退栈","date":"2018-11-27T02:43:00.000Z","path":"2018/11/27/Android-Fragment回退栈/","text":"导语: Fragment作为Android最基本，最重要的基础概念之一，在开发中经常会和他打交道。本文从为什么出现Fragment开始，介绍了Fragment相关的方方面面，包括Fragment的基本定义及使用、回退栈的内部实现、Fragment通信、DialogFragment、ViewPager+Fragment的使用、嵌套Fragment、懒加载等。 基本概念 Fragment，简称碎片，是Android 3.0（API 11）提出的，为了兼容低版本，support-v4库中也开发了一套Fragment API，最低兼容Android 1.6。 过去support-v4库是一个jar包，24.2.0版本开始，将support-v4库模块化为多个jar包，包含：support-fragment, support-ui, support-media-compat等，这么做是为了减少APK包大小，你需要用哪个模块就引入哪个模块。 如果想引入整个support-v4库，则compile 'com.android.support:support-v4:24.2.1'，如果只想引入support-fragment库，则com.android.support:support-fragment:24.2.1。 因为support库是不断更新的，因此建议使用support库中的android.support.v4.app.Fragment，而不要用系统自带的android.app.Fragment。而如果要使用support库的Fragment，Activity必须要继承FragmentActivity（AppCompatActivity是FragmentActivity的子类）。 Fragment是依赖于Activity的，不能独立存在的。 一个Activity里可以有多个Fragment。 一个Fragment可以被多个Activity重用。 Fragment有自己的生命周期，并能接收输入事件。 我们能在Activity运行时动态地添加或删除Fragment。 Fragment的优势有以下几点： 模块化（Modularity）：我们不必把所有代码全部写在Activity中，而是把代码写在各自的Fragment中。 可重用（Reusability）：多个Activity可以重用一个Fragment。 可适配（Adaptability）：根据硬件的屏幕尺寸、屏幕方向，能够方便地实现不同的布局，这样用户体验更好。 基本使用 这里给出Fragment最基本的使用方式。首先，创建继承Fragment的类，名为Fragment1： 12345678910111213141516171819202122public class Fragment1 extends Fragment{ private static String ARG_PARAM = \"param_key\"; private String mParam; private Activity mActivity; public void onAttach(Context context) { mActivity = (Activity) context; mParam = getArguments().getString(ARG_PARAM); //获取参数 } public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View root = inflater.inflate(R.layout.fragment_1, container, false); TextView view = root.findViewById(R.id.text); view.setText(mParam); return root; } public static Fragment1 newInstance(String str) { Fragment1 frag = new Fragment1(); Bundle bundle = new Bundle(); bundle.putString(ARG_PARAM, str); fragment.setArguments(bundle); //设置参数 return fragment; }} Fragment有很多可以复写的方法，其中最常用的就是onCreateView()，该方法返回Fragment的UI布局，需要注意的是inflate()的第三个参数是false，因为在Fragment内部实现中，会把该布局添加到container中，如果设为true，那么就会重复做两次添加，则会抛如下异常： 1Caused by: java.lang.IllegalStateException: The specified child already has a parent. You must call removeView() on the child's parent first. 如果在创建Fragment时要传入参数，必须要通过setArguments(Bundle bundle)方式添加，而不建议通过为Fragment添加带参数的构造函数，因为通过setArguments()方式添加，在由于内存紧张导致Fragment被系统杀掉并恢复（re-instantiate）时能保留这些数据。官方建议如下： 1It is strongly recommended that subclasses do not have other constructors with parameters, since these constructors will not be called when the fragment is re-instantiated. 我们可以在Fragment的onAttach()中通过getArguments()获得传进来的参数，并在之后使用这些参数。如果要获取Activity对象，不建议调用getActivity()，而是在onAttach()中将Context对象强转为Activity对象。 创建完Fragment后，接下来就是把Fragment添加到Activity中。在Activity中添加Fragment的方式有两种： 静态添加：通过xml的方式添加，缺点是一旦添加就不能在运行时删除。 动态添加：运行时添加，这种方式比较灵活，因此建议使用这种方式。虽然Fragment能在XML中添加，但是这只是一个语法糖而已，Fragment并不是一个View，而是和Activity同一层次的。 这里只给出动态添加的方式。首先Activity需要有一个容器存放Fragment，一般是FrameLayout，因此在Activity的布局文件中加入FrameLayout： 1234&lt;FrameLayout android:id=\"@+id/container\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt; 然后在onCreate()中，通过以下代码将Fragment添加进Activity中。 12345if (bundle == null) { getSupportFragmentManager().beginTransaction() .add(R.id.container, Fragment1.newInstance(\"hello world\"), \"f1\") //.addToBackStack(\"fname\") .commit();} 这里需要注意几点： 因为我们使用了support库的Fragment，因此需要使用getSupportFragmentManager()获取FragmentManager。 add()是对Fragment众多操作中的一种，还有remove(), replace()等，第一个参数是根容器的id（FrameLayout的id，即”@id/container”），第二个参数是Fragment对象，第三个参数是fragment的tag名，指定tag的好处是后续我们可以通过Fragment1 frag = getSupportFragmentManager().findFragmentByTag(\"f1\")从FragmentManager中查找Fragment对象。 在一次事务中，可以做多个操作，比如同时做add().remove().replace()。 commit()操作是异步的，内部通过mManager.enqueueAction()加入处理队列。对应的同步方法为commitNow()，commit()内部会有checkStateLoss()操作，如果开发人员使用不当（比如commit()操作在onSaveInstanceState()之后），可能会抛出异常，而commitAllowingStateLoss()方法则是不会抛出异常版本的commit()方法，但是尽量使用commit()，而不要使用commitAllowingStateLoss()。 addToBackStack(\"fname\")是可选的。FragmentManager拥有回退栈（BackStack），类似于Activity的任务栈，如果添加了该语句，就把该事务加入回退栈，当用户点击返回按钮，会回退该事务（回退指的是如果事务是add(frag1)，那么回退操作就是remove(frag1)）；如果没添加该语句，用户点击返回按钮会直接销毁Activity。 Fragment有一个常见的问题，即Fragment重叠问题，这是由于Fragment被系统杀掉，并重新初始化时再次将fragment加入activity，因此通过在外围加if语句能判断此时是否是被系统杀掉并重新初始化的情况。 Fragment有个常见的异常：12345java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState at android.support.v4.app.FragmentManagerImpl.checkStateLoss(FragmentManager.java:1341) at android.support.v4.app.FragmentManagerImpl.enqueueAction(FragmentManager.java:1352) at android.support.v4.app.BackStackRecord.commitInternal(BackStackRecord.java:595) at android.support.v4.app.BackStackRecord.commit(BackStackRecord.java:574) 该异常出现的原因是：commit()在onSaveInstanceState()后调用。首先，onSaveInstanceState()在onPause()之后，onStop()之前调用。onRestoreInstanceState()在onStart()之后，onResume()之前。 因此避免出现该异常的方案有： 不要把Fragment事务放在异步线程的回调中，比如不要把Fragment事务放在AsyncTask的onPostExecute()，因此onPostExecute()可能会在onSaveInstanceState()之后执行。 逼不得已时使用commitAllowingStateLoss()。 生命周期 Fragment的生命周期和Activity类似，但比Activity的生命周期复杂一些，基本的生命周期方法如下图： 生命周期 解释如下： onAttach()：Fragment和Activity相关联时调用。可以通过该方法获取Activity引用，还可以通过getArguments()获取参数。 onCreate()：Fragment被创建时调用。 onCreateView()：创建Fragment的布局。 onActivityCreated()：当Activity完成onCreate()时调用。 onStart()：当Fragment可见时调用。 onResume()：当Fragment可见且可交互时调用。 onPause()：当Fragment不可交互但可见时调用。 onStop()：当Fragment不可见时调用。 onDestroyView()：当Fragment的UI从视图结构中移除时调用。 onDestroy()：销毁Fragment时调用。 onDetach()：当Fragment和Activity解除关联时调用。 上面的方法中，只有onCreateView()在重写时不用写super方法，其他都需要。 因为Fragment是依赖Activity的，因此为了讲解Fragment的生命周期，需要和Activity的生命周期方法一起讲，即Fragment的各个生命周期方法和Activity的各个生命周期方法的关系和顺序，如图： LifeCycle 我们这里举个例子来理解Fragment生命周期方法。功能如下：共有两个Fragment：F1和F2，F1在初始化时就加入Activity，点击F1中的按钮调用replace替换为F2。 当F1在Activity的onCreate()中被添加时，日志如下： 123456789101112131415161718192021222324252627BasicActivity: [onCreate] BEGINBasicActivity: [onCreate] ENDBasicActivity: [onStart] BEGINFragment1: [onAttach] BEGIN Fragment1: [onAttach] ENDBasicActivity: [onAttachFragment] BEGINBasicActivity: [onAttachFragment] ENDFragment1: [onCreate] BEGINFragment1: [onCreate] ENDFragment1: [onCreateView]Fragment1: [onViewCreated] BEGINFragment1: [onViewCreated] ENDFragment1: [onActivityCreated] BEGINFragment1: [onActivityCreated] ENDFragment1: [onStart] BEGINFragment1: [onStart] ENDBasicActivity: [onStart] ENDBasicActivity: [onPostCreate] BEGINBasicActivity: [onPostCreate] ENDBasicActivity: [onResume] BEGINBasicActivity: [onResume] ENDBasicActivity: [onPostResume] BEGINFragment1: [onResume] BEGINFragment1: [onResume] ENDBasicActivity: [onPostResume] ENDBasicActivity: [onAttachedToWindow] BEGINBasicActivity: [onAttachedToWindow] END 可以看出： Fragment的onAttach()-&gt;onCreate()-&gt;onCreateView()-&gt;onActivityCreated()-&gt;onStart()都是在Activity的onStart()中调用的。 Fragment的onResume()在Activity的onResume()之后调用。 接下去分两种情况，分别是不加addToBackStack()和加addToBackStack()。 1、当点击F1的按钮，调用replace()替换为F2，且不加addToBackStack()时，日志如下： 12345678910111213141516171819202122232425Fragment2: [onAttach] BEGINFragment2: [onAttach] ENDBasicActivity: [onAttachFragment] BEGINBasicActivity: [onAttachFragment] ENDFragment2: [onCreate] BEGINFragment2: [onCreate] ENDFragment1: [onPause] BEGINFragment1: [onPause] ENDFragment1: [onStop] BEGINFragment1: [onStop] ENDFragment1: [onDestroyView] BEGINFragment1: [onDestroyView] ENDFragment1: [onDestroy] BEGINFragment1: [onDestroy] ENDFragment1: [onDetach] BEGINFragment1: [onDetach] ENDFragment2: [onCreateView]Fragment2: [onViewCreated] BEGINFragment2: [onViewCreated] ENDFragment2: [onActivityCreated] BEGINFragment2: [onActivityCreated] ENDFragment2: [onStart] BEGINFragment2: [onStart] ENDFragment2: [onResume] BEGINFragment2: [onResume] END 可以看到，F1最后调用了onDestroy()和onDetach()。 2、当点击F1的按钮，调用replace()替换为F2，且加addToBackStack()时，日志如下： 123456789101112131415161718192021Fragment2: [onAttach] BEGINFragment2: [onAttach] ENDBasicActivity: [onAttachFragment] BEGINBasicActivity: [onAttachFragment] ENDFragment2: [onCreate] BEGINFragment2: [onCreate] ENDFragment1: [onPause] BEGINFragment1: [onPause] ENDFragment1: [onStop] BEGINFragment1: [onStop] ENDFragment1: [onDestroyView] BEGINFragment1: [onDestroyView] ENDFragment2: [onCreateView]Fragment2: [onViewCreated] BEGINFragment2: [onViewCreated] ENDFragment2: [onActivityCreated] BEGINFragment2: [onActivityCreated] ENDFragment2: [onStart] BEGINFragment2: [onStart] ENDFragment2: [onResume] BEGINFragment2: [onResume] END 可以看到，F1被替换时，最后只调到了onDestroyView()，并没有调用onDestroy()和onDetach()。当用户点返回按钮回退事务时，F1会调onCreateView()-&gt;onStart()-&gt;onResume()，因此在Fragment事务中加不加addToBackStack()会影响Fragment的生命周期。 FragmentTransaction有一些基本方法，下面给出调用这些方法时，Fragment生命周期的变化： add(): onAttach()-&gt;…-&gt;onResume()。 remove(): onPause()-&gt;…-&gt;onDetach()。 replace(): 相当于旧Fragment调用remove()，新Fragment调用add()。 show(): 不调用任何生命周期方法，调用该方法的前提是要显示的 Fragment已经被添加到容器，只是纯粹把Fragment UI的setVisibility为true。 hide(): 不调用任何生命周期方法，调用该方法的前提是要显示的Fragment已经被添加到容器，只是纯粹把Fragment UI的setVisibility为false。 detach(): onPause()-&gt;onStop()-&gt;onDestroyView()。UI从布局中移除，但是仍然被FragmentManager管理。 attach(): onCreateView()-&gt;onStart()-&gt;onResume()。 Fragment实现原理和Back Stack 我们知道Activity有任务栈，用户通过startActivity将Activity加入栈，点击返回按钮将Activity出栈。Fragment也有类似的栈，称为回退栈（Back Stack），回退栈是由FragmentManager管理的。默认情况下，Fragment事务是不会加入回退栈的，如果想将Fragment事务加入回退栈，则可以加入addToBackStack(\"\")。如果没有加入回退栈，则用户点击返回按钮会直接将Activity出栈；如果加入了回退栈，则用户点击返回按钮会回滚Fragment事务。 我们将通过最常见的Fragment用法，讲解Back Stack的实现原理： 1234getSupportFragmentManager().beginTransaction() .add(R.id.container, f1, \"f1\") .addToBackStack(\"\") .commit(); 上面这个代码的功能就是将Fragment加入Activity中，内部实现为：创建一个BackStackRecord对象，该对象记录了这个事务的全部操作轨迹（这里只做了一次add操作，并且加入回退栈），随后将该对象提交到FragmentManager的执行队列中，等待执行。 BackStackRecord类的定义如下 1class BackStackRecord extends FragmentTransaction implements FragmentManager.BackStackEntry, Runnable {} 从定义可以看出，BackStackRecord有三重含义： 继承了FragmentTransaction，即是事务，保存了整个事务的全部操作轨迹。 实现了BackStackEntry，作为回退栈的元素，正是因为该类拥有事务全部的操作轨迹，因此在popBackStack()时能回退整个事务。 继承了Runnable，即被放入FragmentManager执行队列，等待被执行。 先看第一层含义，getSupportFragmentManager.beginTransaction()返回的就是BackStackRecord对象，代码如下： 123public FragmentTransaction beginTransaction() { return new BackStackRecord(this);} BackStackRecord类包含了一次事务的整个操作轨迹，是以链表形式存在的，链表的元素是Op类，表示其中某个操作，定义如下： 123456static final class Op { Op next; //链表后一个节点 Op prev; //链表前一个节点 int cmd; //操作是add或remove或replace或hide或show等 Fragment fragment; //对哪个Fragment对象做操作} 我们来看下具体场景下这些类是怎么被使用的，比如我们的事务做add操作。add函数的定义： 1234public FragmentTransaction add(int containerViewId, Fragment fragment, String tag) { doAddOp(containerViewId, fragment, tag, OP_ADD); return this;} doAddOp()方法就是创建Op对象，并加入链表，定义如下： 12345678private void doAddOp(int containerViewId, Fragment fragment, String tag, int opcmd) { fragment.mTag = tag; //设置fragment的tag fragment.mContainerId = fragment.mFragmentId = containerViewId; //设置fragment的容器id Op op = new Op(); op.cmd = opcmd; op.fragment = fragment; addOp(op);} addOp()是将创建好的Op对象加入链表，定义如下： 12345678910void addOp(Op op) { if (mHead == null) { mHead = mTail = op; } else { op.prev = mTail; mTail.next = op; mTail = op; } mNumOp++;} addToBackStack(“”)是将mAddToBackStack变量记为true，在commit()中会用到该变量。commit()是异步的，即不是立即生效的，但是后面会看到整个过程还是在主线程完成，只是把事务的执行扔给主线程的Handler，commit()内部是commitInternal()，实现如下： 12345678910int commitInternal(boolean allowStateLoss) { mCommitted = true; if (mAddToBackStack) { mIndex = mManager.allocBackStackIndex(this); } else { mIndex = -1; } mManager.enqueueAction(this, allowStateLoss); //将事务添加进待执行队列中 return mIndex;} 如果mAddToBackStack为true，则调用allocBackStackIndex(this)将事务添加进回退栈，FragmentManager类的变量ArrayListmBackStackIndices;就是回退栈。实现如下： 12345678public int allocBackStackIndex(BackStackRecord bse) { if (mBackStackIndices == null) { mBackStackIndices = new ArrayList&lt;BackStackRecord&gt;(); } int index = mBackStackIndices.size(); mBackStackIndices.add(bse); return index;} 在commitInternal()中，mManager.enqueueAction(this, allowStateLoss);是将BackStackRecord加入待执行队列中，定义如下： 12345678910public void enqueueAction(Runnable action, boolean allowStateLoss) { if (mPendingActions == null) { mPendingActions = new ArrayList&lt;Runnable&gt;(); } mPendingActions.add(action); if (mPendingActions.size() == 1) { mHost.getHandler().removeCallbacks(mExecCommit); mHost.getHandler().post(mExecCommit); //调用execPendingActions()执行待执行队列的事务 }} mPendingActions就是前面说的待执行队列，mHost.getHandler()就是主线程的Handler，因此Runnable是在主线程执行的，mExecCommit的内部就是调用了execPendingActions()，即把mPendingActions中所有积压的没被执行的事务全部执行。执行队列中的事务会怎样被执行呢？就是调用BackStackRecord的run()方法，run()方法就是执行Fragment的生命周期函数，还有将视图添加进container中。 与addToBackStack()对应的是popBackStack()，有以下几种变种： popBackStack()：将回退栈的栈顶弹出，并回退该事务。 popBackStack(String name, int flag)：name为addToBackStack(String name)的参数，通过name能找到回退栈的特定元素，flag可以为0或者FragmentManager.POP_BACK_STACK_INCLUSIVE，0表示只弹出该元素以上的所有元素，POP_BACK_STACK_INCLUSIVE表示弹出包含该元素及以上的所有元素。这里说的弹出所有元素包含回退这些事务。 popBackStack()是异步执行的，是丢到主线程的MessageQueue执行，popBackStackImmediate()是同步版本。 我们通过讲解Demo来更清晰地了解回退栈的使用。功能如下：共有三个Fragment：F1, F2, F3，F1在初始化时就加入Activity，点击F1中的按钮跳转到F2，点击F2的按钮跳转到F3，点击F3的按钮回退到F1。 在Activity的onCreate()中，将F1加入Activity中： 1234getSupportFragmentManager().beginTransaction() .add(R.id.container, f1, \"f1\") .addToBackStack(Fragment1.class.getSimpleName()) .commit(); F1按钮的onClick()内容如下： 1234getFragmentManager().beginTransaction() .replace(R.id.container, f2, \"f2\") .addToBackStack(Fragment2.class.getSimpleName()) .commit(); F2按钮的onClick()如下： 1234getFragmentManager().beginTransaction() .replace(R.id.container, f3, \"f3\") .addToBackStack(Fragment3.class.getSimpleName()) .commit(); F3按钮的onClick()如下： 12getFragmentManager().popBackStack(Fragment2.class.getSimpleName(), FragmentManager.POP_BACK_STACK_INCLUSIVE); 这样就完成了整个界面的跳转逻辑。 这里补充一个点getSupportFragmentManager().findFragmentByTag()是经常用到的方法，他是FragmentManager的方法，FragmentManager是抽象类，FragmentManagerImpl是继承FragmentManager的实现类，他的内部实现是： 1234567891011121314151617181920212223class FragmentManagerImpl extends FragmentManager { ArrayList&lt;Fragment&gt; mActive; ArrayList&lt;Fragment&gt; mAdded; public Fragment findFragmentByTag(String tag) { if (mAdded != null &amp;&amp; tag != null) { for (int i=mAdded.size()-1; i&gt;=0; i--) { Fragment f = mAdded.get(i); if (f != null &amp;&amp; tag.equals(f.mTag)) { return f; } } } if (mActive != null &amp;&amp; tag != null) { for (int i=mActive.size()-1; i&gt;=0; i--) { Fragment f = mActive.get(i); if (f != null &amp;&amp; tag.equals(f.mTag)) { return f; } } } return null; }} 从上面看到，先从mAdded中查找是否有该Fragment，如果没找到，再从mActive中查找是否有该Fragment。mAdded是已经添加到Activity的Fragment的集合，mActive不仅包含mAdded，还包含虽然不在Activity中，但还在回退栈中的Fragment。 Fragment通信 Fragment向Activity传递数据首先，在Fragment中定义接口，并让Activity实现该接口（具体实现省略）： 1public interface OnFragmentInteractionListener { void onItemClick(String str); //将str从Fragment传递给Activity} 在Fragment的onAttach()中，将参数Context强转为OnFragmentInteractionListener对象： 123456789public void onAttach(Context context) { super.onAttach(context); if (context instanceof OnFragmentInteractionListener) { mListener = (OnFragmentInteractionListener) context; } else { throw new RuntimeException(context.toString() + \" must implement OnFragmentInteractionListener\"); }} 并在Fragment合适的地方调用mListener.onItemClick(\"hello\")将”hello”从Fragment传递给Activity。 FABridge由于通过接口的方式从Fragment向Activity进行数据传递比较麻烦，需要在Fragment中定义interface，并让Activity实现该interface，FABridge(https://github.com/hongyangAndroid/FABridge)通过注解的形式免去了这些定义。 在build.gradle中添加依赖： 1annotationProcessor 'com.zhy.fabridge:fabridge-compiler:1.0.0'compile 'com.zhy.fabridge:fabridge-api:1.0.0' 首先定义方法ID，这里为FAB_ITEM_CLICK，接着在Activity中定义接口： 123@FCallbackId(id = FAB_ITEM_CLICK)public void onItemClick(String str) { //方法名任意 Toast.makeText(this, str, Toast.LENGTH_SHORT).show();} 最后，在Fragment中，通过以下形式调用”ID=FAB_ITEM_CLICK”的方法（该方法可能在Activity中，也可能在任何类中）： 1Fabridge.call(mActivity,FAB_ITEM_CLICK,\"data\"); //调用ID对应的方法，\"data\"为参数值 Activity向Fragment传递数据Activity向Fragment传递数据比较简单，获取Fragment对象，并调用Fragment的方法即可，比如要将一个字符串传递给Fragment，则在Fragment中定义方法： 123public void setString(String str) { this.str = str;} 并在Activity中调用fragment.setString(\"hello\")即可。 Fragment之间通信由于Fragment之间是没有任何依赖关系的，因此如果要进行Fragment之间的通信，建议通过Activity作为中介，不要Fragment之间直接通信。 DialogFragmentDialogFragment是Android 3.0提出的，代替了Dialog，用于实现对话框。他的优点是：即使旋转屏幕，也能保留对话框状态。 如果要自定义对话框样式，只需要继承DialogFragment，并重写onCreateView()，该方法返回对话框UI。这里我们举个例子，实现进度条样式的圆角对话框。 12345678910111213public class ProgressDialogFragment extends DialogFragment { @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { getDialog().requestWindowFeature(Window.FEATURE_NO_TITLE); //消除Title区域 getDialog().getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT)); //将背景变为透明 setCancelable(false); //点击外部不可取消 View root = inflater.inflate(R.layout.fragment_progress_dialog, container); return root; } public static ProgressDialogFragment newInstance() { return new ProgressDialogFragment(); }} 进度条动画我们使用Lottie(https://github.com/airbnb/lottie-android)实现，Lottie动画从这里(https://www.lottiefiles.com/)找到。使用非常方便，只需要下载JSON动画文件，然后在XML中写入： 123456&lt;com.airbnb.lottie.LottieAnimationView android:layout_width=\"wrap_content\" //大小根据JSON文件确定 android:layout_height=\"wrap_content\" app:lottie_fileName=\"loader_ring.json\" //JSON文件 app:lottie_loop=\"true\" //循环播放 app:lottie_autoPlay=\"true\" /&gt; //自动播放 然后通过下面代码显示对话框： 12ProgressDialogFragment fragment = ProgressDialogFragment.newInstance();fragment.show(getSupportFragmentManager(), \"tag\");//fragment.dismiss(); 为了实现圆角，除了在onCreateView()中把背景设为透明，还需要对UI加入背景： 12345&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;solid android:color=\"#ffffff\"/&gt; &lt;corners android:radius=\"20dp\"/&gt;&lt;/shape&gt; 转自Bugly 公众号 https://mp.weixin.qq.com/s/dUuGSVhWinAnN9uMiBaXgw 参考：https://www.jianshu.com/p/11c8ced79193 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Qt动画","date":"2018-11-26T10:44:00.000Z","path":"2018/11/26/Qt动画/","text":"动画框架类这些类提供了用于创建简单的和复杂的动画的框架 类 描述 QAbstractAnimation 所有动画类的基类 QAnimationGroup 动画容器类的抽象基类 QEasingCurve 动画控制的缓和曲线类 QParallelAnimationGroup 并行动画容器 QPauseAnimation QSequentialAnimationGroup暂停 QPropertyAnimation Qt的动画属性 QSequentialAnimationGroup 串行动画容器 QTimeLine 控制动画的时间轴类 QVariantAnimation 动画类的抽象基类 Qt动画属性如上所述，QPropertyAnimation类能够修改Qt属性值，正是该类用于改变动画属性值。事实上，它的基类QVariantAnimation是一个抽象类，所以不能被直接使用。 选用Qt动画属性的一个主要原因，是因为它给我们很大的自由性去动画操作Qt API中已经存在的类，尤其是拥有bounds、colors等属性的QWidget类（能被嵌入到QGraphicsView中的QWidget）。 来看一个小例子： 123456789QPushButton button(\"Animated Button\");button.show();QPropertyAnimation animation(&amp;button, \"geometry\");animation.setDuration(10000);animation.setStartValue(QRect(0, 0, 100, 30));animation.setEndValue(QRect(250, 250, 100, 30));animation.start(); 上述代码，在10秒的持续时间把button从屏幕的左上角移动到(250, 250)点处。 上面的例子在开始值与结束值之间做了线性插值。当然，设置的值在开始处与结束处之间的数值也是合理的，那么插值衍化就沿这些点进行。 1234567891011QPushButton button(\"Animated Button\");button.show();QPropertyAnimation animation(&amp;button, \"geometry\");animation.setDuration(10000);animation.setKeyValueAt(0, QRect(0, 0, 100, 30));animation.setKeyValueAt(0.8, QRect(250, 250, 100, 30));animation.setKeyValueAt(1, QRect(0, 0, 100, 30));animation.start(); 这个例子中，在8秒的持续时间将button移到(250, 250)，然后在剩下的2秒再移回至初始位置；这些点之间的移动都是通过线性插值的。 你也可以动画操作没有声明动画属性的QObject对象中的值，但是唯一的条件是该值有个能进行修改的设置函数。所以可以进行子类化，在该类中包含声明属性的值并且有个设置函数。每个Qt属性需要一个获取值的访问函数，因此如果类本身没提供对该值的访问函数的话，你自己就需要提供一个。 12345class MyGraphicsRectItem : public QObject, public QGraphicsRectItem{ Q_OBJECT Q_PROPERTY(QRectF geometry READ geometry WRITE setGeometry)}; 如上所示的代码例子中，我们子类化QGraphicsRectItem类，并且定义了”geometry”属性。即使QGraphicsRectItem没有提供”geometry”属性，我们也可以动画操作MyGraphicsRectItem的位置信息了。 动画和图形视图框架当你想动画操作QGraphicsItem时，也可以使用QPropertyAnimation类。然而，QGraphicsItem并不继承于QObject。一个好的解决办法是子类化一个你需要的图形项，同时这个类也继承自QObject。通过这种方式，QPropertyAnimation类就能适用于QGraphicsItem。下面的代码例子展示了这是如何实现的。另一种可行性是只继承于QGraphicsWidget，因为QGraphicsWidget继承于QObject。 123456class Pixmap : public QObject, public QGraphicsPixmapItem{ Q_OBJECT Q_PROPERTY(QPointF pos READ pos WRITE setPos) ...}; 如上所述，我们定义了一个需要动画操作的属性值。 注意：出于元对象系统的要求，QObject必须是第一个继承者。 缓和曲线QPropertyAnimation在开始与结束之间执行插值操作。除了为动画添加更多的键值外，你也可以使用缓和曲线，缓和曲线控制着在0与1之间的插值速度，如果你想在没有改变插值路径的情况下改变动画速度，那么缓和曲线是很有用的。 1234567891011QPushButton button(\"Animated Button\");button.show();QPropertyAnimation animation(&amp;button, \"geometry\");animation.setDuration(3000);animation.setStartValue(QRect(0, 0, 100, 30));animation.setEndValue(QRect(250, 250, 100, 30));animation.setEasingCurve(QEasingCurve::OutBounce);animation.start(); 这里，动画即沿着OutBounce曲线，该曲线样式是到结束处会弹跳起来像个弹跳球。QEasingCurve类有大量供选择的曲线，它们被定义成QEasingCurve::Type枚举。如果你需要另外的曲线样式，也可以自己实现一个，然后用QEasingCurve注册它既可。 动画分组一个应用程序常常包含多个动画。例如，你或许希望同时移动不止一个图形项或者一个接一个的顺序移动它们。 QAnimationGroup（QSequentialAnimationGroup和QParallelAnimationGroup）的子类是动画容器类，因此多个动画可以被串行或者并行执行。QAnimationGroup类就是一个例子，其不操作动画属性，但是它能周期性的获得定时通知，这使得它能把定时通知应用于动画中，从而进行控制。 下面我们来看看使用QSequentialAnimationGroup和QParallelAnimationGroup的例子： 1234567891011121314151617QPushButton *bonnie = new QPushButton(\"Bonnie\");bonnie-&gt;show();QPushButton *clyde = new QPushButton(\"Clyde\");clyde-&gt;show();// 动画一QPropertyAnimation *anim1 = new QPropertyAnimation(bonnie, \"geometry\");// 动画二QPropertyAnimation *anim2 = new QPropertyAnimation(clyde, \"geometry\");QParallelAnimationGroup *group = new QParallelAnimationGroup;group-&gt;addAnimation(anim1);group-&gt;addAnimation(anim2);group-&gt;start(); 并行容器内的动画是同时进行的，调用它的start()函数即开始操作它所管理的所有动画。 12345678910111213141516171819QPushButton button(\"Animated Button\");button.show();QPropertyAnimation anim1(&amp;button, \"geometry\");anim1.setDuration(3000);anim1.setStartValue(QRect(0, 0, 100, 30));anim1.setEndValue(QRect(500, 500, 100, 30));QPropertyAnimation anim2(&amp;button, \"geometry\");anim2.setDuration(3000);anim2.setStartValue(QRect(500, 500, 100, 30));anim2.setEndValue(QRect(1000, 500, 100, 30));QSequentialAnimationGroup group;group.addAnimation(&amp;anim1);group.addAnimation(&amp;anim2);group.start(); 毫无疑问你已经猜到了，QSequentialAnimationGroup串行的操作它所管理的动画。 因为动画容器类也是动画，所以你可以将其加入到其它动画容器里；用这种方式，就可以建造一个动画树结构，该结构指定了动画彼此之间运行的关系。 动画和状态当使用状态机时，我们可以使用QSignalTransition或QEventTransition类将一个或者多个动画与状态之间的切换中进行关联。这些类继承于QAbstractTransition，QAbstractTransition类提供了便利的函数addAnimation()，该函数在状态切换发生的情况下能触发一个或多个被附加的动画。 我们也可以和状态进行属性关联，而不是自己设置开始和结束值，下面就是一段完整的动画操作QPushButton位置的代码例子： 123456789101112131415161718192021QPushButton *button = new QPushButton(\"Animated Button\");button-&gt;show();QStateMachine *machine = new QStateMachine;QState *state1 = new QState(machine);state1-&gt;assignProperty(button, \"geometry\", QRect(0, 0, 100, 30));machine-&gt;setInitialState(state1);QState *state2 = new QState(machine);state2-&gt;assignProperty(button, \"geometry\", QRect(250, 250, 100, 30));QSignalTransition *transition1 = state1-&gt;addTransition(button, SIGNAL(clicked()), state2);transition1-&gt;addAnimation(new QPropertyAnimation(button, \"geometry\"));QSignalTransition *transition2 = state2-&gt;addTransition(button, SIGNAL(clicked()), state1);transition2-&gt;addAnimation(new QPropertyAnimation(button, \"geometry\"));machine-&gt;start(); 参考：https://blog.csdn.net/liang19890820/article/details/51850579 自定义属性通过自定义属性alpha，来使用动画设置标签的样式。 Q_PROPERTY(int alpha READ alpha WRITE setAlpha) 源码123456789101112131415161718192021222324#ifndef MAIN_WINDOW_H#define MAIN_WINDOW_H...class MainWindow : public CustomWindow{ Q_OBJECT Q_PROPERTY(int alpha READ alpha WRITE setAlpha)public: explicit MainWindow(QWidget *parent = 0); ~MainWindow();private: int alpha() const; void setAlpha(const int alpha);private: int m_nAlpha; QLabel *m_pLabel;};#endif // MAIN_WINDOW_H 123456789101112131415161718192021222324252627282930313233343536373839#include \"main_window.h\"MainWindow::MainWindow(QWidget *parent) : CustomWindow(parent){ ... QPushButton *pStartButton = new QPushButton(this); pStartButton-&gt;setText(QString::fromLocal8Bit(\"开始动画\")); m_pLabel = new QLabel(this); m_pLabel-&gt;setText(QString::fromLocal8Bit(\"一去丶二三里\")); m_pLabel-&gt;setAlignment(Qt::AlignCenter); m_pLabel-&gt;setStyleSheet(\"color: rgb(0, 160, 230);\"); QPropertyAnimation *pAnimation = new QPropertyAnimation(); pAnimation-&gt;setTargetObject(this); pAnimation-&gt;setPropertyName(\"alpha\"); pAnimation-&gt;setDuration(1000); pAnimation-&gt;setKeyValueAt(0, 255); pAnimation-&gt;setKeyValueAt(0.5, 100); pAnimation-&gt;setKeyValueAt(1, 255); pAnimation-&gt;setLoopCount(-1); //永远运行，直到stop connect(pStartButton, SIGNAL(clicked(bool)), pAnimation, SLOT(start())); ...}int MainWindow::alpha() const{ return m_nAlpha;}void MainWindow::setAlpha(const int alpha){ m_nAlpha = alpha; QString strQSS = QString(\"color: rgb(0, 160, 230); background-color: rgba(10, 160, 105, %1);\").arg(m_nAlpha); m_pLabel-&gt;setStyleSheet(strQSS);} O(∩_∩)O~是不是很easy，如果你想要实现更多其它效果，都可以自定义。但一定要注意以下两点： 需要用QVariantAnimation检测你自定义的QVariant类型是否支持。 声明属性的类必须是一个QObject，必须为属性提供一个setter（这样，QPropertyAnimation才可以设置属性的值）。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"ThinkPHP+Socket","date":"2018-11-25T08:37:00.000Z","path":"2018/11/25/ThinkPHP-Socket/","text":"服务端 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?php // 服务端error_reporting(E_ALL); // 报错级别set_time_limit(0); // 设置长链接$address = \"127.0.0.1\"; // i p$port = 10005; // 端口//创建一个套接字if (($sock = socket_create(AF_INET, SOCK_STREAM, SOL_TCP)) === false) { echo \"创建一个套接字 失败\\n\";}//启动套接字if (socket_bind($sock, $address, $port) === false) { echo \"启动套接字 失败\" . socket_strerror(socket_last_error($sock)) . \"\\n\";}//监听端口if (socket_listen($sock, 5) === false) { echo \"监听端口 失败\" . socket_strerror(socket_last_error($sock)) . \"\\n\";}do { // 接收客户端传来的消息 if (($msgsock = socket_accept($sock)) === false) { echo \"socket_accepty() failed :reason:\" . socket_strerror(socket_last_error($sock)) . \"\\n\"; break; } //echo \"读取客户端传来的消息\".\"\\n\"; $buf = socket_read($msgsock, 8192); $talkback = \"我已经成功接到客户端的信息了。现在我还回信息给客户端\" . \"\\n\"; if (false === socket_write($msgsock, $talkback)) { echo \"socket_write() failed reason:\" . socket_strerror(socket_last_error($sock)) . \"\\n\"; } else { echo \"return info msg ku fu duan success\" . \"\\n\"; } socket_close($msgsock); } while (true);socket_close($sock);?&gt; 客户端12345678910111213141516171819202122&lt;?php // 客户端require(\"./Socket.class.php\");$confing = array( 'persistent' =&gt; false, 'host' =&gt; 'localhost', 'protocol' =&gt; 'tcp', 'port' =&gt; 10005, 'timeout' =&gt; 1800);$Socket = new Socket($confing);if ($Socket-&gt;connect()) { echo \"TP类 创建Socket链接成功！&lt;hr&gt;\";} else { echo \"TP类 创建Socket链接失败！&lt;hr&gt;\";}$data = \"我是客户端，我要发数据给服务端\";$Socket-&gt;write($data);$read = $Socket-&gt;read();//$read 是服务端还回的数据echo $read . \"&lt;hr &gt;\";$Socket-&gt;disconnect();?&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.iwxyi.com/tags/PHP/"},{"name":"Socket","slug":"Socket","permalink":"http://blog.iwxyi.com/tags/Socket/"},{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"http://blog.iwxyi.com/tags/ThinkPHP/"}]},{"title":"汇编MASM-学习笔记","date":"2018-11-19T12:18:00.000Z","path":"2018/11/19/汇编MASM-学习笔记/","text":"运行 DOSBox mount c: d:\\masm C: masm test.asm 回车3次 link test.obj 回车4次 debug test.exe -r 运行 -t 继续 -t 10 运行10条指令 -d 内存 -u 源码 -p 跳过（尤其是库函数） -q 退出 常用指令 assume 声明 mov 复制内存 mov ax, [bx] inc 加一 inc ax dec 减一 jmp 跳转 jmp loop1 cmp 比较大小 cmp ax, bx add 增加某数 add ax, 10 其他指令 ADC 带进位加法 LEA dx, [0000] 相当于MOV字符串 ? 比较大小 cmp cx, 0 比较结果执行下面的语句 ja &gt; above jb &lt; blow jbe &lt;= jae &gt;= jz == （相减为 zero） jnz != 库函数 INT 21 MOV AH 0A 时：接收一个用户输入到 ds[dx] MOV AH 4C 时：退出程序，返回操作系统 寄存器拆开AX = AH + AL只有 AX BX CX DX 这四个可以拆开用 常用代码块声明变量12assume cs:code, ds:data1mov ax, data1 变量加一123mov al, [bx] ; 数据段寄存器DS 到 寄存器inc al ; 增加 1mov [bx], al ; 寄存器 到 DS 循环1for (i = 0; i &lt; 10; i++); 123456mov cx, 0loop1: inc cx cmp cx, 10 jb loop1 while 循环12345i = 10;while (i &gt;= 0) { // P1 i--;} 12345678910mov ax, 10loop1: cmp ax, 0 jb next ;P1 dec ax jmp loop1next: 接收用户输入12345MOV AX, 076AMOV DS, AXMOV DX, 0000MOV AH, 0AINT 21 清屏12345678910111213141516171819 mov ax,cs mov ss,ax mov sp,0x7c00 ;set stack and sp mov ah,0x06 mov al,0 ; 准备清窗口 mov ch,0 ; 左上角的行号 mov cl,0 ; 左上角的列号 mov dh,25 ; 右下角的行号 mov dl,80 ; 右下角的行号 mov bh,0x07; 属性为蓝底白字 int 0x10 ; 执行清空操作@1: jmp @1 times 510-($-$$) db 0 db 0x55,0xaa 画白线123456789101112131415161718 mov al, 0x13 ; VGA320×200×8bit 显示模式 mov ah, 0x00 int 0x10 mov ax, 0x0a000 ; 往显存中放入点数据 mov ds, ax mov dl, 30 mov ax, 0 f: mov bx, ax mov [ds:bx], dl inc ax cmp ax, 50 ja io jmp f io: 画线函数123456789101112131415161718192021org 0x7c00 mov ax, 80 ; y mov bx, 50 ; x1 mov cx, 150 ; x2 call drawline ; 运行画线 ; y:ax, x1:bx, x2:cxdrawline: mov dx, 320 ; 屏幕宽是320 mul dx ; dx *= ax 16位中AX为被乘数，8位中AL为被乘数 sub cx, bx ; cx = x2-x1 线的宽度 add bx, ax ; 横偏移量+横纵偏移量 = 偏移位置 mov dl, 1 ; 色号loop0: mov [ds:bx], dl ; 填充颜色 inc bx ; 偏移位置+1 dec cx ; 循环次数-1 jnz loop0 ; 受到上面的DEC的ZF标志位RET 画竖线123456789101112131415;****************************************; y1-&gt;ax, y2-&gt;cx, x-&gt;bx;****************************************DrawVerticalLine: mov dx, 320 ; w = 320 mov bp, dx sub cx, ax ; y1 = y2-y1 循环次数 mul dx ; ax = w * y1 纵偏移量 add bx, ax ; 横纵偏移量 mov dl, 1x1: mov [ds:bx], dl add bx, bp dec cx jnz x1ret 设置颜色12345678910111213mov al, 1 ; 颜色号mov dx, 0x3c8out dx, almov al, 100 ; R / 4 = 25mov dx, 0x3c9out dx, almov al, 0 ; Gout dx, almov al, 0 ; Bout dx, al 数组123456789;rgb db 100, 0, 0, 0, 100, 0, 0, 0, 100rgb db 100, 0, 0, db 0, 100, 0, db 0, 0, 100mov ax, 0mov ds, axmov si, rgbmov [ds:si], ... ; 偏移地址，si为下标 进栈出栈保存变量123push axmov ax, 0pop ax 定时器每隔18分之一秒运行一次，多个任务的话会被覆盖掉 1mov word [ds:0x20],int_timer0 打印字符函数：在 ex:bx 的位置显示一个 ‘A’ 12345678910int_timer0: mov byte [es:bx],'A' mov byte [es:bx+1],0x0a inc bx ; 自增两次到下次打印的字符 inc bx mov al,0x20 mov dx,0x20 out dx,al ;EOI=0 中断 iret 获取按键输入123456789101112int_key: mov dx, 0x20 ; 下一个键值可以进来了（没有这一段就只能输入一次按键了） mov al, 0x61 out dx, al mov dx, 0x60 ; 读取一次按键 in al, dx cmp al, 0x9e jz func0func0: 显示一个数字12 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.iwxyi.com/tags/学习笔记/"},{"name":"汇编","slug":"汇编","permalink":"http://blog.iwxyi.com/tags/汇编/"}]},{"title":"C简单小知识整理","date":"2018-11-13T00:18:00.000Z","path":"2018/11/13/C简单小知识整理/","text":"C 与 C++相关内容，一部分从网上摘录。个人能力水平有限，不能保证没有错误。 ——王心意，2018.11.13 必知12【必知】整数/整数 = 整数，向下取整。3/5 == 0, 需要改成：3.0/5 == 0.6 1a = 10, a += a *= 4; // 40 + 40 = 80 123a == b &lt; c; // a == (b &lt; c) // 判断a = b &lt; c; // a = (b &lt; c) // 0 或 1b &lt; c == a; // 0 或 1 == a 1for (; ; i++) { /*...*/} 中的 break 不会执行 i++ 语句，continue 会执行 i++ 1字符串复制：while (*p1++ = *p2++); // 谭浩强的书上有 12*p++; /* 地址++ */(*p)++; /* 值++ */ 读入回车解决方案 12345getchar(); // 会读入上一个scanf的回车scanf(\"%c\", &amp;c); // 这是想要的字符while(scanf(\" %c\", &amp;c) != EOF)； // 避免读取回车while(scanf(\"%c%*c\", &amp;c) != EOF); // 强行去掉回车 计算机的浮点值计算有个”不确定尾数“的现象： 120.1+0.2 != 0.3 // 0.300000000000000040.1+0.5 == 0.6 原因在 https://0.30000000000000004.com 123char a[] = \"hello\"; strcpy(a, \"hehe\"); // 正确，字符串常量能当做临时的指针常量char *p = \"hello\"; p[2] = 'a'; // 错误，常量不能改 123int a[5], (*p)[5]; // 指向数组的指针，下标必须明确p = &amp;a;(*p)[i] == a[i]; 1puts(str[2])、strlen(&amp;str[2])、gets(str+2); //都是从第二个位置开始。输入后末尾自动加上 '\\0' （即 ASCII码的 0） 12int a = 3; int &amp;b = a; // 引用类型：对b操作就是对a操作，printf(\"%d\", b)就是3void swap( int &amp;a, int &amp;b); //引用，比指针方便 取 int 或者 long long 变量的某个数字，如：125 / 10 % 10; //倒数第二位 函数 floor( f ) 对浮点数取整，但是因为浮点数误差，一般用：floor( f + 0.5);浮点数陷阱：for (double i = 0; i != 10; i++); // 死循环 升级1printf(\"%d %d %d\", a, a++, a++); //在有些编译器上（实测如VC，不包括VS），从右到左执行，从左到右输出，a=10时会输出：12， 11， 10 1a = b = 3; // 是从右到左开始运算，而非从左到右 不使用临时变量交换两个整数 123a = a + bb = a - ba = a - b 位运算： 123a = a ^ b;b = a ^ b;a = a ^ b; 输出”\\r”字符串，光标位置回调到行首，并逐字覆盖这一行的文字（可用于做表格） 1int i1, i2; // 分配空间（例子）：i1:10008，i2:10004 逆序添加 static int m; 可以让其他文件不能调用变量或者函数，作用域只限于本模块头文件不要定义全局变量（多次调用会报告已声明），可以用 extern 很大的数组比如几百亿的，开到全局（main函数外面，太大了也必须全局），会全部自动初始化成 0 (2^32) - 1 = 4294967295，unsigned 的大小-n 的内部表示是：(2 ^ 32) - n; 判断素数： 1234if (n &lt; 2) return false;for (int i = 2; i * i &lt;= n; i++) if (n % i == 0) return false;return true; 也可以素数筛按照倍数打表（多次用到或数字很大时） int q = 0; !q 的值在 0 和 非零 之间变换 1scanf(\"%*s\"); // 可以跳过输入一个字符串，其他类型同理 123char t[] = \"hello\\0world\";sizeof(t) == 12;strlen(t) == 5; 数字转换成字符串：sprintf(str, \"%d\", num);字符串转换成数字：sscanf(str, \"%d\", &amp;num); 清空queue等STL的数据：que.swap( queue&lt;T&gt;() ) ; //消亡值语义 void指针（仅用于代表地址）： 12345678910void zero(void * data, int bytesize){ char * p = (char *)data; for (int i = 0; i &lt; bytesize; i++) *ptr++ = 0;}int nums[30]; zero(nums, sizeof(nums)); //不管什么类型，都能按照字符（字节）来清零，因为字节总长度不变Person p1; zero(p1, sizeof(p1)); //Person 为 struct 结构体，也能用同一个函数来清零 或者 复制数据 strncat、strncpy：比较安全的函数，第三个参数是数量，比如：sizeof(num)/sizeof(int) 指向函数的指针： 123typedef void (* intFunc)(int i);test1(int a) { printf(\"%d\\n\", a); } // intFunc 就是一个指向函数test1的指针了intFunc func = test1; func(3); 1( a * 2 + 1 ) == ( a &lt;&lt; 1 | 1 )； // 位运算速度快很多很多 1std::ios::sync_with_stdio(false); // 禁用 cin 和 stdin 的同步，大大加快C艹的cin速度，与scanf相差无几（约为三倍） 1a / b % m == a % (m * b) / b // 取模 字符串常量[下标]，例如：\"qwerty\"[4] == 'r' C语言只有一维数组，但数组元素可以是另一个数组，仿真出多维数组 16进制用0x开头，八进制用0开头；小数常量默认double，末尾可加f表示为float；整数常量默认int，末尾可加l表示是long；其他格式同理（然而没必要的，有隐式转换） 随机数（例如rand()函数）并不是真的随机（但有些新设备可以实现真随机） 叨唠// C语言的爸爸是B语言没错 // 即使从面向过程的C语言转到面向对象的C++，你也不一定能找到对象。 // 计算机的减法乘法都是通过加法器来实现的（最终都可以分解为与或非逻辑门组合运算） // 大部分程序员不用关注二进制是啥（但考试要考到） // 你写程序的大部分时间不是在写代码 // 看到这句话将会很开心： 0 error,0 warning // 项目中适当的注释往往比代码本身还重要 // 仅用顺序结构，分支结构和循环结果能写出所有的可计算函数。 // 可以用多个不同的编辑器看看这段注释的颜色：/*/zhushi/*/ 偏僻知识点 来自网络 无符号int自动转换12345678910void foo(){ unsigned int a = 6; int b = -20; (a+b &gt; 6)?puts(\"&gt; 6\") : puts(\"&lt;= 6\"); //输出 &gt;6 /* 原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型，因此-20变成了一个非常大的 正整数，所以该表达式计算出的结果大于 6 */} 数组共同体12345678910111213141516union{ int i; char x[2];}a;void fun(){ a.x[0] = 10; a.x[1] = 2; printf(\"%d-%d-%d\\n\",a.i,a.x[0],a.x[1]);//522-10-2 :说明a.x[0]与a.x[1]互无影响，所以它们的地址是不同的。a.i=a.x[0]+a.x[1]*256(2的8次方); a.i=1027; printf(\"%d-%d-%d\\n\",a.i,a.x[0],a.x[1]);//1027-3-4 1027=(4)*256+(3) a.x[0] = 300; a.x[1] = 10; printf(\"%d-%d-%d\\n\",a.i,a.x[0],a.x[1]);//2604-44-10, a.x[0]=300-256=44;a.i=a.x[0]+a.x[1]*256;} union这种类型，就是内部的变量共同使用一块空间，按照size大的分配，int i 占4个字节，char x[2] 占2个，所以一共分配了4个字节。一共4个字节的内存，对应x来说相当于占用了低2个字节，而给x赋值的1，和10，就存在个位和十位上了（十六进制） 公用体公用一个内存区域sizeof(a)为共用体成员中长度最长的成员的size。即i 1234int: (|_|_|_|_|_|_|_|_|)(|_|_|_|_|_|_|_|_|)(|_|_|_|_|_|_|_|_|)(|_|_|_|_|_|_|_|_|)char x[2] : (|_|_|_|_|_|_|_|_|)(|_|_|_|_|_|_|_|_|) ^ ^ 高地址 低地址 分析： 12a.x[0] = 10 ============&gt;(|0|0|0|0|1|0|1|0|)a.x[1] = 2 ============&gt;(|0|0|0|0|0|0|1|0|) 公用体公用sizeof(int)长度即4字节32为，则赋值后共用体内存为 1a: (|0|0|0|0|0|0|0|0|)(|0|0|0|0|0|0|0|0|)(|0|0|0|0|0|0|1|0|)(|0|0|0|0|1|0|1|0|) a.i 为4字节整型，则 i = 2^9 + 2^3 + 2^1 = 256 + 8 + 2 = 522 宏定义运算1234567891011121314#include &lt;iostream&gt;using namespace std;#define SQR(X) X*Xint main(void){ int i=10,j=5,n=10; n*=i+j;//n=n*(i+j) cout&lt;&lt;n&lt;&lt;endl;//150 int a = 10,k = 2, m=1; a /= SQR(k+m)/SQR(k+m); // 等效于 a /= (k+m*k+m/k+m*k+m) cout&lt;&lt;a&lt;&lt;endl;//1 return 0;} 宏定义运算尽量添加小括号 1#define SQR(X) (X*X) sizeof(union)123456789101112#include &lt;iostream&gt;using namespace std;union A {int a_int1;double a_double;int a_int2;};typedef struct{A a1;char y;} B;class C{double c_double;B b1;A a2;};int main(void){ cout&lt;&lt;sizeof(A)&lt;&lt;endl;//8 cout&lt;&lt;sizeof(B)&lt;&lt;endl;//16 cout&lt;&lt;sizeof(C)&lt;&lt;endl;//32 return 0;} 数组内存分配123456789101112char str1[] = \"abc\";char str2[] = \"abc\";const char str3[] = \"abc\";const char str4[] = \"abc\";const char *str5 = \"abc\";const char *str6 = \"abc\";char *str7 = \"abc\";char *str8 = \"abc\";cout &lt;&lt; ( str1 == str2 ) &lt;&lt; endl; // 0cout &lt;&lt; ( str3 == str4 ) &lt;&lt; endl; // 0cout &lt;&lt; ( str5 == str6 ) &lt;&lt; endl; // 1cout &lt;&lt; ( str7 == str8 ) &lt;&lt; endl; // 1 解答：str1,str2,str3,str4是数组变量，它们有各自的内存空间;而str5,str6,str7,str8是指针，它们指向相同的常量区域。 char &lt;==&gt; int应该不算偏僻，ACM刷题经常会用到（刷题之外就用到的不多了） 123456//一位整数 to char char x=5+'0'; //'5'//一位整数的char to int int y='5'-'0'; //5//获取'a'后面的'd' char z='a'+3;//'d' 自增12345678910111213141516171819202122{ int a = 4; a += (a++);//==&gt;&gt; a=a+(a++); cout&lt;&lt;a&lt;&lt;endl;//9}{ int a = 4; a += (++a);//==&gt;&gt; a = a+(++a); cout&lt;&lt;a&lt;&lt;endl;//10}{ int a = 4; //(a++) += a;//error，\"+=\"左操作数必须为左值 cout&lt;&lt;a&lt;&lt;endl;}{ int a = 4; (++a) += (a++); //A=(++a); //A=A+(a++) cout&lt;&lt;a&lt;&lt;endl;//11} 总结：(a++),在整个表达式执行完后，才+1;(++a),在整个表达式执行前就+1; 连接下一行行尾添加反斜杠 \\ 如果在宏定义中使用，则真正代码也会包括换行。可用来做接口宏。 多行字符串也能用这个来拼接。 数组下标为0数组下标为0时，指针p不分配空间 12345Struct MutableLenArray { int count; char p[0]; }; 任意字符串使用 # 符号 12#define TO_STRING(x) #xconst char *str = TO_STRING( test ); str的内容就是\" test \"，也就是说#会把其后的符号 直接加上双引号。 符号连接##符号会连接两个符号，从而产生新的符号(词法层次)，例如： 12#define SIGN( x ) INT_##xint SIGN( 1 ); 宏被展开后将成为：int INT_1; 变参宏12#define LOG( format, ... ) printf( format, VA_ARGS )LOG( \"%s %d\", str, count ); VA_ARGS是系统预定义宏，被自动替换为参数列表。 宏例外当一个宏参数被放进宏体时，如果宏体（外部的宏）参数有#，则宏体的参数不会展开。若要展开，则需要借助第三个宏 123#define PARAM(x) PARAM1(x)#define PARAM1( x ) #x #define ADDPARAM( x ) INT_##x 函数参数指针与引用函数参数指针和引用的区别：引用必须已经初始化，且不能为空；指针可以 const修饰指针12345678int a = 1;// const在*左侧，修饰指针指向的变量，表示指针指向的是常量，即(*a)不允许改变const int *b = &amp;a;int const *c = &amp;a;// const在*右侧，修饰指针，表示指针指向的位置不能改变，且必须定义时初始化int* const d = &amp;a;// 均为常量const int* const e = &amp;a; const引用常量const 引用能引用常量：const double &amp;PI = 3.14 非const不能引用常量 const函数int fun() const; 只读函数，不允许修改其中成员变量 const int *fun(); 修饰的是返回值，返回常量（这里是指向常量的指针） const对象只能调用const函数；const成员函数中无法调用非const成员变量，也无法修改const成员变量 如果在常函数中真的需要修改某个成员变量的数据，那么需要这个成员被 mutable修饰 C与C++的bool C++具有真的布尔类型，bool是C++中的关键字，在C语言中使用布尔类型需要导入头文件stdbool.h（在C11中bool应该是数据类型了）。 在C++中 true false 是关键字，而在C语言中不是。 在C++中 true false 是1字节，而C语言中是4字节。 C++的void* C语言中void* 可以与任意类型指针 自动转换。 C++中void*不能给其他类型的指针直接赋值，必须强制类型转换，但其他类型的指针可以自动给void*赋值。 C++为什么这样修改void*？为了更安全，所以C++类型检查更严格。 操作符别名某些特殊语言的键没有~,&amp;符号，国际标准化组织为一些操作符规定了别名，以便使用这些语言的键盘也能输入正确的C/C++代码。 C95和C++98以后的语言标准都支持ISO-646 123456and &amp;&amp;or ||not !{ &lt;% } %&gt;# :% 确定函数的步骤 候选函数函数调用的第一步就是确定所有可调用的函数的集合（函数名、作用域），该集合中的函数就是候选函数。 选择可行函数从候选函数中选择一个或多个函数，选择的标准是参数个数相同，而且通过类型提升实参可被隐式转换为形参。 寻找最佳匹配优先每个参数都完全匹配的方案，其次参数完全匹配的个数，再其次是浪费内存的字节数。 new/delete和malloc/free的区别？ 不同点： 方面 new/delete malloc/free 身份 运算符 标准库函数 参数 类型（自动计算） 字节数（手动计算） 返回值 带类型的地址 void*地址 调用构造 自动调用 不能调用构造/析构函数 出错 抛出异常 返回NULL 相同点： 都能管理堆内存 不能重复释放 可以释放NULL 当分配的内存过大，没有能满足需求的整块内存就会抛出异常 std::bad_alloc new/delete/new[]/delete[]运算符重载 C++缺省的堆内存管理器速度较慢，重载new/delete底层使用malloc/free可以提高运行速度 new在失败会产生异常，而每次使用new时为了安全都应该进行异常捕获，而重载new操作符只需要在操作符函数中进行一次错误处理即可。 在一些占字节数比较小的类，频繁使用new，可能会产生大量的内存碎片，而重载new操作符后，可以适当的扩大每次申请的字节数，减少内存碎片产生的机率。 重载 new/delete 可以记录堆内存使用的信息 重载 delete 可以检查到释放内存失败时的信息，检查到内存泄漏。 类对象的创建过程与释放过程。创建：分配内存（对象）-&gt; 父类构造-&gt; 成员构造-&gt; 自己构造父类构造：按照继承表从左到右依次构造。成员构造：按照声明顺序从上至下依次构造。 释放：自己析构-&gt; 成员析构-&gt; 父类析构-&gt; 释放内存（对象）成员析构：按照声明顺序从下到上依次构造。父类析构：按照继承表从右到左依次构造。 操作符重载成员函数 12const 类 operator#(const 类&amp; that) const{ return 类(参数#参数); } 全局函数(可以加友元) 1const 类 operator#(const 类&amp; a,const 类&amp; b) {} 赋值类型时去掉左const 特殊操作符的重载 下标操作符[] 1类型&amp; operator[](int i){} 函数操作符() 一个类如果重载函数操作符，那么它的对象就可以像函数一样使用，参数的个数、返回值类型，可以不确定，它是唯一一个可以参数有缺省参数的操作符 解引用操作符*、成员访问操作符-&gt;像指针一样使用（智能指针） 运算符重载的注意点 不能重载的操作符 域限定符 :: 直接成员访问操作符 . 三目操作符 ?: 字节长度操作符 sizeof 类型信息操作符 typeid 重载操作符不能修改操作符的优先级 无法重载所有基本类型的操作符运算 不能修改操作符的参数个数 不能发明新的操作符 钻石继承一个子类继承多个父类，这些父类有一个共同的祖先，这种继承叫钻石继承。钻石继承不会导致继承错误，但访问祖先类中的成员时每次需要使用 类名::成员名 ，重点是这种继承会造成冗余。 虚继承当进行钻石继承时，祖先类中的内容会有冗余，而进行虚继承后，在子类中的内容只会保留一份。注意：但使用虚继承时，子类中会多了一些内容（指向从祖先类继承来的成员）。 类型信息typeid用于获取数据的类型信息，同时还支持 == != 用来比较是否是同一种类型，或者是否具有继承关系（但没法判断出实际new的对象类型） 1if (typeid(a) == typeid(b)) 123Parent* p = new Child();cout &lt;&lt; (typeid(*p) == typeid(Child)) &lt;&lt; endl;cout &lt;&lt; (typeid(p) == typeid(Child*)) &lt;&lt; endl; C语言主要关键词基本类型：int, short,long, signed, unsigned,char,float, double,void 控制：if...else, switch...case...default, for , while, do...while,return, break, continue,goto 自定义类型：enum, struct, union, typedef 修饰词：const, static, extern, inline, restrict, volatile 运算符：+, -, *,/, %,++,--,&amp;,| ,~, ^,&amp;&amp;,||,!,&lt;,&gt;,&lt;=,&gt;=,==,!=, &lt;&lt;,&gt;&gt;, ., -&gt;,?:,sizeof及复合运算符 预处理器：#include, #define, #undef, #if/#ifdef/#ifndef...#elif...#else...#endif, defined, #pragma,#error 有极少数关键字有多种语义，例如static、void 掌握上面这些就算入门了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C语言","slug":"C语言","permalink":"http://blog.iwxyi.com/tags/C语言/"},{"name":"整理","slug":"整理","permalink":"http://blog.iwxyi.com/tags/整理/"}]},{"title":"Qt使用MySQL数据库","date":"2018-11-06T09:43:00.000Z","path":"2018/11/06/Qt使用MySQL数据库/","text":"增删改查1、实现对MySql得数据库插入操作 1234567QSqlQuery query(dbconn);query.prepare(\"INSERT INTO faceimage(FaceData,StrName,Sijian,Shijian)\" \"VALUES(:FaceData,:StrName,:Sijian,:Shijian)\"); query.bindValue(\":FaceData\",this-&gt;ui-&gt;ImageLabel-&gt;text()); query.bindValue(\":StrName\",this-&gt;ui-&gt;userName-&gt;text());query.bindValue(\":Sijian\",this-&gt;ui-&gt;idNumber-&gt;text());query.bindValue(\":Shijian\",Catchtime);query.exec(); 2、实现对MySql得数据库删除操作 1234QSqlQuery query(dbconn);query.prepare(QString(\"DELETE FROM faceimage WHERE Faceid=?\"));query.addBindValue(Faceid);query.exec(); 3、实现对MySql得数据库得更新操作 12345query.prepare(\"update faceimage set StrName=?,Sijian=? where Faceid=?\");query.addBindValue(this-&gt;ui-&gt;XGuserName-&gt;text());query.addBindValue(this-&gt;ui-&gt;XGidNumber-&gt;text());query.addBindValue(Faceid);query.exec(); 4、实现对MySql数据库得遍历操作 12345678910 QSqlQuery query(dbconn); query.prepare(sql); while(query.next()) { m_model-&gt;setItem(i,0,new QStandardItem(query.value(0).toString())); m_model-&gt;setItem(i,1,new QStandardItem(query.value(3).toString())); m_model-&gt;setItem(i,2,new QStandardItem(query.value(6).toString())); m_model-&gt;setItem(i,3,new QStandardItem(query.value(2).toString())); i++;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"MySQL","slug":"MySQL","permalink":"http://blog.iwxyi.com/tags/MySQL/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"C++多个文件共用全局变量","date":"2018-11-06T00:01:00.000Z","path":"2018/11/06/C-多个文件共用全局变量/","text":"示例： 头文件：state.h 源文件：state.cpp其它源文件：t1.cpp t2.cpp t3.cpp, 这些源文件都包含头文件state.h。 需要定义一个全局变量供这些源文件中使用：方法如下 1、在state.h中声明全局变量： extern int a; 2、在state.cpp中定义该全局变量：int a =10; 这样其它源文件就可以使用该变量啦，只需要 include 一下 state.cpp 这里需要的是“声明”，不是“定义”！根据C++标准的规定，一个变量声明必须同时满足两个条件，否则就是定义： (1)声明必须使用extern关键字；(2)不能给变量赋初值 extern int a; //声明 int a; //定义 int a = 0; //定义 extern int a =0; //定义 头文件中应使用extern关键字声明全局变量（不定义），如果这个变量有多个文件用到，可以新建一个cpp，在其中定义，把这个cpp加入工程即可。头文件请不要定义任何变量，那是非常业余的行为…… 定义专用的 .cpp 文件不需要 include 一般在头文件中声明，用extern；在cpp中定义。 如果在头文件中定义，如果这个头文件被多个cpp引用，会造成重复定义的链接错误。 头文件只能申明全局变量（extern），不可定义（不推荐使用）.cpp里，在最外层定义即可（int gi），直接引用 如果在.cpp里使用static定义，则该变量只在当前cpp文件中有效，在别的文件中无效在.h里使用static定义，不会进行编译（.h文件不编译），只会在其每个include的cpp文件中包含编译，相当于在.cpp里使用static定义。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"}]},{"title":"Qt QTextEdit特定行改变指针","date":"2018-11-05T12:05:00.000Z","path":"2018/11/05/Qt-QTextEdit特定行改变指针/","text":"行文本形式如下&lt;&lt;word 文档标题&gt;&gt; [word 文档路径] 段落序号 123456789101112131415161718192021222324252627282930313233343536373839void DzfContentEdit::mouseMoveEvent(QMouseEvent *e){ QTextEdit::mouseMoveEvent(e); // 得到鼠标下行文本 auto pos = e-&gt;pos(); auto cursor = cursorForPosition(pos); cursor.select(QTextCursor::LineUnderCursor); auto line = cursor.selectedText(); QRegExp reg(\"\\\\[(.*docx?)\\\\]\"); if(reg.indexIn(line) != -1){ // 得到文件路径 doc_ = reg.capturedTexts().at(1); // 若在指定行上, 改变鼠标形状 viewport()-&gt;setCursor(Qt::PointingHandCursor); }else{ doc_.clear(); // 若不在指定行上, 恢复鼠标形状 viewport()-&gt;setCursor(Qt::IBeamCursor); }}/**/void DzfContentEdit::mouseDoubleClickEvent(QMouseEvent *e){ if(!doc_.isEmpty()){ // 文件路径前不加上 \"file:///\", 路径中含中文字符时出现乱码 doc_.prepend(\"file:///\"); // 打开文件 QDesktopServices::openUrl(QUrl(doc_)); }else{ QTextEdit::mouseDoubleClickEvent(e); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"ThinkPHP view模板用法","date":"2018-11-05T08:38:00.000Z","path":"2018/11/05/ThinkPHP-view模板用法/","text":"标签123&lt;if condition=\"$monthItem eq I('get.monthParam') \"&gt;...&lt;/if&gt; 1234&lt;eq name=\"userData.user_level\" value=\"3\"&gt; &lt;li&gt;&lt;a href=\"\" title=\"\"&gt;管理员功能&lt;/a&gt;&lt;/li&gt;&lt;else/&gt;&lt;/eq&gt; 获取系统变量普通的模板变量需要首先赋值后才能在模板中输出，但是系统变量则不需要，可以直接在模板中输出，系统变量的输出通常以$Think开头，例如： 1234{$Think.server.script_name} // 输出$_SERVER['SCRIPT_NAME']变量{$Think.session.user_id} // 输出$_SESSION['user_id']变量{$Think.get.pageNumber} // 输出$_GET['pageNumber']变量{$Think.cookie.name} // 输出$_COOKIE['name']变量 获取网址123{:request()-&gt;module()} // 模块{:request()-&gt;controller()} // 控制器，注意区分大小写的{:request()-&gt;action()} // 触发器 12&lt;!-- 导航菜单 --&gt;&lt;li {eq name=\":request()-&gt;controller()\" value=\"Room\"}class=\"active\"{/eq}&gt;&lt;a href=\"{:url('Room/index')}\"&gt;房间管理&lt;/a&gt;&lt;/li&gt; 网址重定向1{:url('Login/index')} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.iwxyi.com/tags/PHP/"},{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"http://blog.iwxyi.com/tags/ThinkPHP/"}]},{"title":"贪心算法-讲解","date":"2018-11-04T12:46:00.000Z","path":"2018/11/04/贪心算法/","text":"ACM 贪心算法贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。 例题钱币找零问题假设1元、2元、5元、10元、20元、50元、100元的纸币分别有c0, c1, c2, c3, c4, c5, c6张。现在要用这些钱来支付K元，至少要用多少张纸币？ 代码12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;using namespace std;const int N=7;int Count[N]={3,0,2,1,0,3,5};int Value[N]={1,2,5,10,20,50,100};int main(){ int money; scanf(\"%d\", &amp;money); int num = 0; for(int i=N-1;i&gt;=0;i--) { int c=min(money/Value[i],Count[i]); money=money-c*Value[i]; num+=c; } if(num!=-1) printf(\"%d\\n\", num); else printf(\"NO\\n\");} 可分割背包问题有一个背包，背包容量是M，有N个物品，要求尽可能让装入背包中的物品总价值最大，但不能超过总容量，物品可以只取一部分。 输入第一行输入一个正整数n（1&lt;=n&lt;=5）,表示有n组测试数据；随后有n测试数据，每组测试数据的第一行有两个正整数s，m（1&lt;=s&lt;=10）;s表示有s个物品。接下来的s行每行有两个正整数v，w，分别表示物品的单位价值和总质量。输出输出每组测试数据中背包内的物品的价值和，每次输出占一行。样例输入 1234513 155 102 83 9 样例输出 165 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;#define MAXN 10000int main(int argc, char const *argv[]){ int T; scanf(\"%d\", &amp;T); while (T--) { int n, m; int v[MAXN], w[MAXN]; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) scanf(\"%d%d\", &amp;v[i], &amp;w[i]); for (int i = 0; i &lt; n - 1; i++) for (int j = 0; j &lt; n - i - 1; j++) if (v[j] &lt; v[j + 1]) { int temp = v[j]; v[j] = v[j + 1]; v[j + 1] = temp; temp = w[j]; w[j] = w[j + 1]; w[j + 1] = temp; } int ans = 0; for (int i = 0; i &lt; n; i++) { if (w[i] &gt;= m) { ans += m * v[i]; m = 0; break; } else { ans += w[i] * v[i]; m -= w[i]; } } printf(\"%d\\n\", ans); } return 0;} 排序冒泡排序12345678for (int i = 0; i &lt; len - 1; i++) for (int j = 0; j &lt; len - 1 - i; j++) if (arr[j] &gt; arr[j + 1]) { temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } 选择排序12345678910for(i = 0; i &lt; n-1; i++){ min = i;//查找最小值 for(j = i+1; j&lt;n; j++) if(A[min] &gt; A[j]) min = j; if(min != i) swap(&amp;A[min], &amp;A[i]);} 其他排序已经帮你们百度好的链接 建议用C++的 algorithm 头文件中的 sort 函数，也是ACM中最常用的排序算法。 缺点贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。 ⑴贪心策略：总价值最大反例： W=30物品：A B C重量：28 12 12价值：30 20 20 根据策略，首先选取物品A，接下来就无法再选取了，可是，选取B、C则更好。 ⑵贪心策略：重量最小它的反例与第一种策略的反例差不多。 ⑶贪心策略：单位量价值最大反例： W=30物品：A B C重量：28 20 10价值：28 20 10 根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择A，则答案错误。 【注意：如果物品可以分割为任意大小，那么策略3可得最优解】 (4)DP问题（动态规划）W=40物品：A B C重量：25 20 15价值：25 20 15 这需要DP。 题目今年暑假不AC（节目表）“今年暑假不AC？”“是的。”“那你干什么呢？”“看世界杯呀，笨蛋！”“@#$%^&amp;*%…” 确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的《开心辞典》等等，假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目） Input 输入数据包含多个测试实例，每个测试实例的第一行只有一个整数n(n&lt;=100)，表示你喜欢看的节目的总数，然后是n行数据，每行包括两个数据Ti_s,Ti_e (1&lt;=i&lt;=n)，分别表示第i个节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。n=0表示输入结束，不做处理。 Output 对于每个测试实例，输出能完整看到的电视节目的个数，每个测试实例的输出占一行。 Sample Input 123456789101112131412 1 3 3 4 0 7 3 8 15 19 15 20 10 15 8 18 6 12 5 10 4 14 2 9 0 Sample Output 15 代码（HDU 2037）123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;int main(int argc, const char *argv[]){ int i, n, j, tmp; while (scanf(\"%d\", &amp;n) != EOF &amp;&amp; n != 0) { int count = 1, a[100] = {0}, b[100] = {0}; for (i = 0; i &lt; n; i++) scanf(\"%d %d\", &amp;a[i], &amp;b[i]); for (i = 0; i &lt; (n - 1); i++) { for (j = 0; j &lt; (n - 1 - i); j++) { if (b[j] &gt; b[j + 1]) { tmp = a[j]; a[j] = a[j + 1]; a[j + 1] = tmp; tmp = b[j]; b[j] = b[j + 1]; b[j + 1] = tmp; } } } int time = 0; for (i = 1; i &lt; n; i++) { if (a[i] &gt;= b [time]) { time = i; count++; } } printf(\"%d\\n\", count); } return 0;} 阶乘之和描述给你一个非负数整数n，判断n是不是一些数（这些数不允许重复使用，且为正数）的阶乘之和，如9=1！+2!+3!，如果是，则输出Yes，否则输出No； 输入第一行有一个整数0&lt;m&lt;100,表示有m组测试数据；每组测试数据有一个正整数n&lt;1000000;输出如果符合条件，输出Yes，否则输出No;样例输入 122910 样例输出 12YesNo 喷水装置（一）描述现有一块草坪，长为20米，宽为2米，要在横中心线上放置半径为Ri的喷水装置，每个喷水装置的效果都会让以它为中心的半径为实数Ri(0&lt;Ri&lt;15)的圆被湿润，这有充足的喷水装置i（1&lt;i&lt;600)个，并且一定能把草坪全部湿润，你要做的是：选择尽量少的喷水装置，把整个草坪的全部湿润。 输入第一行m表示有m组测试数据每一组测试数据的第一行有一个整数数n，n表示共有n个喷水装置，随后的一行，有n个实数ri，ri表示该喷水装置能覆盖的圆的半径。 输出输出所用装置的个数 样例输入 12345252 3.2 4 4.5 6 101 2 3 1 2 1.2 3 1.1 1 2 样例输出 1225 &gt; 喷水装置（二）改成二维，输入装置个数n、草坪宽 w、高 h（实数），以及每个喷水装置的横坐标和半径。其余题意同上一题。 过河问题描述在漆黑的夜里，N位旅行者来到了一座狭窄而且没有护栏的桥边。如果不借助手电筒的话，大家是无论如何也不敢过桥去的。不幸的是，N个人一共只带了一只手电筒，而桥窄得只够让两个人同时过。如果各自单独过桥的话，N人所需要的时间已知；而如果两人同时过桥，所需要的时间就是走得比较慢的那个人单独行动时所需的时间。问题是，如何设计一个方案，让这N人尽快过桥。 输入第一行是一个整数T(1&lt;=T&lt;=20)表示测试数据的组数每组测试数据的第一行是一个整数N(1&lt;=N&lt;=1000)表示共有N个人要过河每组测试数据的第二行是N个整数Si,表示此人过河所需要花时间。(0&lt;Si&lt;=100)输出输出所有人都过河需要用的最少时间样例输入 123141 2 5 10 样例输出 117 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"算法","slug":"算法","permalink":"http://blog.iwxyi.com/tags/算法/"},{"name":"讲解","slug":"讲解","permalink":"http://blog.iwxyi.com/tags/讲解/"}]},{"title":"ThinkPHP5-学习笔记","date":"2018-11-04T08:36:00.000Z","path":"2018/11/04/ThinkPHP5-学习笔记/","text":"运行单一入口：index.php12345&lt;?phpdefine('APP_DEBUG', true);define('APP_NAME', 'App'); // 定义应用名称define('APP_PATH', './App2'); // 应用路径，生成目录下 /App/ 文件夹，注意别忘了最后的斜线require './ThinkPHP/ThinkPHP.php'; // 加载 ThinkPHP 运行流程：索引控制器123456789101112131415&lt;?php$module = isset($_GET['m']) ? $_GET['m'] : 'Index';$action = isset($_GET['a']) ? $_GET['a'] : 'Index';$mooc = new $module();$mooc-&gt;$action();class index{ function __construct() {echo \"I'm index controler&lt;br /&gt;\"; } function Index() {echo \"这是 index 控制器的 index 方法&lt;br /&gt;\"; } function test() {echo \"这是 index 控制器的 test 方法&lt;br /&gt;\"; }} 在浏览器地址栏输入： 网站地址/?m=index&amp;a=index 来访问 index 的 index 方法使用 ?m=index&amp;a=test 来访问 index 的 test 方法 也可以多建几个 class 和 function，达到不同的 module 和 function 目录结构解析 Common 存放当前项目的公共函数 Conf 存放当前项目的配置文件 Lang 存放当前项目的语言包 Lib 存放当前项目的控制器和模型 （存放MVC中的M、C） Runtime 存放当前显示的运行时的文件：\\Cache\\、\\Date\\、\\Logs\\、\\Temp\\、~runtime.php Tpl 存放当前项目的模板文件 （存放MVC中的V） ThinkPHP 配置文件全局设置总的文件路径：\\ThinkPHP\\Conf\\convention.php 每个程序的设置应用配置路径：\\[应用名]\\Common\\Conf\\config.php 12345&lt;?phpreturn array( //'配置项'=&gt;'配置值' 'name'=&gt;'Hello'); 如果有自定义配置文件，而且入口的 APP_DEBUG 不是为 true 的话，修改了默认的配置文件后，程序不会重新编译，需要重启才能生效。 控制配置路径：[应用名]\\Home\\Controller\\IndexController.class.php 123456789&lt;?php// 本类由系统自动生成，仅供测试用途namespace Home\\Controller;use Think\\Controller;class IndexController extends Controller { public function index(){ echo C('name'); // 根据上面的配置项，输出 Hello }} 针对每个程序的配置，不会和其他程序公用 用户自定义配置文件配置文件：\\[应用名]\\Common\\Conf\\config.php 123456&lt;?phpreturn array( //'配置项'=&gt;'配置值' 'name'=&gt;'Hello', 'LOAD_EXT_CONFIG'=&gt;'user' // 加上这一句); 新建：\\[应用名]\\Common\\Conf\\user.php 12345&lt;?phpreturn array( //'配置项'=&gt;'配置值' 'user'=&gt;'UUU'); 可以直接用 echo C('user'); 来输出配置值 URL 模式URL_MODEL 1 默认模式 pathinfo 模式 0 普通模式 2 重写模式 3 兼容模式 在配置文件：[应用名]\\Home\\Controller\\IndexController.class.php 的 index 方法中加上： 1echo C('URL_MODEL'); 来显示当前的URL模式。 U() 方法U(‘模块/方法’, array(‘id’=&gt;1), ‘xxx html htm sthml’, true/false, ‘localhost’); 参数2：URL后面传的值 参数3：后缀 参数4：是否需要跳转，true的话会加上 http://127.0.0.1前缀，（并直接跳转？） 参数5：域名 用来显示对应的完整的URL 示例编辑配置文件：[应用名]\\Home\\Controller\\IndexController.class.php 123456789101112131415&lt;?php// 本类由系统自动生成，仅供测试用途namespace Home\\Controller;use Think\\Controller;class IndexController extends Controller { public function index(){ echo C('URL_MODEL') . \"&lt;br /&gt;\"; echo U('Index/user', array('id'=&gt;1), 'html', false, 'localhost'); } public function user() { echo 'id:' . $_GET['id'] . '&lt;br /&gt;'; echo \"这是 Index 模块的 user 方法\"; }} 打开网站首页，运行结果： 121/ThinkPHP/index.php/Home/Index/user/id/1.html 访问网址localhost/ThinkPHP/index.php/Home/Index/user/id/1.html，出现结果： 12id:1这是 Index 模块的 user 方法 修改URL模式程序配置文件 \\[应用名]\\Common\\Conf\\config.php 加上配置项： 1'URL_MODEL'=&gt;0 或者可以在全局配置文件 \\ThinkPHP\\Conf\\convention.php 中修改 模式说明网站路径为：http://localhost/ThinkPHP/ 1 默认模式：http://localhost/ThinkPHP/index.php/Home/Index/user/id/1.html 0 普通模式：http://localhost/ThinkPHP/index.php?m=Index&amp;a=user&amp;id=1 2 重写模式：http://localhost/ThinkPHP/Index/user/id/1.html 需要开启Apache的重写 3 兼容模式：http://localhost/ThinkPHP/index.php?s=/Home/Index/user/id/1.html 隐藏 index.php即重写模式 打开 Apache 的配置文件 httpd.conf，搜索 rewrite.so ，去除前面的 “#” 号 1#LoadModule rewrite_module modules/mod_rewrite.so // 去除前面的 # 号 重启 Apache 项目目录下建立一个文件：.htaccess，写入以下内容： 123456&lt;Ifmodule mod_rewrite.c&gt;RewriteEngine onRewriteCond %{REQUEST_FILENAME} !-dRewriteCond %{REQUEST_FILENAME} !-fRewriteRule ^(.*)$ index.php/$1 [QSA,PT,L]&lt;/Ifmodule&gt; 分别是：开启重写引擎、重写判断条件、重写规则（正则） 404 Not Found : No input file specified 在Fastcgi模式下，php不支持rewrite的目标网址的PATH_INFO的解析，当我们的 ThinkPHP运行在URL_MODEL=2时，就会出现 No input file specified.的情况。这时可以修改网站目录的.htaccess文件： 将 RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L] 改为 RewriteRule ^(.*)$ index.php?s=$1 [QSA,PT,L] URL 伪静态把 shtml 改成和 html 一样作为后缀名来识别 全局配置文件，‘URL_HTML_SUFFIX' =&gt; ‘html’ 在单个项目配置文件中（不建议改全局）改为： 12345&lt;?phpreturn array( // ... =&gt; ..., 'URL_HTML_SUFFIX' =&gt; ‘html|shtml’); 伪静态有益于搜索引擎的抓取 自定义函数库 自动加载自定义函数文件函数文件放在项目公共目录Common下。项目目录下，需要在配置文件Conf/config.php配置自动加载的函数文件的文件名。配置项为\"LOAD_EXT_FILE\"，如\"LOAD_EXT_FILE\"=&gt;\"user,mysqldb\"表示在项目目录下Common/user.php和Common/mysqldb.php两个文件会自动加载。自动加载多项用逗号隔开。 手动加载函数文件使用load函数，如load('@.myfunction');表示系统会加载Common/myfunction.php这个文件。 自动加载自定义类文件类文件放在项目类库Lib下。项目目录下，需要在配置文件Conf/conf.php配置自动加载的函数文件的文件夹。配置项为'APP_AUTOLOAD_PATH' =&gt;'‘, ，如'APP_AUTOLOAD_PATH' =&gt;'@.Common',表示在项目目录下Lib/Common文件夹下的类文件都会被自动加载，当然，类文件名要以***.class.php文件命名。 自动加载多项用逗号隔开。 手动加载类文件使用import()函数。如 import('@.Common.mysqldb');则系统会加载Lib/Common/mysqldb.class.php文件 模板技术建立项目模板模板路径： \\[应用名]\\Home\\View\\模块名\\方法名.html 例如 Index 模块的 index 方法：\\Application\\Home\\View\\Index\\index.html 使用模板1234$this-&gt;display(); // 默认 Index/index$this-&gt;display(\"\"); // 等同于上一个$this-&gt;display(\"Index/test\"); // 非默认模块方法$this-&gt;display(\"test\"); // 默认的模块 Index 可省略 模板的赋值和输出方法一：display()\\[应用名]\\Home\\Controller\\IndexController.class.php： 12345678910&lt;?phpnamespace Home\\Controller;use Think\\Controller;class IndexController extends Controller { public function index(){ $name = 'WXY'; $this-&gt;myname = $name; $this-&gt;display(); }} \\[应用名]\\Home\\View\\Index\\index.html： 123456&lt;html&gt; Hello World~ &lt;?php echo $myname; ?&gt;&lt;/html&gt; 结果： Hello World~WXY 方法二：assign()$this-&gt;assign('变量名', 变量值); \\Home\\Controller\\IndexController.class.php： 123$date = date(\"Y-m-d\");$this-&gt;assign('today', $date)-&gt;assign('weather', 'sun'); // 可连起来$this-&gt;display(); 与直接赋值的区别在于，可以多次连续赋值 模板引擎ThinkTemplate.class.php ：（文件位置未找到） 变量运算和输出控制 \\Home\\Controller\\IndexController.class.php： 1234567891011&lt;?phpnamespace Home\\Controller;use Think\\Controller;class IndexController extends Controller { public function index(){ $me['name'] = 'WXY'; $me['age'] = '20'; $this-&gt;assign('me', $me); $this-&gt;display(); }} 模板 \\[应用名]\\Home\\View\\Index\\index.html： 12345678Hello World~ &lt;br /&gt;{$me['name']} &lt;br /&gt;{$me.name} &lt;br /&gt;{//$me.sex 空的是输出不了的} &lt;br /&gt;{$me.sex|default='man'} &lt;br /&gt;{// $me.age+1 这种是输出不了的} &lt;br /&gt;{$me['age']+1} &lt;br /&gt; 注释是前面加两个斜杠。（也可以在中间加，但是可能会出错） $me.sex|default='man' 如果 sex 没有定义，那么就能输出默认值。 算术运算可以使用+、-、*、/、++、–-，此时必须使用$me['age']这种方式。 调用函数和系统参数控制 \\Home\\Controller\\IndexController.class.php： 123456789101112&lt;?phpnamespace Home\\Controller;use Think\\Controller;class IndexController extends Controller { public function index(){ $me['name'] = 'WXY'; $me['age'] = '20'; $this-&gt;now = time(); $this-&gt;assign('me', $me); $this-&gt;display(); }} 模板 \\[应用名]\\Home\\View\\Index\\index.html： 1234MD5加密：{$me['name']|md5}加密后并截取前五位：{$me['name']|md5|substr=0,5}输出时间：{$now}指定格式的时间：{$now|date='Y-m-d H:i:s',###} 三个#表示传时间戳(即$now)的值 函数等同于在控制文件中执行： 1echo substr(md5($me['name']), 0, 5); 系统变量： 123系统时间：{$Think.now} 输出格式化后的时间系统版本：{$Think.version}系统版本：{$Think.server.http_host} 输出 localhost volist和foreach循环控制 \\[应用名]\\Home\\Controller\\IndexController.class.php： 123456789// 套在外面的class等已略写$person = array( 1 =&gt; array('name'=&gt;'Jack','age'=&gt;'18'), 2 =&gt; array('name'=&gt;'Tom','age'=&gt;'19'), 3 =&gt; array('name'=&gt;'Peter','age'=&gt;'20'), 4 =&gt; array('name'=&gt;'Mary','age'=&gt;'21'),);$this-&gt;assign('person', $person);$this-&gt;display(); 模板文件 \\[应用名]\\Home\\View\\Index\\index.html： 1234name='原变量名' id='循环中的变量名'&lt;volist name='person' id='data'&gt; {$data['name']}-----{$data['age']} &lt;br/&gt;&lt;/volist&gt; 截取一部分： 123从第二个到第三个&lt;volist name='person' id='data' offset='1' length='2'&gt;&lt;/volist&gt; 如果没有数据： 123变量不存在时，输出empty中的内容&lt;volist name='person' id='data' empty='我没数据'&gt;&lt;/volist&gt; 模板文件 \\[应用名]\\Home\\View\\Index\\index.html： 1234name='原变量名' item='循环中的变量名'&lt;foreach name='person' item='data'&gt; {$data['name']}-----{$data['age']} &lt;br/&gt;&lt;/volist&gt; foreach 循环没有截取功能 for循环 eq = neq != gt &gt; egt &gt;= lt &lt; elt &lt;= heq === nheq !=== 123&lt;for start='1' end='10' comparison='elt' name='k'&gt; {$k}&lt;/for&gt; 等同于： 123for ($i = 0; $i &lt; 10; $i++){ echo $i;} if 判断1234&lt;if condition='$num gt 10'&gt; num 大于 10&lt;elseif condition='$num lt 10' /&gt; num 小于 10&lt;else /&gt; num 等于 10&lt;/if&gt; 别忘了 &lt;elseif /&gt; 和 &lt;else /&gt; 后面结束的/符号，如果没有则会继续运行到下一句（类似于break没写）。 switch 判断12345&lt;switch name='peopleName'&gt; &lt;case value='laoshi'&gt;老师&lt;/case&gt; &lt;case value='xiaoming|xiaohong'&gt;学生&lt;/case&gt; &lt;default /&gt;谁都不是&lt;/switch&gt; 同样别忘了 &lt;default /&gt; 后面结束的/符号 比较标签1&lt;比较标签 name='变量名' value='比较的值' &gt; &lt;/比较标签&gt; 123456789&lt;eq name='num' value='10'&gt; num = 10 &lt;else /&gt; num != 10&lt;/eq&gt;&lt;neq name='num' value='12'&gt; num != 12 &lt;/neq&gt;&lt;compare name='num' value='12' type='eq'&gt; num = 12&lt;else /&gt; num != 12&lt;/compare&gt; 区间标签 in 在区间里 notin 不在区间里 between 连续区间 notbetween 不在连续区间 range 只能替换 in 和 notin，不能替换 between 12345678910111213141516&lt;in name='num' value='1,2,3'&gt; 在这个区间&lt;else /&gt; 不在这个区间&lt;/in&gt;&lt;notin name='num' value='1,2,3'&gt; 不在这个区间 &lt;/notin&gt;&lt;between name='num' value='1,10'&gt; 在这个区间&lt;/between&gt;&lt;notbetween name='num' value='1,10'&gt; 不在这个区间&lt;else /&gt; 居然在这个区间&lt;/notbetween&gt;&lt;range name='num' value='1,11,12' type='in'&gt; 有11这个数&lt;else /&gt; 没有11这个数&lt;/range&gt; 三元运算符1{$num &gt; 10 ? '大于10' : '不大于10'} 案例实战判断人物有没有成年 12345&lt;foreach name='person' item='data'&gt; &lt;egt name='data.age' value='18'&gt;{$data.name}已经成年了 &lt;else/&gt;{$data.name}还是个孩子 &lt;/egt&gt; &lt;br/&gt;&lt;/foreach&gt; 原生态PHP标签官方推荐使用&lt;php&gt;而非&lt;?php，因为后者可能会被屏蔽掉。 12345&lt;html&gt;&lt;php&gt; echo \"Hello!\";&lt;/php&gt;&lt;/html&gt; ThinkPHP调试方法开启调试模式 define('APP_DEBUG', true); 创建文件 \\[应用名]\\Conf\\debug.php ： 12345&lt;?php return array( 'name'=&gt;'WXY_Debug', 'SHOW_PAGE_TRACE'=&gt;true, // 显示页面 trace 信息 ); 控制 \\Home\\Controller\\IndexController.class.php： 123456789101112131415161718192021&lt;?phpnamespace Home\\Controller;use Think\\Controller;class IndexController extends Controller { public function index(){ } public function user(){ echo C('name'); // 方法一：输出调试配置中的变量 trace('name', C('name')); // 方法三：trace中的调试 监视变量 dump($_SERVER); // 方法四：输出变量信息 { // 方法五：输出运行时间（毫秒） G('run'); for ($i = 0; $i &lt; 100000; $i++) { $count += $i; } echo G('run','end'); } $this-&gt;displace(); // 方法二：开启trace后右下角会出现信息框 }} 访问路径：ThinkPHP路径/index.php/Index/user 输出：WXY_Debug 把define('APP_DEBUG', true);取消后，就不会输出了 同名变量会覆盖普通配置的变量 数据库连接数据库配置文件：\\[应用名]\\Common\\Conf\\config.php 12345678910111213141516&lt;?phpreturn array( /* ...... */ 'DB_TYPE' =&gt; 'mysql', // 数据类型 'DB_HOST' =&gt; 'localhost', // 数据服务地址 'DB_NAME' =&gt; 'test', // 数据库名 'DB_USER' =&gt; 'root', // 数据库用户名 'DB_PWD' =&gt; 'root', // 数据库用户密码 'DB_PORT' =&gt; '3306', // 数据库端口 'DB_PREFIX' =&gt; 't_', // 数据库表前缀 // 开启主从读写分离 'DB_RW_SEPARATE' =&gt; true, // 多个主数据库服务器 'DB_MASTER_NUM' =&gt; 2,); 实例化模型1、实例化基础模型控制文件：[应用名]/Home/Controller/IndexController.class.php 1234567891011&lt;?phpnamespace Home\\Controller;use Think\\Controller;class IndexController extends Controller { public function index(){ // $user = new Model('notes'); // 这句不知道为什么会导致崩溃，只能用下面的M方法 $user = M('notes'); $data = $user-&gt;select(); dump($data); // 输出所有的信息（数组+映射格式） }} 2、实例化用户自定义模型新建 Model 文件：[应用名]/Home/Model/[名字]Model.class.php格式要规范，例如：UserModel.class.php 12345678&lt;?phpnamespace Home\\Model;use Think\\Model; // 加上这两行，D('Model/User') 可以省略 'Model/'，否则必须全路径class UserModel extends Model { public function getInfo() { return \"Hello World\"; }} Think/Model 方法不存在 解决方法： 需要继承RelationModel，引入use Think\\Model\\RelationModel ; 1234&gt; use Think\\Model\\RelationModel ;&gt; class UserModel extends RelationModel { /*...*/ }&gt; &gt; Controller 文件： 1234// $user = new UserModel(); // 要放到 Home\\Controller 下才能用$user = D('User');$data = $user-&gt;select(); // 需要表存在dump($data); 如果 Model 文件不存在，D()方法会自动执行M()方法，即构建基础Model 3、实例化公共模型能进行一些通用的方法 新建 Model 文件：[应用名]/Home/Model/CommonModel.class.php 12345678&lt;?phpnamespace Home\\Model;use Think\\Model\\RelationModel;class CommonModel extends RelationModel { public function strMake($str) { return md5(sha1(md5($str))); // 统一的字符串加密 }} Controller 文件： 如果提示找不到 CommonModel，顶部加上声明：use Home\\Model\\CommonModel; 1234public function index(){ $user = new CommonModel(); echo $user-&gt;strMake('aaa');} 用户自定义公共模型自定义的XxxModel不要继承Model，继承CommonModel，CommonModel再继承自RelationModel 4、实例化空模型Controller 文件： 123$model = M();$model-&gt;query($sql); // 日常读取 select$model-&gt;execute($sql); // 写入 update insert，返回修改行数（int） CURD操作插入数据controller 文件： 12345$data = array( 'username' =&gt; '', 'password' =&gt; '',);echo M('User')-&gt;add($data); // 返回所在行值 插入多条数据addAll() 方法 （只适合MySQL） 123456789101112131415$data = array( 0 =&gt; array( 'username' =&gt; '000', 'password' =&gt; '00', ), 1 =&gt; array( 'username' =&gt; '111', 'password' =&gt; '11', ), 2 =&gt; array( 'username' =&gt; '222', 'password' =&gt; '22', ),);echo M('User')-&gt;addAll($data); // 返回第一次添加的行数（int） 查询数据M(‘User’)-&gt;select() 会查询两次： Show columns from `user` SELECT * from `user` 如果 debug 开启，那么每次 SELECT 前都会查询字段，并缓存起来。 1、带条件查询： 1$data = M('User')-&gt;where('id=1')-&gt;select(); 2、多个条件查询： 1234$where['id'] = 1;$where['name'] = 'a';$where['_logic'] = 'or'; // 默认where逻辑是 AND$data = M('User')-&gt;where($where)-&gt;select(); 3、表达式查询： 12345678$where['id'] = array('gt', 1); // id &gt; 1$data = M('User')-&gt;where($where)-&gt;select();$where['id'] = array('not between', '1,8'); // id &lt; 1 || id &gt; 8$where['username'] = array('like', '%a'); // name 以 a 结尾$where['username'] = array('like', array('%e', 's%')); // e结尾 OR s开头 4、区间查询 12$where['id'] = array(array('gt',1), array('lt',10)); // 1&lt;id&lt;10，默认 AND 运算$where['id'] = array(array('lt',3), array('gt',100), 'or'); // id&lt;3 OR id&gt;100 5、混合用法 123$where['id'] = array('gt', 10);$where['_string'] = 'score &gt; 10'; // 字符串方式（不建议用，容易被SQL注入）$data = M('User')-&gt;where($where)-&gt;select(); 尽量不要用字符串方式，表达式查询会进行字符串格式化，安全 6、统计用法 1234$data = M('User')-&gt;count();dump($data); // 例如 100条结果 会输出： string(3) \"100\"$data = M('User')-&gt;max('score'); // max min avg sum 都需要带一个参数 更新数据12345678$where['id'] = 1;$data = M('User')-&gt;where($where)-&gt;select();dump($data);$update['score'] = 60;$where['id'] = 1;$data = M('User')-&gt;where($where)-&gt;save($update); // 千万不要写成 update()方法dump($data); // 返回影响的行数 删除数据123$where['id'] = 1;//$data = M('User')-&gt;where($where)-&gt;select();echo M('User')-&gt;where($where)-&gt;delete(); // 输出1 1echo M('User')-&gt;delete(3); // 主要传入主键值（也只能传主键值） 连贯操作排序 order1$data = M('User')-&gt;order('score desc, id asc')-&gt;select(); // score从大到小，ID、从小到大 筛选数据 fieldfield($string, false); 参数一 string 传入多个字段用英文逗号分开 参数二默认为false，即只显示string中的字段；为true时只有string中的字段不显示 1$data = M('User')-&gt;field('id, username')-&gt;select(); // 只显示 id 和 username 限制数据量 limit 和 page12$data = M('User')-&gt;limit(5)-&gt;select(); // 0 ~ 5，序号从0开始$data = M('User')-&gt;limit(2, 5)-&gt;select(); // 2（第三条） ~ 5 12$data = M('User')-&gt;page(1)-&gt;select(); // 第一页，参数二默认每页20条$data = M('User')-&gt;page(1, 5)-&gt;select(); // 第一页，每页5条 分组 group 和 having1M('User')-&gt;field('score, count(*) as total')-&gt;group('score')-&gt;select(); // 每个成绩的数据数量 输出结果示例： 1234567891011arrar(10) { [0] =&gt; array(2) { [\"score\"] =&gt; string(2) \"15\" [\"total\"] =&gt; string(1) \"6\" } [1] =&gt; array(2) { [\"score\"] =&gt; string(2) \"16\" [\"total\"] =&gt; string(1) \"3\" } [2]...} having 12345M('User') -&gt;field('score, count(*) as total') -&gt;having('score &gt;= 20') -&gt;group('score') -&gt;select(); // 超过20分的成绩的数据数量 多表查询table 方法table(array('完整表名'=&gt;'别名')) 如果有前缀，表名一定要加前缀（M方法中的表名参数不用加config中设置的前缀） 123M()-&gt;table(array('tb_user'=&gt;'user', 'tb_info'=&gt;'info')) -&gt;where('user.id=info.userid') -&gt;select(); // tb_ 为表前缀 join 方法12345678910111213141516M('User') -&gt;join('tb_info on tb_info.userid=tb_user.id') -&gt;select(); // 默认是左关联，即tb_info中有但tb_user中没有这条信息，也会查出来，此时相当于tb_user中的内容为空M('User') -&gt;join('Right join tb_info on tb_info.userid=tb_user.id') -&gt;select(); // 右关联M('User') -&gt;join(/**/) -&gt;join(/**/) -&gt;select(); // 使用多个join关联M('User') -&gt;join(array('tb_info on tb_info.userid=tb_user.id', '/**/', '/**/')) -&gt;select(); // 使用join数组关联 union 方法union(string/array, false/true) 参数二默认false，使用union查询；true 为uni查询（去掉重复结果） 12345678910M('User') -&gt;field('username', 'id') -&gt;union('select username, id from tb_user2') -&gt;select(); // 查询 tb_user 和 tb_user2 中的 username 和 idM('User') -&gt;field('username') -&gt;union(array('field'=&gt;'username', 'table'=&gt;'tb_user2')) -&gt;union(array('field'=&gt;'username', 'table'=&gt;'tb_user3')) -&gt;select(); 查询字段的类型（包括field和union中的顺序）必须是一样的 过滤查询 distinct1$data = M('User')-&gt;distinct(true)-&gt;field('score')-&gt;order('score asc')-&gt;select(); // 参数 true 为过滤 关于命名范围的使用查询分数超过60的 [应用名]/Home/Model/UserModel.class.php 12345678910111213141516171819202122&lt;?phpnamespace Home\\Model;use Think\\Model\\RelationModel;class UserModel extends CommonModel { protected $_scope = array( /*'命名范围的标识名' =&gt; array( '属性' =&gt; '值', 支持的方法有：where limit field order table page having group distinct )*/ 'jige' =&gt; array( 'where' =&gt; array( 'score'=&gt;array('egt', 60), ), 'order' =&gt; 'id asc', ), 'ziduan' =&gt; array( 'field' =&gt; 'nickname, score' ) );} [应用名]/Home/Controller/IndexController.class.php 123456public function fanwei(){ $user = D('User'); $data = $user-&gt;scope('jige', 'ziduan')-&gt;select(); echo M()-&gt;getLastSql();} 如果两个命名范围冲突（如一个 limit 10，另一个 limit 5，则后面的会覆盖前面的），没冲突（例如 where 条件）则会用 AND 连接 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.iwxyi.com/tags/学习笔记/"},{"name":"PHP","slug":"PHP","permalink":"http://blog.iwxyi.com/tags/PHP/"},{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"http://blog.iwxyi.com/tags/ThinkPHP/"}]},{"title":"Python解析网络JSON","date":"2018-11-04T05:39:00.000Z","path":"2018/11/04/Python解析网络JSON/","text":"123456789import jsonfrom urllib.request import urlopenurl = \"https://gdata.youtube.com/feeds/api.standardfeeds/top_rated?alt=json\"response = urlopen(url)contents = response.read()text = contents.decode('utf8')data = json.loads(text)for video in data['feed']['entry'][0:6]:print(video['title']['$t']) 第1行：从Python标准库中导入名为json的所有代码。第2行：从Python标准urllib库中导入urlopen函数。第3行：给变量url赋值一个YouTube地址。第4行：连接指定地址处的Web服务器并请求指定的Web服务。第5行：获取响应数据并赋值给变量contents。第6行：把contents解码成一个JSON 格式的文本字符串并赋值给变量text。第7行：把text转换为data——一个存储视频信息的Python数据结构。第8行：每次获取一个视频的信息并赋值给变量video。第8行：使用两层Python字典（data[‘feed’][‘entry’]）和切片操作（[0:6]）。第9行：使用print函数打印出视频标题。 使用第三方Python软件包requests 123456import requestsurl = \"https://gdata.youtube.com/feeds/api.standardfeeds/top_rated?alt=json\"response = requests.get(url)data = response.json()for video in data['feed']['entry'][0:6]:print(video['title']['$t']) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Python","slug":"Python","permalink":"http://blog.iwxyi.com/tags/Python/"}]},{"title":"Android ViewPage模板","date":"2018-10-29T03:02:00.000Z","path":"2018/10/29/Android-ViewPage模板/","text":"多可左右滑动的分页容器模板 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import android.support.v7.app.AppCompatActivity;import android.support.v4.app.Fragment;import android.support.v4.app.FragmentManager;import android.support.v4.app.FragmentPagerAdapter;import android.support.v4.view.ViewPager;import android.os.Bundle;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;public class MainActivity extends AppCompatActivity { private SectionsPagerAdapter mSectionsPagerAdapter; // 适配器 private ViewPager mViewPager; // 容器 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 通过 FragmentManager 创建适配器 mSectionsPagerAdapter = new SectionsPagerAdapter(getSupportFragmentManager()); // 设置 ViewPager 容器 mViewPager = (ViewPager) findViewById(R.id.container); mViewPager.setAdapter(mSectionsPagerAdapter); } /* fragment 类 */ public static class PlaceholderFragment extends Fragment { // 定义一个储存参数的key的常量 private static final String ARG_SECTION_NUMBER = \"section_number\"; public PlaceholderFragment() { } // 创建一个 fragment，好像是工厂模式？（静态） public static PlaceholderFragment newInstance(int sectionNumber) { PlaceholderFragment fragment = new PlaceholderFragment(); Bundle args = new Bundle(); args.putInt(ARG_SECTION_NUMBER, sectionNumber); fragment.setArguments(args); return fragment; } // 返回一个 inflate 的 view，并且读取参数并设置 @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View rootView = inflater.inflate(R.layout.fragment_main, container, false); TextView textView = (TextView) rootView.findViewById(R.id.section_label); textView.setText(getString(R.string.section_format, getArguments().getInt(ARG_SECTION_NUMBER))); return rootView; } } /* 适配器 */ public class SectionsPagerAdapter extends FragmentPagerAdapter { public SectionsPagerAdapter(FragmentManager fm) { super(fm); } // 只在第一次的时候才需要 getItem，创建一个fragment @Override public Fragment getItem(int position) { return PlaceholderFragment.newInstance(position + 1); } @Override public int getCount() { return 3; } }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"},{"name":"模板","slug":"模板","permalink":"http://blog.iwxyi.com/tags/模板/"}]},{"title":"Android Color类颜色值坑点","date":"2018-10-29T02:39:00.000Z","path":"2018/10/29/Android-Color类颜色值坑点/","text":"Color.alpha 0x00~0xFF 00表示完全透明，FF表示完全不透明 其中有两个方法 Color.argb(int alpha, int red, int green, int blue);//设置颜色，同步设置颜色的透明度 Color.rgb(int red, int green, int blue);//设置颜色，默认透明度为0xFF，完全不透明 在面试的时候，笔试的时候，很多题目会提到颜色相同的rgb和argb有哪些？ 如下是我自己验证过的内容 FFAABB = FFFFAABB != 00FFAABB 上面的比较简单，很容易理解，比较容易误导人的是这样的 FFAB ?= FAB 不等于 FFFAB ?= FAB 等于 FFFAB ?= FFAB 不等于 FFAABB ?= FAB 不等于 得出以下结论：在只有单个字符去表示颜色时:F == 0F, A == 0A…，可以使用这个公式去替换掉上面这些公式，转换之后： FFAB ?= FAB -&gt; 0F 0F 0A 0B ?= FF 0F 0A 0B 明显，不相等 FFFAB ?= FAB -&gt; FF 0F 0A 0B ?= FF 0F 0A 0B 相等 FFFAB ?= FFAB -&gt; FF 0F 0A 0B ?= 0F 0F 0A 0B 不相等 FFAABB ?= FAB -&gt; FF FF AA BB ?= FF 0F 0A 0B 不相等 参考：https://blog.csdn.net/sunhengzhi_212/article/details/73028313 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"},{"name":"踩坑","slug":"踩坑","permalink":"http://blog.iwxyi.com/tags/踩坑/"}]},{"title":"Qt QMap","date":"2018-10-27T09:38:00.000Z","path":"2018/10/27/Qt-QMap/","text":"1. 基本应用下面以“键-值”都是QString的例子说明QMap的基本使用方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;qmap.h&gt;#include &lt;iostream&gt;using namespace std;class MapTest{public: void showMap() { if(!m_map.isEmpty()) return; //判断map是否为空 { m_map.insert(“111″, “aaa”); //向map里添加一对“键-值” } if(!m_map.contains(“222″)) //判断map里是否已经包含某“键-值” { m_map.insert(“222″, “bbb”); } m_map[\"333\"] = “ccc”; //另一种添加的方式 //这种方式既可以用于添加，也可以用于获取，但是你必须知道它确实存在 qDebug(“map[333] , value is : ” + m_map[\"333\"]); if(m_map.contains(“111″)) { //找到特定的“键-值”对 QMap&lt;QString,QString&gt;::iterator it = m_map.find(“111″); //获取map里对应的值 qDebug(“find 111 , value is : ” + it.data()); } cout&lt;&lt; endl; qDebug(“size of this map is : %d”, m_map.count()); //获取map包含的总数 cout&lt;&lt; endl; QMap&lt;QString,QString&gt;::iterator it; //遍历map for ( it = m_map.begin(); it != m_map.end(); ++it ) { //用key()和data()分别获取“键”和“值” qDebug( “%s: %s”, it.key().ascii(), it.data().ascii()); } m_map.clear(); //清空map }private: QMap&lt;QString,QString&gt; m_map; //定义一个QMap对象}; 调用类函数showMap(),显示结果： 12345678map[333] , value is : cccfind 111 , value is : aaasize of this map is : 3111: aaa222: bbb333: ccc 2. 对象的使用map当中还可以保存类对象、自己定义类对象。 例子如下（摘自QT帮助文档《Qt Assistant》，更详细的说明参考之）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;qstring.h&gt;#include &lt;qmap.h&gt;#include &lt;qstring.h&gt;// 自定义一个Employee类，包含fn、sn、sal属性class Employee{public: Employee(): sn(0) {} Employee( const QString&amp; forename, const QString&amp; surname, int salary ) : fn(forename), sn(surname), sal(salary) {} QString forename() const { return fn; } QString surname() const { return sn; } int salary() const { return sal; } void setSalary( int salary ) { sal = salary; }private: int sal; QString fn; QString sn;};int main(int argc, char **argv){ QApplication app( argc, argv ); // 自定义一个map类型，值为EmployeeMap对象 typedef QMap&lt;QString, Employee&gt; EmployeeMap; EmployeeMap map; // 向map里插入键-值 map[\"JD001\"] = Employee(“John”, “Doe”, 50000); map[\"JW002\"] = Employee(“Jane”, “Williams”, 80000); map[\"TJ001\"] = Employee(“Tom”, “Jones”, 60000); Employee sasha( “Sasha”, “Hind”, 50000 ); map[\"SH001\"] = sasha; // 修改map值的内容，因为map采用值传递，所以无效 sasha.setSalary( 40000 ); // 批量打印 EmployeeMap::Iterator it; for ( it = map.begin(); it != map.end(); ++it ) { printf( “%s: %s, %s earns %d/n”, it.key().latin1(), it.data().surname().latin1(), it.data().forename().latin1(), it.data().salary() ); } return 0;} 输出结果： 1234JD001: Doe, John earns 50000JW002: Williams, Jane earns 80000SH001: Hind, Sasha earns 50000TJ001: Jones, Tom earns 60000 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"基于Qt的图像处理技术和算法","date":"2018-10-27T08:57:00.000Z","path":"2018/10/27/基于Qt的图像处理技术和算法/","text":"这篇文章主要阐述了如何使用Qt在像素级别上对图像进行操作，并实现了一些图像效果，这些效果主要有：灰度，模糊，锐化，添加相框，金属质感，改变图像饱和度，亮度还有白平衡。 介绍文章中，我们将讨论在Qt中修改图像的一些技术和算法，在这之前，你必须知道在Qt中操作图像的一些方法。 在Qt中有两种表示图像的类，Qt:QImage和QPixmap，还有QBitmap来存储单色的图像，比如遮罩，QPicture在存储QPainter的一些操作指令。 当我们想要在屏幕上绘制图像的时候，最快的方法就是使用QPixmap，不过坏处就是无法访问和修改像素； QImage在IO操作中有很快的速度，并且给出了访问像素的接口，这篇文章中我们就使用这个类。 如果你是要处理大的图片，比如摄像头拍摄的照片，这种情况最好是将原图缩小之后作为预览图显示在屏幕上，除非我们允许用户缩放图像。有两种加载并缩放图像的方法。 将图像加载进QImage或者QPixmap，然后调整大小： 12QImage image(\"sample.png\");image = image.scaled(width, height); 使用QImageReader来读取和缩放图片，然后再加载进QImage中。QImageReader无法将一张图片加载进QPixmap中去，但是可以使用静态方法 QPixmap::fromImage(QImage img)从QImage中加载进QPixmap。这个方法非常快，并且不需要加载大图的内存开销： 1234QImageReader imgReader(\"sample.png\");imgReader.setScaledSize(QSize(width, height));QImage * image;imgReader.read(image); 每一张图片都是由像素点组成，每一个像素都有三个通道：红，绿，蓝，还有一个alpha通道来保存透明度（JPEG格式的图片不支持透明）。每个通道的值是0-255，三个通道都是0的话，表示黑色，都是255表示白色。这篇文章中我们用RGB来表示一种颜色，也就是三个通道的值。 相比于一个像素一个像素地读取，uchar * QImage::scanLine(int i)可以一次读取整行的像素值，会更加高效，下面的例子就是按行读取的例子，也是我们将要讲的第一个例子，转灰度图。 12345678910111213141516QImage * MainWindow::greyScale(QImage * origin){ QImage * newImage = new QImage(origin-&gt;width(), origin-&gt;height(), QImage::Format_ARGB32); QRgb * line; for(int y = 0; y&lt;newImage-&gt;height(); y++){ QRgb * line = (QRgb *)origin-&gt;scanLine(y); for(int x = 0; x&lt;newImage-&gt;width(); x++){ int average = (qRed(line[x]) + qGreen(line[x]) + qRed(line[x]))/3; newImage-&gt;setPixel(x,y, qRgb(average, average, average)); } } return newImage;} 灰度我们要学习的第一个技术就是将彩色图转换成灰度图，我们首先要明白的一点就是，其实标准的灰度图就是每个像素点的三个通道的值一样或者近似，我们的策略就是将每个像素的每个通道的值都调成一样，取R,G,B值为三者的算数平均数就可以了，比如原色是RGB(169,204,69), 那么最终的RGB就是（169+204+69）/3 = 147. 123456789101112131415QImage * MainWindow::greyScale(QImage * origin){ QImage * newImage = new QImage(origin-&gt;width(), origin-&gt;height(), QImage::Format_ARGB32); QColor oldColor; for(int x = 0; x&lt;newImage-&gt;width(); x++){ for(int y = 0; y&lt;newImage-&gt;height(); y++){ oldColor = QColor(origin-&gt;pixel(x,y)); int average = (oldColor.red()+oldColor.green()+oldColor.blue())/3; newImage-&gt;setPixel(x,y,qRgb(average,average,average)); } } return newImage;} 亮度调节就如之前我们提到的，白色用RGB(255,255,255)表示，黑色用RGB(0,0,0)表示，所以如果我们需要提高图片的亮度（颜色接近白色），我们需要同时增加三个通道的数值，反之就是变暗。 在这里我们添加了一个函数参数来决定要提高多少亮度，如果参数是负数的话就是减少亮度了。在每个通道都加上delta值之后，需要做的就是让它不要低于0且不要高于255. 暖色调当我们说一一幅暖色调的图片的时候通常是因为这张图色调偏黄。我们没有黄色的通道，但是红色和绿色混合起来就是黄色，所以我们增加这两个通道值，然后蓝色通道值不变就好了。 我们使用一个delta参数来决定增加红色和绿色通道的值。一张暖色的图片能够给人一种复古效果，如果是有沙子的图片，图片将会更加生动。 123456789101112131415161718192021222324QImage * MainWindow::warm(int delta, QImage * origin){ QImage *newImage = new QImage(origin-&gt;width(), origin-&gt;height(), QImage::Format_ARGB32); QColor oldColor; int r,g,b; for(int x=0; x&lt;newImage-&gt;width(); x++){ for(int y=0; y&lt;newImage-&gt;height(); y++){ oldColor = QColor(origin-&gt;pixel(x,y)); r = oldColor.red() + delta; g = oldColor.green() + delta; b = oldColor.blue(); //we check if the new values are between 0 and 255 r = qBound(0, r, 255); g = qBound(0, g, 255); newImage-&gt;setPixel(x,y, qRgb(r,g,b)); } } return newImage;} 冷色调如果说暖色调的图片偏黄色，那么冷色调的图片应该就是偏蓝色了。在这个方法里面我们只增加蓝色通道的值，红色和绿色的值不变。 冷色调的图片可以联想到未来，死亡或者，冷。 1234567891011121314151617181920212223QImage * MainWindow::cool(int delta, QImage * origin){ QImage *newImage = new QImage(origin-&gt;width(), origin-&gt;height(), QImage::Format_ARGB32); QColor oldColor; int r,g,b; for(int x=0; x&lt;newImage-&gt;width(); x++){ for(int y=0; y&lt;newImage-&gt;height(); y++){ oldColor = QColor(origin-&gt;pixel(x,y)); r = oldColor.red(); g = oldColor.green(); b = oldColor.blue()+delta; //we check if the new value is between 0 and 255 b = qBound(0, b, 255); newImage-&gt;setPixel(x,y, qRgb(r,g,b)); } } return newImage;} 饱和度我们已经说了，颜色由三个通道组成：红，绿，蓝，尽管如此，RGB不是唯一一个表示色彩的方式，在这里，我们使用HSL格式表示色彩 - hue（色相）, saturation（饱和度）, lightness（明度）。 饱和的图像拥有更加生动的颜色，通常会比较好看，但是有一点要记住：不要滥用饱和度，因为很容易出现失真。 123456789101112131415161718192021222324252627QImage * MainWindow::saturation(int delta, QImage * origin){ QImage * newImage = new QImage(origin-&gt;width(), origin-&gt;height(), QImage::Format_ARGB32); QColor oldColor; QColor newColor; int h,s,l; for(int x=0; x&lt;newImage-&gt;width(); x++){ for(int y=0; y&lt;newImage-&gt;height(); y++){ oldColor = QColor(origin-&gt;pixel(x,y)); newColor = oldColor.toHsl(); h = newColor.hue(); s = newColor.saturation()+delta; l = newColor.lightness(); //we check if the new value is between 0 and 255 s = qBound(0, s, 255); newColor.setHsl(h, s, l); newImage-&gt;setPixel(x, y, qRgb(newColor.red(), newColor.green(), newColor.blue())); } } return newImage;} 模糊这个效果相对于之前的有一点点复杂。我们会用到一个卷积滤波器，根据当前像素的颜色和相邻像素的颜色来获得一个新的颜色。同时还有一个kernel的矩阵来决定计算中相邻像素的影响程度。 原像素会在矩阵的中心，因此我们会使用基数行的行和列。我们不会修改边缘的像素点，因为那些点没有我们需要的相邻像素点，虽然我们也可以只使用有效的像素点。 举了例子，让我们来看看如何计算像素的RGB值。下面的三个举证代表着当前像素和邻接像素的RGB值，最中间的是当前像素。 123456789101112131415R = 20 102 99150 200 77 170 210 105G = 22 33 4017 21 338 15 24B = 88 70 5590 72 5985 69 50Kenel = 0 2 02 5 20 2 0 使用滤波器进行计算： 123r = ( (102*2) + (150*2) + (200*5) + (77*2) + (210*2) ) / (2+2+5+2+2) = 159g = ( (33*2) + ( 17*2) + (21*5) + (33*2) + (15*2) ) / (2+2+5+2+2) = 23b = ( (70*2) + (90*2) + (72*5) + (59*2) + (69*2) ) / (2+2+5+2+2) = 72 由原始的RGB(200, 21, 72)得到了RGB(159, 23, 72). 发现最大的变化是红色的通道，因为红色通道的值差距最大。 在修改肖像照片的时候通常会使用到模糊的技术，它能后掩盖住皮肤的瑕疵。 123456789101112131415161718192021222324252627282930313233343536373839QImage * MainWindow::blur(QImage * origin){ QImage * newImage = new QImage(*origin); int kernel [5][5]= {{0,0,1,0,0}, {0,1,3,1,0}, {1,3,7,3,1}, {0,1,3,1,0}, {0,0,1,0,0}}; int kernelSize = 5; int sumKernel = 27; int r,g,b; QColor color; for(int x=kernelSize/2; x&lt;newImage-&gt;width()-(kernelSize/2); x++){ for(int y=kernelSize/2; y&lt;newImage-&gt;height()-(kernelSize/2); y++){ r = 0; g = 0; b = 0; for(int i = -kernelSize/2; i&lt;= kernelSize/2; i++){ for(int j = -kernelSize/2; j&lt;= kernelSize/2; j++){ color = QColor(origin-&gt;pixel(x+i, y+j)); r += color.red()*kernel[kernelSize/2+i][kernelSize/2+j]; g += color.green()*kernel[kernelSize/2+i][kernelSize/2+j]; b += color.blue()*kernel[kernelSize/2+i][kernelSize/2+j]; } } r = qBound(0, r/sumKernel, 255); g = qBound(0, g/sumKernel, 255); b = qBound(0, b/sumKernel, 255); newImage-&gt;setPixel(x,y, qRgb(r,g,b)); } } return newImage;} 锐化像模糊中一样，锐化一张图片也会使用一个卷积滤波器，但是kernel矩阵是不一样的，相邻像素对应的值是负的。 锐化能够处理模糊的照片，能够提升细节。 12345678910111213141516171819202122232425262728293031323334353637QImage * MainWindow::sharpen(QImage * origin){ QImage * newImage = new QImage(* origin); int kernel [3][3]= {{0,-1,0}, {-1,5,-1}, {0,-1,0}}; int kernelSize = 3; int sumKernel = 1; int r,g,b; QColor color; for(int x=kernelSize/2; x&lt;newImage-&gt;width()-(kernelSize/2); x++){ for(int y=kernelSize/2; y&lt;newImage-&gt;height()-(kernelSize/2); y++){ r = 0; g = 0; b = 0; for(int i = -kernelSize/2; i&lt;= kernelSize/2; i++){ for(int j = -kernelSize/2; j&lt;= kernelSize/2; j++){ color = QColor(origin-&gt;pixel(x+i, y+j)); r += color.red()*kernel[kernelSize/2+i][kernelSize/2+j]; g += color.green()*kernel[kernelSize/2+i][kernelSize/2+j]; b += color.blue()*kernel[kernelSize/2+i][kernelSize/2+j]; } } r = qBound(0, r/sumKernel, 255); g = qBound(0, g/sumKernel, 255); b = qBound(0, b/sumKernel, 255); newImage-&gt;setPixel(x,y, qRgb(r,g,b)); } } return newImage;} 添加相框绘制一个相框是非常见到那的，我们只需要把相框在原图上面绘制就可以了。这里假设我们已经有一个和图片一样大小的相框了，不一样的话要resize到一样大。 123456789101112QImage * MainWindow::drawFrame(QImage * origin){ QImage * newImage = new QImage(* origin); QPainter painter; painter.begin(newImage); painter.drawImage(0,0, QImage(\":images/frame.png\")); painter.end(); return newImage;} 参考：https://blog.csdn.net/silangquan/article/details/41008183 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"Android ViewPage","date":"2018-10-27T03:01:00.000Z","path":"2018/10/27/Android-ViewPage/","text":"（注：本篇文章的例子使用的是ConstraintLayout布局方式） ViewPage有两种使用方式，一是直接加载布局文件（使用PagerAdapter），二是加载fragment（使用FragmentPagerAdapter）。 一、直接加载布局文件1. 在主布局中加入ViewPage123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"com.example.test.MainActivity\"&gt; &lt;android.support.v4.view.ViewPager android:id=\"@+id/viewPage\" android:layout_width=\"0dp\" android:layout_height=\"0dp\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\"&gt;&lt;/android.support.v4.view.ViewPager&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 2. 新建三个layout为了方便我们新建三个基本一样的layout。layout1： 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:layout_width=\"0dp\" android:layout_height=\"0dp\" android:text=\"layout1\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintVertical_bias=\"0.498\" tools:layout_constraintBottom_creator=\"1\" tools:layout_constraintLeft_creator=\"1\" tools:layout_constraintRight_creator=\"1\" tools:layout_constraintTop_creator=\"1\" android:layout_marginLeft=\"0dp\" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 这三个布局是添加到ViewPage中的，里面的内容非常简单，当然我们只是为了测试，你可以在其中加入更多的东西。 3. 适配器PagerAdapter新建ViewPageAdapter继承自PagerAdapter： 123456789101112131415161718192021222324252627282930313233343536373839package com.example.test;import android.support.v4.view.PagerAdapter;import android.view.View;import android.view.ViewGroup;import java.util.List;public class ViewPageAdapter extends PagerAdapter { private List&lt;View&gt; list; public ViewPageAdapter(List&lt;View&gt; list) { this.list = list; } // 返回要滑动的VIew的个数 @Override public int getCount() { return list.size(); } @Override public boolean isViewFromObject(View view, Object object) { return view == object; } // 做了两件事，第一：将当前视图添加到container中，第二：返回当前View @Override public Object instantiateItem(ViewGroup container, int position) { container.addView(list.get(position)); return list.get(position); } // 从当前container中删除指定位置（position）的View @Override public void destroyItem(ViewGroup container, int position, Object object) { container.removeView(list.get(position)); }} 4. 在Activity中配置ViewPage123456789101112131415161718192021222324252627282930313233343536package com.example.test;import android.support.v4.view.ViewPager;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.LayoutInflater;import android.view.View;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity { private View view1, view2, view3; private List&lt;View&gt; viewList;//view数组 private ViewPager viewPager; //对应的viewPager @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); viewPager = (ViewPager) findViewById(R.id.viewPage); LayoutInflater inflater=getLayoutInflater(); view1 = inflater.inflate(R.layout.layout1, null); view2 = inflater.inflate(R.layout.layout2,null); view3 = inflater.inflate(R.layout.layout3, null); viewList = new ArrayList&lt;View&gt;();// 将要分页显示的View装入数组中 viewList.add(view1); viewList.add(view2); viewList.add(view3); ViewPageAdapter adapter = new ViewPageAdapter(viewList); viewPager.setAdapter(adapter); }} 上面的代码将layout加载到view中，把view放到数组中并设置到Adapter中，最后给ViewPage设置Adapter。到这里第一种方式实现ViewPage就完成了。 二、加载fragment通过加载fragment设置ViewPage与第一种方式的前两步一样，加载主布局和新建三个layout这里省略直接进行第三步。 3. 新建fragmentfragment1： 12345678910111213141516171819202122232425262728package com.example.test;import android.os.Bundle;import android.support.v4.app.Fragment;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;/** * A simple {@link Fragment} subclass. */ public class Fragment1 extends Fragment { public Fragment1() { // Required empty public constructor } @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View rootView=inflater.inflate(R.layout.layout1, container, false); return rootView; }} 代码很简单，这里新建了三个fragment，分别加载三个layout。 4. 适配器FragmentPagerAdapter新建ViewPageFragmentAdapter继承自FragmentPagerAdapter： 1234567891011121314151617181920212223242526272829303132333435package com.example.test;import android.support.v4.app.Fragment;import android.support.v4.app.FragmentManager;import android.support.v4.app.FragmentPagerAdapter;import java.util.ArrayList;import java.util.List;/** * Created by Administrator on 2017/7/11. */public class ViewPageFragmentAdapter extends FragmentPagerAdapter { private List&lt;Fragment&gt; fragmentList = new ArrayList&lt;&gt;(); public ViewPageFragmentAdapter(FragmentManager fm) { super(fm); } public void addFragment(Fragment fragment) { fragmentList.add(fragment); } @Override public Fragment getItem(int position) { return fragmentList.get(position); } @Override public int getCount() { return fragmentList.size(); }} 除了必须要实现的几个方法外，这里我自定义了一个方法addFragment()，用于将fragment传递进来。 5. 在Activity中配置ViewPage12345678910111213141516171819202122232425262728package com.example.test;import android.support.v4.view.ViewPager;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.LayoutInflater;import android.view.View;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity { private ViewPager viewPager; //对应的viewPager @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); viewPager = (ViewPager) findViewById(R.id.viewPage); ViewPageFragmentAdapter adapter = new ViewPageFragmentAdapter(getSupportFragmentManager()); adapter.addFragment(new Fragment1()); adapter.addFragment(new Fragment2()); adapter.addFragment(new Fragment3()); viewPager.setAdapter(adapter); }} 新建适配器，将fragment加入到适配器中并给ViewPage设置适配器。 参考：https://blog.csdn.net/shanshui911587154/article/details/74963447 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Android Fragment用法","date":"2018-10-23T02:44:00.000Z","path":"2018/10/23/Android-Fragment用法/","text":"Android Fragment 简单实例 这里用的是import android.support.v4.app.FragmentTransaction，而不是import android.app.FragmentTransaction，后者会报错的。 Fragment 在 onCreateView这里初始化控件 12345678910public class MessageFragment extends Fragment{ private TextView tv; public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View messageLayout = inflater.inflate(R.layout.message, container, false); tv=(TextView) messageLayout.findViewById(R.id.message); tv.setText(\"哈哈哈哈哈哈\"); return messageLayout; }} Activity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193public class MainActivity extends Activity implements OnClickListener {/*** 用于展示消息的Fragment*/private MessageFragment messageFragment; /*** 用于展示联系人的Fragment*/private ContactsFragment contactsFragment; /*** 用于展示动态的Fragment*/private NewsFragment newsFragment; /*** 用于展示设置的Fragment*/private SettingFragment settingFragment; /*** 消息界面布局*/private View messageLayout; /*** 联系人界面布局*/private View contactsLayout; /*** 动态界面布局*/private View newsLayout; /*** 设置界面布局*/private View settingLayout;/*** 用于对Fragment进行管理*/private FragmentManager fragmentManager; @Overrideprotected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initViews(); fragmentManager = getFragmentManager(); // 第一次启动时选中第0个tab setTabSelection(0);} /*** 在这里获取到每个需要用到的控件的实例，并给它们设置好必要的点击事件。*/ private void initViews() { messageLayout = findViewById(R.id.message_layout); contactsLayout = findViewById(R.id.contacts_layout); newsLayout = findViewById(R.id.news_layout); settingLayout = findViewById(R.id.setting_layout); messageLayout.setOnClickListener(this); contactsLayout.setOnClickListener(this); newsLayout.setOnClickListener(this); settingLayout.setOnClickListener(this);} @Overridepublic void onClick(View v) { switch (v.getId()) { case R.id.message_layout: // 当点击了消息tab时，选中第1个tab setTabSelection(0); break; case R.id.contacts_layout: // 当点击了联系人tab时，选中第2个tab setTabSelection(1); break; case R.id.news_layout: // 当点击了动态tab时，选中第3个tab setTabSelection(2); break; case R.id.setting_layout: // 当点击了设置tab时，选中第4个tab setTabSelection(3); break; default: break;} } /*** 根据传入的index参数来设置选中的tab页。** @param index* 每个tab页对应的下标。0表示消息，1表示联系人，2表示动态，3表示设置。*/private void setTabSelection(int index) { // 每次选中之前先清楚掉上次的选中状态 clearSelection(); // 开启一个Fragment事务 FragmentTransaction transaction = fragmentManager.beginTransaction(); // 先隐藏掉所有的Fragment，以防止有多个Fragment显示在界面上的情况 hideFragments(transaction); switch (index) { case 0: messageLayout.setBackgroundColor(0xff0000ff); if (messageFragment == null) { // 如果MessageFragment为空，则创建一个并添加到界面上 messageFragment = new MessageFragment(); transaction.add(R.id.content, messageFragment); } else { // 如果MessageFragment不为空，则直接将它显示出来 transaction.show(messageFragment); } break; case 1: // 当点击了联系人tab时，改变控件的图片和文字颜色 contactsLayout.setBackgroundColor(0xff0000ff); if (contactsFragment == null) { // 如果ContactsFragment为空，则创建一个并添加到界面上 contactsFragment = new ContactsFragment(); transaction.add(R.id.content, contactsFragment); } else { // 如果ContactsFragment不为空，则直接将它显示出来 transaction.show(contactsFragment); } break; case 2: // 当点击了动态tab时，改变控件的图片和文字颜色 newsLayout.setBackgroundColor(0xff0000ff); if (newsFragment == null) { // 如果NewsFragment为空，则创建一个并添加到界面上 newsFragment = new NewsFragment(); transaction.add(R.id.content, newsFragment); } else { // 如果NewsFragment不为空，则直接将它显示出来 transaction.show(newsFragment); } break; case 3: default: // 当点击了设置tab时，改变控件的图片和文字颜色 settingLayout.setBackgroundColor(0xff0000ff); if (settingFragment == null) { // 如果SettingFragment为空，则创建一个并添加到界面上 settingFragment = new SettingFragment(); transaction.add(R.id.content, settingFragment); } else { // 如果SettingFragment不为空，则直接将它显示出来 transaction.show(settingFragment); } break; } transaction.commit();} /*** 将所有的Fragment都置为隐藏状态。** @param transaction* 用于对Fragment执行操作的事务*/private void hideFragments(FragmentTransaction transaction) { if (messageFragment != null) { transaction.hide(messageFragment); } if (contactsFragment != null) { transaction.hide(contactsFragment); } if (newsFragment != null) { transaction.hide(newsFragment); } if (settingFragment != null) { transaction.hide(settingFragment); }} /*** 清除掉所有的选中状态。*/private void clearSelection() { messageLayout.setBackgroundColor(0xffffffff); contactsLayout.setBackgroundColor(0xffffffff); newsLayout.setBackgroundColor(0xffffffff); settingLayout.setBackgroundColor(0xffffffff); }} 参考：https://www.jb51.net/article/138944.htm document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"睡眠排序法Java版","date":"2018-10-16T05:28:00.000Z","path":"2018/10/16/睡眠排序法Java版/","text":"基本思想：根据CPU的调度算法实现，对一组数据进行排序，不能存在负数值。 这个数是多大，那么就在线程里睡眠它的10倍再加10。 不是睡眠和它的数值一样大的原因是，当数值太小时，误差太大，睡眠的时间不比输出的时间少，那么就会存在不正确的输出结果。 1234567891011121314151617181920212223242526272829303132public class SleepSort { public static void main(String[] args) { int[] arr = {1,4,7,3,8,9,2,6,5}; //创建指定长度的线程数组 SortThread[] sortThreads = new SortThread[arr.length]; //指定每个线程数组的值 for (int i = 0; i &lt; sortThreads.length; i++) { sortThreads[i] = new SortThread(arr[i]); } //开启每个线程 for (int i = 0; i &lt; sortThreads.length; i++) { sortThreads[i].start(); } }}class SortThread extends Thread{ int s = 0; public SortThread(int s){ this.s = s; } public void run(){ try { sleep(s*10+10); //睡眠指定的时间 } catch (InterruptedException e) { e.printStackTrace(); } //输出该数 System.out.println(s); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Java","slug":"Java","permalink":"http://blog.iwxyi.com/tags/Java/"},{"name":"算法","slug":"算法","permalink":"http://blog.iwxyi.com/tags/算法/"}]},{"title":"Android CardView用法","date":"2018-10-14T02:38:00.000Z","path":"2018/10/14/Android-CardView用法/","text":"今天主要是CardView的用法，CardView是在安卓5.0提出的卡片式控件。首先介绍一下它的配置。在gradle文件下添加依赖库： compile ‘com.android.support:cardview-v7:22.2.1’ 新版建议吧compile改成implementation，注意版本也要改 import android.support.v7.widget.CardView; 其次介绍一下它的基本属性： app:cardBackgroundColor这是设置背景颜色 app:cardCornerRadius这是设置圆角大小 app:cardElevation这是设置z轴的阴影 app:cardMaxElevation这是设置z轴的最大高度值 app:cardUseCompatPadding是否使用CompatPadding app:cardPreventCornerOverlap是否使用PreventCornerOverlap app:contentPadding 设置内容的padding app:contentPaddingLeft 设置内容的左padding app:contentPaddingTop 设置内容的上padding app:contentPaddingRight 设置内容的右padding app:contentPaddingBottom 设置内容的底padding CardView是在布局中使用的： 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginBottom=\"10dp\" android:background=\"@color/gray\"&gt; &lt;android.support.v7.widget.CardView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_marginLeft=\"10dp\" android:layout_marginRight=\"10dp\" app:cardBackgroundColor=\"@color/blue\" app:cardCornerRadius=\"16dp\" app:cardElevation=\"16dp\"&gt; &lt;TextView android:id=\"@+id/id_num\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\" android:layout_margin=\"10dp\" android:gravity=\"center\" android:textColor=\"@color/white\" android:textSize=\"20sp\" /&gt; &lt;/android.support.v7.widget.CardView&gt;&lt;/FrameLayout&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"PHP调用Python并获取返回值","date":"2018-10-11T08:27:00.000Z","path":"2018/10/11/PHP调用Python并获取返回值/","text":"## 一：php调用python脚本 并传入参数，并接收返回值 php调用python脚本可以用 system()，exec()和passthru() 函数，本篇文章主要介绍exec 函数 exec有三个参数，第一个参数为一个字符串，包括三个子串，起一个子串为使用的当前系统的解释器，如果直接写python则默认为系统默认的解释器，也可以指定本地python.exe 的路径。第二个子串为所要执行的python脚本的位置。第三个子串为所需传入的参数不限个数，中间用空格分隔，注意格式。子串间空格分割。 tips:如果使用相对路径指定脚本位置，或者在python脚本中使用了文件的相对路径，都需要改为当前php文件所对应的相对路径。 第二个参数是php接收的python脚本的返回值，注意，此处的$out中存放的并非python中return的值，并且所有return的值都不会进行保存，$out中存放的是python脚本中输出的值，即为print（）函数所输出的所有数据，每次print（）都会记录为一条字典数据，组合成array数组如下图： 第三个参数为执行情况的状态码，如果执行成功，返回0，否则返回一个非0数 二：python获取php传递参数导入sys包 img 使用sys.argv[ ]数组获取传入参数，第一个传入参数为sys.argv[1],第二个为sys.argv[2]以此类推，不要使用argv【0】 img tips:如果要获取python脚本的返回值，直接在python脚本中print（）出来，$out数组会自动记录，而system（）和passthru（）在获取返回值上存在一定缺陷。使用数组作为参数，python接收时会将数组变为一个“Arrqy”字符串，所以本文的解决方案为将传入数组写成字符串，在python中重新分割为数组。 在linux上使用php调用python 可能会出现文件写入权限的问题，需要更改文件的读写权限。在linux上调用python脚本时一定要明确指出exec（）函数中python 的绝对路径并安装好所有需要的包，否则会报错 参考：https://blog.csdn.net/qq_39490713/article/details/81543174?utm_source=copy document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.iwxyi.com/tags/PHP/"},{"name":"Python","slug":"Python","permalink":"http://blog.iwxyi.com/tags/Python/"}]},{"title":"Ubuntu安装Apache2和PHP","date":"2018-10-11T06:04:00.000Z","path":"2018/10/11/Ubuntu安装Apache2和PHP/","text":"安装Apache2和PHP：安装 Apache2： 1sudo apt-get install apache2 安装PHP模块： 1sudo apt-get install php5 安装Mysql 1sudo apt-get install mysql-server 其他模块安装： 1234sudo apt-get install libapache2-mod-php5sudo apt-get install libapache2-mod-auth-mysqlsudo apt-get install php5-mysqlsudo apt-get install php5-gd 前两个很容易明白，要想apache能够解析PHP，就需要借助这两个模块来找到php engine。第三个在php操作mysql数据库时用到，大多数人都有数据库编程经验，所以这就不用多解释了。第四个GD库。 1.apache根目录 安装完apache2，根目录在/var/www下，可以通过http://localhost/测试一下是否好用。当然也可以在该目录下新建一个文件test.html来试一试http://localhost/test.html。 （好像是在/var/www/html/诶） 2.改变apache2的默认目录到当前的开发目录 apache2的默认目录配置在/etc/apache2/sites-enabled/00default文件中。 找到该文件中的DocumentRoot项，将/var/www改为你的开发目录就OK了。 当然，还有一种方法就是不改变默认目录，只是在var/www下建立一个到你的目录的链接。比如你的目录在/home/username/phptest，那么你只要 1sudo ln -s/home/username/phptest /var/www/phptest 这样你就可以通过http://localhost/phptest访问你的工作目录了。 3、配置中常用命令 重启apache 1sudo /etc/init.d/apache2 restart 错误Apache2启动失败在安装完成后就会显示这错误。 1sudo vim /etc/apache2/apache2.conf 最后加入一句: ServerName localhost:80 找不到PHP7.0Couldn't find any package by regex 'php-7.0' 更新包源： 123sudo apt-add-repository ppa:ondrej/phpsudo apt-get updatesudo apt-get install php7.0 端口被占用Address already in use: AH00072: make_sock: could not bind to address 0.0.0.0:80 用netstat -nlp |grep :80命令看看有什么进程占用了80端口 例如Nginx，用pkill -9 nginx杀死进程 再次启动Apache 启动失败Segmentation fault ``Action ‘start’ failed.` 是因为装了多个PHP……彻底卸载PHP，重装即可。 其他教程搭建sudo apt-get install apache2sudo apt-get install php7.0php -v 查看PHP是否安装成功sudo apt-get install libapache2-mod-php7.0cd /var/www/html 切换到apache项目目录下， 新建文件：sudo vim test.php//vim显示行号：：set nusudo apt-get install mysql-server mysql-client//mysql设置密码 用户名root//mysql -V 查看安装的版本信息安装php的mysql插件：sudo apt-get install php7.0-mysql安装一些常用的php扩展；sudo apt-get install php7.0-gd php7.0-mbstring php7.0-xml安装composer：sudo apt-get install composer 博客来源：https://blog.csdn.net/u010071211/article/details/79511928 彻底卸载PHP7一、删除php的相关包及配置 1sudo apt-get autoremove php7* 二、删除关联 1sudo find /etc -name \"*php*\" |xargs rm -rf 三、清除dept列表 1sudo apt purge `dpkg -l | grep php| awk '{print $2}' |tr \"\\n\" \" \"` 四、检查是否卸载干净（无返回就是卸载完成） 1dpkg -l | grep php7.0 移动上传的文件失败move_upload_file 权限问题 /tmp的权限是drwxrwxrwx，而我的/var/www/html 权限为drwxr-xr-x 修改所在文件夹的权限： 1chmod -R 777 /home document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.iwxyi.com/tags/Linux/"}]},{"title":"Android DrawerLayout用法","date":"2018-10-07T02:41:00.000Z","path":"2018/10/07/Android-DrawerLayout用法/","text":"布局NavigationView：在Material Design中，Navigation drawer导航抽屉，被设计用于应用导航，提供了一种通用的导航方式，体现了设计的一致性。而NavigationView的典型用途就是配合之前v4包的DrawerLayout，作为其中的Drawer部分，即导航菜单的本体部分。NavigationView是一个导航菜单框架，使用menu资源填充数据，使我们可以更简单高效的实现导航菜单。它提供了不错的默认样式、选中项高亮、分组单选、分组子标题、以及可选的Header。 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/drawer_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;FrameLayout android:id=\"@+id/content\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt;&lt;/FrameLayout&gt; &lt;android.support.design.widget.NavigationView android:id=\"@+id/nav_view\" android:layout_width=\"150dp\" android:layout_height=\"match_parent\" android:layout_gravity=\"start\" android:background=\"#303030\" app:headerLayout=\"@layout/nav_header\" app:itemIconTint=\"@color/white\" app:itemTextColor=\"@color/white\" app:menu=\"@menu/nav_menu\" /&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 注意其中NavigationView的两个自定义属性app:headerLayout接收一个layout，作为导航菜单顶部的Header，可选项。app:menu接收一个menu，作为导航菜单的菜单项，几乎是必选项，不然这个控件就失去意义了。但也可以在运行时动态改变menu属性。用于NavigationView的典型menu文件，应该是一个可选中菜单项的集合。其中checked=”true”的item将会高亮显示，这可以确保用户知道当前选中的菜单项是哪个。item的选中状态可以在代码中设置，代码如下 nav_menu.xml123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;group android:id=\"@+id/g1\" android:checkableBehavior=\"single\"&gt; &lt;item android:id=\"@+id/nav_queue\" android:checkable=\"true\" android:icon=\"@mipmap/queue\" android:title=\"排队\" /&gt; &lt;item android:id=\"@+id/nav_count\" android:checkable=\"true\" android:icon=\"@mipmap/count\" android:title=\"统计\" /&gt; &lt;item android:id=\"@+id/nav_tv\" android:checkable=\"true\" android:icon=\"@mipmap/tv\" android:title=\"TV设置\" /&gt; &lt;item android:id=\"@+id/nav_more\" android:checkable=\"true\" android:icon=\"@mipmap/more\" android:title=\"更多\" /&gt; &lt;/group&gt;&lt;/menu&gt; FragmentActivity.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class HomeActivity extends FragmentActivity implements NavigationView .OnNavigationItemSelectedListener { // @InjectView(R.id.nav_view) public static NavigationView navView; // @InjectView(R.id.drawer_layout) public static DrawerLayout drawerLayout; private QueueFragment queueFragment; private MoreFragment moreFragment; private CountFragment countFragment; private TVFragment tvFragment; private FragmentManager fm; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate( savedInstanceState ); setContentView( R.layout.activity_home ); navView = (NavigationView) findViewById( R.id.nav_view ); drawerLayout = (DrawerLayout) findViewById( R.id.drawer_layout );// ButterKnife.inject( this ); init(); } /*** * 初始化，默认选中排队选项 */ public void init() { fm = getSupportFragmentManager(); queueFragment = new QueueFragment(); FragmentTransaction ft = fm.beginTransaction(); ft.add( R.id.content, queueFragment, \"queue\" ).commit(); // 别忘了 commit navView.setNavigationItemSelectedListener( this ); } /** * 打开侧滑栏 *这个方法是在其他类里面调用，点击某个按钮可以调出侧滑栏 */ public static void showDrawerLayout() { if (!HomeActivity.drawerLayout.isDrawerOpen( HomeActivity.navView )) { HomeActivity.drawerLayout.openDrawer( HomeActivity.navView ); } } /** * 侧滑栏点击 */ @Override public boolean onNavigationItemSelected(@NonNull MenuItem item) { FragmentTransaction ft = fm.beginTransaction(); hideFragment( ft ); switch (item.getItemId()) { case R.id.nav_queue://排队单击事件 if (queueFragment == null) { queueFragment = new QueueFragment(); ft.add( R.id.content, queueFragment, \"queue\" ); } else { ft.show( queueFragment ); } break; case R.id.nav_count://统计单击事件 if (countFragment == null) { countFragment = new CountFragment(); ft.add( R.id.content, countFragment, \"count\" ); } else { ft.show( countFragment ); } break; case R.id.nav_tv://TV设置单机时间 if (tvFragment == null) { tvFragment = new TVFragment(); ft.add( R.id.content, tvFragment, \"tv\" ); } else { ft.show( tvFragment ); } break; case R.id.nav_more://更多点击事件 if (moreFragment == null) { moreFragment = new MoreFragment(); ft.add( R.id.content, moreFragment, \"more\" ); } else { ft.show( moreFragment ); } break; } ft.commit(); // 别忘了这里，不然是不会有效果的 drawerLayout.closeDrawers(); return true; } /*** * 隐藏fragment */ public void hideFragment(FragmentTransaction ft) { if (queueFragment != null) { ft.hide( queueFragment ); } if (moreFragment != null) { ft.hide( moreFragment ); } if (countFragment != null) { ft.hide( countFragment ); } if (tvFragment != null) { ft.hide( tvFragment ); } }} 这是其中一个子Fragment的例子，其余的都一样 1234567891011121314151617181920212223242526package com.mxt.net.protect.UI.fragment;import android.os.Bundle;import android.support.annotation.Nullable;import android.support.v4.app.Fragment;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import com.mxt.net.protect.R;/** * Created by Spencer on 2017/3/11. */public class TVFragment extends Fragment { private View view; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) { view = inflater.inflate(R.layout.tv_fragment, container, false); return view; }} 参考：https://blog.csdn.net/u010068253/article/details/70155261 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Qt仿音乐播放器托盘菜单","date":"2018-10-01T11:13:00.000Z","path":"2018/10/01/Qt仿音乐播放器托盘菜单/","text":"QT自定义菜单（仿音乐播放器托盘菜单） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162void SystemTray::createPlayAction(){ // 菜单总控件 play_widget = new QWidget(); play_widget_action = new QWidgetAction(pop_menu); play_button = new QPushButton(); backward_button = new QPushButton(); forward_button = new QPushButton(); // 正在播放的音乐名字 music_name_label = new QLabel(); music_name_label-&gt;setFixedWidth(MUSIC_NAME_WIDTH); music_name_label-&gt;setAlignment(Qt::AlignCenter); music_name_label-&gt;setText('player'); music_name_label-&gt;setEnabled(false); // 暂停按钮 QPixmap play_pixmap(':/action/pause'); play_button-&gt;setIcon(play_pixmap); play_button-&gt;setIconSize(play_pixmap.size()); play_button-&gt;setObjectName('transparentButton'); // 上一曲按钮 QPixmap backward_pixmap(':/action/backward'); backward_button-&gt;setIcon(backward_pixmap); backward_button-&gt;setIconSize(backward_pixmap.size()); backward_button-&gt;setObjectName('transparentButton'); // 下一曲按钮 QPixmap forward_pixmap(':/action/forward'); forward_button-&gt;setIcon(forward_pixmap); forward_button-&gt;setIconSize(forward_pixmap.size()); forward_button-&gt;setObjectName('transparentButton'); // 设置鼠标 backward_button-&gt;setCursor(Qt::PointingHandCursor); play_button-&gt;setCursor(Qt::PointingHandCursor); forward_button-&gt;setCursor(Qt::PointingHandCursor); // 播放控件布局（横向） QHBoxLayout *layout = new QHBoxLayout(); layout-&gt;addWidget(backward_button); layout-&gt;addWidget(play_button); layout-&gt;addWidget(forward_button); layout-&gt;setSpacing(0); layout-&gt;setContentsMargins(20, 0, 20, 0); // 总体布局（纵向） QVBoxLayout *layout2 = new QVBoxLayout(); layout2-&gt;addLayout(layout); layout2-&gt;addWidget(music_name_label, 0, Qt::AlignCenter); layout2-&gt;setSpacing(5); layout2-&gt;setContentsMargins(0, 0, 0, 5); play_widget-&gt;setLayout(layout2); play_widget_action-&gt;setDefaultWidget(play_widget); connect(play_button, &amp;QPushButton::clicked, this, &amp;SystemTray::play); connect(backward_button, &amp;QPushButton::clicked, this, &amp;SystemTray::skipBackward); connect(forward_button, &amp;QPushButton::clicked, this, &amp;SystemTray::skipForward);} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"修电脑","date":"2018-09-24T12:39:00.000Z","path":"2018/09/24/修电脑/","text":"WIN无操作自动休眠这是系统无人值守时睡眠时间的设定，默认是两分钟。 解决方法： regedit进入注册表管理器，定位到HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Power\\PowerSettings\\238C9FA8-0AAD-41ED-83F4-97BE242C8F20\\7bc4a2f9-d8fc-4469-b07b-33eb785aaca0，修改attributes的值为2。 进入高级电源设置，在睡眠选项中会出现“无人参与系统睡眠超时”，将默认的2分钟修改成你想要的时间。 开关操作中心regedit进入注册表编辑器，计算机\\HKEY_CURRENT_USER\\Software\\Policies\\Microsoft\\Windows\\Explorer新建项DisableNotificationCenter，值为1时关闭操作中心。重启电脑生效。 开启休眠选项Power Sheel(管理员) 输入 powercfg /h on并运行，重新打开控制面板后会出现休眠选项。 修改安装路径npm命令行输入npm config ls查看 npm 当前配置 12npm config set prefix \"D:\\DevKits\\nodejs\\modules\" # 默认已有个 node_modules 文件夹 npm config set cache \"D:\\DevKits\\nodejs\\node_cache\" 连接wifi，提示需要执行操作，并自动打开微软网站的问题 注册表键值HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\services\\NlaSvc\\Parameters\\Internet 窗口右侧中的“EnableActiveProbing”，然后将其值更改为0，重启计算机 睡眠时继续下载注册表：HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Power 查看右边窗口，是否有AwayModeEnabled值（离开模式）？如没有创建一个。 修改该值为1。 如果要取消，可直接删除。 查看休眠最后一个唤醒源1powercfg -lastwake 示例问题： 1234567唤醒历史记录计数 - 1唤醒历史记录 [0] 唤醒源计数 - 1 唤醒源 [0] 类型: 唤醒计时器 所有者: [SERVICE] \\Device\\HarddiskVolume7\\Windows\\System32\\svchost.exe (SystemEventsBroker) 所有者提供的原因: Windows 将执行“NT TASK\\Microsoft\\Windows\\UpdateOrchestrator\\Reboot_AC”计划的任务，该任务请求唤醒计算机。 解决方法： 组策略/计算机配置/管理模板/Windows 组件/Windows 更新，双击“启用 Windows 更新电脑管理以自动唤醒系统来安装计划的更新”，选择禁用 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Windows","slug":"Windows","permalink":"http://blog.iwxyi.com/tags/Windows/"}]},{"title":"Android RecyclerView添加点击事件","date":"2018-09-22T02:53:00.000Z","path":"2018/09/22/Android-RecyclerView添加点击事件/","text":"使用 Recyclerview 时，如果要添加 item 的点击监听等功能，可以在 Recyclerview.Adapter 的 onBindViewHolder 中设置 123456holder.tv.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { int pos=holder.getLayoutPosition(); } } 注意需要把 onBindViewHolder 中的 holder 参数改成 filnal 类型 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Qt添加Q_OBJECT后编译出错解决方案","date":"2018-09-21T09:03:00.000Z","path":"2018/09/21/Qt添加Q-OBJECT后编译出错解决方案/","text":"在Qt编写过程中，如多线程使用信号槽时，需要添加Q_OBJECT，但是在添加之后发现编译老会出错。如下： 123456789class ThreadSxxx : public QThread{ Q_OBJECTpublic: ThreadSxxx ();signals: signaltrig();} 编译后总是提示 undefined reference to vtable for \"xxxx\" 的错误问题。 出现该错误的原因是此时的Q_OBJECT是半途加入的，你需要让项目重新加载编译，解决的办法是直接在.pro文件中随便改动一点东西，即使是随便加个空格都可以，此时再编译就可以通过。 若没有这么做，即使你对整个项目进行清除再重新构建都是不行的。 参考：https://blog.csdn.net/xzq413520903/article/details/79554318 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"Android点击图片显示像素颜色值","date":"2018-09-16T03:07:00.000Z","path":"2018/09/16/Android点击图片显示像素颜色值/","text":"包含知识点： 选择图片（相册+拍照） 正方形裁剪 图片压缩 图片点击 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/ll\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:gravity=\"center\" android:orientation=\"vertical\" &gt; &lt;Button android:id=\"@+id/btnColor\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:layout_gravity=\"top\" android:text=\"获取图片\" /&gt; &lt;ImageView android:id=\"@+id/iv_image\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:scaleType=\"fitCenter\" /&gt;&lt;/LinearLayout&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188package com.wxy.treecalc;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import android.app.Activity;import android.content.Intent;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.graphics.Color;import android.net.Uri;import android.os.Bundle;import android.provider.MediaStore;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.view.MotionEvent;import android.view.View;import android.view.View.OnClickListener;import android.view.View.OnTouchListener;import android.widget.Button;import android.widget.ImageView;import android.widget.TextView;public class MainActivity extends AppCompatActivity { private TextView tv_rgb; private ImageView iv_image; private Bitmap bitmap; private String TAG = \"RGBActivity\"; private Button btnColor; public static final int NONE = 0; public static final int PHOTOHRAPH = 1;// 拍照 public static final int PHOTOZOOM = 2; // 缩放 public static final int PHOTORESOULT = 3;// 结果 public static final String IMAGE_UNSPECIFIED = \"image/*\"; public static final String TEMP_JPG_NAME = \"temp.jpg\"; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tv_rgb = (TextView) findViewById(R.id.textview); btnColor = (Button) findViewById(R.id.btnColor); iv_image = (ImageView) findViewById(R.id.iv_image); btnColor.setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { openAlbum(); } }); iv_image.setOnTouchListener(new OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { int x = (int) event.getX(); int y = (int) event.getY(); if (event.getAction() == MotionEvent.ACTION_UP) { int color = bitmap.getPixel(x, y); // 如果你想做的更细致的话 可以把颜色值的R G B 拿到做响应的处理 int r = Color.red(color); int g = Color.green(color); int b = Color.blue(color); int a = Color.alpha(color); Log.i(TAG, \"r=\" + r + \",g=\" + g + \",b=\" + b); tv_rgb.setText(\"a=\" + a + \",r=\" + r + \",g=\" + g + \",b=\" + b); btnColor.setTextColor(Color.rgb(r, g, b)); } return true; } }); } // 打开相册 private void openAlbum() { Intent intent = new Intent(Intent.ACTION_PICK, null); intent.setDataAndType(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, \"image/*\"); startActivityForResult(intent, PHOTOZOOM); } @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { try { if (resultCode == NONE) return; if (data == null) return; // 读取相册缩放图片 if (requestCode == PHOTOZOOM) { if (data != null) { startPhotoZoom(data.getData()); } } // 处理结果 if (requestCode == PHOTORESOULT) { Bundle extras = data.getExtras(); if (extras != null) { bitmap = extras.getParcelable(\"data\"); //ByteArrayOutputStream stream = new ByteArrayOutputStream(); comp(bitmap); //bitmap.compress(Bitmap.CompressFormat.JPEG, 100, stream); iv_image.setImageBitmap(bitmap); /* logoName = FileUtils.getFilename(MainAppUtil.getCustom().getSusername()); FileUtils.writeFile(Constants.LOGO_CACHE_PATH, logoName, photo);*/ } } super.onActivityResult(requestCode, resultCode, data); } catch (Exception e) { e.printStackTrace(); } } private Bitmap compressImage(Bitmap image) { ByteArrayOutputStream baos = new ByteArrayOutputStream(); image.compress(Bitmap.CompressFormat.JPEG, 100, baos);//质量压缩方法，这里100表示不压缩，把压缩后的数据存放到baos中 int options = 100; while (baos.toByteArray().length / 1024 &gt; 100) { //循环判断如果压缩后图片是否大于100kb,大于继续压缩 baos.reset();//重置baos即清空baos image.compress(Bitmap.CompressFormat.JPEG, options, baos);//这里压缩options%，把压缩后的数据存放到baos中 options -= 10;//每次都减少10 } ByteArrayInputStream isBm = new ByteArrayInputStream(baos.toByteArray());//把压缩后的数据baos存放到ByteArrayInputStream中 Bitmap bitmap = BitmapFactory.decodeStream(isBm, null, null);//把ByteArrayInputStream数据生成图片 return bitmap; } private Bitmap comp(Bitmap image) { ByteArrayOutputStream baos = new ByteArrayOutputStream(); image.compress(Bitmap.CompressFormat.JPEG, 100, baos); if (baos.toByteArray().length / 1024 &gt; 1024) { //判断如果图片大于1M,进行压缩避免在生成图片（BitmapFactory.decodeStream）时溢出 baos.reset();//重置baos即清空baos image.compress(Bitmap.CompressFormat.JPEG, 50, baos); //这里压缩50%，把压缩后的数据存放到baos中 } ByteArrayInputStream isBm = new ByteArrayInputStream(baos.toByteArray()); BitmapFactory.Options newOpts = new BitmapFactory.Options(); //开始读入图片，此时把options.inJustDecodeBounds 设回true了 newOpts.inJustDecodeBounds = true; Bitmap bitmap = BitmapFactory.decodeStream(isBm, null, newOpts); newOpts.inJustDecodeBounds = false; int w = newOpts.outWidth; int h = newOpts.outHeight; //现在主流手机比较多是800*500分辨率，所以高和宽我们设置为 float hh = 800f;//这里设置高度为800f float ww = 500f;//这里设置宽度为500f //缩放比。由于是固定比例缩放，只用高或者宽其中一个数据进行计算即可 int be = 1;//be=1表示不缩放 if (w &gt; h &amp;&amp; w &gt; ww) {//如果宽度大的话根据宽度固定大小缩放 be = (int) (newOpts.outWidth / ww); } else if (w &lt; h &amp;&amp; h &gt; hh) {//如果高度高的话根据宽度固定大小缩放 be = (int) (newOpts.outHeight / hh); } if (be &lt;= 0) be = 1; newOpts.inSampleSize = be;//设置缩放比例 //重新读入图片，注意此时已经把options.inJustDecodeBounds 设回false了 isBm = new ByteArrayInputStream(baos.toByteArray()); bitmap = BitmapFactory.decodeStream(isBm, null, newOpts); return compressImage(bitmap);//压缩好比例大小后再进行质量压缩 } private void startPhotoZoom(Uri uri) { Intent intent = new Intent(\"com.android.camera.action.CROP\"); intent.setDataAndType(uri, IMAGE_UNSPECIFIED); intent.putExtra(\"crop\", \"true\"); // aspectX aspectY 是宽高的比例 intent.putExtra(\"aspectX\", 1); intent.putExtra(\"aspectY\", 1); // outputX outputY 是裁剪图片宽高 intent.putExtra(\"outputX\", 300); intent.putExtra(\"outputY\", 300); intent.putExtra(\"return-data\", true); startActivityForResult(intent, PHOTORESOULT); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Android读取图片颜色值","date":"2018-09-15T03:12:00.000Z","path":"2018/09/15/Android读取图片颜色值/","text":"Android SDK中提供了Bitmap图片每个像素颜色读取的方法： 123456789Bitmap src = BitmapFactory.decodeResource(getResources(),R.drawable.imgbg);int height = src.getHeight();int width = src.getWidth();for (int y = 0; y &lt; height; y++) { for (int x = 0; x &lt; width; x++) { int pixelColor = src.getPixel(x, y); // 颜色值 int A = Color.alpha(pixelColor); // A R G B }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Qt QListView拖拽排序","date":"2018-09-11T09:37:00.000Z","path":"2018/09/11/Qt-QListView拖拽排序/","text":"拖拽事件流程 mousePressEvent 鼠标按下 mouseMoveEvent 鼠标开始移动（接下来换成dragMoveEvent） dragEnterEvent 开始拖拽 dragMoveEvent dragMoveEvent …(重复) dragMoveEvent dragMoveEvent dropEvent 鼠标松开的时候触发（拖到外面不会触发） 拖拽没有 mouseReleaseEvent，只在点击时有 如果拖到 QListView 的底部空白，根据点获取到的索引是 -1 头文件123456789101112131415161718192021222324#ifndef DRAG_TABLE_H#define DRAG_TABLE_H #include &lt;QTableWidget&gt;#include &lt;QListWidget&gt;#include &lt;QtGui&gt;#include &lt;QDrag&gt; class DragListWidget : public QListWidget{public: DragListWidget(QWidget *parent = 0);protected: void mousePressEvent(QMouseEvent *event); void mouseMoveEvent(QMouseEvent *event); void dragEnterEvent(QDragEnterEvent *event); void dragMoveEvent(QDragMoveEvent *event); void dropEvent(QDropEvent *event);public: QPoint startPos; QPoint endPos;}; #endif 源文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include \"DragTable.h\" DragListWidget::DragListWidget(QWidget *parent):QListWidget(parent){ this-&gt;setCurrentRow(10); addItem(\"1\"); addItem(\"2\"); addItem(\"3\"); addItem(\"4\"); addItem(\"5\"); addItem(\"6\"); addItem(\"7\"); addItem(\"8\"); addItem(\"9\"); addItem(\"10\"); this-&gt;setAcceptDrops(true);//设置QListWidget的Item项可以被拖拽} void DragListWidget::mousePressEvent( QMouseEvent *event ){ if (event-&gt;button() == Qt::LeftButton) startPos = event-&gt;pos(); QListWidget::mousePressEvent(event);} void DragListWidget::mouseMoveEvent(QMouseEvent *event){ QListWidgetItem *item = currentItem(); mimeData = new QMimeData; mimeData-&gt;setText(item-&gt;text()); QDrag *drag = new QDrag(this); drag-&gt;setMimeData(mimeData); //drag-&gt;setPixmap(pixmap); Qt::DropAction dropAction = drag-&gt;exec(Qt::CopyAction | Qt::MoveAction, Qt::CopyAction); if(dropAction == Qt::MoveAction) { delete item;//删除原有的item,在dropEvent(QDropEvent *event)函数中插入item }} void DragListWidget::mouseReleaseEvent(QMouseEvent *event){ int distance = (endPos - startPos).manhattanLength(); if (distance &gt;= QApplication::startDragDistance()) { startDrag(); }} void DragListWidget::dragEnterEvent( QDragEnterEvent *event ){ DragListWidget *source = (DragListWidget *)((void*)(event-&gt;source())); if (source &amp;&amp; source == this) { event-&gt;setDropAction(Qt::MoveAction); event-&gt;accept(); }} void DragListWidget::dragMoveEvent( QDragMoveEvent *event ){ DragListWidget *source = (DragListWidget *)((void*)(event-&gt;source())); if (source &amp;&amp; source == this) { event-&gt;setDropAction(Qt::MoveAction); event-&gt;accept(); }} void DragListWidget::dropEvent( QDropEvent *event ){ DragListWidget *source = (DragListWidget *)((void*)(event-&gt;source())); if (source &amp;&amp; source == this) { endPos = event-&gt;pos();//得到鼠标移动到的坐标 QListWidgetItem *itemRow = itemAt(endPos);.//通过endPos获取鼠标位置所在的行 int rowCount = row(itemRow); insertItem(rowCount + 1,mimeData-&gt;text());//row+1 为鼠标所指向的行，如果只是向末尾位置插入，把insertItem(rowCount + 1,mimeData-&gt;text())改为addItem(mimeData-&gt;text()) event-&gt;setDropAction(Qt::MoveAction); event-&gt;accept(); }} 博客来源：https://blog.csdn.net/yueye30121/article/details/12508675 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"Qt QListView实现双击编辑","date":"2018-09-11T09:36:00.000Z","path":"2018/09/11/Qt-QListView实现双击编辑/","text":"Delegate 部分关键是重写这四个函数： 1QWidget *createEditor(QWidget *parent, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const; 1void setEditorData(QWidget *editor, const QModelIndex &amp;index) const; 1void setModelData(QWidget *editor, QAbstractItemModel *model, const QModelIndex &amp;index) const; 1void updateEditorGeometry(QWidget *editor, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const; 头文件combodelegate.h 1234567891011121314class ComboDelegate:public QItemDelegate{ Q_OBJECTpublic: ComboDelegate(QObject *parent=0); QWidget *createEditor(QWidget *parent, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const; void setEditorData(QWidget *editor, const QModelIndex &amp;index) const; void setModelData(QWidget *editor, QAbstractItemModel *model, const QModelIndex &amp;index) const; void updateEditorGeometry(QWidget *editor, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const;}; 源文件combodelegate.cpp 123456789101112131415161718192021222324252627282930QWidget *ComboDelegate::createEditor(QWidget *parent, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const{ QComboBox *editor=new QComboBox(parent); editor-&gt;addItem(\"程序员\"); editor-&gt;addItem(\"网管\"); editor-&gt;addItem(\"修电脑的\"); editor-&gt;addItem(\"送水的\"); editor-&gt;installEventFilter(const_cast&lt;ComboDelegate*&gt;(this)); return editor;} void ComboDelegate::setEditorData(QWidget *editor, const QModelIndex &amp;index) const{ QString str=index.model()-&gt;data(index).toString(); QComboBox *box=static_cast&lt;QComboBox*&gt;(editor); int i=box-&gt;findText(str); box-&gt;setCurrentIndex(i);} void ComboDelegate::setModelData(QWidget *editor, QAbstractItemModel *model, const QModelIndex &amp;index) const{ QComboBox *box=static_cast&lt;QComboBox*&gt;(editor); QString str=box-&gt;currentText(); model-&gt;setData(index,str);} void ComboDelegate::updateEditorGeometry(QWidget *editor, const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const{ editor-&gt;setGeometry(option.rect);} Model 部分重写 flag() 函数 和 setData() 函数 123456Qt::ItemFlags flags(const QModelIndex &amp;index) const{ Qt::ItemFlags flags = QAbstractItemModel::flags(index); flags |= Qt::ItemIsEditable; // 允许编辑 return flags;} 123456789bool setData(const QModelIndex &amp;index, const QVariant &amp;value, int role){ if (!index.isValid()) return false; if (role == Qt::EditRole) // 可以手动设置 role { ; // 通过 index 来设置 value } return true;} View 部分手动实现重命名1234void NovelDirListView::slotRenameChapter(){ edit(currentIndex()); // 手动重命名函数} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"AJAX实现图片拖拽上传","date":"2018-09-11T07:44:00.000Z","path":"2018/09/11/AJAX实现图片拖拽上传/","text":"1.html中div标签预览显示，button标签触发上传事件12&lt;div id=\"drop_area\" style=\"border:3px dashed silver;width:200px; height:200px\"&gt;将图片拖拽到此&lt;/div&gt; &lt;button onclick=\"xhr2()\"&gt;ajax上传&lt;/button&gt; 2.禁止浏览器打开文件行为123456789101112document.addEventListener(\"drop\",function(e){ //拖离 e.preventDefault(); }) document.addEventListener(\"dragleave\",function(e){ //拖后放 e.preventDefault(); }) document.addEventListener(\"dragenter\",function(e){ //拖进 e.preventDefault(); }) document.addEventListener(\"dragover\",function(e){ //拖来拖去 e.preventDefault(); }) 3.拖拽,预览文件12345678910111213141516171819202122232425262728293031var box = document.getElementById('drop_area'); //拖拽区域 box.addEventListener(\"drop\",function(e){ var fileList = e.dataTransfer.files; //获取文件对象 //检测是否是拖拽文件到页面的操作 if(fileList.length == 0){ return false; } //拖拉图片到浏览器，可以实现预览功能 //规定视频格式 Array.prototype.S=String.fromCharCode(2); Array.prototype.in_array=function(e){ var r=new RegExp(this.S+e+this.S); return (r.test(this.S+this.join(this.S)+this.S)); }; var video_type=[\"video/mp4\",\"video/ogg\"]; //创建一个url连接,供src属性引用 var fileurl = window.URL.createObjectURL(fileList[0]); if(fileList[0].type.indexOf('image') === 0){ //如果是图片 var str=\"&lt;img width='200px' height='200px' src='\"+fileurl+\"'&gt;\"; document.getElementById('drop_area').innerHTML=str; }else if(video_type.in_array(fileList[0].type)){ //如果是规定格式内的视频 var str=\"&lt;video width='200px' height='200px' controls='controls' src='\"+fileurl+\"'&gt;&lt;/video&gt;\"; document.getElementById('drop_area').innerHTML=str; }else{ //其他格式，输出文件名 //alert(\"不预览\"); var str=\"文件名字:\"+fileList[0].name; document.getElementById('drop_area').innerHTML=str; } resultfile = fileList[0]; },false); 4.ajax上传12345678910111213141516171819202122function xhr2(){ var xhr = new XMLHttpRequest();//第一步 //新建一个FormData对象 var formData = new FormData(); //++++++++++ //追加文件数据 formData.append('file', resultfile); //post方式 xhr.open('POST', 'xhr2.php'); //第二步骤 //发送请求 xhr.send(formData); //第三步骤 //ajax返回 xhr.onreadystatechange = function(){ //第四步 if ( xhr.readyState == 4 &amp;&amp; xhr.status == 200 ) { console.log( xhr.responseText ); } }; //设置超时时间 xhr.timeout = 10000; xhr.ontimeout = function(event){ alert('请求超时！'); } } 5.PHP保存文件12345&lt;?php print_r($_FILES[\"file\"]); $name = $_FILES[\"file\"][\"name\"]; //中文可能乱码使用iconv函数 move_uploaded_file($_FILES[\"file\"][\"tmp_name\"],iconv(\"UTF-8\",\"gb2312\",$name)); ?&gt; 参考：https://blog.csdn.net/wjn2000414/article/details/80396056 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"JS","slug":"JS","permalink":"http://blog.iwxyi.com/tags/JS/"},{"name":"AJAX","slug":"AJAX","permalink":"http://blog.iwxyi.com/tags/AJAX/"},{"name":"PHP","slug":"PHP","permalink":"http://blog.iwxyi.com/tags/PHP/"}]},{"title":"Android自定义控件之QQ红点","date":"2018-09-11T03:34:00.000Z","path":"2018/09/11/Android自定义控件之QQ红点/","text":"# 拖拽效果 拖拽效果的实现其实是用贝塞尔曲线去构成的，这里上一张图就很明白 可以看到，所谓的拖拽效果只是在两个圆圈之间根据两个圆同侧切点和圆心连线中点三个点构建一条二阶贝塞尔曲线，另一侧也是，将其用颜色填充，就构成了qq红点的拖拽效果，是不是很简单 那么我们这里的目标就是先算出p0，p1,Q0三个点的坐标 代码12345678910111213141516171819202122232425float endX = nowFingerPoint.x;float endY = nowFingerPoint.y;float dx = endX - startX;float dy = endY - startY; float distance = (float) Math.sqrt(Math.pow(endY-startY, 2) + Math.pow(endX-startX, 2));radius = 50 - distance/15;radius = radius&lt;20 ? 20 : radius; double a = Math.atan(dy / dx);float offsetX = (float) (radius * Math.sin(a));float offsetY = (float) (radius * Math.cos(a)); // 根据角度算出四边形的四个点float x1 = startX - offsetX;float y1 = startY + offsetY; float x2 = endX - offsetX;float y2 = endY + offsetY; float x3 = endX + offsetX;float y3 = endY - offsetY; float x4 = startX + offsetX;float y4 = startY - offsetY; 然后要做的就是画两个圆点，以及把这四个点连起来构成贝塞尔曲线 1234567891011float anchorX = (startX + endX) / 2;float anchorY = (startY + endY) / 2; path.reset(); path.reset();path.moveTo(x1, y1);path.quadTo(anchorX, anchorY, x2, y2);path.lineTo(x3, y3);path.quadTo(anchorX, anchorY, x4, y4);path.lineTo(x1, y1); 画圆点，响应移动事件这些就不写了，我直接贴源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118public class QQ_message_drag_effect extends View { public QQ_message_drag_effect(Context context) { super(context); } public QQ_message_drag_effect(Context context, @Nullable AttributeSet attrs) { super(context, attrs); } public QQ_message_drag_effect(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); } int width; int height; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec, heightMeasureSpec); setMeasuredDimension(width = ((ViewGroup)getParent()).getMeasuredWidth(),height = ((ViewGroup)getParent()).getMeasuredHeight()); } float radius = 50; PointF startPoint = new PointF(300,500); PointF nowFingerPoint = new PointF(); boolean isMoveing = false; Paint paint = new Paint(); Path path = new Path(); @Override public boolean onTouchEvent(MotionEvent event) { int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()){ case MotionEvent.ACTION_DOWN: if((x &lt; startPoint.x + radius &amp;&amp; x &gt; startPoint.x - radius) &amp;&amp; (y &lt; startPoint.y + radius &amp;&amp; y &gt; startPoint.y - radius)){ isMoveing = true; } break; case MotionEvent.ACTION_MOVE: if(isMoveing){ nowFingerPoint.y = y; nowFingerPoint.x = x; invalidate(); } break; case MotionEvent.ACTION_UP: isMoveing = false; radius = 50; invalidate(); break; } return true; } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); float startX = startPoint.x; float startY = startPoint.y; paint.setColor(Color.RED); canvas.drawCircle(startX,startY,radius,paint); if(isMoveing){ float endX = nowFingerPoint.x; float endY = nowFingerPoint.y; float dx = endX - startX; float dy = endY - startY; float distance = (float) Math.sqrt(Math.pow(endY-startY, 2) + Math.pow(endX-startX, 2)); radius = 50 - distance/15; radius = radius&lt;20 ? 20 : radius; double a = Math.atan(dy / dx); float offsetX = (float) (radius * Math.sin(a)); float offsetY = (float) (radius * Math.cos(a)); // 根据角度算出四边形的四个点 float x1 = startX - offsetX; float y1 = startY + offsetY; float x2 = endX - offsetX; float y2 = endY + offsetY; float x3 = endX + offsetX; float y3 = endY - offsetY; float x4 = startX + offsetX; float y4 = startY - offsetY; float anchorX = (startX + endX) / 2; float anchorY = (startY + endY) / 2; path.reset(); path.reset(); path.moveTo(x1, y1); path.quadTo(anchorX, anchorY, x2, y2); path.lineTo(x3, y3); path.quadTo(anchorX, anchorY, x4, y4); path.lineTo(x1, y1); canvas.drawPath(path,paint); canvas.drawCircle(endX,endY,radius,paint); } }} 参考：https://blog.csdn.net/asffghfgfghfg1556/article/details/80409902 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Node.js-学习笔记","date":"2018-09-02T07:27:00.000Z","path":"2018/09/02/Node-js-学习笔记/","text":"环境配置全篇教程来源：菜鸟教程 https://www.runoob.com/nodejs/nodejs-tutorial.html 安装64 位安装包下载地址 : https://nodejs.org/dist/v4.4.3/node-v4.4.3-x64.msi 第一个应用 引入 required 模块 我们使用 require 指令来载入 http 模块，并将实例化的 HTTP 赋值给变量 http，实例如下: 1var http = require(\"http\"); 创建服务器 使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过 request, response 参数来接收和响应数据。 实例如下，在你项目的根目录下创建一个叫 server.js 的文件，并写入以下代码： 1234567891011121314var http = require('http');http.createServer(function (request, response) { // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.writeHead(200, {'Content-Type': 'text/plain'}); // 发送响应数据 \"Hello World\" response.end('Hello World\\n');}).listen(8888);// 终端打印如下信息console.log('Server running at http://127.0.0.1:8888/'); 以上代码完成了一个可以工作的 HTTP 服务器。 使用 node 命令执行以上的代码： 12node server.jsServer running at http://127.0.0.1:8888/ 接下来，打开浏览器访问 http://127.0.0.1:8888/，你会看到一个写着 “Hello World”的网页。 NPMNPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种： 允许用户从NPM服务器下载别人编写的第三方包到本地使用。 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 新版的nodejs已经集成了npm。 npm安装教程：https://www.runoob.com/nodejs/nodejs-npm.html 使用 npm 命令安装模块npm 安装 Node.js 模块语法格式如下： 1$ npm install &lt;Module Name&gt; 以下实例，我们使用 npm 命令安装常用的 Node.js web框架模块 express: 12npm install express # 本地安装npm install express -g # 全局安装 安装好之后，express 包就放在了工程目录下的 node_modules 目录中，因此在代码中只需要通过 require(‘express’) 的方式就好，无需指定第三方包路径。 1var express = require('express'); Node.js REPL(交互式解释器)Node.js REPL(Read Eval Print Loop:交互式解释器) 表示一个电脑的环境，类似 Window 系统的终端或 Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。 REPL 语法启动 Node 的终端12$ node&gt; 这时就可以在 &gt; 后输入简单的表达式，并按下回车键来计算结果。 简单的表达式运算在 Node.js REPL 的命令行窗口中执行简单的数学运算： 12345$ node&gt; 5 / 22.5&gt; 1 + ( 2 * 3 ) - 43 使用变量变量声明需要使用 var 关键字，如果没有使用 var 关键字变量会直接打印出来。 使用 var 关键字的变量可以使用 console.log() 来输出变量。 12345678910$ node&gt; x = 1010&gt; var y = 10undefined&gt; x + y20&gt; console.log(\"Hello World\")Hello Worldundefined 多行表达式Node REPL 支持输入多行表达式，这就有点类似 JavaScript。接下来让我们来执行一个 do-while 循环： 1234567891011$ node&gt; var x = 0undefined&gt; do {... x++;... console.log(\"x: \" + x);... } while ( x &lt; 3 );x: 1x: 2x: 3undefined … 三个点的符号是系统自动生成的，回车换行后即可。Node 会自动检测是否为连续的表达式。 下划线(_)变量使用下划线(_)获取上一个表达式的运算结果 123456$ node&gt; 10 + 2030&gt; console.log(_ + _)60undefined REPL 命令 ctrl + c - 退出当前终端，可能会提示 .exit ctrl + c 按下两次 - 退出 Node REPL。 ctrl + d - 退出 Node REPL. 向上/向下 键 - 查看输入的历史命令 tab 键 - 列出当前命令 .help - 列出使用命令 .break - 退出多行表达式 .clear - 退出多行表达式 .save filename - 保存当前的 Node REPL 会话到指定文件 .load filename - 载入当前 Node REPL 会话的文件内容。 方法Node.js 回调函数Node.js 异步编程的直接体现就是回调 ，其所有 API 都支持回调函数。 阻塞代码实例main.js 文件代码： 1234var fs = require(\"fs\"); // file stream 模块？var data = fs.readFileSync('input.txt');console.log(data.toString());console.log(\"程序执行结束!\"); 运行程序： 1$ node main.js 非阻塞代码实例main.js 文件代码： 123456var fs = require(\"fs\");fs.readFile('input.txt', function (err, data) { if (err) return console.error(err); console.log(data.toString());});console.log(\"程序执行结束!\"); Node.js 事件通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件，如下实例： 12var events = require('events'); // 引入 events 模块var eventEmitter = new events.EventEmitter(); // 创建 eventEmitter 对象 以下程序绑定事件处理程序： 1eventEmitter.on('eventName', eventHandler); // 绑定事件及事件的处理程序 我们可以通过程序触发事件： 1eventEmitter.emit('eventName'); // 触发事件 绑定示例： 12345678910var events = require('events');var eventEmitter = new events.EventEmitter();var connectHandler = function connected() { // 创建事件处理程序 console.log('连接成功。');}eventEmitter.on('connection', connectHandler); // 绑定 connection 事件处理程序eventEmitter.emit('connection'); // 触发 connection 事件 EventEmitter 类events 模块只提供了一个对象：events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。 EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。 12345678var EventEmitter = require('events').EventEmitter;var event = new EventEmitter(); event.on('ev', function() { console.log('ev 事件触发'); }); setTimeout(function() { event.emit('ev'); }, 1000); // 定时1秒 123456789var events = require('events'); var emitter = new events.EventEmitter(); emitter.on('ev', function(arg1, arg2) { console.log('listener1', arg1, arg2); }); emitter.on('ev', function(arg1, arg2) { console.log('listener2', arg1, arg2); }); emitter.emit('ev', 'arg1 参数', 'arg2 参数'); 运行结果：两个事件监听器回调函数被先后调用。 EventEmitter 的属性 addListener(event, listener) 为指定事件添加一个监听器到监听器数组的尾部。 on(event, listener) 为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。 1server.on('ev', function (stream) { ; }); once(event, listener) 为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器 1server.once('ev', function (stream) { ; }); removeListener(event, listener) 移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。它接受两个参数，第一个是事件名称，第二个是回调函数名称。 1server.removeListener('ev', callback); removeAllListeners([event]) 移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。 setMaxListeners(n) 默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。 listeners(event) 返回指定事件的监听器数组。 emit(event, [arg1], [arg2], [...]) 按参数的顺序执行每个监听器，如果事件有注册监听返回 true，否则返回 false。 类方法 listenerCount(emitter, event) 返回指定事件的监听器数量。 事件 newListener event - 字符串，事件名称 listener- 处理事件函数该事件在添加新监听器时被触发。 removeListener event - 字符串，事件名称 listener - 处理事件函数从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引。 实例：获取特定事件数量 12345678910111213141516var events = require('events');var eventEmitter = new events.EventEmitter();var listener1 = function listener1() {;}var listener2 = function listener2() {;}// addListener 和 on 效果一样的eventEmitter.addListener('connection', listener1);eventEmitter.on('connection', listener2);var eventListeners = require('events').EventEmitter.listenerCount(eventEmitter,'connection');console.log(eventListeners + \" 个监听器监听连接事件。\");eventEmitter.removeListener('connection', listener1);eventEmitter.emit('connection'); error 事件如果没有响应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。 一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。 继承 EventEmitter大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。 数据Node.js Buffer 缓冲区JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。 但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。 Buffer 与字符编码Buffer 实例一般用于表示编码字符的序列，比如 UTF-8 、 UCS2 、 Base64 、或十六进制编码的数据。 通过使用显式的字符编码，就可以在 Buffer 实例与普通的 JavaScript 字符串之间进行相互转换。 123const buf = Buffer.from('runoob', 'ascii');console.log(buf.toString('hex')); // 输出 72756e6f6f62console.log(buf.toString('base64')); // 输出 cnVub29i Node.js 目前支持的字符编码包括： ascii - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。 utf8 - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。 utf16le - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。 ucs2 - utf16le 的别名。 base64 - Base64 编码。 latin1 - 一种把 Buffer 编码成一字节编码的字符串的方式。 binary - latin1 的别名。 hex - 将每个字节编码为两个十六进制字符。 创建 Buffer 类Buffer 提供了以下 API 来创建 Buffer 类： Buffer.alloc(size[, fill[, encoding]])： 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0 Buffer.allocUnsafe(size)： 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据 Buffer.allocUnsafeSlow(size) Buffer.from(array)： 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖） Buffer.from(arrayBuffer[, byteOffset[, length]])： 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。 Buffer.from(buffer)： 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例 Buffer.from(string[, encoding])： 返回一个被 string 的值初始化的新的 Buffer 实例 123456789101112131415161718// 创建一个长度为 10、且用 0 填充（默认）的 Buffer。const buf1 = Buffer.alloc(10);// 创建一个长度为 10、且用 0x1 填充的 Buffer。 const buf2 = Buffer.alloc(10, 1);// 创建一个长度为 10、且未初始化的 Buffer，这个方法比调用 Buffer.alloc() 更快，// 但返回的 Buffer 实例可能包含旧数据，因此需要使用 fill() 或 write() 重写。const buf3 = Buffer.allocUnsafe(10);// 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。const buf4 = Buffer.from([1, 2, 3]);// 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。const buf5 = Buffer.from('tést');// 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。const buf6 = Buffer.from('tést', 'latin1'); 写入缓冲区1buf.write(string[, offset[, length]][, encoding]) string - 写入缓冲区的字符串。 offset - 缓冲区开始写入的索引值，默认为 0 。 length - 写入的字节数，默认为 buffer.length encoding - 使用的编码。默认为 ‘utf8’ 。 根据 encoding 的字符编码写入 string 到 buf 中的 offset 位置。如果 buf 没有足够的空间保存整个字符串，则只会写入 string 的一部分。 只部分解码的字符不会被写入。 返回值：返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。 12buf = Buffer.alloc(256);len = buf.write(\"www.runoob.com\"); // 14 从缓冲区读取数据1buf.toString([encoding[, start[, end]]]) encoding - 使用的编码。默认为 ‘utf8’ 。 start - 指定开始读取的索引位置，默认为 0。 end - 结束位置，默认为缓冲区的末尾。 返回值：解码缓冲区数据并使用指定的编码返回字符串。 123456789buf = Buffer.alloc(26);for (var i = 0 ; i &lt; 26 ; i++) { buf[i] = i + 97;}console.log( buf.toString('ascii')); // 输出: abcdefghijklmnopqrstuvwxyzconsole.log( buf.toString('ascii',0,5)); // 输出: abcdeconsole.log( buf.toString('utf8',0,5)); // 输出: abcdeconsole.log( buf.toString(undefined,0,5)); // 使用 'utf8' 编码, 并输出: abcde 将 Buffer 转换为 JSON 对象1buf.toJSON() 当字符串化一个 Buffer 实例时，JSON.stringify() 会隐式地调用该 toJSON()。 返回值：返回 JSON 对象。 12345678910const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);const json = JSON.stringify(buf);console.log(json); // 输出: {\"type\":\"Buffer\",\"data\":[1,2,3,4,5]}const copy = JSON.parse(json, (key, value) =&gt; { return value &amp;&amp; value.type === 'Buffer' ? Buffer.from(value.data) : value;});console.log(copy); // 输出: &lt;Buffer 01 02 03 04 05&gt; 缓冲区合并1Buffer.concat(list[, totalLength]) list - 用于合并的 Buffer 对象数组列表。 totalLength - 指定合并后Buffer对象的总长度。 返回值：返回一个多个成员合并的新 Buffer 对象。 1234var buffer1 = Buffer.from(('Hello '));var buffer2 = Buffer.from(('World!'));var buffer3 = Buffer.concat([buffer1,buffer2]);console.log(\"buffer3: \" + buffer3.toString()); // buffer3: Hello World! 缓冲区比较1buf.compare(otherBuffer); otherBuffer - 与 buf 对象比较的另外一个 Buffer 对象。 返回值：返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同。 1234567var buffer1 = Buffer.from('ABC');var buffer2 = Buffer.from('ABCD');var result = buffer1.compare(buffer2);if(result &lt; 0) { console.log(buffer1 + \" 在 \" + buffer2 + \"之前\");}else if(result == 0){ } 拷贝缓冲区1buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]]) targetBuffer - 要拷贝的 Buffer 对象。 targetStart - 数字, 可选, 默认: 0 sourceStart - 数字, 可选, 默认: 0 sourceEnd - 数字, 可选, 默认: buffer.length 返回值：没有返回值。 1234var buf1 = Buffer.from('abcdefghijkl');var buf2 = Buffer.from('RUNOOB');buf2.copy(buf1, 2); //将 buf2 插入到 buf1 指定位置上console.log(buf1.toString()); // abRUNOOBijkl 缓冲区裁剪1buf.slice([start[, end]]) start - 数字, 可选, 默认: 0 end - 数字, 可选, 默认: buffer.length 返回值：返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引 start 到 end 的位置剪切。 123var buffer1 = Buffer.from('hello');var buffer2 = buffer1.slice(0,2); // 剪切缓冲区console.log(\"buffer2: \" + buffer2.toString()); // he 缓冲区长度1buf.length; 返回值：返回 Buffer 对象所占据的内存长度。 12var buffer = Buffer.from('www.runoob.com');console.log(\"buffer length: \" + buffer.length); // 14 Node.js StreamStream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。 Node.js，Stream 有四种流类型： Readable - 可读操作。 Writable - 可写操作。 Duplex - 可读可写操作. Transform - 操作被写入数据，然后读出结果。 所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有： data - 当有数据可读时触发。 end - 没有更多的数据可读时触发。 error - 在接收和写入过程中发生错误时触发。 finish - 所有数据已被写入到底层系统时触发。 从流中读取数据12345678910var fs = require(\"fs\"); // file stream 的缩写吧var data = ''; // 存储读出的内容var readerStream = fs.createReadStream('input.txt'); // 创建可读流readerStream.setEncoding('UTF8'); // 设置编码为 utf8。// 处理流事件 --&gt; data, end, errorreaderStream.on('data', function(chunk) { data += chunk; } );readerStream.on('end',function(){ console.log(data); } );readerStream.on('error', function(err){ console.log(err.stack); } ); 写入流123456789var fs = require(\"fs\");var data = '菜鸟教程官网地址：www.runoob.com';var writerStream = fs.createWriteStream('output.txt'); // 创建一个可以写入的流writerStream.write(data,'UTF8'); // 使用 utf8 编码写入数据writerStream.end(); // 标记文件末尾writerStream.on('finish', function() { console.log(\"写入完成。\"); } );writerStream.on('error', function(err){ console.log(err.stack); } ); 管道流管道提供了一个输出流到输入流的机制。通常我们用于从一个流中获取数据并将数据传递到另外一个流中。 以下实例通过读取一个文件内容并将内容写入到另外一个文件中。： 123456var fs = require(\"fs\");var readerStream = fs.createReadStream('input.txt'); // 创建一个可读流var writerStream = fs.createWriteStream('output.txt'); // 创建一个可写流// 管道读写操作：读取 input.txt 文件内容，并将内容写入到 output.txt 文件中readerStream.pipe(writerStream); 链式流链式是通过连接输出流到另外一个流并创建多个流操作链的机制。链式流一般用于管道操作。 用管道和链式来压缩和解压文件： 123456789var fs = require(\"fs\");var zlib = require('zlib');// 压缩 input.txt 文件为 input.txt.gzfs.createReadStream('input.txt') .pipe(zlib.createGzip()) .pipe(fs.createWriteStream('input.txt.gz')); console.log(\"文件压缩完成。\"); 执行完以上操作后，我们可以看到当前目录下生成了 input.txt 的压缩文件 input.txt.gz。 接下来，反过来解压该文件，代码如下： 123456789var fs = require(\"fs\");var zlib = require('zlib');// 解压 input.txt.gz 文件为 input.txtfs.createReadStream('input.txt.gz') .pipe(zlib.createGunzip()) .pipe(fs.createWriteStream('input.txt')); console.log(\"文件解压完成。\"); 流程Node.js 模块系统模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。 创建模块在 Node.js 中，创建一个模块非常简单，如下我们创建一个 main.js 文件，代码如下: 12var hello = require('./hello');hello.world(); 以上实例中，代码 require('./hello') 引入了当前目录下的 hello.js 文件（./ 为当前目录，node.js 默认后缀为 js）。 Node.js 提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。 接下来我们就来创建 hello.js 文件，代码如下： 123exports.world = function() { console.log('Hello World');} 在以上示例中，hello.js 通过 exports 对象把 world 作为模块的访问接口，在 main.js 中通过 require(‘./hello’) 加载这个模块，然后就可以直接访 问 hello.js 中 exports 对象的成员函数了。 封装对象到模块有时候我们只是想把一个对象封装到模块中，格式如下： 123module.exports = function() { // ...} 例如： hello.js 12345678910function Hello() { var name; this.setName = function(thyName) { name = thyName; }; this.sayHello = function() { console.log('Hello ' + name); }; }; module.exports = Hello; 这样就可以直接获得这个对象了： main.js 1234var Hello = require('./hello'); hello = new Hello(); hello.setName('BYVoid'); hello.sayHello(); 模块接口的唯一变化是使用 module.exports = Hello 代替了exports.world = function(){}。 在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports。 服务端模块Node.js 中自带了一个叫做 http 的模块。 模块加载顺序：文件模块缓存 -&gt; 原生模块 -&gt; 文件 Node.js 函数一个函数可以作为另一个函数的参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。例如： 123456789function say(word) { console.log(word);}function execute(someFunction, value) { someFunction(value);}execute(say, \"Hello\"); 匿名函数把一个函数作为变量传递，绕开“先定义，再传递” 12345function execute(someFunction, value) { someFunction(value);}execute(function(word){ console.log(word) }, \"Hello\"); Node.js 路由我们要为路由提供请求的 URL 和其他需要的 GET 及 POST 参数，随后路由需要根据这些数据来执行相应的代码。 我们需要的所有数据都会包含在 request 对象中，该对象作为 onRequest() 回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的 Node.JS 模块，它们分别是 url 和 querystring 模块。 找出浏览器请求的 URL 路径： server.js 1234567891011121314151617181920var http = require(\"http\");var url = require(\"url\"); function start(route) { function onRequest(request, response) { var pathname = url.parse(request.url).pathname; console.log(\"Request for \" + pathname + \" received.\"); route(pathname); response.writeHead(200, {\"Content-Type\": \"text/plain\"}); response.write(\"Hello World\"); response.end(); } http.createServer(onRequest).listen(8888); console.log(\"Server has started.\");} exports.start = start; router.js 12345function route(pathname) { console.log(\"About to route a request for \" + pathname);}exports.route = route; index.js 1234var server = require(\"./server\");var router = require(\"./router\"); server.start(router.route); $ node index.js，浏览器访问 http://127.0.0.1:8888 输出会有比较烦人的 /favicon.ico 请求相关的部分（可无视） Node.js 全局对象在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。global 最根本的作用是作为全局变量的宿主。 当你定义一个全局变量时，这个变量同时也会成为全局对象的属性，反之亦然。需要注意的是，在 Node.js 中你不可能在最外层定义变量，因为所有用户代码都是属于当前模块的， 而模块本身不是最外层上下文。 注意： 最好不要使用 var 定义变量以避免引入全局变量，因为全局变量会污染命名空间，提高代码的耦合风险。 __filename 当前正在执行的脚本的文件名。输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。 如果在模块中，返回的值是模块文件的路径。 __dirname 当前执行脚本所在的目录。 setTimeout(cb, ms) 在指定的毫秒(ms)数后执行指定函数(cb)。只执行一次指定函数。 返回一个代表定时器的句柄值。 clearTimeout(t) 用于停止一个之前通过 setTimeout() 创建的定时器。 参数 t 是通过 setTimeout() 函数创建的定时器。 123456function printHello(){ console.log( \"Hello, World!\");}var t = setTimeout(printHello, 2000); // 两秒后执行以上函数clearTimeout(t); // 清除定时器 setInterval(cb, ms) 在指定的毫秒(ms)数后执行指定函数(cb)。会不停地调用，直到清除或关闭。 返回一个代表定时器的句柄值。可以使用 clearInterval(t) 函数来清除定时器。 console 提供控制台标准输出：log / info / error / warn / dir / time / timeEnd / trace / assert process 描述当前Node.js 进程状态的对象，提供了一个与操作系统的简单接口。 exit / beforeExit / uncaughtException / Signal 事件 退出状态码、属性、方法：菜鸟教程 工具Node.js 常用工具util 是一个Node.js 核心模块，提供常用函数的集合，用于弥补核心JavaScript 的功能 过于精简的不足。 util.inherits实现对象间原型继承的函数 JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有提供对象继承的语言级别特性，而是通过原型复制来实现的。 1234567891011121314151617181920212223var util = require('util'); function Base() { this.name = 'base'; this.base = 1991; this.sayHello = function() { console.log('Hello ' + this.name); }; } Base.prototype.showName = function() { console.log(this.name);}; function Sub() { this.name = 'sub'; } util.inherits(Sub, Base); var objBase = new Base(); objBase.showName(); // baseobjBase.sayHello(); // Hello baseconsole.log(objBase); // { name: 'base', base: 1991, sayHello: [Function] } var objSub = new Sub();objSub.showName(); // sub//objSub.sayHello(); // (构造函数中的不会继承)console.log(objSub); { name: 'sub' } 我们定义了一个基础对象 Base 和一个继承自 Base 的 Sub，Base 有三个在构造函数内定义的属性和一个原型中定义的函数，通过util.inherits 实现继承。 注意：Sub 仅仅继承了Base 在原型中定义的函数，而构造函数内部创造的 base 属 性和 sayHello 函数都没有被 Sub 继承。 同时，在原型中定义的属性不会被 console.log 作 为对象的属性输出。如果我们去掉 objSub.sayHello(); 这行的注释，将会看到： 1234567891011node.js:201 throw e; // process.nextTick error, or 'error' event on first tick ^ TypeError: Object #&amp;lt;Sub&amp;gt; has no method 'sayHello' at Object.&amp;lt;anonymous&amp;gt; (/home/byvoid/utilinherits.js:29:8) at Module._compile (module.js:441:26) at Object..js (module.js:459:10) at Module.load (module.js:348:31) at Function._load (module.js:308:12) at Array.0 (module.js:479:10) at EventEmitter._tickCallback (node.js:192:40) util.inspectutil.inspect(object,[showHidden],[depth],[colors]) 是一个将任意对象转换 为字符串的方法，通常用于调试和错误输出。它至少接受一个参数 object，即要转换的对象。 showHidden 是一个可选参数，如果值为 true，将会输出更多隐藏信息。 depth 表示最大递归的层数，如果对象很复杂，你可以指定层数以控制输出信息的多 少。如果不指定depth，默认会递归2层，指定为 null 表示将不限递归层数完整遍历对象。 如果color 值为 true，输出格式将会以ANSI 颜色编码，通常用于在终端显示更漂亮 的效果。 特别要指出的是，util.inspect 并不会简单地直接把对象转换为字符串，即使该对象定义了 toString 方法也不会调用。 12345678910var util = require('util'); function Person() { this.name = 'byvoid'; this.toString = function() { return this.name; }; } var obj = new Person(); console.log(util.inspect(obj)); console.log(util.inspect(obj, true)); 运行结果是： 12345678910Person { name: 'byvoid', toString: [Function] }Person { name: 'byvoid', toString: { [Function] [length]: 0, [name]: '', [arguments]: null, [caller]: null, [prototype]: { [constructor]: [Circular] } } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.iwxyi.com/tags/学习笔记/"},{"name":"Node.js","slug":"Node-js","permalink":"http://blog.iwxyi.com/tags/Node-js/"}]},{"title":"Bat常用脚本命令","date":"2018-09-01T12:40:00.000Z","path":"2018/09/01/Bat常用脚本命令/","text":"run.bat—打开百度 12path=%path%; C:\\Program Files (x86)\\Internet Explorer\\start iexplore http://www.baidu.com 将c盘下所有文件名输出到a.txt中，如果没有a文件，则在bat同一目录下创建一个 1dir c:\\*.* &gt;a.txt 执行另一个批处理文件 1call c:\\code\\run.bat echo回显 1234@echo off 表示在此语句后所有运行的命令都不显示命令行本身 cd code 进入code文件夹echo enter code directory 显示enter code directorycall run.bat 增加入参 123@echo off type %1 type %2 cmd为 run.bat a.txt b.txt控制台会显示出a和b的文件内容 for循环的使用 123bat脚本@echo offfor %%t in (*.bat *.txt) do type %%t 注意1，打印的是bat和txt文件的内容注意2，此bat放在需打印文件内容的文件一个目录层级下 12@echo offFOR /L %%i in (1,2,20) DO echo %%i if/else判断语句的使用 1234567bat脚本@echo offif {%1}=={%2} (echo eq l.) else (echo not eq l.) cmd输入run.bat 1 2结果为 not eq 1 在一个批处理文件内最多可以使用10个替换参数(%0到%9) 1234567@echo offif exist a.txt ( echo This is a.txt type a.txt)else ( echo a.txt missing.) 判断当前目录下是否有a.txt 12345@ECHO OFFIF EXIST D:\\*.XLS () else (GOTO fail)PAUSE :failECHO 没找到文件 删除文件 12@echo offdel a.txt 12&gt; 注意：指定路径会删除该路径下所有文件&gt; 移动、拷贝文件、文件夹 123456@echo offmove c:\\a.txt c:\\code\\a.txt copy c:\\code\\a.txt c:\\a.txt rd c:\\code\\abc\\abc REM 删除非空文件夹 GOTO语句 123456@ECHO OFFGOTO SECOND:FIRSTecho I AM FIRST:SECONDecho I AM SECOND choice/errorlevel的用法 12345678910111213141516@echo off choice /C 123 /M \"RUN1,RUN2,RUN3\"if errorlevel 3 goto RUN3if errorlevel 2 goto RUN2 if errorlevel 1 goto RUN1 :RUN1 c:\\code\\RUN1 goto RUN3 :RUN2c:\\code\\RUN2goto RUN3 :RUN3echo good bye set 123456789@echo offset a=aa1bb1aa2bb2echo %a%set b=12echo %b%set /a c=39/10 echo %c% 1234567@echo offset p=aaaif %p%==aaa ( echo %p% set p=bbb echo %p% ) 输出 aaa aaa 1234567@echo offset p=aaaif %p%==aaa ( echo %p% set /p p=bbb echo %p% ) 输出 aaa bbb 123echo %CD% #代表当前目录的字符串echo %DATE% #当前日期echo %TIME% #当前时间 从FTP下载文件 12345678910111213@echo open 10.86.56.6 &gt;ftp.txt rem ftp server ip@echo user mos&gt;&gt;ftp.txt rem 用户名@echo mos&gt;&gt;ftp.txt rem 密码@echo cd test&gt;&gt;ftp.txt rem 文件路径@echo get mw-license-switch-conffile.xml&gt;&gt;ftp.txt rem 文件名@echo bye&gt;&gt;ftp.txtftp -i -n -s:ftp.txt rem 文件存放在脚本所在路径下 切换盘符 123set current_dir=C:\\Program Files\\HaoZip pushd %current_dir% echo %cd% 博客来源：https://www.cnblogs.com/laislabonita/p/7145731.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Bat","slug":"Bat","permalink":"http://blog.iwxyi.com/tags/Bat/"}]},{"title":"搭建FFM","date":"2018-08-30T05:48:00.000Z","path":"2018/08/30/搭建FFM/","text":"FFM 说明实现无需qq后台，直接借助服务器接收消息通过谷歌云端推送FCM推送到安卓手机，需要科学上网(除非你在国外)和谷歌服务框架，节省手机电量，顺便支持Android 7.0+的通知栏回复。 现在 Web QQ 已经挂掉了，此应用从此失效 一键脚本打基础，cpanm、Mojo-Webqq 这些就不用再装了，直接从下面的第三步开始。不过可能会出问题，最好还是按照下面的步骤来一遍。 再安装一下依赖，直接启动。 12yum install git -ygit clone https://github.com/null-ecp/FFM-one-step.git &amp;&amp; source ~/FFM-one-step/GCM.sh 分步安装1.安装Cpanm1curl -kL https://cpanmin.us | perl - App::cpanminus 2.安装Mojo-Webqq1cpanm Mojo::Webqq 部分centos在这一步会报错，重新执行cpanm Mojo::Webqq即可 3.安装Webqq::Encryption先安装依赖:1yum install -y perl-Crypt-OpenSSL-RSA perl-Crypt-OpenSSL-Bignum 继续安装模块1cpanm Webqq::Encryption 如果 失败则再次安装一遍依赖 4.安装FCM For Mojo安装git包管理器1yum install -y git 安装node.js12curl -sL https://rpm.nodesource.com/setup_9.x | bash -yum -y install nodejs 随后依次执行以下命令1234git clone https://github.com/RikkaApps/FCM-for-Mojo-Server.gitcd FCM-for-Mojo-Servercp config.example.js config.jsnpm install 自此安装完成 后台运行 screen为了让程序在断开ssh后也能运行，可以安装screen 1yum install -y screen 新建screen1screen -S qq screen常用命令1234screen -S [name] //新建screenscreen -r [name] //切换到一个screenscreen -ls //列出所有的screenexit //关闭当前screen 可以使用Ctrl+a+d来将当前screen移至后台 启动FFM1npm start 关闭防火墙不管可能会 time out 1234//临时关闭systemctl stop firewalld//禁止开机启动systemctl disable firewalld VIM 用法 i 在前面编辑 a 在后面编辑 :wq 保存退出 :q 退出 修改HOSTS修改命令 1vi /etc/hosts 404问题 connect.qq.com/proxy.html 404 解决方法是 修改HOSTS改为： 1112.90.143.119 web2.qq.com 一键机器人1cpanm Mojo::Webqq &amp;&amp; perl -MMojo::Webqq -e \"Mojo::Webqq-&gt;new-&gt;load('ShowMsg')-&gt;load('SmartReply')-&gt;run()\" 不过现在好像用不了了？ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"服务器","slug":"服务器","permalink":"http://blog.iwxyi.com/tags/服务器/"}]},{"title":"Qt QListView和QListWidget用法","date":"2018-08-19T09:34:00.000Z","path":"2018/08/19/Qt-QListView和QListWidget用法/","text":"QListView与QTreeView一样，也是采取的mvc模式，添加数据时，用相应的模式 1、初始化时添加数据1234567QStandardItemModel *model = new QStandardItemModel(this); //可以把这行放到头文件里面QStandardItem *item = new QStandardItem(\"item1\"); model-&gt;appendRow(item); item = new QStandardItem(\"item2\"); model-&gt;appendRow(item); ui-&gt;listViewTask-&gt;setModel(model); 2、根据用户操作来添加数据1234QStandardItem *item = new QStandardItem(\"item3\"); QStandardItemModel *model = dynamic_cast&lt;QStandardItemModel*&gt;(ui-&gt;listViewTask-&gt;model()); model-&gt;appendRow(item); 3、删除数据12QStandardItemModel *model = dynamic_cast&lt;QStandardItemModel*&gt;(ui-&gt;listViewTask-&gt;model()); model-&gt;removeRow(ui-&gt;listViewTask-&gt;currentIndex().row()); 4.获取行数；1int row_num = ui-&gt;listViewTask-&gt;model()-&gt;rowCount(); 5.选中指定的行号12QModelIndex qindex = m_listviewmodel_-&gt;index(index,0); //默认选中 indexui-&gt;listViewTask-&gt;setCurrentIndex(qindex); 6.设置滚动方式1234567enum QAbstractItemView::ScrollMode Constant Value Description QAbstractItemView::ScrollPerItem 0 The view will scroll the contents one item at a time. QAbstractItemView::ScrollPerPixel 1 The view will scroll the contents one pixel at a time. //设置为像素滚动；setVerticalScrollMode(QAbstractItemView::ScrollPerPixel); 7.初始化并设置隔行彩色显示；123456789101112131415161718192021222324252627282930311. standardItemModel = new QStandardItemModel(this); 2. 3. QStringList strList; 4. strList.append(\"string1\"); 5. strList.append(\"string2\"); 6. strList.append(\"string3\"); 7. strList.append(\"string4\"); 8. strList.append(\"string5\"); 9. strList.append(\"string6\"); 10. strList.append(\"string7\"); 11. strList &lt;&lt; \"string8\"; 12. strList += \"string9\"; 13. int nCount = strList.size(); 14. for(int i = 0; i &lt; nCount; i++) 15. { 16. QString string = static_cast&lt;QString&gt;(strList.at(i)); 17. QStandardItem *item = new QStandardItem(string); 18. if(i % 2 == 1) 19. { 20. QLinearGradient linearGrad(QPointF(0, 0), QPointF(200, 200)); 21. linearGrad.setColorAt(0, Qt::darkGreen); 22. linearGrad.setColorAt(1, Qt::yellow); 23. QBrush brush(linearGrad); 24. item-&gt;setBackground(brush); 25. } 26. standardItemModel-&gt;appendRow(item); 27. } 28. listView-&gt;setModel(standardItemModel); 29. listView-&gt;setFixedSize(200,300); 30. connect(listView,SIGNAL(clicked(QModelIndex)),this,SLOT(itemClicked(QModelIndex))); 31. } 8、更新某一行；12345678910111213141516171819int row=listview-&gt;currentIndex().row();if(row!=-1){ QModelIndex index=listmodel-&gt;index(row); QString str=listmodel-&gt;data(index,Qt::DisplayRole).toString();//get data bool ok; QString text = QInputDialog::getText(this, tr(\"edit item\"), tr(\"please edit item\"), QLineEdit::Normal, str, &amp;ok); if (ok &amp;&amp; !text.isEmpty()) { listmodel-&gt;setData(index,text,Qt::EditRole); listview-&gt;setCurrentIndex(index); }}else{ QMessageBox::information(NULL,tr(\"information\"),tr(\"please select a item\"));} QListWidgetQListWidget 是派生于QListView的。有了QListWidget ，QListView便是废了；因为QListWidget 能完成所有QListView的。没有必要再用listview 添加12345678910 QString strInput = XGlobal::mGetInputString(\"请输入任务名称，比如上传省局节点机\"); if(strInput.isEmpty()) { return; } QListWidgetItem *pItem = new QListWidgetItem(); pItem-&gt;setText(strInput); ui-&gt;listViewTask-&gt;addItem(pItem); 或者这样也行 1234QStringList strList;strList&lt;&lt; \"Item1\"&lt;&lt;\"Item2\"&lt;&lt; \"Item3\"&lt;&lt;\"Item4\";this-&gt;addItems(strList); 删除1234567/***** 删除单个列表项 *****/void MainWindow::deletebtn(){ //获取列表项的指针 QListWidgetItem *item = ui-&gt;listWidget-&gt;takeItem(ui-&gt;listWidget-&gt;currentRow()); delete item; //释放指针所指向的列表项} 1234567891011/***** 删除多个列表项 *****/void MainWindow::delallbtn(){ int num = ui-&gt;listWidget-&gt;count(); //获取列表项的总数目 ui-&gt;listWidget-&gt;setFocus(); //将光标设置到列表框上，若注释该语句，则删除时，要手动将焦点设置到列表框，即点击列表项 for(int i=0;i&lt;num;i++) { //逐个获取列表项的指针，并删除 QListWidgetItem *item = ui-&gt;listWidget-&gt;takeItem(ui-&gt;listWidget-&gt;currentRow()); delete item; }} 12345678910111213141516171819202122/***** 添加多个列表项 *****/void MainWindow::addallbtn(){ QStringList FileNames = QFileDialog::getOpenFileNames(this,\"打开\",QDir::currentPath(),\"所有文件(*.*);;文本文档(*.txt)\"); //方法1 整体添加// ui-&gt;listWidget-&gt;addItems(FileNames); //方法2 逐个添加 int index=0,count=0;// QListWidgetItem *item = new QListWidgetItem; //…………注释1 count = FileNames.count(); //获取打开文件的总数目// for(index = 0;index&lt;count;index++) //这样会报错，无法先取出栈底元素 //注释2 for(index=count-1;index&gt;=0;index--) //QList&lt;QString&gt;的数据结构是栈，只能从栈顶取元素 { QListWidgetItem *item = new QListWidgetItem; item-&gt;setText(FileNames.takeAt(index)); //逐个设置列表项的文本// qDebug()&lt;&lt;FileNames.takeAt(index); //…………注释3 ui-&gt;listWidget-&gt;addItem(item); //加载列表项到列表框 }} 点击12345/***** 列表项单击操作 *****/void MainWindow::singleclicked(QListWidgetItem* item){QMessageBox::information(this,\"单击消息\",\"单击\"+item-&gt;text());} 12345/***** 列表项双击操作 *****/void MainWindow::doubleclicked(QListWidgetItem* item){QMessageBox::information(this,\"双击消息\",\"双击\"+item-&gt;text());} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"Qt实现窗口关闭动画","date":"2018-08-18T11:00:00.000Z","path":"2018/08/18/Qt实现窗口关闭动画/","text":"现在很多软件在窗口状态切换的时候都会带那么一些小动画，看起来还挺酷的。比如程序退出的时候，有些软件会展现一个 窗口合拢的效果；比如QQ贴边隐藏、展现会有一个滑出滑入的动画效果，如果要我们自己实现也可以，就是动态改变窗口大小和位置嘛，但效率如何就不敢保证啦。还好Qt早就为我们准备了这么一个动画框架：QAbstractAnimation. 这个抽象类被 QAnimationGroup, QPauseAnimation, and QVariantAnimation这3个类继承，第一个主要是完成动画的并行播放，第二个是为并行播放提供单个动画的暂停，第三个是提供任意Variant类型的动画效果,它被QPropertyAnimation继承。完成窗口关闭动画效果只要用这个类就行了。 下面说一下实现流程：首先当窗口关闭的时候会接收到一个closeEvent,当我们截获到这个closeEvent的时候就要播放关闭动画，当动画播放完毕，我们就关闭窗口,代码如下: 1234567891011121314151617181920212223void StyledWindow::playCloseAnimation(){ setMinimumSize(0,0); QPropertyAnimation* closeAnimation = new QPropertyAnimation(this,\"geometry\"); closeAnimation-&gt;setStartValue(geometry()); closeAnimation-&gt;setEndValue(QRect(geometry().x(),geometry().y()+height()/2,width(),0)); closeAnimation-&gt;setDuration(300); closeAnimationState = hasplayed; connect(closeAnimation,SIGNAL(finished()),this,SLOT(close())); closeAnimation-&gt;start(QAbstractAnimation::DeleteWhenStopped);}void StyledWindow::closeEvent(QCloseEvent *event){ if(isPlayCloseAnimation &amp;&amp; closeAnimationState == notplay){ playCloseAnimation(); event-&gt;ignore(); } else{ event-&gt;accept(); }} 第一行是为了防止窗口设置了最小值，改变不了大小！这要注意一下！我把playCloseAnimation()弄成了虚函数，这样继承这个类的时候只要重新实现虚函数就可以完成不一样的关闭动画，无需再重写closeEvent().但是注意了,这段代码仅对无边框的窗口有效，如果你的窗口不是无边框的那么需要改变的是frameGeometry属性，但是这个属性只有读函数，没有写函数，你必须自己实现一个写函数，然后利用Q_Property宏声明一下才行，详细的请查询 Q_Property System document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"Qt控件渐变消失","date":"2018-08-18T10:58:00.000Z","path":"2018/08/18/Qt控件渐变消失/","text":"QT控件渐变消失前言在 Qt 开发中，经常会设置某些控件透明的透明度，比如设置QLabel字体渐变隐藏，设置某个按钮渐变消失等等，这在消息提示框中会常用到，显示一定时间后让控件有一个动画逐渐消失的过程，其实原理很简单，就是设置控件的透明度，直到透明度为0后再将控件设置为隐藏即可。动画的过程可以用两种方式来实现，第一是通过定时器，不断的设置控件的透明度，第二是通过QPropertyAnimation来实现，当然，后者会更简单。那么该如何设置控件透明度呢，这里需要用到QGraphicsOpacityEffect类。 正文当然，还可以将 QLabel 换成其他控件，比如 QPushButton等等。 来看源码： 123456789101112131415161718192021222324252627Widget::Widget(QWidget *parent) : QWidget(parent), ui(new Ui::Widget){ ui-&gt;setupUi(this); m_pGraphicsOpacityEffect = new QGraphicsOpacityEffect(ui-&gt;label); m_pGraphicsOpacityEffect-&gt;setOpacity(1); ui-&gt;label-&gt;setGraphicsEffect(m_pGraphicsOpacityEffect); m_pNameAnimation = new QPropertyAnimation(m_pGraphicsOpacityEffect,\"opacity\",this); m_pNameAnimation-&gt;setEasingCurve(QEasingCurve::Linear); m_pNameAnimation-&gt;setDuration(2500);}Widget::~Widget(){ delete ui; delete m_pGraphicsOpacityEffect; delete m_pNameAnimation;}void Widget::on_pushButton_clicked(){ m_pNameAnimation-&gt;setStartValue(1); m_pNameAnimation-&gt;setEndValue(0); m_pNameAnimation-&gt;start(QAbstractAnimation::KeepWhenStopped);} 代码很简单，就是QGraphicsOpacityEffect + QPropertyAnimation来实现想要的效果。 以上是设置控件的透明度，如果想要设置窗口透明度，需要用到 QWidget 的函数setWindowOpacity来实现，原理和上面一样，也可以通过QPropertyAnimation来实现动画效果。 参考：https://blog.csdn.net/luoyayun361/article/details/77921311 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"Qt定时器","date":"2018-08-18T09:50:00.000Z","path":"2018/08/18/Qt定时器/","text":"有两种方法实现定时器。 第一种：1.新建GUI工程，工程名可以设置为timer。并在主界面上添加一个标签，并设置其内容为”0000-00-00 00:00:00 星期日“。 2.在mainwindow.h中添加槽函数声明。 12private slots: void timerUpDate(); 3.在mainwindow.cpp中添加代码。 添加#include &lt;QtCore&gt;的头文件包含，这样就包含了QtCore下的所有文件。 构造函数里添加代码： 12345QTimer *timer = new QTimer(this); //新建定时器connect(timer,SIGNAL(timeout()),this,SLOT(timeUpDate())); //关联定时器计满信号和相应的槽函数。timer-&gt;start(1000); //定时器开始计时，其中1000表示1000ms即1s,每1000ms就会触发一次槽函数。 4.然后实现更新函数。 12345678voidMainWindow::timerUpDate(){ QDateTime time = QDateTime::currentDateTime();//获取系统现在的时间 QString str = time.toString(\"yyyy-MM-dd hh:mm:ss dddd\");//设置系统时间显示格式 ui-&gt;label-&gt;setText(str);//在标签上显示时间} 5.运行程序，效果如图： 第二种：使用事件（有点像单片机中的定时器）1.新建工程。在窗口中添加标签。 2.在main.cpp中添加代码，实现中文显示。 123#include &lt;QTextCodec&gt;QTextCodec::setCodecForTr(QTextCodec::codecForLocale()); 3.在mainwindow.h中添加代码。 1void timeEvent(QTimerEvent *); 4.在mainwindow.cpp中添加代码 添加头文件 #include &lt;QtCore&gt; 在构造函数里添加以下代码。 123startTimer(1000);//其返回值为1，即其timerId为1startTimer(5000);//其返回值为2,即其timerId为2startTimer(10000);//其返回值为3，即其timerId为3 添加了三个定时器，它们的timerId分别为1,2,3,。注意第几个定时器的返回值就是几。所以要注意定时器顺序。 在下面添加函数实现。 123456789voidMainWindow::timerEvent(QTimerEvent *t)//定时器时间{ switch(t-&gt;timerId())；//判断定时器的句柄 { case 1:ui-&gt;label-&gt;setText(tr(\"每秒产生一个随机数:%1\").arg(qrand()%10));break; case 2:ui-&gt;label_2-&gt;setText(tr(\"5秒后软件将关闭\"));break; case 3:qApp-&gt;quit();break;//退出系统 }} 这里添加了三个定时器，并都在定时器时间中判断他们，然后执行相应的功能，这样就不用每个定时器都写一个关联函数和槽函数 随机数的实现：上面程序中qrand(),可以产生随机数，qrand()%10可以产生0~9之间的随机数。要想产生100以内的随机数就得%100，以此类推但这样每次启动程序后，都按同一种顺序产生随机数，为了实现每次启动程序产生不同的初始值，我们可以使用qsrand(time(0));实现设置随机数的初始值而程序每次启动时time(0)返回的值都不同，这样就实现了产生不同初始值的功能。我们将qsrand(time(0));一句加入到构造函数里。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"Qt自定义Model、View、Delegate","date":"2018-08-18T09:30:00.000Z","path":"2018/08/18/Qt自定义Model、View、Delegate/","text":"如何使用Model View delegate自定义列表这是一个演示Model/View Programming 中自定义model，自定义delegate用法的程序。 通过自定义的model，delegate，实现自定义的列表元素。 目标是构造一个列表，其中每个列表元素包含若干图片，文字， 按钮等。要实现这样的功能，第一反应是 自己定义一个widget，把图片文字控件放在里面加上layout， 然后再用使用void QAbstractItemView::setIndexWidget，加LlistView或TableView里面。 当界面元素固定，少量的时候，这是首选，但是要看到setIndexWidget帮助文档里面的警告，这样做是有效率代价的，如果列表有100项，那么就要加入100个widget， 很大的消耗。 使用delegate的话你可以只是paint 每个元素， 在需要操作的时候才构建真正的控件，而画控件可以用QStyle::drawControl() 画出来，当然这样做你需要构造，自己的model，delegate， 自己做数据绑定。 这样做效率很高，因为只有当前的控件是真的，其他都是画上去的！ 开始 关于Model/View Programming的使用，最好的文档当然是Qt自己的帮助，建议先通读一遍， 同时参考Qt中的例子： StringListModel ：位于doc\\src\\snippets\\stringlistmodel， 这个例子的代码都在帮助的 Creating New Models这一章，建议阅读的时候顺手做一下，而我下面的例子是在这个例子基础上改成的。 SpinBoxDelegate：这个例子用以演示 如何自定义delegate， 来实现自定义的表元素，每个列表元是个spinbox， 可以编辑。这个例子解释了自定义delegate 的方方面面，但是用的model 是框架自带的 PixelDelegate： 这是个很漂亮的例子，演示了model view delegate的强大威力，其model 和delegate的自定义程度很高，演示了model和delegate之间的数据交互。遗憾的是这是个只读的例子，就是说并不能通过model改变data。 StarDelegate： 这个例子演示了如何定制delegate， 使用了自定义的数据结构，和编辑器，效果很强大，我们的自定义控件也期望这个目标。遗憾是没有定制model。 我们期望自己的StarDelegatedelegate能画上图片等元素 如StarDelegate，PixelDelegate， 又能支持一些系统控件（button，checkbox…）如SpinBoxDelegate，但是上面三个强大的例子都没能完全达到这个目标，所以才写这篇文章。 下面开始新建一个QT工程，选Mobile QT Application， 在ui中拖入一个ListView。 自定义model为了说明问题，这里用最简单的数据结构，一个QStringList， model 是 数据的直接接口，有了String， 我们可以显示文字，也可以作为路径读取图片，在这个小例子中足够了。按照帮助中 Creating New Models的顺序，首先我们做一个只读的model， 在mainWindow.cpp中 对listview 加载model： 12parserModel *model = new parserModel(strings, this);ui-&gt;listView-&gt;setModel(model); 只读的model只读的model 只需要实现rowCount ，data 两个方法， 这里为ListView服务，所以我们继承QAbstractListModel， 如果用TableView的话，可以像PixelDelegate那样使用QAbstractTableModel。 1234567891011121314class parserModel : public QAbstractListModel{ Q_OBJECTpublic: parserModel(const QStringList &amp;strings, QObject *parent = 0); //basic function for a read-only model int rowCount ( const QModelIndex &amp; parent = QModelIndex() ) const; QVariant data ( const QModelIndex &amp; index, int role = Qt::DisplayRole ) const ; private: //simple data source just a QStringList, if need can add other list of QString, int, bool, struct or class QStringList stringList;}; 想要 rowCount 能返回string list 中string的个数，所以我们这样写： 1234int parserModel::rowCount(const QModelIndex &amp;parent) const{ return stringList.count();} 接下来关键的 data 函数，这个函数是 View 或 Delegate 获取数据的主要接口，我们想要显示文字，图片，都是从model中直接获得，我们这样写： 123456789101112131415161718192021222324QVariant parserModel::data(const QModelIndex &amp;index, int role) const{ if ( (!index.isValid()) || (index.row() &gt;= stringList.size())) return QVariant(); if(role == Qt::UserRole) { return stringList.at(index.row()); } else if( role == Qt::UserRole+1) { QPixmap pixmap; pixmap.load(stringList.at(index.row())); return pixmap.scaled(80, 80,Qt::KeepAspectRatioByExpanding, Qt::FastTransformation); } else if( role == Qt::UserRole+2) { QPixmap pixmap; pixmap.load(stringList.at(index.row())); return pixmap.scaled(20, 20,Qt::KeepAspectRatio, Qt::FastTransformation); } return QVariant();} 这里默认是返回QVariant()， 关键是看中间返回的东西，必须结合后面的Delegate实现来一起看。 当delegate 或 view 询问数据的时候会传给data方法两个参数，就是问model要 位于 index这个地方的具有role数据，enum Qt::ItemDataRole 中常见的role是 Qt::DisplayRole 返回 QString 文字 Qt::DecorationRole 返回 QPixmap 图片 但是如果你想要返回另一幅图的话，就要用其他的role了，所以这里我全用 Qt::UserRole，来解释这个问题。 一个解释Qt::ItemDataRole 的例子是 Color Editor Factory，在这个例子中列表显示颜色和颜色名，都是从颜色名字符串中读数据，但是显示的时候一个是颜色方块，和名字，这就是同一个数据的两种表现形式，两个role。更进一步的，你可以在model中再引用一个struct 或者class Data， 当被询问不同的role的时候返回 Data.str1,或 Data.int2, 这样同一个index可以返回不同的数据，不同的数据类型。也可以是SQL查询的结果，在选择语句中传入不同的查询参数，这取决于你的数据结构，总之data被model 包装隔离了。不清楚没关系，下面我们看delegate如何数据。 自定义delegateQT 4.6以后推荐自定义delegate 继承自QStyledItemDelegate，使用styleSheet来显示。不失一般性，这里先用QItemDelegate来说明问题。在mainWindow.cpp中 对listview 加载delegate： 12MyDelegate *delegate = new MyDelegate(this);ui-&gt;listView-&gt;setItemDelegate(delegate); 只读的delegate先做只读的功能，需要重写 paint，和sizeHint 这个函数 12345678910class MyDelegate : public QItemDelegate{ Q_OBJECTpublic: explicit MyDelegate(QObject *parent = 0); //basic function for a read-only delegate, you can draw anything with the painter void paint ( QPainter * painter, const QStyleOptionViewItem &amp; option, const QModelIndex &amp; index ) const; QSize sizeHint ( const QStyleOptionViewItem &amp; option, const QModelIndex &amp; index ) const;}; sizeHint用于指定绘制每个列表项的大小，关键是paint方法， 有了paint，我们就可以任意定制我们的列表 123456789101112131415161718192021222324252627282930void MyDelegate::paint ( QPainter * painter, const QStyleOptionViewItem &amp; option, const QModelIndex &amp; index ) const{ QStyleOptionViewItemV4 opt = setOptions(index, option); // prepare painter-&gt;save(); // get the data and the rectangles const QPixmap&amp; pixmap = qvariant_cast&lt;QPixmap&gt;(index.data(Qt::UserRole+1)); QRect decorationRect = QRect(opt.rect.topLeft(), QSize(80,80)); const QString&amp; text = index.data(Qt::UserRole).toString(); QFontMetrics fm(painter-&gt;font()); QRect displayRect = QRect(decorationRect.topRight()+QPoint(20,30),QSize(fm.width(text),fm.height())); const QPixmap&amp; pixmapSmall = qvariant_cast&lt;QPixmap&gt;(index.data(Qt::UserRole+2)); QRect smallIconRect = QRect(opt.rect.topRight()-QPoint(100,-20), QSize(20,20)); drawBackground(painter, opt, index); painter-&gt;drawPixmap(decorationRect, pixmap); painter-&gt;drawText(displayRect, text); painter-&gt;drawPixmap(smallIconRect, pixmapSmall); drawFocus(painter, opt, displayRect); // done painter-&gt;restore();} 参见最后的效果图，这里每一个列表项有两幅图，一行文字，图片和文字都是用 qvariant_cast(index.data(Qt::UserRole+1)); index.data(Qt::UserRole).toString(); 取得的，注意qvariant_cast的用法。 index.data(Qt::UserRole+1) 会调用model中的 QVariant data ( const QModelIndex &amp; index, int role ) const 方法。 delegate 的role和 model 的role对应。 通过修改model中data的实现，可以使得delegate显示不同的东西，而delegate的代码不需变动，实现了数据的隔离。到目前为止一个只读的自定义列表就完成了，在paint方法中加入下面的代码，可以画出一个pushButton， 但是点击没有反应，这需要在下面的编辑功能中实现。 12345QStyleOptionButton opt;opt.state |= QStyle::State_Enabled;opt.rect = option.rect.adjusted(1, 1, -10, -10);opt.text = trUtf8(\"Button text\");QApplication::style()-&gt;drawControl(QStyle::CE_PushButton, &amp;opt, painter, 0); item中显示不同的字体这里是painter的使用技巧，要在同一个列表项中的显示的不同的字体，需要在新的的 painter-&gt;save，painter-&gt;restore段中写， 如下的代码段实现了最后的效果图 1234567891011121314151617181920void MyDelegate::paint ( QPainter * painter, const QStyleOptionViewItem &amp; opt, const QModelIndex &amp; index ) const{ painter-&gt;save(); // get the data and the rectangles const QString&amp; text = index.data(Qt::UserRole).toString(); QRect displayRect;//set the paint rect painter-&gt;setPen(QColor(255,127,127)); painter-&gt;drawText(displayRect, text); painter-&gt;restore(); painter-&gt;save(); // get the data and the rectangles const QString&amp; text2 = index.data(Qt::UserRole+1).toString(); QRect displayRect2;//set the paint rect painter-&gt;setPen(QColor(255,122,0)); painter-&gt;drawText(displayRect2, text2); painter-&gt;restore();} 增加编辑功能可编辑的model要使model可以修改data，我们需要重写flags，setData ， 修改后的model变成： 123456789101112131415161718class parserModel : public QAbstractListModel{ Q_OBJECTpublic: parserModel(const QStringList &amp;strings, QObject *parent = 0); //basic function for a read-only model int rowCount ( const QModelIndex &amp; parent = QModelIndex() ) const; QVariant data ( const QModelIndex &amp; index, int role = Qt::DisplayRole ) const ; //for a editable model Qt::ItemFlags flags(const QModelIndex &amp;index) const; bool setData(const QModelIndex &amp;index, const QVariant &amp;value, int role); private: //simple data source just a QStringList, if need can add other list of QString, int, bool, struct or class QStringList stringList;}; 其中 flags方法非常重要，需要根据具体的user case 来设定，这个例子处理的简单草率。 来看setData 1234567891011bool parserModel::setData(const QModelIndex &amp;index, const QVariant &amp;value, int role){ if (index.isValid() &amp;&amp; role == Qt::EditRole) { stringList.replace(index.row(), value.toString()); emit dataChanged(index, index); return true; } return false;} 由于我们使用的是简单的QListView， 要使用标准的Qt::EditRole来传递编辑数据。数据修改结束发射signal 提示listview 改变显示。 emit dataChanged(index, index); 可编辑的delegate要使delegate可以修改data，我们需要重写createEditor ，setEditorData ，setModelData ，updateEditorGeometry ， 修改后的delegate变成： 12345678910111213141516class MyDelegate : public QItemDelegate{ Q_OBJECTpublic: explicit MyDelegate(QObject *parent = 0); //basic function for a read-only delegate, you can draw anything with the painter void paint ( QPainter * painter, const QStyleOptionViewItem &amp; option, const QModelIndex &amp; index ) const; QSize sizeHint ( const QStyleOptionViewItem &amp; option, const QModelIndex &amp; index ) const; //for a editable delegate QWidget * createEditor ( QWidget * parent, const QStyleOptionViewItem &amp; option, const QModelIndex &amp; index ) const ; void setEditorData ( QWidget * editor, const QModelIndex &amp; index ) const ; void setModelData ( QWidget * editor, QAbstractItemModel * model, const QModelIndex &amp; index ) const ; void updateEditorGeometry ( QWidget * editor, const QStyleOptionViewItem &amp; option, const QModelIndex &amp; index ) const ;}; 由于我们这里的数据只是QString, 于是用了个QLineEdit，如果还有其他数据需要编辑，可以做一个widget，在里面加入 QLineEdit ，QSpinBox，checkbox等editor，或自定义的editor如StarDelegate。然后在setModelData 中响应。 12345678910QWidget * MyDelegate::createEditor ( QWidget * parent, const QStyleOptionViewItem &amp; option, const QModelIndex &amp; index ) const{ QLineEdit *editor = new QLineEdit(parent); return editor;}void MyDelegate::setModelData ( QWidget * editor, QAbstractItemModel * model, const QModelIndex &amp; index ) const{ QLineEdit *textEdit = qobject_cast&lt;QLineEdit *&gt;(editor) ; model-&gt;setData(index, qVariantFromValue(textEdit-&gt;text()));} setEditorData需要读取Model数据 123456void MyDelegate::setEditorData ( QWidget * editor, const QModelIndex &amp; index ) const{ const QString&amp; text = index.data(Qt::UserRole).toString(); QLineEdit *textEdit = qobject_cast&lt;QLineEdit *&gt;(editor) ; textEdit-&gt;setText(text);} 列表的元素被选中进入编辑状态后，描绘就不通过paint了，这个时候要重做一遍，好在只需做一次特殊处理，用updateEditorGeometry 1234567void MyDelegate::updateEditorGeometry ( QWidget * editor, const QStyleOptionViewItem &amp; option, const QModelIndex &amp; index ) const{ QRect decorationRect = QRect(option.rect.topLeft(), QSize(80,80)); QRect displayRect = QRect(decorationRect.topRight()+QPoint(20,30),QSize(150,25));//QRect(decorationRect.topRight()+QPoint(20,30),QSize(50,50)); editor-&gt;setGeometry(displayRect);} 至此一个可编辑的自定义listview就做出来了， 通过修改字符串指向已存在的图像的路径，可以改变列表中的图片。 限于篇幅自定义的按钮留待以后实现。 使用StyleSheet定制listview的外观1listView-&gt;setStyleSheet(ss); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"Qt::ItemDataRole","date":"2018-08-18T09:28:00.000Z","path":"2018/08/18/Qt-ItemDataRole/","text":"model中的每个item项都有相关联的数据元素，都有自己的role，这些roles被用于view需要那种类型的model。自定义的model需要返回这些类型的数据。 通用的roles和相关联的种类： 123456789101112131415Constant Value DescriptionQt::DisplayRole 0 The key data to be rendered in the form of text. 数据以文本形式出现. (QString)Qt::DecorationRole 1 The data to be rendered as a decoration in the form of an icon. 数据作为图标出现(QColor, QIcon or QPixmap) Qt::EditRole 2 The data in a form suitable for editing in an editor. 表单中的数据适合在编辑器中编辑(QString)Qt::ToolTipRole 3 The data displayed in the item's tooltip. 数据显示Item提示(QString)Qt::StatusTipRole 4 The data displayed in the status bar. 数据现在在 status bar中 (QString)Qt::WhatsThisRole 5 The data displayed for the item in \"What's This?\" mode. 数据显示在\"What's This?\"mode中(QString)Qt::SizeHintRole 13 The size hint for the item that will be supplied to views. 项的大小提供给Views。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"Qt自定义列表Delegate","date":"2018-08-18T09:26:00.000Z","path":"2018/08/18/Qt自定义列表Delegate/","text":"实现功能：Model/View框架中的Delgate负责单元格的显示。自己定义如何编辑列表listwidget中的项item。1、定义每一项的显示大小。2、显示其data：显示姓名、电话号码，插入表示性别data的图像。 代码实现：1、派生一个QStyledItemDelegate的类对象MyItemDrawer。 123456789101112131415161718192021#ifndef MYITEMDRAWER_H#define MYITEMDRAWER_H#include &lt;QStyledItemDelegate&gt;#include &lt;QIcon&gt;class MyItemDrawer : public QStyledItemDelegate{public: MyItemDrawer(QWidget *parent);private: //重写两个虚函数 virtual void paint(QPainter *painter,const QStyleOptionViewItem &amp;option,const QModelIndex &amp;index)const; //显示性别图片 virtual QSize sizeHint(const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const; //更改item显示的大小private: QPixmap m_male; // 声明表示性别的两个QPixmap类型图片 QPixmap m_female;};#endif // MYITEMDRAWER_H123456789101112131415161718192021 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include \"myitemdrawer.h\"#include &lt;QPainter&gt;MyItemDrawer::MyItemDrawer(QWidget *parent){ m_male.load(\"C:/Users/Maggie/Downloads/male.png\"); //析构函数中初始化图片 m_female.load(\"C:/Users/Maggie/Downloads/female.png\");}QSize MyItemDrawer::sizeHint(const QStyleOptionViewItem &amp;option, const QModelIndex &amp;index) const{ QSize size=QStyledItemDelegate::sizeHint(option,index); size.setHeight(80); return size;}void MyItemDrawer::paint(QPainter* painter,const QStyleOptionViewItem &amp;option,const QModelIndex &amp;index)const{ QRect rect=option.rect; rect.adjust(2,2,-2,-2); //缩小一圈 QString name=index.data(Qt::DisplayRole).toString(); //得到item的数据 姓名 QString phone=index.data(Qt::UserRole+1).toString(); //得到item的数据 电话号码 bool gender=index.data(Qt::UserRole+1).toBool();//得到item的数据 性别 if(option.state&amp;QStyle::State_Selected) { painter-&gt;setBrush(QColor(0xCC,0xAA,0xaa)); painter-&gt;drawRoundedRect(rect,2,2); //给每个item的背景涂色 painter-&gt;setBrush(Qt::NoBrush); } if(1) //显示姓名 { QRect dst=rect; dst.setLeft(rect.left()+40); dst.setBottom(rect.top()+20); painter-&gt;drawText(dst,Qt::AlignLeft|Qt::AlignVCenter,name); } if(1) //显示电话号码 { QRect dst = rect; dst.setLeft(rect.left() + 40); dst.setTop(rect.top() + 20); painter-&gt;drawText(dst, Qt::AlignLeft | Qt::AlignVCenter,phone); } if(1) //显示图片 { QRect dst=rect; dst.setRight(rect.left()+40); QRect area(0,0,24,24); area.moveCenter(dst.center()); painter-&gt;drawPixmap(area,gender?m_male:m_female); }} 2、MainWindow主窗口类中实现AddItem函数： 12345678void MainWindow::AddItem(QString name,QString phone,bool gender){ QListWidgetItem *item=new QListWidgetItem(); item-&gt;setData(Qt::DisplayRole,name); item-&gt;setData(Qt::UserRole+1,phone); item-&gt;setData(Qt::UserRole+2,gender); ui-&gt;listWidget-&gt;addItem(item);}12345678 3、在MainWindow类构造函数中： 12345AddItem(\"zzn\",\"13922233333\",false); //加入多项数据AddItem(\"hw\",\"13833322222\",true);ui-&gt;listWidget-&gt;setItemDelegate(new MyItemDrawer(ui-&gt;listWidget)); //给listwidget设置delegate，如果不设置自己写的，默认框架里也会有一个delegate。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"Qt QListWidget实现复杂的列表控件","date":"2018-08-15T09:35:00.000Z","path":"2018/08/15/Qt-QListView实现复杂的列表控件/","text":"主要用这个函数： void QListWidget::setItemWidget(QListWidgetItem * item, QWidget * widget) 然后应用css样式美化。 1234567891011121314151617181920212223242526272829ui-&gt;alarmListWidget-&gt;setResizeMode(QListView::Adjust);ui-&gt;alarmListWidget-&gt;setAutoScroll(true);QWidget *wContainer = new QWidget(ui-&gt;alarmListWidget);QHBoxLayout *hLayout = new QHBoxLayout(wContainer);QLabel *alarmIcon = new QLabel(tr(\"beih\"));QLabel *placeLabel = new QLabel(tr(\"北京\"));QLabel *videoNumLabel = new QLabel(tr(\"8\"));QLabel *dateLabel = new QLabel(tr(\"2013-4-16\"));QLabel *alarmMsgLabel = new QLabel(tr(\"违章搭建\"));//QPushButton *pDeleteBtn = new QPushButton(QIcon(),tr(\"delete\"));hLayout-&gt;addWidget(alarmIcon);hLayout-&gt;addStretch(1);//将空白没有widget的地方分成了若干份，按比例分配hLayout-&gt;addWidget(placeLabel);hLayout-&gt;addStretch(1);hLayout-&gt;addWidget(videoNumLabel);hLayout-&gt;addStretch(1);hLayout-&gt;addWidget(dateLabel);hLayout-&gt;addStretch(1);//将空白没有widget的地方分成了若干份，按比例分配hLayout-&gt;addWidget(alarmMsgLabel);hLayout-&gt;setContentsMargins(5,0,0,5);//关键代码，如果没有很可能显示不出来// wContainer-&gt;setLayout(hLayout);//如果layout在创建时就已经将父窗口指针当参数，那就不用setlayoutwContainer-&gt;resize(350,50);// wContainer-&gt;show();QListWidgetItem *alarmItem = new QListWidgetItem(ui-&gt;alarmListWidget);ui-&gt;alarmListWidget-&gt;setItemWidget(alarmItem,wContainer); 参考：https://blog.csdn.net/xzh_blue/article/details/49178395 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"IIS允许下载APK安装包","date":"2018-08-10T12:41:00.000Z","path":"2018/08/10/IIS允许下载APK安装包/","text":"IIS允许下载APK安装包（MIME类型配置）IIS7MIME配置过程： 打开IIS信息服务管理器，找到要添加配置的网站； 在该网站的功能视图中单击”MIME类型“按钮（如果在功能视图中没有MIME按钮，则需要通过服务器管理器中角色管理进行添加），打开MIME类型设置窗口； 在操作栏里点击”添加“按钮； 单机”确定“保存设置； 重启IIS，使设置生效。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"服务器","slug":"服务器","permalink":"http://blog.iwxyi.com/tags/服务器/"}]},{"title":"Qt菊花转动画","date":"2018-08-10T10:49:00.000Z","path":"2018/08/10/Qt菊花转动画/","text":"菊花圆圈转动动画 CustomProgressIndicator.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#ifndef CUSTOMPROGRESSINDICATOR_H#define CUSTOMPROGRESSINDICATOR_H #include &lt;QWidget&gt;#include &lt;QColor&gt;/** 菊花转 进度类，基于代码无需图片资源* 作者：陈鲁勇* 邮箱：727057301@qq.com* 创建时间：2017年2月10日16:26:48* QT版本：5.0.2* CSDN：http://blog.csdn.net/csnd_ayo * *************************************** 说明：* 使用前请确保在QT.pro中加入 C++11 的支持** 示例代码： pIndicator = new CustomProgressIndicator(this); pIndicator-&gt;setColor(Qt::red); pIndicator-&gt;startAnimation();*/ class CustomProgressIndicator : public QWidget{ Q_OBJECT Q_PROPERTY(int delay READ animationDelay WRITE setAnimationDelay) Q_PROPERTY(bool displayedWhenStopped READ isDisplayedWhenStopped WRITE setDisplayedWhenStopped) Q_PROPERTY(QColor color READ color WRITE setColor)public: CustomProgressIndicator(QWidget* parent = 0); int animationDelay() const { return delay_; } /* 动画是否正在进行中 */ bool isAnimated () const; /* 动画完毕后，是否隐藏菊花转 */ bool isDisplayedWhenStopped() const; /* 当前菊花转的颜色 */ const QColor &amp; color() const { return color_; } /* 虚函数：当前大小 */ virtual QSize sizeHint() const; void setBackground(const QString&amp; _icon) { currentPix_ = QPixmap(_icon); }signals: void Finished(void);public slots: /* 开始动画 */ void startAnimation(); /* 停止动画 */ void stopAnimation(); /* 设置菊花转的转速 */ void setAnimationDelay(int delay); /* 动画完毕后，是否隐藏菊花转 */ void setDisplayedWhenStopped(bool state); /* 设置菊花转颜色 */ void setColor(const QColor &amp; color); /* * 进度 * 参数 _progress：当前进度 0 &lt; _progress &lt; 100 */ void onProgress(short _progress) { progress_ = _progress; }protected: /* 系统基类函数 */ virtual void timerEvent(QTimerEvent * event); virtual void paintEvent(QPaintEvent * event);private: /* 角度 */ unsigned int angle_; /* 定时器ID */ int timerId_; /* 转速 */ int delay_; /* 是否隐藏 */ bool displayedWhenStopped_; /* 菊花转颜色 */ QColor color_; /* 进度 */ short progress_; /* 背景图 */ QPixmap currentPix_;}; #endif // CUSTOMPROGRESSINDICATOR_H CustomProgressIndicator.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include \"customprogressindicator.h\"#include &lt;QPainter&gt; CustomProgressIndicator::CustomProgressIndicator(QWidget* parent) : QWidget(parent), angle_(0), timerId_(-1), delay_(20), displayedWhenStopped_(false), color_(Qt::green) { setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed); setFocusPolicy(Qt::NoFocus);} bool CustomProgressIndicator::isAnimated () const { return (timerId_ != -1);} void CustomProgressIndicator::setDisplayedWhenStopped(bool state) { displayedWhenStopped_ = state; update();} bool CustomProgressIndicator::isDisplayedWhenStopped() const { return displayedWhenStopped_;} void CustomProgressIndicator::startAnimation() { angle_ = 0; if (timerId_ == -1) { timerId_ = startTimer(delay_); }} void CustomProgressIndicator::stopAnimation() { if (timerId_ != -1) { killTimer(timerId_); } timerId_ = -1; update();} void CustomProgressIndicator::setAnimationDelay(int delay) { if (timerId_ != -1){ killTimer(timerId_); } delay_ = delay; if (timerId_ != -1){ timerId_ = startTimer(delay_); }} void CustomProgressIndicator::setColor(const QColor &amp; color) { color_ = color; update();} QSize CustomProgressIndicator::sizeHint() const { return QSize(25,25);} void CustomProgressIndicator::timerEvent(QTimerEvent * /*event*/) { angle_ = (angle_+30)%360; update();} void CustomProgressIndicator::paintEvent(QPaintEvent * /*event*/) { QPainter p(this); p.setRenderHint(QPainter::Antialiasing); if (!displayedWhenStopped_ &amp;&amp; !isAnimated()) { p.drawPixmap(rect(),currentPix_); return; } int width = qMin(this-&gt;width(), this-&gt;height()); int outerRadius = (width-1) &gt;&gt; 1; int innerRadius = ((width-1) &gt;&gt; 1)*0.38; int capsuleHeight = outerRadius - innerRadius; int capsuleWidth = (width &gt; 32 ) ? capsuleHeight *.23 : capsuleHeight *.35; int capsuleRadius = capsuleWidth &gt;&gt; 1; /* 撰写进度 */ if (progress_ &gt; 0 &amp;&amp; progress_ &lt; 100) { p.setPen(color_); p.drawText(rect(), Qt::AlignCenter, QString(\"%1%\").arg(progress_)); } else if (progress_ == 100) { stopAnimation(); } for (int i=0; i&lt;12; ++i) { QColor color = color_; color.setAlphaF(1.0f - (i/12.0f)); p.setPen(Qt::NoPen); p.setBrush(color); p.save(); p.translate(rect().center()); p.rotate(angle_ - i*30.0f); p.drawRoundedRect(((-capsuleWidth) &gt;&gt; 1), -(innerRadius+capsuleHeight), capsuleWidth, capsuleHeight, capsuleRadius, capsuleRadius); p.restore(); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"fread和fwrite转移文件数据","date":"2018-08-04T12:18:00.000Z","path":"2018/08/04/fread和fwrite转移文件数据/","text":"读取文件，再写入到另一个文件里面： 1、获取文件大小 12345FILE* fp_size = fopen(\"T:/img.jpg\", \"rb\");fseek(fp_size, 0, SEEK_END);int size = ftell(fp_size);fclose(fp_size);cout &lt;&lt; \"文件大小(指针偏移计算):\" &lt;&lt; size; // 字节大小 2、读取文件 1234FILE* fp_read = fopen(\"T:/img.jpg\", \"rb\");int* buffer = (int*)malloc(size+4); // 可以改成其他类型也没事，比如 char*fread(buffer, size, 1, fp_read);fclose(fp_read); 3、写入到另一个文件 123FILE* fp_write = fopen(\"T:/img1.png\", \"wb\");fwrite(buffer,size, 1, fp_write);fclose(fp_write); fread和write的size可以更大，不影响结果（表示上限） 实测一张jpg图片： size超过体积，保存的会是size的大小 1/10时：图片只有一半显示，体积也只有1/10 1/4时：上方5/6的部分清晰，剩下的模糊 1/2时：虽然体积只有一半，但是好像一样清晰…… document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C语言","slug":"C语言","permalink":"http://blog.iwxyi.com/tags/C语言/"},{"name":"文件","slug":"文件","permalink":"http://blog.iwxyi.com/tags/文件/"}]},{"title":"Qt无边框鼠标移动","date":"2018-08-04T09:04:00.000Z","path":"2018/08/04/Qt无边框鼠标移动/","text":"拖动控件，即拖动窗口 12345678910111213141516171819202122232425262728virtual voidmousePressEvent(QMouseEvent* e); // 鼠标的单击事件virtual voidmouseMoveEvent(QMouseEvent* e); // 鼠标的移动事件virtualvoid mouseReleaseEvent(QMouseEvent* e); // 鼠标的单击释放事件bool m_bIsWindowMoveable;voidClassName::mousePressEvent(QMouseEvent* e){ if(e-&gt;button() == Qt::LeftButton) { m_bIsWindowMoveable = true; }}void ClassName:mouseMoveEvent(QMouseEvent*e){ if(m_ bIsWindowMoveable) { move(e-&gt;globalPos()); }}voidClassName::mouseReleaseEvent(QMouseEvent* e){ m_bIsWindowMoveable = false;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"http://blog.iwxyi.com/tags/Qt/"}]},{"title":"HTML表格单元格悬浮提示","date":"2018-08-01T05:07:00.000Z","path":"2018/08/01/HTML表格单元格悬浮提示/","text":"1&lt;td title=\"点击了解详细信息\"&gt;&lt;a href=\"#\"&gt;要显示的文本&lt;/a&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"HTML","slug":"HTML","permalink":"http://blog.iwxyi.com/tags/HTML/"}]},{"title":"Swing框架-学习笔记","date":"2018-07-09T05:26:00.000Z","path":"2018/07/09/Swing框架-学习笔记/","text":"绘图相关的类： JFrame JPanel 画到画板12345678910111213141516171819import javax.swing.JFrame;import java.awt.Color;import java.awt.Panel;public class A{ public static void main(String[] args) { // 创建容器 JFrame frame = new JFrame(); frame.setSize(200, 300); frame.setLocation(100, 100); frame.setVisible(true); // 创建画板 Panel panel = new Panel(); panel.setBackground(Color.YELLOW); // 添加容器到画板 frame.add(panel); }} 画板子类123456789101112131415161718192021222324252627282930313233import java.awt.Color;import java.awt.Graphics;import java.awt.Panel;import java.util.Random;public class M extends Panel { int x[], y[]; public M() { super(); // 初始化星星随机坐标 x = new int[300]; y = new int[300]; Random random = new Random(); for (int i = 0; i &lt; 300; i++) { x[i] = random.nextInt(1000); y[i] = random.nextInt(600); } } public void paint(Graphics g) { super.paint(g); this.setBackground(Color.black); // 画月亮 g.setColor(Color.white); g.fillArc(860, 100, 50, 50, 0, 360); // 画星星（文字） for (int i = 0; i &lt; 300; i++) { g.drawString(\"*\", x[i], y[i]); } }} 动态绘图main 123456M panel = new M();frame.add(panel);Thread t = new Thread(panel);panel.run(); // 开始多线程运行方法一//t.start(); // 开始多线程运行方法二 M 1234567891011121314151617181920public class M extends JPanel implements Runnable { /* ... */ public void run() { while (true) { for (int i = 0; i &lt; x.length; i++) { x[i]--; y[i]++; } try { // 定时（动态）操作 Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } // 重绘函数 repaint(); } }} 解决闪烁JPanel 自带双重缓冲。 动态绘图2构造函数： 1move(); // 直接调用 1234567891011121314151617181920public void move() { new Thread() { public void run() { /* ... 位置初始化 ... */ while (true) { /* ... 控件移动 ... */ repaint(); try { Thread.sleep(24); } catch (InterruptedException e) { e.printStackTrace(); } } } }.start();} 无边框frame.setUndecorated(true); 123456789101112public class Main { public static void main(String[] args) { JFrame frame = new JFrame(); BallPanel panel = new BallPanel(); frame.setBounds(100, 100, 1000, 600); // 代替setLocation和setSize frame.setBackground(Color.YELLOW); frame.setUndecorated(true); frame.add(panel); frame.setVisible(true); }} 实测setVisible必须在add和setUndecorated后面 设置图片Graphics.drawImage() 12345public void paint(Graphics g) { super.paint(g); g.drawImage(new ImageIcon(\"img/pic.jpg\").getImage(), 0, 0, this);} 鼠标拖动main 使用工具类 123456public class Main { public static void main(String[] args) { JFrame frame = new JFrame(); LocationUtil lUtil = new LocationUtil(frame); // 设置鼠标可拖动的工具类 }} util：LocationUtil 工具类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package Util;import java.awt.event.MouseEvent;import java.awt.event.MouseListener;import java.awt.event.MouseMotionListener;import javax.swing.JFrame;public class LocationUtil { JFrame frame; private int xx, yy; private boolean isDraging = false; public LocationUtil(JFrame f) { this.frame = f; // 鼠标按键事件 frame.addMouseListener(new MouseListener() { public void mouseReleased(MouseEvent e) { isDraging = false; } public void mousePressed(MouseEvent e) { isDraging = true; xx = e.getX(); yy = e.getY(); } public void mouseExited(MouseEvent e) { } public void mouseEntered(MouseEvent e) { } public void mouseClicked(MouseEvent e) { } }); // 鼠标移动事件 frame.addMouseMotionListener(new MouseMotionListener() { public void mouseMoved(MouseEvent e) { } public void mouseDragged(MouseEvent e) { if (isDraging == true) { int left = frame.getLocation().x; int top = frame.getLocation().y; frame.setLocation(left + e.getX() - xx, top + e.getY() - yy); } } }); }} 设置成屏幕大小123456Dimension screensize = new Dimension();screensize = tk.getScreenSize();width = screensize.getWidth();height = screensize.getHeight();jframe.setSize((int)width, (int)height);jframe.setLocation(0, 0); java语法单个变量形成数组数组引用的是单个变量的地址空间，所以是同一个 123456Student s1 = new Student();Student s2 = new Student();Student[] ss = new Student[] { s1, s2 };System.out.println(ss[1] == s2); // true 向上转型123456789101112131415private static void pout(Object o) { System.out.println(o.toString());}public static void main(String[] args) { Boolean b = new Boolean(false); pout(b); String s = new String(\"1431\"); pout(s); Integer i = new Integer(1000); pout(i);} 子类的创建、继承、覆盖 构造函数只能调用，不能继承 创建子类对象时在调用子类的构造器前，会调用父类的（无参）构造器 先对父类初始化，再对子类初始化 子类构造器中使用super([参数])来调用父类的构造器 如果父类只有有参构造器，则必须在子类构造函数第一行使用super([参数])来调用 类、字段、构造器不存在覆盖的概念 静态区优先于对象而创建，也不存在覆盖的概念（隐藏）。调用使用类名.方法，而非类示例.方法 遮蔽 三种情况 局部变量和成员变量同名，使用this 子类和父类存在同名成员变量，使用super调用父类成员变量 子类和父类存在相同静态方法，方法不存在覆盖 多态一个对象可以有多种形态 1. 父类指针指向子类对象 2. 把子类对象复制给父类的变量 3. 继承是多态的前提，没有继承就没有多态 多态的好处 - 把不同的子类对象都当做父类类型来看 - 可以屏蔽不同子类对象之间的差异 父类和子类同时存在静态方法时： - 直接调用静态方法（子类） - 父类名.静态方法静态方法不是覆盖，而属于隐藏 多态是对象的概念，和类没有关系 √ instanceof 判断是否是某个（父）类的实例 1if (a instanceof A) // true 123B extends A;if (b instanceof A) // true (其实还有其他更深的用法，例如 c instanceof C 有 true 也有 false) 封装1234567891011121314151617int i = 129;Integer I1 = new Integer(129);Integer I2 = new Integer(129);if (i == I1) // trueif (I1 == I2) // falseif (I1.equals(I2)) // trueInteger I3 = new Integer(127);Integer I4 = new Integer(127)if (I3 == I4) // true, 享元模式 当 &lt; 128 时，Integer对象都是共享的;当 &gt;=128 时，才真正分配对象 就是用一个Integer数组先缓存了，后面如果是在 [-128, 127] 区间内的数直接从缓存数组中取，否则才构造新的Integer。缓存思想还是很重要的。 控件常用函数JFrame123456setBounds(200, 50, 900, 700);setUndecorated(true); // 无边框setIconImage(new ImageIcon(\"\").getImage());add(panel);setVisible(true);setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JPanel1setBackground(Color.black); JButton12345678setBounds(100, 100, 200, 200);addActionListener(click);setActionCommand(\"close\");setBackground(Color.WHITE);setOpaque(false); // 透明setBorderPainted(false); // 无边框setContentAreaFilled(false); // 按下透明setIcon(new ImageIcon(\"\")); JLabel123456setLayout(null);setOpaque(false);setBounds(19, 70, 235, 57);setFont(new Font(\"宋体\", Font.BOLD, 20));setForeground(Color.white);add(label2) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.iwxyi.com/tags/学习笔记/"},{"name":"Java","slug":"Java","permalink":"http://blog.iwxyi.com/tags/Java/"},{"name":"Swing","slug":"Swing","permalink":"http://blog.iwxyi.com/tags/Swing/"}]},{"title":"PHP调用Python","date":"2018-07-08T08:26:00.000Z","path":"2018/07/08/PHP调用Python/","text":"$output = shell_exec('python script/test.py'); 123456&lt;?php$output = shell_exec('python script/test.py');$array = explode(',', $output);foreach ($array as $value) { echo $value;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.iwxyi.com/tags/PHP/"},{"name":"Python","slug":"Python","permalink":"http://blog.iwxyi.com/tags/Python/"}]},{"title":"E4A+PHP上传图片","date":"2018-07-08T08:18:00.000Z","path":"2018/07/08/E4A-PHP上传图片/","text":"E4A 1234567891011变量 协议头 为 哈希表变量 常规参数 为 哈希表变量 文件参数 为 哈希表协议头=创建 哈希表常规参数=创建 哈希表文件参数=创建 哈希表协议头.加入项目(\"User-Agent\",\"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36\")文件参数.加入项目(\"img\",图片地址) // 图片常规参数.加入项目(\"photoname\", 取文件名(图片名称)) // 图片文件名okPOST1.开始POST(1,网络路径 &amp; \"uphoto.php\",协议头,常规参数,文件参数,\"GBK\") 1234567事件 okPOST1.POST进度(任务ID 为 整数型,进度 为 整数型) 设置进度对话框进度(进度)结束 事件事件 okPOST1.POST完毕(任务ID 为 整数型,返回内容 为 文本型) 关闭进度对话框()结束 事件 PHP 123456789101112131415161718&lt;?php require \"public_module.php\"; $photoname = seize0(\"photoname\"); $name = $_FILES[\"img\"][\"name\"]; if (strlen($name) &lt; 1) { echo \"&lt;script&gt;alert('图片不能为空');history.go(-1);&lt;/script&gt;\"; exit(); }; if (!empty($_FILES[\"img\"][\"name\"])) {//提取文件域内容名称，并判断 $path = \"photo/\"; $result = move_uploaded_file($_FILES[\"img\"][\"tmp_name\"], $path . $photoname); echo T; }?&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.iwxyi.com/tags/PHP/"},{"name":"E4A","slug":"E4A","permalink":"http://blog.iwxyi.com/tags/E4A/"}]},{"title":"Python手动安装插件","date":"2018-07-08T05:40:00.000Z","path":"2018/07/08/Python手动安装插件/","text":"路径：C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python35\\Scripts cmd 命令：pip install nltk（注：下载很慢很慢20kb/s） 更新：pip install --upgrade nltk 插件列表： pip install flake8 检测插件 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Python","slug":"Python","permalink":"http://blog.iwxyi.com/tags/Python/"}]},{"title":"CentOS安装可视化界面","date":"2018-07-07T05:59:00.000Z","path":"2018/07/07/CentOS安装可视化界面/","text":"在联网的情况下使用yum命令安装即可需要安装x window服务与desktop桌面，不分先后，命令如下： 12yum groupinstall \"GNOME Desktop\"yum groupinstall \"X Window System\" 最后启动输入命令 1startX 如果在本地使用即可正常切换，通过ssh登录则不能切换，会报错 可视化桌面卸载12yum groupremove 'MATE Desktop' -yyum groupremove 'X Window System' -y 找不到包1No packages in any requested group available to install or update 通过下面语句来看能安装的group，选择名字来安装 1yum grouplist 控制1yum install xrdp 然后使用windows自带的远程桌面控制 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.iwxyi.com/tags/Linux/"}]},{"title":"Node.js添加字符串到文本文件末尾","date":"2018-07-05T07:29:00.000Z","path":"2018/07/05/Node-js添加字符串到文本文件末尾/","text":"有这么一个需求：想把input里面的内容写到outInput里面去，但是上面的方法都是把文档里面的内容重置了，只想添加，而且保留原内容怎么办呢？ 可以在可读流创建完毕的回调函数里面进行操作，看代码： 12345678910111213141516171819202122232425let fs = require('fs');let data = '';let data2 = '你的小青蛙是真的可爱';//1.读取流let readStream = fs.createReadStream(\"input.txt\"); //创建可读流readStream.setEncoding('UTF8'); //设置utf-8编码//处理流事件readStream.on('data', chunk =&gt; data += chunk);readStream.on('end', () =&gt; writeS(data));readStream.on(\"error\", err =&gt; console.log(err.strck));console.log(\"程序1执行完毕\");//2.写入流let writeS = dataS =&gt;{ //创建可写流 let writeStream = fs.createWriteStream(\"outInput.txt\"); writeStream.write(data2+dataS, \"UTF8\"); //使用utf-8写入流 writeStream.end(); //标记文件末尾 //处理事件流 writeStream.on(\"finish\", () =&gt; console.log(\"写入完成\")); writeStream.on(\"error\", err =&gt; console.log(err.stack)); console.log(\"程序2执行完毕\");} 如此，便可以啦！ 如上面可能存在覆盖状态,可以设置写入流的追加参数来解决: 1234var fs = require('fs');var read = fs.createReadStream('input.txt');var write = fs.createWriteStream('out.txt', { 'flags': 'a' }); //设置第二个参数appendread.pipe(write); //管道流读写操作 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.iwxyi.com/tags/Node-js/"}]},{"title":"C#-学习笔记","date":"2018-06-22T23:21:00.000Z","path":"2018/06/23/CSharp-学习笔记/","text":"入门 需要C++基础 示例代码12345678910111213using System;namespace HelloWorldApplication{ class HelloWorld { static void Main(string[] args) { /* 我的第一个 C# 程序*/ Console.WriteLine(\"Hello World\"); Console.ReadKey(); } }} 上面程序的各个部分： 程序的第一行 using System; - using 关键字用于在程序中包含 System 命名空间。 一个程序一般有多个 using 语句。 下一行是 namespace 声明。一个 namespace 是一系列的类。HelloWorldApplication 命名空间包含了类 HelloWorld。 几个注意点： C# 是大小写敏感的。 所有的语句和表达式必须以分号（;）结尾。 程序的执行从 Main 方法开始。 与 Java 不同的是，文件名可以不同于类的名称。 基本语法数据类型：引用类型引用类型不包含存储在变量中的实际数据，但它们包含对变量的引用。换句话说，它们指的是一个内存位置。 内置的引用类型有：object、dynamic 和 string。 对象（Object）类型对象（Object）类型 是 C# 通用类型系统（Common Type System - CTS）中所有数据类型的终极基类。Object 是 System.Object 类的别名。所以对象（Object）类型可以被分配任何其他类型（值类型、引用类型、预定义类型或用户自定义类型）的值。但是，在分配值之前，需要先进行类型转换。 当一个值类型转换为对象类型时，则被称为 装箱；另一方面，当一个对象类型转换为值类型时，则被称为 拆箱。 12object obj;obj = 100; // 这是装箱 动态（Dynamic）类型存储任何类型的值在动态数据类型变量中。 1dynamic &lt;variable_name&gt; = value; 例如： 1dynamic d = 20; 动态类型与对象类型相似，但是对象类型变量的类型检查是在编译时发生的，而动态类型变量的类型检查是在运行时发生的。 字符串（String）类型字符串（String）类型 允许您给变量分配任何字符串值。字符串（String）类型是 System.String 类的别名。它是从对象（Object）类型派生的。字符串（String）类型的值可以通过两种形式进行分配：引号和 @引号。 例如： 1String str = \"runoob.com\"; 一个 @引号字符串： 1@\"runoob.com\"; C# string 字符串的前面可以加 @（称作”逐字字符串”）将转义字符（\\）当作普通字符对待，比如： string str = @\"C:\\Windows\"; 等价于 string str = \"C:\\\\Windows\"; @ 字符串中可以任意换行，换行符及缩进空格都计算在字符串长度之内。 1234string str = @\"&lt;script type=\"\"text/javascript\"\"&gt; &lt;!-- --&gt;&lt;/script&gt;\"; 用户自定义引用类型有：class、interface 或 delegate。 类型转换C# 提供了下列内置的类型转换方法： 序号 方法 &amp; 描述 1 ToBoolean 如果可能的话，把类型转换为布尔型。 2 ToByte 把类型转换为字节类型。 3 ToChar 如果可能的话，把类型转换为单个 Unicode 字符类型。 4 ToDateTime 把类型（整数或字符串类型）转换为 日期-时间 结构。 5 ToDecimal 把浮点型或整数类型转换为十进制类型。 6 ToDouble 把类型转换为双精度浮点型。 7 ToInt16 把类型转换为 16 位整数类型。 8 ToInt32 把类型转换为 32 位整数类型。 9 ToInt64 把类型转换为 64 位整数类型。 10 ToSbyte 把类型转换为有符号字节类型。 11 ToSingle 把类型转换为小浮点数类型。 12 ToString 把类型转换为字符串类型。 13 ToType 把类型转换为指定类型。 14 ToUInt16 把类型转换为 16 位无符号整数类型。 15 ToUInt32 把类型转换为 32 位无符号整数类型。 16 ToUInt64 把类型转换为 64 位无符号整数类型。 例如： 1a.ToString() document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.iwxyi.com/tags/学习笔记/"},{"name":"CSharp","slug":"CSharp","permalink":"http://blog.iwxyi.com/tags/CSharp/"}]},{"title":"Win32 SDK绘制字体及透明文字","date":"2018-06-19T01:40:00.000Z","path":"2018/06/19/VC-绘制字体及透明文字/","text":"在hdc上绘制文字：CreateFont 12345678910111213141516HDC hdc;HFONT hf;TEXTMETRIC tm;double len;int left;hdc = GetDC(hWnd);hf = CreateFont(0, 0, 0, 0, 0, 0, 0, 0, 0, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH, \"楷体\"); // (HFONT) GetStockObject(0)SelectObject(hdc, hf); // 绑定画笔SetTextColor(hdc, 0x0000FF/*BGR*/); // 绑定颜色GetTextMetrics(hdc, &amp;tm); // 绑定大小len = strlen(str) * tm.tmAveCharWidth; // 要画的文字总长度left = R - len / 2; // 居中对齐TextOut(hdc, left, 0, str, strlen(str));DeleteObject(hf);cheight += tm.tmHeight; // 下一行的高度 设置文字背景透明 1SetBkMode(mdc, TRANSPARENT); 还有两句额外的设置颜色的 12SetTextColor(mdc, RGB(255, 0, 0));SetBkColor(mdc, RGB(0, 0, 0)); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Win32 SDK","slug":"Win32-SDK","permalink":"http://blog.iwxyi.com/tags/Win32-SDK/"}]},{"title":"SQL查询及删除重复记录","date":"2018-06-15T10:38:00.000Z","path":"2018/06/15/SQL查询及删除重复记录/","text":"1、查找表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断 12select * from peoplewhere peopleId in (select peopleId from people group by peopleId having count(peopleId) &gt; 1) 2、删除表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断，只留有rowid最小的记录 123delete from peoplewhere peopleId in (select peopleId from people group by peopleId having count(peopleId) &gt; 1)and rowid not in (select min(rowid) from people group by peopleId having count(peopleId )&gt;1) 3、查找表中多余的重复记录（多个字段） 12select * from vitae awhere (a.peopleId,a.seq) in (select peopleId,seq from vitae group by peopleId,seq having count(*) &gt; 1) 4、删除表中多余的重复记录（多个字段），只留有rowid最小的记录 123delete from vitae awhere (a.peopleId,a.seq) in (select peopleId,seq from vitae group by peopleId,seq having count(*) &gt; 1)and rowid not in (select min(rowid) from vitae group by peopleId,seq having count(*)&gt;1) 5、查找表中多余的重复记录（多个字段），不包含rowid最小的记录 123select * from vitae awhere (a.peopleId,a.seq) in (select peopleId,seq from vitae group by peopleId,seq having count(*) &gt; 1)and rowid not in (select min(rowid) from vitae group by peopleId,seq having count(*)&gt;1) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"SQL","slug":"SQL","permalink":"http://blog.iwxyi.com/tags/SQL/"}]},{"title":"JS发送数据XMLHttpRequest","date":"2018-06-13T07:52:00.000Z","path":"2018/06/13/JS发送数据XMLHttpRequest/","text":"JS 发送数据 XMLHttpRequest1234567891011121314151617181920212223242526272829303132function sendData(data){ var XHR = new XMLHttpRequest(); var urlEncodedData = \"\"; var urlEncodedDataPairs = []; var name; for (name in data) { urlEncodedDataPairs.push(encodeURIComponent(name) + '=' + encodeURIComponent(data[name])); } urlEncodedData = urlEncodedDataPairs.join('&amp;').replace(/%20/g, '+'); XHR.addEventListener('load', function (event) { alert('发送成功'); } ); XHR.addEventListener('error', function (event) { alert('发送失败'); } ); XHR.open('POST', 'https://example.com/cors.php'); XHR.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); XHR.send(urlEncodedData);} JS 发送数据 XMLHttpRequest 和 FormDate123456789101112131415161718192021222324252627282930function sendData(data){ var XHR = new XMLHttpRequest(); var FD = new FormData(); // 把我们的数据添加到这个FormData对象中 for (name in data) { FD.append(name, data[name]); } // 定义数据成功发送并返回后执行的操作 XHR.addEventListener('load', function (event) { alert('Yeah! Data sent and response loaded.'); }); // 定义发生错误时执行的操作 XHR.addEventListener('error', function (event) { alert('Oups! Something goes wrong.'); } ); // 设置请求地址和方法 XHR.open('POST', 'http://ucommbieber.unl.edu/CORS/cors.php'); // 发送这个formData对象,HTTP请求头会自动设置 XHR.send(FD);} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"JS","slug":"JS","permalink":"http://blog.iwxyi.com/tags/JS/"},{"name":"HTTP","slug":"HTTP","permalink":"http://blog.iwxyi.com/tags/HTTP/"}]},{"title":"JS打开网址","date":"2018-06-13T07:51:00.000Z","path":"2018/06/13/JS打开网址/","text":"当前标签打开网址 1window.location.href=url; 新标签页打开网址 1window.open(url); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"JS","slug":"JS","permalink":"http://blog.iwxyi.com/tags/JS/"}]},{"title":"AJAX实现前后端实时通讯","date":"2018-06-13T07:43:00.000Z","path":"2018/06/13/AJAX实现前后端实时通讯/","text":"需要 JS 和 后端结合在一起 发送向服务器发送数据 123456789101112131415161718192021222324252627function sendAjax(){ var info = document.getElementById(\"info\").value; var XHR = null; var FD = new FormData(); if (window.XMLHttpRequest) XHR = new XMLHttpRequest(); else if (window.ActiveXObject) XHR = new ActiveXObject(\"Microsoft.XMLHTTP\"); else return ; FD.append(\"info\", info); // 添加信息 XHR.onreadystatechange = function () { if (XHR.readyState == 4 &amp;&amp; XHR.status == 200) { var text = XHR.responseText; // 返回的文本 sendAjax(); // 继续AJAX } } XHR.open('POST', 'ajax.php', true); XHR.send(FD);} 以云笺的实时通讯为例切换实时通讯的开关 1234567891011121314151617181920212223242526272829303132333435var sync = false;var sync_auto = true;var sync_last_text = \"\";var save_time = 0;var save_text = \"\";function switch_sync() // 开关实时同步{ if (sync == false) { sync = true; mdui.snackbar({ message: '已开启当前页同步', buttonText: '帮助', onButtonClick: function() { ; }, }); sendAjax(); } else { sync = false; mdui.snackbar({ message: '已关闭当前页同步', buttonText: '帮助', onButtonClick: function() { ; }, }); }} 发送向服务器发送数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596function sendAjax(){ if (sync == false) return ; var name = document.getElementById(\"name\").value; var info = document.getElementById(\"info\").value; if (name == \"\") return ; var XHR = null; var FD = new FormData(); // 去掉首尾空格 var noblank_name = name.replace(/(^\\s*)|(\\s*$)/g,\"\"); if (noblank_name != name){ name = noblank_name; document.getElementById(\"name\").value = name; } if (window.XMLHttpRequest) { XHR = new XMLHttpRequest(); } else if (window.ActiveXObject) { XHR = new ActiveXObject(\"Microsoft.XMLHTTP\"); } FD.append(\"name\", name); FD.append(\"info\", info); FD.append(\"info2\", sync_last_text); XHR.onreadystatechange = function () { if (XHR.readyState == 4 &amp;&amp; XHR.status == 200) { if (sync == false) return ; // 连接中关闭 var new_info = XHR.responseText; // 新的信息 // new_info = new_info.replace(/\\r/, \"\"); // 返回的信息莫名多了 \\r，还不能直接去掉 new_info = decodeURI((encodeURI(new_info)).replace(/%0D/g, \"\")); if (new_info == \"\"); // 时间到、空文本，继续AJAX else if (document.getElementById(\"name\").value != name); // 已修改名字，发送新的AJAX else if (info == new_info); // 内容一样，自己保存 else if (document.getElementById(\"info\").value == new_info); // 后来添加的信息一样 else if (sync_last_text == new_info); // 收到上次一样的数据 else if ((new Date()).getTime() &lt;= save_time + 3000); // 3秒钟内保存的，可能是自己的 else if (save_text == new_info); // 收到自己的内容 else { var myDate = new Date(); if (sync_auto == true // 自动修改 &amp;&amp; document.getElementById(\"info\").value == save_text // 文本和上次保存的内容相同，即没有自动修改 ) { document.getElementById(\"info\").value = new_info; save_text = new_info; mdui.snackbar({ message: '已更新 '+myDate.getHours()+\":\"+myDate.getMinutes()+\":\"+myDate.getSeconds(), buttonText: '撤销并关闭自动修改', onButtonClick: function() { document.getElementById(\"info\").value = info; save_text = info; sync_auto = false; }, }); } else { mdui.snackbar({ message: '收到更新'+myDate.getHours()+\":\"+myDate.getMinutes()+\":\"+myDate.getSeconds(), buttonText: '修改', onButtonClick: function() { document.getElementById(\"info\").value = new_info; save_text = new_info; }, }); } } sync_last_text = new_info; sendAjax(); // 继续AJAX } } XHR.open('POST', 'sync_ajax.php', true); XHR.send(FD); return false;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"JS","slug":"JS","permalink":"http://blog.iwxyi.com/tags/JS/"},{"name":"AJAX","slug":"AJAX","permalink":"http://blog.iwxyi.com/tags/AJAX/"}]},{"title":"JSP页面重定向","date":"2018-06-13T07:23:00.000Z","path":"2018/06/13/JSP页面重定向/","text":"Java(JSP) 1response.setHeader(\"Location\", \"welcome.jsp\"); JS 1window.location.href=\"url\"; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"JS","slug":"JS","permalink":"http://blog.iwxyi.com/tags/JS/"},{"name":"JSP","slug":"JSP","permalink":"http://blog.iwxyi.com/tags/JSP/"}]},{"title":"JSP表单账号密码登录","date":"2018-06-13T07:12:00.000Z","path":"2018/06/13/JSP表单账号密码登录/","text":"解析表单输入的账号密码，从数据库中获取匹配项 123456789101112131415161718192021222324252627282930313233343536password = request.getParameter(\"password\");if (sqlM.SafeCheck(username) == false || sqlM.SafeCheck(password) == false){ MSG = \"alert('非法账号/密码输入');\";}else{ // 搜索数据库 String sql = \"SELECT username from users where username = '\" + username + \"' and password = '\" + password + \"'\"; ResultSet rs = sqlM.executeQuery(sql); if (rs != null &amp;&amp; rs.next() == true &amp;&amp; username.equals(rs.getString(1))) // 好像数据库结果的下标是从 1 开始的 { usero.setUsername(username); usero.setPassword(password); // 设置 cookies String username_code = java.net.URLEncoder.encode(username, \"UTF-8\"); String password_code = java.net.URLEncoder.encode(password, \"UTF-8\"); Cookie username_cookie = new Cookie(\"username\", username_code); Cookie password_cookie = new Cookie(\"password\", password_code); username_cookie.setMaxAge(60*60*24*3); password_cookie.setMaxAge(60*60*24*3); response.addCookie(username_cookie); response.addCookie(password_cookie); response.setStatus(response.SC_MOVED_TEMPORARILY); response.setHeader(\"Location\", \"welcome.jsp\"); return ; } else { MSG = \"alert('账号或者密码出错');\"; }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"JSP","slug":"JSP","permalink":"http://blog.iwxyi.com/tags/JSP/"}]},{"title":"Win32 SDK绘图函数","date":"2018-06-09T02:16:00.000Z","path":"2018/06/09/Win32-SDK绘图函数/","text":"获取HDC 12345678910111213141516171819202122232425LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam){ switch(message) { case WM_PAINT : PAINTSTRUCT ps; HDC hdc; hdc = BeginPaint(hWnd, &amp;ps); RECT rect; GetClientRect (hWnd, &amp;rect); paintOperator(hdc, rect.left, rect.top, rect.right, rect.bottom); EndPaint(hWnd, &amp;ps); break; case WM_DESTROY : PostQuitMessage(0); // 发出 WM_QUIT 消息，没有这句话则只是关闭窗口但进程不会停止 break; default : return DefWindowProc(hWnd, message, wParam, lParam); // 默认时采用系统消息默认处理函数 } return 0;} 画笔123456789101112131415HPEN hp;hp = (HPEN) GetStockObject(BLACK_PEN); // 默认画笔SelectObject(hdc, hp);MoveToEx(hdc,x,y,NULL);LineTo(hdc,x,y); // 画直线，需要先移动点的位置Ellipse(hdc, L, T, R, B); // 画椭圆hp = (HPEN) CreatePen(PS_SOLID, 3, RGB(0xFF, 0, 0)); // 自定义画笔SelectObject(hdc, hp);POINT lpPoints[4] = { {L, B}, {R, B}, {(L+R)/2, T}, {L, B} }; // 三角形的点Polyline(hdc, lpPoints, 4); // 画点数组DeleteObject(hp); // 别忘了CreatePen后要手动删除 画刷1234HBRUSH hbr = (HBRUSH) CreateSolidBrush(RGB(color[pos][0], color[pos][1], color[pos][2]));SelectObject(hdc, hbr);Rectangle(hdc, L, T, R, B);DeleteObject(hbr); 字体12345678910111213141516HFONT hf;TEXTMETRIC tm;char * str[5] = {\"HELLO WORLD!\", \"\", \"\"};hf = CreateFont(0, 0, 0, 0, 0, 0, 0, 0, 0, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH, \"楷体\"); // (HFONT) GetStockObject(0) // 创建字体SelectObject(hdc, hf);SetTextColor(hdc, 0x0000FF/*BGR*/); // 选择颜色GetTextMetrics(hdc, &amp;tm); // 获取字体属性：宽高double len = strlen(str[0]) * tm.tmAveCharWidth; // 字体长度int left = (R-W/2) - len/2; // 居中靠上显示，获取左边坐标TextOut(hdc, left, 0, str[0], strlen(str[0])); // 输出DeleteObject(hf);double cheight += tm.tmHeight; // 当前字体的高度，以便于下一行double cwidth = tm.tmAveCharWidth; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Win32 SDK","slug":"Win32-SDK","permalink":"http://blog.iwxyi.com/tags/Win32-SDK/"}]},{"title":"C++不能重载的符号","date":"2018-06-07T23:30:00.000Z","path":"2018/06/08/C-不能重载的符号/","text":"半边括号( ) [ ]、{}、&lt;&gt;、!、.、\"、'、?、:、;、~、::、...、//、/* */ 可以重载：, document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"}]},{"title":"Win32 SDK双缓冲模板","date":"2018-06-04T02:19:00.000Z","path":"2018/06/04/Win32-SDK双缓冲模板/","text":"游戏窗口双缓冲模板，可直接使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include &lt;windows.h&gt;#include &lt;tchar.h&gt;#include \"StdAfx.h\"HINSTANCE hInst;HWND hWnd;DWORD tPre, tNow;int TOP, RIGHT, WIDTH = 1000, HEIGHT = 571;int MX, MY; // 鼠标位置HDC hdc, mdc, bufdc;PAINTSTRUCT ps;RECT rect;HBITMAP fullmap, hBgBmp;ATOM MyRegisterClass(HINSTANCE hInstance);BOOL InitInstance(HINSTANCE, int);LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);void MyPaint(HDC hdc);//***WinMain函数，程序入口点函数**************************************int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow){ MSG msg; MyRegisterClass(hInstance); //初始化 if (!InitInstance (hInstance, nCmdShow)) return FALSE; //消息循环 GetMessage(&amp;msg, NULL, NULL, NULL); //初始化msg while( msg.message != WM_QUIT ) { if( PeekMessage( &amp;msg, NULL, 0, 0 , PM_REMOVE) ) { TranslateMessage( &amp;msg ); DispatchMessage( &amp;msg ); } else { tNow = GetTickCount(); if(tNow - tPre &gt;= 40) MyPaint(hdc); } } return msg.wParam;}//****设计一个窗口类，类似填空题，使用窗口结构体*************************ATOM MyRegisterClass(HINSTANCE hInstance){ WNDCLASSEX wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = (WNDPROC)WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.hIcon = NULL; wcex.hCursor = NULL; wcex.hCursor = LoadCursor(NULL, IDC_ARROW); wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); wcex.lpszMenuName = NULL; wcex.lpszClassName = \"canvas\"; wcex.hIconSm = NULL; return RegisterClassEx(&amp;wcex);}//****初始化函数*************************************// 加载位图并设定各对象的初始值BOOL InitInstance(HINSTANCE hInstance, int nCmdShow){ hInst = hInstance; hWnd = CreateWindow(\"canvas\", \"演示\" , WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, WIDTH, HEIGHT, NULL, NULL, hInstance, NULL); if (!hWnd) return FALSE; // MoveWindow(hWnd, 10, 10, WIDTH, HEIGHT, true); ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); hdc = GetDC(hWnd); mdc = CreateCompatibleDC(hdc); bufdc = CreateCompatibleDC(hdc); fullmap = CreateCompatibleBitmap(hdc, WIDTH, HEIGHT); SelectObject(mdc, fullmap); /* ... 初始化各值 ... */ MyPaint(hdc); return TRUE;}void MyPaint(HDC hdc){ /* ... 画图操作，可以生成动画 ... */ tPre = GetTickCount();}//****消息处理函数***********************************LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam){ int i, j; switch (message) { case WM_PAINT : hdc = BeginPaint(hWnd, &amp;ps); GetClientRect(hWnd, &amp;rect); MyPaint(hdc); EndPaint(hWnd, &amp;ps); break; case WM_MOUSEMOVE : MX = LOWORD(lParam) - roleFlyBmp[action][actionFrame].bmWidth / 2; MY = HIWORD(lParam) - roleFlyBmp[action][actionFrame].bmHeight / 2; break; case WM_LBUTTONDOWN : break; case WM_KEYDOWN : switch (wParam) { case VK_UP : break; } break; case WM_CHAR : switch (wParam) { case ' ' : break; } break; case WM_DESTROY: //窗口结束消息，撤销各种DC DeleteDC(mdc); DeleteDC(bufdc); DeleteObject(fullmap); ReleaseDC(hWnd, hdc); PostQuitMessage(0); break; default: //其他消息 return DefWindowProc(hWnd, message, wParam, lParam); } return 0;} 游戏模板参照上面的双缓冲模板。 之前做的一个作业样例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354#include &lt;windows.h&gt;#include &lt;tchar.h&gt;#include &lt;stdio.h&gt;#include \"StdAfx.h\"#include \"testOutput.h\"//using namespace std;#define LIMIT_RECT 1 // 矩形限制区域#define LIMIT_CIRC 2 // 圆形限制区域#define ACTION_STARTFLY 0 // 开始飞行#define ACTION_FLY 1 // 向右飞#define ACTION_FLY2 2 // 向左飞#define ACTION_ATTACK 3 // 向右攻击#define ACTION_ATTACK2 4 // 向左攻击HINSTANCE hInst;HWND hWnd;DWORD tPre, tNow;int TOP, RIGHT, WIDTH = 1000, HEIGHT = 571;int OX = 370, OY = 180, MX, MY; // 实例位置int SX = 10, SY = 10; // 每步移动的距离int EX = 0, EY = 0; // 目标位置HDC hdc, mdc, bufdc;PAINTSTRUCT ps;RECT rect;HBITMAP fullmap, hBgBmp, hRoleBmp[10][100], _hRoleBmp[10][100];BITMAP bgBmp, roleFlyBmp[10][100], _roleFlyBmp[10][100];int action = ACTION_STARTFLY /*0 normal, 1 2 fly*/, actionFrame = 0, actionFrameContrler = 0;int limitsMap[][5] ={ { 0, 0, 1000, 55, LIMIT_RECT }, { 258, 0, 850, 55, LIMIT_RECT }, { 342, 0, 500, 70, LIMIT_RECT }, { 0, 225, 170, 50, LIMIT_RECT }, { 0, 275, 54, 72, LIMIT_RECT }, { 0, 455, 72, 119, LIMIT_RECT }, { 310, 360, 324, 80, LIMIT_RECT }, { 404, 300, 200, 237, LIMIT_RECT }, { 504, 468, 522, 115, LIMIT_RECT }, { 0, 0, 43, 306, LIMIT_RECT }, { 940, 0, 42, 187, LIMIT_RECT }}, limitsMapNum = 11;ATOM MyRegisterClass(HINSTANCE hInstance);BOOL InitInstance(HINSTANCE, int);LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);void MyPaint(HDC hdc);//***WinMain函数，程序入口点函数**************************************int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow){ MSG msg; MyRegisterClass(hInstance); //初始化 if (!InitInstance (hInstance, nCmdShow)) return FALSE; //消息循环 GetMessage(&amp;msg, NULL, NULL, NULL); //初始化msg while( msg.message != WM_QUIT ) { if( PeekMessage( &amp;msg, NULL, 0, 0 , PM_REMOVE) ) { TranslateMessage( &amp;msg ); DispatchMessage( &amp;msg ); } else { tNow = GetTickCount(); if(tNow - tPre &gt;= 40) MyPaint(hdc); } } return msg.wParam;}int max(int a, int b) { return a &gt; b ? a : b;}//****设计一个窗口类，类似填空题，使用窗口结构体*************************ATOM MyRegisterClass(HINSTANCE hInstance){ WNDCLASSEX wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = (WNDPROC)WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.hIcon = NULL; wcex.hCursor = NULL; wcex.hCursor = LoadCursor(NULL, IDC_ARROW); wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); wcex.lpszMenuName = NULL; wcex.lpszClassName = \"canvas\"; wcex.hIconSm = NULL; return RegisterClassEx(&amp;wcex);}//****初始化函数*************************************// 加载位图并设定各对象的初始值BOOL InitInstance(HINSTANCE hInstance, int nCmdShow){ hInst = hInstance; hWnd = CreateWindow(\"canvas\", \"动画演示\" , WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, WIDTH, HEIGHT, NULL, NULL, hInstance, NULL); if (!hWnd) return FALSE; // MoveWindow(hWnd, 10, 10, WIDTH, HEIGHT, true); ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); hdc = GetDC(hWnd); mdc = CreateCompatibleDC(hdc); bufdc = CreateCompatibleDC(hdc); fullmap = CreateCompatibleBitmap(hdc, WIDTH, HEIGHT); SelectObject(mdc, fullmap); hBgBmp = (HBITMAP)LoadImage(NULL, \"bg.bmp\", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE); GetObject(hBgBmp, sizeof(BITMAP), &amp;bgBmp); int i, j; char actionName[10][20] = { \"startfly\", \"fly\", \"fly2\", \"attack\", \"attack2\" }; for (i = 0; i &lt; 5; i++) { char fullName[100]; for (j = 0; j &lt; 5; j++) { sprintf(fullName, \"%s%d.bmp\", actionName[i], j); hRoleBmp[i][j] = (HBITMAP)LoadImage(NULL, fullName, IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE); sprintf(fullName, \"_%s%d.bmp\", actionName[i], j); _hRoleBmp[i][j] = (HBITMAP)LoadImage(NULL, fullName, IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE); GetObject(hRoleBmp[i][j], sizeof(BITMAP), &amp;roleFlyBmp[i][j]); } } MyPaint(hdc); return TRUE;}void limitXY(int nOX, int nOY){ int lix, liy, liw, lih; for (int i = 0; i &lt; limitsMapNum; i++) { lix = limitsMap[i][0]; liy = limitsMap[i][1]; liw = limitsMap[i][2]; lih = limitsMap[i][3]; // 画限制区域和人物的范围，调试用 /*HBRUSH hb; hb = (HBRUSH) CreateSolidBrush(RGB(0xFF, 0xFF, 0xFF)); SelectObject(hdc, hb); Rectangle(hdc, lix, liy, lix + liw, liy + lih); Ellipse(hdc, OX, OY, OX + roleFlyBmp[action][actionFrame].bmWidth, OY + roleFlyBmp[action][actionFrame].bmHeight); DeleteObject(hb);*/ if (OX &gt; lix + liw || OX + roleFlyBmp[action][actionFrame].bmWidth &lt; lix || OY &gt; liy + lih || OY + roleFlyBmp[action][actionFrame].bmHeight &lt; liy || (OX - lix - liw / 2) * (OX - lix - liw / 2) + (OY - liy - lih / 2) * (OY - liy - lih / 2) &gt; (max(liw , lih) * max(liw , lih)) &gt;&gt; 1) ; // 边角处理 else { if (OX &gt; lix + liw || OX + roleFlyBmp[action][actionFrame].bmWidth &lt; lix) ; else OX = nOX; if (OY &gt; liy + lih || OY + roleFlyBmp[action][actionFrame].bmHeight &lt; liy) ; else OY = nOY; if (OX == nOX &amp;&amp; OY == nOY) break; } }}void MyPaint(HDC hdc){ // 运动 int nOX = OX, nOY = OY; if (EX || EY) { int fflag = 0; if (abs(EX - OX) &gt; SX) { fflag = 1; if (EX &gt; OX) OX += SX; else OX -= SX; } if (abs(EY - OY) &gt; SY) { fflag = 1; if (EY &gt; OY) OY += SY; else OY -= SY; } if (!fflag) EX = EY = 0; } limitXY(nOX, nOY); // 画背景 SelectObject(bufdc, hBgBmp); BitBlt(mdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, bufdc, 0, 0, SRCCOPY); // 画背景 SelectObject(bufdc, _hRoleBmp[action][actionFrame]); BitBlt(mdc, OX, OY, roleFlyBmp[action][actionFrame].bmWidth, roleFlyBmp[action][actionFrame].bmHeight, bufdc, 0, 0, SRCAND); // 画人物 SelectObject(bufdc, hRoleBmp[action][actionFrame]); BitBlt(mdc, OX, OY, roleFlyBmp[action][actionFrame].bmWidth, roleFlyBmp[action][actionFrame].bmHeight, bufdc, 0, 0, SRCPAINT); // 画人物 BitBlt(hdc, 0, 0, WIDTH, HEIGHT, mdc, 0, 0, SRCCOPY); // 动画 switch (action) { case ACTION_STARTFLY: if (!EX &amp;&amp; !EY &amp;&amp; OX==370 &amp;&amp; OY==180) return ; if (actionFrameContrler &gt;= 4) { actionFrameContrler = 0; action = 1; } actionFrame = actionFrameContrler; break; case ACTION_FLY: case ACTION_FLY2: if (actionFrameContrler &gt;= 8) actionFrameContrler = 0; actionFrame = actionFrameContrler / 2; break; case ACTION_ATTACK: case ACTION_ATTACK2: if (actionFrameContrler &gt;= 15) { actionFrameContrler = 0; action -= (ACTION_ATTACK - ACTION_FLY); } actionFrame = actionFrameContrler / 3; break; } actionFrameContrler++; tPre = GetTickCount();}//****消息处理函数***********************************LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam){ int i, j; switch (message) { case WM_PAINT : hdc = BeginPaint(hWnd, &amp;ps); GetClientRect(hWnd, &amp;rect); MyPaint(hdc); EndPaint(hWnd, &amp;ps); break; case WM_MOUSEMOVE : MX = LOWORD(lParam) - roleFlyBmp[action][actionFrame].bmWidth / 2; MY = HIWORD(lParam) - roleFlyBmp[action][actionFrame].bmHeight / 2; break; case WM_LBUTTONDOWN : EX = MX; EY = MY; if (EX &lt; OX) action = ACTION_FLY2; else if (action != ACTION_STARTFLY) action = ACTION_FLY; break; case WM_KEYDOWN : switch (wParam) { case VK_UP : OY -= 20; limitXY(OX, OY + 20); break; case VK_DOWN : OY += 20; limitXY(OX, OY - 20); break; case VK_LEFT : OX -= 20; limitXY(OX + 20, OY); action = 2; break; case VK_RIGHT : OX += 20; limitXY(OX - 20, OY); action = 1; break; } break; case WM_CHAR : switch (wParam) { case 'w' : OY -= 20; limitXY(OX, OY + 20); break; case 's' : OY += 20; limitXY(OX, OY - 20); break; case 'a' : OX -= 20; limitXY(OX + 20, OY); action = 2; break; case 'd' : OX += 20; limitXY(OX - 20, OY); action = 1; break; case ' ' : if (action != 3 &amp;&amp; action != 4) { if (action == 1 || action == 2) action += 2; else action = 3; actionFrameContrler = 0; break; } } break; case WM_DESTROY: //窗口结束消息，撤销各种DC DeleteDC(mdc); DeleteDC(bufdc); DeleteObject(fullmap); for (i = 0; i &lt; 5; i++) for (j = 0; j &lt; 5; j++) { DeleteObject(hRoleBmp[i][j]); DeleteObject(_hRoleBmp[i][j]); } ReleaseDC(hWnd, hdc); PostQuitMessage(0); break; default: //其他消息 return DefWindowProc(hWnd, message, wParam, lParam); } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"模板","slug":"模板","permalink":"http://blog.iwxyi.com/tags/模板/"},{"name":"Win32 SDK","slug":"Win32-SDK","permalink":"http://blog.iwxyi.com/tags/Win32-SDK/"}]},{"title":"Win32 SDK双缓冲","date":"2018-06-04T02:00:00.000Z","path":"2018/06/04/Win32-SDK双缓冲/","text":"声明123HDC hdc, mdc, bufdc;HBITMAP fullmap, hBgBmp, hRoleBmp[10][100], _hRoleBmp[10][100];BITMAP bgBmp, roleFlyBmp[10][100], _roleFlyBmp[10][100]; 初始化1234567891011121314151617181920212223242526hdc = GetDC(hWnd);mdc = CreateCompatibleDC(hdc);bufdc = CreateCompatibleDC(hdc);fullmap = CreateCompatibleBitmap(hdc, WIDTH, HEIGHT);SelectObject(mdc, fullmap);hBgBmp = (HBITMAP)LoadImage(NULL, \"bg.bmp\", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);GetObject(hBgBmp, sizeof(BITMAP), &amp;bgBmp);// 循环加载所有图片int i, j;char actionName[10][20] = { \"startfly\", \"fly\", \"fly2\", \"attack\", \"attack2\" };for (i = 0; i &lt; 5; i++){ char fullName[100]; for (j = 0; j &lt; 5; j++) { sprintf(fullName, \"%s%d.bmp\", actionName[i], j); hRoleBmp[i][j] = (HBITMAP)LoadImage(NULL, fullName, IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE); // 原图 sprintf(fullName, \"_%s%d.bmp\", actionName[i], j); _hRoleBmp[i][j] = (HBITMAP)LoadImage(NULL, fullName, IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE); // 掩图 GetObject(hRoleBmp[i][j], sizeof(BITMAP), &amp;roleFlyBmp[i][j]); }} 绘图12345678910SelectObject(bufdc, hBgBmp);BitBlt(mdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, bufdc, 0, 0, SRCCOPY); // 画背景到mdcSelectObject(bufdc, _hRoleBmp[action][actionFrame]);BitBlt(mdc, OX, OY, roleFlyBmp[action][actionFrame].bmWidth, roleFlyBmp[action][actionFrame].bmHeight, bufdc, 0, 0, SRCAND); // 画人物[掩图]到mdcSelectObject(bufdc, hRoleBmp[action][actionFrame]);BitBlt(mdc, OX, OY, roleFlyBmp[action][actionFrame].bmWidth, roleFlyBmp[action][actionFrame].bmHeight, bufdc, 0, 0, SRCPAINT);BitBlt(hdc, 0, 0, WIDTH, HEIGHT, mdc, 0, 0, SRCCOPY); // 画mdc到hdc document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Win32 SDK","slug":"Win32-SDK","permalink":"http://blog.iwxyi.com/tags/Win32-SDK/"}]},{"title":"PHP XML解析器","date":"2018-06-03T08:33:00.000Z","path":"2018/06/03/PHP-XML解析器/","text":"通过 xml_parser_create() 函数初始化 XML 解析器创建配合不同事件处理程序的的函数 添加 xml_set_element_handler() 函数来定义，当解析器遇到开始和结束标签时执行哪个函数 添加 xml_set_character_data_handler() 函数来定义，当解析器遇到字符数据时执行哪个函数通过 xml_parse() 函数来解析文件 “test.xml” 万一有错误的话，添加 xml_error_string() 函数把 XML 错误转换为文本说明 调用 xml_parser_free() 函数来释放分配给 xml_parser_create() 函数的内存 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?php //Initialize the XML parser $parser=xml_parser_create(); //Function to use at the start of an element function start($parser,$element_name,$element_attrs) { switch($element_name) { case \"NOTE\": echo \"-- Note --&lt;br /&gt;\"; break; case \"TO\": echo \"To: \"; break; case \"FROM\": echo \"From: \"; break; case \"HEADING\": echo \"Heading: \"; break; case \"BODY\": echo \"Message: \"; } } //Function to use at the end of an element function stop($parser,$element_name) { echo \"&lt;br /&gt;\"; } //Function to use when finding character data function char($parser,$data) { echo $data; } //Specify element handler xml_set_element_handler($parser,\"start\",\"stop\"); //Specify data handler xml_set_character_data_handler($parser,\"char\"); //Open XML file $fp=fopen(\"test.xml\",\"r\"); //Read data while ($data=fread($fp,4096)) { xml_parse($parser,$data,feof($fp)) or die (sprintf(\"XML Error: %s at line %d\", xml_error_string(xml_get_error_code($parser)), xml_get_current_line_number($parser))); } //Free the XML parser xml_parser_free($parser);?&gt; XML文件： 1234567&lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt;&lt;note&gt; &lt;to&gt;George&lt;/to&gt; &lt;from&gt;John&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don't forget the meeting!&lt;/body&gt;&lt;/note&gt; 以上XML的输出： 12345-- Note --To: GeorgeFrom: JohnHeading: ReminderMessage: Don't forget the meeting! XML Dom输出XML文件内容到浏览器（原封不动）标签会当作HTML标签，隐藏 1234567&lt;?php $xmlDoc = new DOMDocument(); $xmlDoc-&gt;load(\"note.xml\"); print $xmlDoc-&gt;saveXML();?&gt;saveXML() 函数把内部 XML 文档放入一个字符串，这样我们就可以输出它。 12345678910&lt;?php $xmlDoc = new DOMDocument(); $xmlDoc-&gt;load(\"note.xml\"); $x = $xmlDoc-&gt;documentElement; foreach ($x-&gt;childNodes AS $item) { print $item-&gt;nodeName . \" = \" . $item-&gt;nodeValue . \"&lt;br /&gt;\"; }?&gt; 以上代码的输出： 123456789#text =to = George#text =from = John#text =heading = Reminder#text =body = Don't forget the meeting!#text = 当 XML 生成时，它通常会在节点之间包含空白。XML DOM 解析器把它们当作普通的元素，如果您不注意它们，有时会产生问题。 SimpleXML 12345678910&lt;?php $xml = simplexml_load_file(\"test.xml\"); echo $xml-&gt;getName() . \"&lt;br /&gt;\"; foreach($xml-&gt;children() as $child) { echo $child-&gt;getName() . \": \" . $child . \"&lt;br /&gt;\"; }?&gt; 以上代码的输出： 12345noteto: Georgefrom: Johnheading: Reminderbody: Don't forget the meeting! document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.iwxyi.com/tags/PHP/"}]},{"title":"PHP判断PC端还是移动端","date":"2018-06-03T08:23:00.000Z","path":"2018/06/03/PHP判断PC端还是移动端/","text":"多种方式判断平台 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?phpfunction isMobile(){ // 如果有HTTP_X_WAP_PROFILE则一定是移动设备 if (isset($_SERVER['HTTP_X_WAP_PROFILE'])) { return true; } // 如果via信息含有wap则一定是移动设备 if (isset($_SERVER['HTTP_VIA'])) { // 找不到为flase,否则为true return stristr($_SERVER['HTTP_VIA'], \"wap\") ? true : false; } // 脑残法，判断手机发送的客户端标志,兼容性有待提高 if (isset($_SERVER['HTTP_USER_AGENT'])) { $clientkeywords = array( 'nokia', 'sony', 'ericsson', 'mot', 'samsung', 'htc', 'sgh', 'lg', 'sharp', 'sie-', 'philips', 'panasonic', 'alcatel', 'lenovo', 'iphone', 'ipod', 'blackberry', 'meizu', 'android', 'netfront', 'symbian', 'ucweb', 'windowsce', 'palm', 'operamini', 'operamobi', 'openwave', 'nexusone', 'cldc', 'midp', 'wap', 'mobile' ); // 从HTTP_USER_AGENT中查找手机浏览器的关键字 if (preg_match(\"/(\" . implode('|', $clientkeywords) . \")/i\", strtolower($_SERVER['HTTP_USER_AGENT']))) { return true; } } // 协议法，因为有可能不准确，放到最后判断 if (isset($_SERVER['HTTP_ACCEPT'])) { // 如果只支持wml并且不支持html那一定是移动设备 // 如果支持wml和html但是wml在html之前则是移动设备 if ((strpos($_SERVER['HTTP_ACCEPT'], 'vnd.wap.wml') !== false) &amp;&amp; (strpos($_SERVER['HTTP_ACCEPT'], 'text/html') === false || (strpos($_SERVER['HTTP_ACCEPT'], 'vnd.wap.wml') &lt; strpos($_SERVER['HTTP_ACCEPT'], 'text/html')))) { return true; } } return false;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.iwxyi.com/tags/PHP/"}]},{"title":"JS正则与子字符串切片","date":"2018-06-03T07:58:00.000Z","path":"2018/06/03/JS正则与子字符串切片/","text":"云笺根据名字打开目录例如：test test_ test_2 打开的都是 test 的目录 1234567891011121314function openContent() { var name = document.getElementById(\"name\").value; if (name == \"\") return ; var url = \"\", pat = /(.+_)\\d{1,2}/; if (pat.test(name)) // 符合正则 url = name.slice(0, name.lastIndexOf('_')+1); // \"_\" 左边及其内容 else if (name.lastIndexOf('_') == name.length-1) // 以 \"_\" 结尾 url = name; else url = name + \"_\"; window.open(\"index.php?n=\" + encodeURI(url)); return false;} 打开下一页123456789101112131415161718192021function page_next() { var name = document.getElementById(\"name\").value; if (name == \"\") return ; var url = \"\"; var pat = /(.+_)\\d{1,2}/; if (pat.test(name)) { url = name.slice(0, name.lastIndexOf('_')+1); pagenum = name.slice(name.lastIndexOf(\"_\")+1, name.length); // 获取页码 pagenum = parseFloat(pagenum) + 1; url = url + pagenum; } else if (name.lastIndexOf('_') == name.length-1) url = name + \"1\"; else url = name + \"_1\"; openYunj2(\"index.php?n=\" + encodeURI(url)); return false;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"JS","slug":"JS","permalink":"http://blog.iwxyi.com/tags/JS/"},{"name":"RegExp","slug":"RegExp","permalink":"http://blog.iwxyi.com/tags/RegExp/"}]},{"title":"JS判断PC端还是移动端","date":"2018-06-03T07:56:00.000Z","path":"2018/06/03/JS判断PC端还是移动端/","text":"根据UA名字来判断设备类型： 12345678910111213141516171819202122232425262728&lt;script type = \"text/javascript\"&gt;function browserRedirect(){ var sUserAgent = navigator.userAgent.toLowerCase(); var bIsIpad = sUserAgent.match(/ipad/i) == \"ipad\"; var bIsIphoneOs = sUserAgent.match(/iphone os/i) == \"iphone os\"; var bIsMidp = sUserAgent.match(/midp/i) == \"midp\"; var bIsUc7 = sUserAgent.match(/rv:1.2.3.4/i) == \"rv:1.2.3.4\"; var bIsUc = sUserAgent.match(/ucweb/i) == \"ucweb\"; var bIsAndroid = sUserAgent.match(/android/i) == \"android\"; var bIsCE = sUserAgent.match(/windows ce/i) == \"windows ce\"; var bIsWM = sUserAgent.match(/windows mobile/i) == \"windows mobile\"; if (bIsIpad || bIsIphoneOs || bIsMidp || bIsUc7 || bIsUc || bIsAndroid || bIsCE || bIsWM) { var choice = confirm(\"you appears to be in mobile mode, will rediect to baidu\"); var choice1; window.location = choice ? \"https://www.baidu.com/\" : (choice1 = confirm(\"force to redirect to zhihu could result in bad viewer experience\") ? \"https://www.zhihu.com\" : \"https://www.baidu.com/\"); } else { var choice = confirm(\"you appears to be in pc mode, will rediect to zhihu\"); var choice1; window.location = choice ? \"https://www.zhihu.com/\" : (choice1 = confirm(\"force to redirect to baidu could result in bad viewer experience\") ? \"https://www.baidu.com/\" : \"https://www.zhihu.com\"); }}browserRedirect();&lt;/script&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"JS","slug":"JS","permalink":"http://blog.iwxyi.com/tags/JS/"}]},{"title":"JS关闭标签页前提示","date":"2018-06-03T07:40:00.000Z","path":"2018/06/03/JS关闭标签页前提示/","text":"实测chrome无效……七星浏览器（Chrome+IE双内核）一旦有这个函数，不论内容，任意改变表单就会提示未修改 123456window.onbeforeunload = function(event){ if (document.getElementById(\"info\").value != save_text) return '您可能有数据没有保存'; else return false;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"JS","slug":"JS","permalink":"http://blog.iwxyi.com/tags/JS/"}]},{"title":"JS检查邮箱格式","date":"2018-06-03T07:40:00.000Z","path":"2018/06/03/JS检查邮箱格式/","text":"123456789101112131415function checkEmail(){ var email = document.getElementById(\"email\").value; if(email == \"\" || email == null) { document.getElementById(\"email_helper\").innerHTML = \"\"; return false; } var myreg = /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(.[a-zA-Z0-9_-])+/; if(!myreg.test(email)) { document.getElementById(\"email_helper\").innerHTML = \"请输入正确的邮箱\"; } else { document.getElementById(\"email_helper\").innerHTML = \"\"; }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"JS","slug":"JS","permalink":"http://blog.iwxyi.com/tags/JS/"},{"name":"RegExp","slug":"RegExp","permalink":"http://blog.iwxyi.com/tags/RegExp/"}]},{"title":"JS捕捉按键按下","date":"2018-06-03T07:31:00.000Z","path":"2018/06/03/JS捕捉按键按下/","text":"必须要在按下按键的事件里添加函数并且return false才能消除原有的按键操作。 1&lt;input id=\"name\" onkeydown=\"nameClick();\" type=\"text\" /&gt; 12345678910111213141516171819function nameClick() { var e = event || window.event || arguments.callee.caller.arguments[0]; if (!e) return ; if (e.keyCode == 13) // 回车 { /* ... code ... */ return false; } else if (e.keyCode == 9 &amp;&amp; !(e.altKey || e.ctrlKey || e.shiftKey)) // tab { /* ... code ... */ return false; } else if (e.keyCode == 83 &amp;&amp; (e.altKey || e.ctrlKey) ) // Ctrl+S { /* ... code ... */ return false; }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"JS","slug":"JS","permalink":"http://blog.iwxyi.com/tags/JS/"}]},{"title":"JSP取网页源码","date":"2018-06-03T07:17:00.000Z","path":"2018/06/03/JSP取网页源码/","text":"取网页源码123456String line = \"\", source = \"\", url = \"https://www.qidian.com/all\";HttpURLConnection l_connection = (HttpURLConnection) (new URL(url)).openConnection();l_connection.connect();InputStreamReader isr = new InputStreamReader(l_connection.getInputStream(), \"UTF-8\");BufferedReader l_reader = new BufferedReader(isr);while ((line = l_reader.readLine()) != null) source+=line; 取源码后截取中间文本 1234567891011121314int startPos = source.indexOf(\"左边文本\", endPos);int endPos = source.indexOf(\"右边文本\", startPos+10);if (endPos == 0 || endPos == -1) endPos = source.length();String part = source.substring(startPos, endPos);String bookID, bookUrl, bookName;String regEx = \"要匹配的正则表达式\";Pattern p = Pattern.compile(regEx, Pattern.CASE_INSENSITIVE);Matcher m = p.matcher(part);while (m.find()){ String a = m.group(1); String b = m.group(2);} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://blog.iwxyi.com/tags/HTTP/"},{"name":"JSP","slug":"JSP","permalink":"http://blog.iwxyi.com/tags/JSP/"}]},{"title":"JSP从cookie登录","date":"2018-06-03T07:14:00.000Z","path":"2018/06/03/JSP从cookie登录/","text":"读取本地 cookies 的 username 和 password 字段，和数据库中记录进行判断 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ page import=\"java.io.*,java.util.*\" %&gt;&lt;%@ page import=\"com.mysql.jdbc.Driver, java.sql.*\" %&gt;&lt;jsp:useBean id=\"usero\" class=\"wxy.jsp.novel.UserO\" scope=\"session\" /&gt;&lt;jsp:useBean id=\"sqlM\" class=\"wxy.jsp.mysql.sqlBean\" scope=\"session\" /&gt;&lt;% String username = request.getParameter(\"username\"); String password = null; Cookie cookie = null; Cookie[] cookies = null; String MSG = \"\"; // 读取 cookie cookies = request.getCookies(); if (cookies != null) { for (int i = 0; i &lt; cookies.length; i++) { cookie = cookies[i]; if (cookie.getName().equals(\"username\")) { username = java.net.URLDecoder.decode(cookie.getValue(), \"utf-8\"); } else if (cookie.getName().equals(\"password\")) { password = java.net.URLDecoder.decode(cookie.getValue(), \"utf-8\"); } } } if (username == null) username = \"\"; if (password == null) password = \"\"; if (username != null &amp;&amp; password != null &amp;&amp; !username.equals(\"\") &amp;&amp; !password.equals(\"\")) // 带参数 { if (sqlM.SafeCheck(username) == false || sqlM.SafeCheck(password) == false) { MSG = \"alert('非法账号/密码输入');\"; } else { // 搜索数据库 String sql = \"SELECT * from users where username = '\" + username + \"' and password = '\" + password + \"'\"; ResultSet rs = sqlM.executeQuery(sql); if (rs != null &amp;&amp; rs.next() == true) { usero.setUsername(username); usero.setPassword(password); String username_code = java.net.URLEncoder.encode(username, \"UTF-8\"); String password_code = java.net.URLEncoder.encode(password, \"UTF-8\"); Cookie username_cookie = new Cookie(\"username\", username_code); Cookie password_cookie = new Cookie(\"password\", password_code); username_cookie.setMaxAge(60*60*24*3); password_cookie.setMaxAge(60*60*24*3); response.addCookie(username_cookie); response.addCookie(password_cookie); response.setStatus(response.SC_MOVED_TEMPORARILY); response.setHeader(\"Location\", \"account.jsp\"); return ; } } }%&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"JSP","slug":"JSP","permalink":"http://blog.iwxyi.com/tags/JSP/"}]},{"title":"HTML改变Chrome标签页颜色","date":"2018-06-03T05:09:00.000Z","path":"2018/06/03/HTML改变Chrome标签页颜色/","text":"1&lt;meta name=\"theme-color\" content=\"#db5945\"&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"HTML","slug":"HTML","permalink":"http://blog.iwxyi.com/tags/HTML/"}]},{"title":"CSS伪元素计数","date":"2018-06-03T04:57:00.000Z","path":"2018/06/03/CSS伪元素计数/","text":"123456789&lt;h2&gt;&lt;/h2&gt;&lt;h2&gt;&lt;/h2&gt;&lt;style&gt;body {counter-reset:section;}h2:before {counter-increment: section;content: \"Chapter\" counter(section) \".\";}&lt;/style&gt; 结果如下： 12Chapter1.Chapter2. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"CSS","slug":"CSS","permalink":"http://blog.iwxyi.com/tags/CSS/"}]},{"title":"C++取数组长度函数","date":"2018-06-03T00:17:00.000Z","path":"2018/06/03/C-取数组长度函数/","text":"12345template &lt;typename Type, size_t N&gt;inline size_t GetArrayLength(const Type(&amp;)[N]){ return N;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"}]},{"title":"C++11 Lambda示例","date":"2018-06-03T00:04:00.000Z","path":"2018/06/03/C-11-Lambda示例/","text":"声明 Lambda 表达式12345auto f1 = [](int x, int y) { return x + y; };cout &lt;&lt; f1(2, 3) &lt;&lt; endl; // 输出 5function&lt;int(int, int)&gt; f2 = [](int x, int y) { return x + y; };cout &lt;&lt; f2(3, 4) &lt;&lt; endl; // 输出 7 12345678910111213141516#include &lt;functional&gt;#include &lt;iostream&gt;int main(){ using namespace std; int i = 3, j = 5; function&lt;int (void)&gt; f = [i, &amp;j] { return i + j; }; i = 22; j = 44; cout &lt;&lt; f() &lt;&lt; endl; // 3 + j = 47，输出 47} 调用 Lambda 表达式12345678#include &lt;iostream&gt;int main(){ using namespace std; int n = [] (int x, int y) { return x + y; }(5, 4); cout &lt;&lt; n &lt;&lt; endl; // 输出 9} 12345678910111213141516171819202122232425// STL+Lambda 用法#include &lt;list&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;int main(){ using namespace std; list&lt;int&gt; numbers; numbers.push_back(13); numbers.push_back(17); numbers.push_back(42); numbers.push_back(46); numbers.push_back(99); const list&lt;int&gt;::const_iterator result = find_if(numbers.begin(), numbers.end(),[](int n) { return (n % 2) == 0; }); if (result != numbers.end()) { cout &lt;&lt; \"The first even number in the list is \" &lt;&lt; *result &lt;&lt; \".\" &lt;&lt; endl; // 第一个偶数是 42 } else { cout &lt;&lt; \"The list contains no even numbers.\" &lt;&lt; endl; }} 嵌套 Lambda 表达式12345678910111213#include &lt;iostream&gt;int main(){ using namespace std; // The following lambda expression contains a nested lambda // expression. int timestwoplusthree = [](int x) { return [](int y) { return y * 2; }(x) + 3; }(5); // Print the result. cout &lt;&lt; timestwoplusthree &lt;&lt; endl;} 高阶Lambda函数https://msdn.microsoft.com/zh-cn/library/dd293599.aspx document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++11","slug":"C-11","permalink":"http://blog.iwxyi.com/tags/C-11/"},{"name":"Lambda","slug":"Lambda","permalink":"http://blog.iwxyi.com/tags/Lambda/"}]},{"title":"C++11 auto类型与引用","date":"2018-06-02T23:50:00.000Z","path":"2018/06/03/C-11-auto类型与引用/","text":"123int count = 10;int&amp; countRef = count;auto myAuto = countRef; // 普通的int，非引用 您可能会认为 myAuto 是一个 int 引用，但它不是。 验证： 12345countRef = 11;cout &lt;&lt; count &lt;&lt; \" \";myAuto = 12;cout &lt;&lt; count &lt;&lt; endl; 它只是一个 int。因为输出为 11 11，而不是 11 12； 如果 auto 尚未删除此引用，则会出现此情况。 12345678910111213141516171819202122map&lt;int,list&lt;string&gt;&gt;::iterator i = m.begin();auto i = m.begin(); // 就是如此简单……#include &lt;deque&gt;using namespace std;int main(){ deque&lt;double&gt; dqDoubleData(10, 0.1); for (auto iter = dqDoubleData.begin(); iter != dqDoubleData.end(); ++iter) // 注意是 ++iter { /* ... */ } for (auto elem : dqDoubleData) { /* ... */ } for (auto&amp; elem : dqDoubleData) { /* ... */ } for (const auto&amp; elem : dqDoubleData) { /* ... */ }} 123456789101112131415161718double x = 12.34;auto *y = new auto(x), **z = new auto(&amp;x);auto x = 1, *y = &amp;x, **z = &amp;y; // Resolves to int.auto a(2.01), *b (&amp;a); // Resolves to double.auto c = 'a', *d(&amp;c); // Resolves to char.auto m = 1, &amp;n = m; // Resolves to int.int f(int x) { return x; }int main(){ auto x = f(0); // int x const auto &amp; y = f(1); // const int &amp; y 引用 int (*p)(int x); p = f; auto fp = p; // 返回值为 int 类型的函数的指针} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++11","slug":"C-11","permalink":"http://blog.iwxyi.com/tags/C-11/"}]},{"title":"C++重载()仿构造函数","date":"2018-06-02T23:46:00.000Z","path":"2018/06/03/C-重载-仿构造函数/","text":"坑同事技巧+1 1234567891011121314151617181920class Point{public: Point() { _x = _y = 0; } Point &amp;operator()( int dx, int dy ) { _x += dx; _y += dy; return *this; }private: int _x, _y;};int main(){ Point pt; // 初始化为 (0, 0) pt( 3, 2 ); // 这他妈不是函数……} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"}]},{"title":"C++异常规范","date":"2018-06-02T23:43:00.000Z","path":"2018/06/03/C-异常规范/","text":"throw、try、catch 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;void handler() { printf_s(\"in handler\\n\");}void f1(void) throw(int) { printf_s(\"About to throw 1\\n\"); if (1) throw 1;}void f5(void) throw() { try { f1(); } catch(...) { handler(); }}//invalid, doesn't handle the int exception thrown from f1()/*void f3(void) throw() { f1();}*/void __declspec(nothrow) f2(void) { try { f1(); } catch(int) { handler(); }}extern \"C\" void f4(void);void f4(void) { f1();}int main() { f2(); try { f4(); } catch(...) { printf_s(\"Caught exception from f4\\n\"); } f5();} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"}]},{"title":"C++线程函数","date":"2018-06-02T23:42:00.000Z","path":"2018/06/03/C-线程函数/","text":"线程随着 std::thread 类型实例的创建而创建 从 C++ 11 开始，推荐使用列表初始化的方式，构造类类型的变量。 当函数的名字被当做一个值来使用的时候，实际上使用的是函数的指针。 12345678910111213#include &lt;iostream&gt;#include &lt;thread&gt; // 1void greeting() { // 2 std::cout &lt;&lt; \"Hello multithread!\" &lt;&lt; std::endl; return;}int main() { std::thread t{greeting}; // 3 t.join(); // 4 return 0;} std::thread wk_thread(ThreadTask()); // 1 std::thread wk_thread{ThreadTask{}}; // 2 在 (1) 处，作者的本意，是想构造一个 ThreadTask 实例，作为可调用对象作为 wk_thread 线程的线程函数。但实际上，ThreadTask() 是一个函数指针的类型——这个函数没有参数 (void)，返回值的类型是 ThreadTask。因此，整个 (1) 会被 C++ 理解为一个函数声明：参数是一个函数指针（前述），返回类型是 std::thread。 构造函数和普通的函数是有一些不同的。构造函数执行完毕之后，就产生了一个可用的实例。产生这样误解的本质原因，是 std::thread 的构造函数也是函数，因而采用 () 接受参数列表；这样一来，从形式上构造函数就没有任何特殊性了。C++ 11 引入了列表初始化的概念，允许程序员以花括号代替圆括号，将参数传递给构造函数。这样一来，(2) 就没有歧义了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"多线程","slug":"多线程","permalink":"http://blog.iwxyi.com/tags/多线程/"},{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"}]},{"title":"C++11 Lambda表达式","date":"2018-06-02T23:27:00.000Z","path":"2018/06/03/C-11-Lambda表达式/","text":"Lambda 可在其主体中引入新的变量（用 C++14），它还可以访问（或“捕获”）周边范围内的变量。 12345678910#include &lt;algorithm&gt;#include &lt;cmath&gt;void abssort(float* x, unsigned n) { std::sort(x, x + n, [](float a, float b) { return (std::abs(a) &lt; std::abs(b)); } );} 指定要捕获的变量以及是通过值还是引用进行捕获。 有与号 (&amp;) 前缀的变量通过引用访问，没有该前缀的变量通过值访问。 以使用默认捕获模式（标准语法中的 capture-default）来指示如何捕获 lambda 中引用的任何外部变量：[&amp;] 表示通过引用捕获引用的所有变量，而 [=] 表示通过值捕获它们。 可以使用默认捕获模式，然后为特定变量显式指定相反的模式。 （引用和值，效果同函数形参） 例如，如果 lambda 体通过引用访问外部变量 total 并通过值访问外部变量 factor，则以下 capture 子句等效： 123456[&amp;total, factor][factor, &amp;total][&amp;, factor][factor, &amp;][=, &amp;total][&amp;total, =] identifier(&amp;/=) 或 this 在 capture 子句中出现的次数不能超过一次。示例： 12345678struct S { void f(int i); };void S::f(int i) { [&amp;, i]{}; // OK [&amp;, &amp;i]{}; // ERROR: i preceded by &amp; when &amp; is the default [=, this]{}; // ERROR: this when = is the default [i, i]{}; // ERROR: i repeated} 包扩展：capture 后跟省略号可变参数模板 12345template&lt;class... Args&gt;void f(Args... args) { auto x = [args...] { return g(args...); }; x();} 参数列表 1234int y = [] (int first, int second){ return first + second;}; 12345// C++14，创建模板auto y = [] (auto first, auto second){ return first + second;}; 在 C++14 中，如果参数类型是泛型，则可以使用 auto 关键字作为类型说明符。 这将告知编译器将函数调用运算符创建为模板。 参数列表中的每个 auto 实例等效于一个不同的类型参数。 异常规范 1234int main() // C4297 expected{ []() throw() { throw 5; }();} 返回类型 1234auto x1 = [](int i){ return i; }; // OK: return type is intauto x2 = []{ return{ 1, 2 }; }; // ERROR: return type is void, deducing// return type from braced-init-list is not valid lambda 表达式可以生成另一个 lambda 表达式作为其返回值。 通过值显式捕获变量 n 并通过引用隐式捕获变量 m 的 lambda 表达式： 12345678910#include &lt;iostream&gt;using namespace std;int main(){ int m = 0; int n = 0; [&amp;, n] (int a) mutable { m = ++n + a; }(4); cout &lt;&lt; m &lt;&lt; \" \" &lt;&lt; n &lt;&lt; endl; // 输出：5 0} mutable 规范允许在 lambda 中修改 n。 示例：使用 generate 函数和 lambda 表达式为 vector 对象中的每个元素赋值。 lambda 表达式将修改静态变量以生成下一个元素的值。 12345678910111213#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;void fillVector(vector&lt;int&gt;&amp; v){ static int nextValue = 1; generate(v.begin(), v.end(), [] { return nextValue++; }); // generate 函数见：生成 ‎ //WARNING: not thread-safe and …} 1234567891011121314151617181920212223242526272829303132template &lt;typename C&gt;void print(const string&amp; s, const C&amp; c) { cout &lt;&lt; s; for (const auto&amp; e : c) { cout &lt;&lt; e &lt;&lt; \" \"; } cout &lt;&lt; endl;}int main(){ const int elementCount = 9; vector&lt;int&gt; v(elementCount, 1); int x = 1, y = 1; //斐波那契：每个等于前两个的和 generate_n(v.begin() + 2, elementCount - 2, [=]() mutable throw() -&gt; int { int n = x + y; x = y; y = n; return n; }); print(\"vector v after call to generate_n() with lambda: \", v); cout &lt;&lt; \"x: \" &lt;&lt; x &lt;&lt; \" y: \" &lt;&lt; y &lt;&lt; endl; // x y 仍为1 fillVector(v); print(\"vector v after 1st call to fillVector(): \", v); fillVector(v); print(\"vector v after 2nd call to fillVector(): \", v);} 输出： 1234vector v after call to generate_n() with lambda: 1 1 2 3 5 8 13 21 34x: 1 y: 1vector v after 1st call to fillVector(): 1 2 3 4 5 6 7 8 9vector v after 2nd call to fillVector(): 10 11 12 13 14 15 16 17 18 参考：https://msdn.microsoft.com/zh-cn/library/dd293608.aspx document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++11","slug":"C-11","permalink":"http://blog.iwxyi.com/tags/C-11/"},{"name":"Lambda","slug":"Lambda","permalink":"http://blog.iwxyi.com/tags/Lambda/"}]},{"title":"VC++ ATL对象的COM组件","date":"2018-06-01T02:05:00.000Z","path":"2018/06/01/VC-ATL对象的COM组件/","text":"使用 ATL 开发和调用 COM 组件 12345678910111213141516171819202122232425262728293031323334353637383940414243#include \"stdafx.h\"#include \"ATL1.h\"#include \"ATL1_i.c\"int main(){ ITest * pITest; HRESULT hResult; if (CoInitialize(NULL) != S_OK) { printf(\"Initialize COM library failed!n\"); return -1; } GUID ATL1CLSID; hResult = ::CLSIDFromProgID(L\"ATL1.Test\", &amp;ATL1CLSID); if (hResult != S_OK) { printf(\"Can't find the ATL1 CLSID!n\"); return -2; } hResult = CoCreateInstance(ATL1CLSID, NULL, CLSCTX_INPROC_SERVER, IID_ITest, (void **)&amp;pITest); if (hResult != S_OK) { printf(\"Create object failed!n\"); return -2; } printf(\"Call ITest interface's functions...n\"); double k; double *ans = &amp;k; pITest-&gt;getArea(3, 4, 5, ans); printf(\"3,4,5=%.2lfn\",*ans); printf(\"Test over...n\"); pITest-&gt;Release(); CoUninitialize(); return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"VC++","slug":"VC","permalink":"http://blog.iwxyi.com/tags/VC/"}]},{"title":"JSP正则表达式提取文本","date":"2018-05-31T07:24:00.000Z","path":"2018/05/31/JSP正则表达式提取文本/","text":"1234String regEx =\"href=\\\"//book.qidian.com/info/(\\\\d+)\\\"\";Pattern p = Pattern.compile(regEx, Pattern.CASE_INSENSITIVE);Matcher m = p.matcher(str);if(m.find()) bookID = m.group(1); // 第一个括号 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"JSP","slug":"JSP","permalink":"http://blog.iwxyi.com/tags/JSP/"},{"name":"RegExp","slug":"RegExp","permalink":"http://blog.iwxyi.com/tags/RegExp/"}]},{"title":"JSP连接数据库","date":"2018-05-30T07:16:00.000Z","path":"2018/05/30/JSP连接数据库/","text":"连接数据库下载 Java 专用的连接 MySQL 的驱动包 JDBC (jar 包)，复制到 lib 里面 例子12345678910111213141516171819202122232425&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ page import=\"com.mysql.jdbc.Driver\" %&gt;&lt;%@ page import=\"java.sql.*\" %&gt;&lt;% String driverName = \"com.mysql.jdbc.Driver\"; //加载驱动程序 String userName = \"root\"; //数据库信息 String userPasswd = \"root\"; //密码 String dbName = \"test\"; //数据库名 String tableName = \"users\"; //表名 //将数据库信息字符串连接成为一个完整的url（也可以直接写成url，分开写是明了可维护性强） String url=\"jdbc:mysql://localhost/\"+dbName+\"?user=\"+userName+\"&amp;password=\"+userPasswd; Class.forName(\"com.mysql.jdbc.Driver\").newInstance(); Connection conn = DriverManager.getConnection(url); Statement stmt = conn.createStatement(); String sql=\"SELECT * FROM \"+tableName; ResultSet rs = stmt.executeQuery(sql); while(rs.next()) { out.print(rs.getString(1)+\"&lt;br&gt;\"); } rs.close(); stmt.close(); conn.close();%&gt; 查询操作statment.executeQuery(); 用于产生单个结果集的语句，例如 SELECT 语句。最常用。 12345678910111213141516171819&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ page import=\"com.mysql.jdbc.Driver, java.sql.*\" %&gt;&lt;% String url = \"jdbc:mysql://localhost/test?user=root&amp;password=root\"; Class.forName(\"com.mysql.jdbc.Driver\").newInstance(); Connection conn = DriverManager.getConnection(url); Statement stmt = conn.createStatement(); String sql=\"SELECT * FROM users\"; ResultSet rs = stmt.executeQuery(sql); while(rs.next()) { out.print(rs.getString(1)+\"&lt;br&gt;\"); } rs.close(); stmt.close(); conn.close();%&gt; 数据操作statment.executeUpdate(); 用于执行 INSERT、UPDATE 或 DELETE 语句以及 SQL DDL（数据定义语言，例如 CREATE TABLE 和 DROP TABLE）语句。 INSERT、UPDATE 或 DELETE 语句的效果是修改表中零行或多行中的一列或多列，executeUpdate 的返回值是一个整数，指示受影响的行数（即更新计数）。 对于 CREATE TABLE 或 DROP TABLE 等不操作行的语句，executeUpdate 的返回值总为零。 123456789101112131415&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ page import=\"com.mysql.jdbc.Driver, java.sql.*\" %&gt;&lt;% String url=\"jdbc:mysql://localhost/test?user=root&amp;password=root\"; Class.forName(\"com.mysql.jdbc.Driver\").newInstance(); Connection conn=DriverManager.getConnection(url); Statement stmt = conn.createStatement(); String sql=\"INSERT into users (username, id) values ('hhhhhhhh', '111')\"; stmt.executeUpdate(sql); // execute 也行 stmt.close(); conn.close();%&gt; 高级操作statment.execute(); 用于执行返回多个结果集、多个更新计数或二者组合的语句。 execute方法应该仅在语句能返回多个ResultSet对象、多个更新计数或ResultSet对象与更新计数的组合时使用。当执行某个已存储过程或动态执行未知 SQL 字符串（即应用程序程序员在编译时未知）时，有可能出现多个结果的情况，尽管这种情况很少见。 1234567891011121314151617181920212223242526272829303132333435363738&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ page import=\"com.mysql.jdbc.Driver, java.sql.*\" %&gt;&lt;% /* ... code ... */ stmt.execute(queryStringWithUnknownResults); while (true) { int rowCount = stmt.getUpdateCount(); if (rowCount &gt; 0) // 它是更新计数 { System.out.println(\"Rows changed = \" + count); stmt.getMoreResults(); continue; } if (rowCount == 0) // DDL 命令或 0 个更新 { System.out.println(\" No rows changed or statement was DDLcommand\"); stmt.getMoreResults(); continue; } // 执行到这里，证明有一个结果集或没有其它结果 ResultSet rs = stmt.getResultSet; if (rs != null) { while (rs.next()) // 使用元数据获得关于结果集列的信息 { stmt.getMoreResults(); // 处理结果 continue; } break; // 没有其它结果 } }%&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"JSP","slug":"JSP","permalink":"http://blog.iwxyi.com/tags/JSP/"}]},{"title":"PHP设置网站虚拟目录","date":"2018-05-29T08:12:00.000Z","path":"2018/05/29/PHP设置网站虚拟目录/","text":"首先在 Apache 目录下找到 httpd.conf 文件，编辑打开。 （可选）先把默认的路径注释，用 # 注释，默认路径为如下：DocumentRoot “E:/PHPSever/wamp/www/“ 这是我的，因人而异，取决于你的安装目录，让它变成这样即可：#DocumentRoot “E:/PHPSever/wamp/www/“ 添加虚拟目录： 找到： 123&lt;IfModule dir_module&gt; DirectoryIndex index.php index.php3 index.html index.htm&lt;/IfModule&gt; 在这行代码的下面加上： 12345678&lt;IfModule dir_module&gt; DirectoryIndex index.html index.htm index.php Alias /phpworkspace \"F:/phpworkspace\" &lt;Directory f:/phpworkspace&gt; order allow,deny Allow from all &lt;/Directory&gt;&lt;/IfModule&gt; 里面的 F:/phpworkspace 和 f:/phpworkspace 是你要用的虚拟路径 Alias 后面的 / phpworkspace 原则上是自己随便给定，但建议与你的目录下的文件夹名称一致。 这样就把虚拟路径配好了，假设在 phpworkspace 下有 HelloWorld.php 文件，在浏览器中输入：http://localhost/phpworkspace/HelloWorld.php了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.iwxyi.com/tags/PHP/"}]},{"title":"JSP数据库封装用法","date":"2018-05-28T07:22:00.000Z","path":"2018/05/28/JSP数据库封装用法/","text":"声明声明数据库的 Javabean &lt;jsp:useBean id=\"sqlM\" class=\"wxy.jsp.mysql.sqlBean\" scope=\"session\" /&gt; 安全检查检查用户名密码，如果包含特殊字符则触发 if 里面的内容MSG 为占位变量，放到 HTML 里，弹出警告信息 1234if (sqlM.SafeCheck(username) == false || sqlM.SafeCheck(password) == false){ MSG = \"alert('非法账号/密码输入');\";} 初始化设置账号密码，连接数据库 123init(); // 使用默认的数据库、账号、密码来登录init(String dburl, String db_user, String db_passwd); // 使用自己的信息 查询使用函数 ResultSet sqlM.executeQuery(String) 获取查询的返回值 只要不出错，rs 就不为 null，rs.next() 判断有没有下一行，第一次用的话就是判断有没有数据 123String sql = \"SELECT username from users where username = '\" + username + \"' and password = '\" + password + \"'\";ResultSet rs = sqlM.executeQuery(sql);if (rs != null &amp;&amp; rs.next() == true &amp;&amp; username.equals(rs.getString(1))) { } // 数据存在 一次性查询：ResultSet executeQ(String sql) 自动连接数据库、自动关闭。不过由于 Java 的特性，无法保留返回值，等同于废了。 更新使用函数 int sqlM.executeUpdate(sql) 来进行插入、更新、删除操作，返回修改的行数 使用函数 int sqlM.executeU(sql) 来进行插入、更新、删除的一次性操作。只需要声明一下 javabean，不需要初始化、用完也不需要关掉，直接使用这个函数，会自动做好一切。 示例：向数据库插入用户名、密码 12String sql=\"INSERT into users (username, password) values ('\" + username + \"', '\" + password+\" + \"')\";sqlM.executeU(sql); 关闭如果不是使用那个一次性的函数（sqlM.executeU），用完则需要关掉。 根据不同的生命周期，来决定到底要不要关。 1sqlM.close(); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"JSP","slug":"JSP","permalink":"http://blog.iwxyi.com/tags/JSP/"}]},{"title":"JSP数据库封装","date":"2018-05-28T07:20:00.000Z","path":"2018/05/28/JSP数据库封装/","text":"简单实用的数据库相关方法封装后的工具 编辑时间：2018.05.17 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196package wxy.jsp.mysql;import java.sql.*;import java.lang.String;public class sqlBean{ Connection conn; Statement stmt; ResultSet rs; public sqlBean() { // init(); } public void init(String dburl, String db_user, String db_passwd) { try { Class.forName(\"com.mysql.jdbc.Driver\").newInstance(); conn = DriverManager.getConnection(dburl, db_user, db_passwd); } catch(IllegalAccessException iae) { System.err.println(\"Load Driver Error: \" + iae.getMessage()); } catch(InstantiationException ie) { System.err.println(\"Load Driver Error: \" + ie.getMessage()); } catch(java.lang.ClassNotFoundException e) { System.err.println(\"Load Driver Error: \" + e.getMessage()); } catch(SQLException ex) { System.err.println(\"Get Connection Error: \" + ex.getMessage()); } } public void init() { try { String url = \"jdbc:mysql://localhost/novel?user=root&amp;password=root\"; Class.forName(\"com.mysql.jdbc.Driver\").newInstance(); conn = DriverManager.getConnection(url); } catch(IllegalAccessException iae) { System.err.println(\"Load Driver Error: \" + iae.getMessage()); } catch(InstantiationException ie) { System.err.println(\"Load Driver Error: \" + ie.getMessage()); } catch(java.lang.ClassNotFoundException e) { System.err.println(\"Load Driver Error: \" + e.getMessage()); } catch(SQLException ex) { System.err.println(\"Get Connection Error: \" + ex.getMessage()); } } public ResultSet executeQuery(String sql) { if (conn == null) init(); try { if (stmt == null) stmt = conn.createStatement(); rs = stmt.executeQuery(sql); } catch(SQLException ex) { System.err.println(\"SQL Error: \" + ex.getMessage()); } return rs; } public void executeUpdate(String sql) { if (conn == null) init(); try { if (stmt == null) stmt = conn.createStatement(); stmt.executeUpdate(sql); } catch(SQLException ex) { System.err.println(\"SQL Error: \" + ex.getMessage()); } } public int executeU(String sql) { try { String url = \"jdbc:mysql://localhost/novel?user=root&amp;password=root\"; Class.forName(\"com.mysql.jdbc.Driver\").newInstance(); Connection conn = DriverManager.getConnection(url); Statement stmt = conn.createStatement(); stmt.executeUpdate(sql); stmt.close(); conn.close(); } catch(IllegalAccessException iae) { System.err.println(\"Load Driver Error: \" + iae.getMessage()); } catch(InstantiationException ie) { System.err.println(\"Load Driver Error: \" + ie.getMessage()); } catch(java.lang.ClassNotFoundException e) { System.err.println(\"Load Driver Error: \" + e.getMessage()); } catch (SQLException ex) { System.err.println(\"SQL Error: \" + ex.getMessage()); } return 0; } public ResultSet executeQ(String sql) { try { String url = \"jdbc:mysql://localhost/novel?user=root&amp;password=root\"; Class.forName(\"com.mysql.jdbc.Driver\").newInstance(); Connection conn = DriverManager.getConnection(url); Statement stmt = conn.createStatement(); ResultSet rs = stmt.executeQuery(sql); stmt.close(); conn.close(); return rs; } catch(IllegalAccessException iae) { System.err.println(\"Load Driver Error: \" + iae.getMessage()); } catch(InstantiationException ie) { System.err.println(\"Load Driver Error: \" + ie.getMessage()); } catch(java.lang.ClassNotFoundException e) { System.err.println(\"Load Driver Error: \" + e.getMessage()); } catch (SQLException ex) { System.err.println(\"SQL Error: \" + ex.getMessage()); } return rs; } public void close() throws SQLException { stmt.close(); conn.close(); } public static boolean SafeCheck(String str) { str += \" \"; String inj_str = \"'|and|exec|insert|select|delete|update|count|*|%|chr|mid|master|truncate|char|declare|;|or|-|+|,\"; String inj_stra[] = inj_str.split(\"|\"); for (int i = 0 ; i &lt; inj_stra.length ; i++ ) { if (str.indexOf(inj_stra[i]) &gt; 0) { return false; } } return true; }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"模板","slug":"模板","permalink":"http://blog.iwxyi.com/tags/模板/"},{"name":"JSP","slug":"JSP","permalink":"http://blog.iwxyi.com/tags/JSP/"}]},{"title":"HTML解决英文段落不换行","date":"2018-05-28T05:09:00.000Z","path":"2018/05/28/HTML解决英文段落不换行/","text":"加上这2个属性其中之一，就可以实现换行了。 word-break : break-all; 只对英文起作用，以字母作为换行依据 word-wrap : break-word; 只对英文起作用，以单词作为换行依据 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"HTML","slug":"HTML","permalink":"http://blog.iwxyi.com/tags/HTML/"}]},{"title":"Android延迟操作","date":"2018-05-20T12:11:00.000Z","path":"2018/05/20/Android延迟操作/","text":"延迟3秒切换窗口（闪屏） 1234567new Handler().postDelayed(new Runnable() { public void run() { Intent mainIntent = new Intent(LoadActivity.this, MainActivity.class); LoadActivity.this.startActivity(mainIntent); LoadActivity.this.finish(); }}, 3000); // 3 秒 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"嵌套循环优化","date":"2018-05-20T11:50:00.000Z","path":"2018/05/20/嵌套循环优化/","text":"题目请对以下的代码进行优化： 1234for (int i = 0; i &lt; 1000; i++) for (int j = 0; j &lt; 100; j++) for (int k = 0; k &lt; 10; k++) testFunction (i, j, k); 分析从给出的代码可知，不论如何优化，testFunction执行的次数都是相同的，该部分不存在优化的可能。那么，代码的优化只能从循环变量i、j、k的实例化、初始化、比较、自增等方面的耗时上进行分析。 首先，我们先分析原题代码循环变量在实例化、初始化、比较、自增等方面的耗时情况： 变量 实例化(次数) 初始化(次数) 比较(次数) 自增(次数) i 1 1 1000 1000 j 1000 1000 1000 * 100 1000 * 100 k 1000 * 100 1000 * 100 1000 * 100 * 10 1000 * 100 * 10 该代码的性能优化就是尽可能减少循环变量i、j、k的实例化、初始化、比较、自增的次数，同时，不能引进其它可能的运算耗时。 方案1234for (int i = 0; i &lt; 10; i++) for (int j = 0; j &lt; 100; j++) for (int k = 0; k &lt; 1000; k++) testFunction (k, j, i); 该方案主要是将循环次数最少的放到外面，循环次数最多的放里面，这样可以最大程度的（注：3个不同次数的循环变量共有6种排列组合情况，此种组合为最优）减少相关循环变量的实例化次数、初始化次数、比较次数、自增次数，方案耗时情况如下： 变量 实例化(次数) 初始化(次数) 比较(次数) 自增(次数) i 1 1 10 10 j 10 10 10 * 100 10 * 100 k 10 * 100 10 * 100 10 * 100 * 1000 10 * 100 * 1000 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C语言","slug":"C语言","permalink":"http://blog.iwxyi.com/tags/C语言/"},{"name":"优化","slug":"优化","permalink":"http://blog.iwxyi.com/tags/优化/"}]},{"title":"PHP双引号内字符串用法","date":"2018-05-19T08:16:00.000Z","path":"2018/05/19/PHP双引号内字符串用法/","text":"普通变量123&lt;?php$b = 5;echo \"fdsfdsf$b\\n\"; 1fdsfdsf5 数组用法12345678910&lt;?php// 数组用法$ary = array('a'=&gt;1, 2=&gt;3);// 直接用echo \"fdsfdsf$ary[a]\\n\"; // 字符串不用加引号echo \"fdsfdsf$ary[1]\\n\";// 花括号包起来echo \"fdsfdsf{$ary['a']}\"; 123fdsfdsf1fdsfdsf3fdsfdsf1 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.iwxyi.com/tags/PHP/"}]},{"title":"PHP数据库事务","date":"2018-05-17T08:25:00.000Z","path":"2018/05/17/PHP数据库事务/","text":"连接数据库： 123$LinkID =mysql_connect('localhost:3307','root',*******);mysql_select_db('web_his',$LinkID);mysql_query(\"set names utf8\"); 使用事务： 123456789101112131415161718192021/* 创建事务 */mysql_query('START TRANSACTION') or exit(mysql_error());$ssql1=\"insert into pf_item values('22','我们','30')\"; //执行sql 1if(!mysql_query($ssql1)){ echo $ssql1.mysql_errno().\":\".mysql_error().\"&lt;br&gt;\"; mysql_query('ROLLBACK') or exit(mysql_error());//判断当执行失败时回滚 exit;}$ssql1=\"insert into pf_item values('21','hell','10')\"; //执行sql 2if(!mysql_query($ssql1)){ echo $ssql1.mysql_errno().\":\".mysql_error().\"&lt;br&gt;\"; mysql_query('ROLLBACK') or exit(mysql_error());//判断当执行失败时回滚 exit;}mysql_query('COMMIT') or exit(mysql_error());//执行事务mysql_close($LinkID); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PHP","slug":"PHP","permalink":"http://blog.iwxyi.com/tags/PHP/"},{"name":"MySQL","slug":"MySQL","permalink":"http://blog.iwxyi.com/tags/MySQL/"}]},{"title":"Android SharedPreferences 存取 JavaBean 或 List Bean","date":"2018-05-17T02:55:00.000Z","path":"2018/05/17/Android-SharedPreferences-存取-JavaBean-或-List-Bean/","text":"1. 存储单个JavaBean12345678910SharedPreferences sp = getSharedPreferences(\"SP_PEOPLE\",Activity.MODE_PRIVATE);//创建sp对象,如果有key为\"SP_PEOPLE\"的sp就取出，否则就创建一个此key的sp对象People people= new People() ;//创建javabean对象people.setId(1); people.setName(\"小邵\");Gson gson = new Gson(); String jsonStr=gson.toJson(people); //将对象转换成Jsoneditor = sp.edit() ;editor.putString(\"KEY_PEOPLE_DATA\", jsonStr) ; //存入json串editor.commit() ; //提交ShowDialog(\"您已经保存成功\"); 2. 存储JavBean的List集合1234567891011121314151617SharedPreferences sp = getSharedPreferences(\"SP_PEOPLE_List\",Activity.MODE_PRIVATE);//创建sp对象List&lt;People&gt; peopleList = new ArrayList&lt;People&gt;() ; //创建List集合对象People people1= new People() ;//创建javabean对象people1.setId(1); people1.setName(\"小邵\"); People people2= new People() ;//创建javabean对象people2.setId(2); people2.setName(\"小林\"); peopleList.add(people1);peopleList.add(people2);Gson gson = new Gson(); String jsonStr=gson.toJson(peopleList); //将List转换成JsonSharedPreferences.Editor editor = sp.edit() ;editor.putString(\"KEY_PEOPLE_LIST_DATA\", jsonStr) ; //存入json串editor.commit() ; //提交ShowDialog(\"您已经保存成功\"); 3. 从SP中查询一个JavaBean1234567SharedPreferences sp = getSharedPreferences(\"SP_PEOPLE\",Activity.MODE_PRIVATE);//创建sp对象,如果有key为\"SP_PEOPLE\"的sp就取出peopleJson = sp.getString(\"KEY_PEOPLE_DATA\",\"\"); //取出key为\"KEY_PEOPLE_DATA\"的值，如果值为空，则将第二个参数作为默认值赋值if(peopleJson!=\"\") //防空判断{Gson gson = new Gson(); People people = gson.fromJson(peopleJson, People.class); //将json字符串转换成 people对象} 4. 从SP中查询javaBean集合1234567SharedPreferences sp = getSharedPreferences(\"SP_PEOPLE_LIST\",Activity.MODE_PRIVATE);//创建sp对象,如果有key为\"SP_PEOPLE\"的sp就取出peopleListJson = sp.getString(\"KEY_PEOPLE_LIST_DATA\",\"\"); //取出key为\"KEY_PEOPLE_DATA\"的值，如果值为空，则将第二个参数作为默认值赋值if(peopleJson!=\"\") //防空判断{Gson gson = new Gson(); List&lt;People&gt; peopleList = gson.fromJson(peopleListJson, new TypeToken&lt;List&lt;People&gt;&gt;() {}.getType()); //将json字符串转换成List集合} 5. 删除一个JavaBean直接把sp干掉。 12345SharedPreferences sp = getSharedPreferences(\"SP_PEOPLE\",Activity.MODE_PRIVATE);//创建sp对象,如果有key为\"SP_PEOPLE\"的sp就取出peopleJson = sp.getString(\"KEY_PEOPLE_DATA\",\"\"); SharedPreferences.Editor editor = sp.edit() ;editor.clear();editor.commit(); 6. 删除List中的某个javaBean1.先取，2.转换成List，3.从List中删掉，4.转换成新List,5.存入新json串将原先的替换掉。 1234567891011121314SharedPreferences sp = getSharedPreferences(\"SP_PEOPLE_LIST\",Activity.MODE_PRIVATE);peopleListJson = sp.getString(\"KEY_PEOPLE_LIST_DATA\",\"\"); if(peopleJson!=\"\") //防空判断{Gson gson = new Gson(); List&lt;People&gt; peopleList = gson.fromJson(peopleListJson, new TypeToken&lt;List&lt;People&gt;&gt;() {}.getType()); //1.2\\. 取出并转换成ListpeopleList.remove(position) ; //3.移除第position个的javabeanString jsonStr=gson.toJson(peopleList); //4.将删除完的List转换成JsonSharedPreferences.Editor editor = sp.edit() ;editor.putString(\"KEY_PEOPLE_LIST_DATA\", jsonStr) ; //存入json串editor.commit() ; //提交} 7. 更新先取，将要改变的bean更新了 ，转换成List，存入新json串将原先的替换掉。 1234567891011121314SharedPreferences sp = getSharedPreferences(\"SP_PEOPLE_LIST\",Activity.MODE_PRIVATE);peopleListJson = sp.getString(\"KEY_PEOPLE_LIST_DATA\",\"\"); if(peopleJson!=\"\") //防空判断{Gson gson = new Gson(); List&lt;People&gt; peopleList = gson.fromJson(peopleListJson, new TypeToken&lt;List&lt;People&gt;&gt;() {}.getType()); //取出**// 省略的操作：取出，更新bean的操作，添加到List,将新List转换成json**SharedPreferences.Editor editor = sp.edit() ;editor.putString(\"KEY_PEOPLE_LIST_DATA\", jsonStr) ; //存入json串editor.commit() ; //提交} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"JSP使用JavaBean","date":"2018-05-16T07:18:00.000Z","path":"2018/05/16/JSP使用JavaBean/","text":"SimpleBean.java123456789101112package wxy;public class SimpleBean{ private String message; public SimpleBean() { ; } public void setMessage(String mess) { message = mess; } public String getMessage(){ return message; }} 用合适版本的javac（否则会报错）放到 网站根目录/WEB-INF/class/包路径/ 下 JavaBean.jsp123456&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ page import=\"wxy.*\" %&gt;&lt;jsp:useBean id=\"t1\" scope=\"session\" class=\"wxy.SimpleBean\" /&gt;&lt;jsp:setProperty name=\"t1\" property=\"message\" value=\"hhh\" /&gt;&lt;jsp:getProperty name=\"t1\" property=\"message\" /&gt; 修改 class 文件，需要重启Tomcat document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"JSP","slug":"JSP","permalink":"http://blog.iwxyi.com/tags/JSP/"}]},{"title":"Android users-permission与permission的区别","date":"2018-05-15T03:26:00.000Z","path":"2018/05/15/Android-users-permission与permission的区别/","text":"&lt;uses-permission android:name=\"android.permission.CALL_PHONE\" /&gt;官方权限，会显示在应用权限那里是调用别人的东西自己需要声明的权限与 application 节点同级 &lt;permission android:name=\"android.permission.CALL_PHONE\" /&gt;可以供其他应用使用本应用的说明在 application 节点里面 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Android Intent拨号","date":"2018-05-15T02:45:00.000Z","path":"2018/05/15/Android-Intent拨号/","text":"Intent 拨号权限：&lt;uses-permission android:name=\"android.permission.CALL_PHONE\" 1234567891011121314151617public void gotoCall(View v){ EditText et = findViewById(R.id.phone); String num = et.getText().toString(); if (num.equals(\"\")) Toast.makeText(this, \"no num\", Toast.LENGTH_SHORT).show(); else startCall(num);}public void startCall(String num){ Intent intent = new Intent(); intent.setAction(Intent.ACTION_CALL); intent.setData(Uri.parse(\"tel:\" + num)); startActivity(intent);} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"MFC常用控件","date":"2018-05-15T02:10:00.000Z","path":"2018/05/15/MFC常用控件/","text":"静态文本框1m_stext.SetWindowTextW(TEXT(\"Hello\")); 编辑框基本函数123456m_Edit1.SetSel(0,-1); //表示选中编辑框IDC_EDIT1中的全部内容。m_Edit1.ReplaceSel(\"\"); //用空字符串代替所选中的文本，即把所选的文本删除掉m_Edit1.Copy(); //将m_Editl编辑框中所选的内容拷贝到剪贴板上m_Edit2.Paste(); //将剪贴板中的内容粘贴到m_Edit2编辑框中m_Edit1.Undo(); // Undo（）函数是CEdit类中的成员函数，表示取消编辑框中上一次操作m_Edit1.GetWindowText(str, 10); // 将内容放到字符串上，参数2是长度（包括\\0） 数值与控件转换IDC_EDIT1 绑定 int 变量 m_A 123456UpdateData(TRUE); // 刷新成数值int i=m_A*m_B;m_Result.Format(\"%d\", i);UpdateData(FALSE); // 刷新回控件 图像框12 组框 Group Box12 按钮按下按钮 1m_btn1.SetWindowText(\"你已按下了按钮！\"); 复选框1234if(m_chk1.GetCheck()&gt;0) m_chk1.SetCheck(0); else m_chk1.SetCheck(1); 单选框按下单选框1m_rad1.SetCheck(1); 初始化选中给一组单选按钮中的一个指定按钮加上选中标志，并且清除组中其他按钮的选中标志。 1BOOL CheckRadioButton([HWND hDlg,] int nlDFirstButton, int nlDLastBUtton, int nlDCheckButton) 获取状态12345int iSexRADIO = GetCheckedRadioButton(IDC_BOY_RADIO, IDC_GIRL_RADIO); // 参数是第一个和最后一个if (iSexRADIO == IDC_BOY_RADIO) ;else ; 组合框初始化时添加下拉列表框项目1m_cb.AddString(\"Monday\"); // 添加项目 初始化时选中字符串SelectString：搜索在组合框的列表框中的字符串，如果找到该字符串，选择列表框和复制的字符串到编辑控件。 1m_Combo.SelectString(-1, \"a\"); // 参数1：从0开始的索引，-1为全部；参数2：搜索词，区分大小写 获取并弹出选中项目123CString msg;m_cb.GetLBText(m_cb.GetCurSel(), msg);AfxMessageBox(msg); 列表框12 水平滚动条12 垂直滚动条12 旋转 Spin滑块的滚动事件在对话框的事件里，与其他控件不同。为什么？它就是这样设计的。 初始化 12CSpinButtonCtrl* pSpin =(CSpinButtonCtrl*) GetDlgItem(IDC_SPIN1);pSpin-&gt;SetRange(0, 100); 滚动事件 12345678910void CTestDlg::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) { if (pScrollBar-&gt;GetDlgCtrlID() == IDC_SPIN1) { CString strValue; strValue.Format(\"%3.1f\", (double) nPos / 10.0); // 共3位，小数点后1位 ( (CSpinButtonCtrl*) pScrollBar )-&gt;GetBuddy()-&gt;SetWindowText(strValue); } CDialog::OnVScroll(nSBCode, nPos, pScrollBar);} 进度条 Progress1234CProgressCtrl* pProg = (CProgressCtrl*) GetDlgItem(IDC_PROGRESS1);pSlide1-&gt;SetRange(0, 100); // 范围pProg-&gt;SetPos(0); // 进度=0pProg-&gt;SetPos( pProg-&gt;GetPos()+1 ); // 获取进度并+1 滑块滑块事件也是在对话框滚动事件里面。 12345678910void CTestDlg::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) { if(pScrollBar-&gt;GetDlgCtrlID() == IDC_SLIDER1) { CSliderCtrl* pSlide = (CSliderCtrl*) pScrollBar; CString strText; strText.Format(\"%d\", pSlide-&gt;GetPos()); SetDlgItemText(IDC_STATIC_SLIDER, strText); // 滑块位置显示到编辑框里 }} 热键12 列表控件初始化 123456789101112131415static char * color[] = {\"white\",\"black\",\"red\",\"blue\",\"yellow\",\"cyan\",\"purple\",\"green\"};HICON hIcon[8];int n;m_imageList.Create(16,16,0,8,8); hIcon[0] = AfxGetApp()-&gt;LoadIcon(IDI_ICON_WHITE);hIcon[1] = ...略...for (n=0;n&lt;8;n++) m_imageList.Add(hIcon[n]);CListCtrl* pList = (CListCtrl*) GetDlgItem(IDC_LIST1); // 获得控件对象pList-&gt;SetImageList(&amp;m_imageList, LVSIL_SMALL); // 设置小图标图片列表for (n = 0; n &lt; 8; n++) pList-&gt;InsertItem(n, color[n], n); // 第一个参数为项id，第二个为标签文字，第三个为对应图片列表idpList-&gt;SetBkColor(RGB(0, 255, 255)); // 设置背景色pList-&gt;SetTextBkColor(RGB(255, 0, 255)); //设置文字的背景色 事件 12345678910111213141516171819202122232425262728293031323334353637void CTestDlg::OnItemchangedList1(NMHDR* pNMHDR, LRESULT* pResult) // 选中，修改用来显示的标签{ NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR; CListCtrl* pList = (CListCtrl*) GetDlgItem(IDC_LIST1); int nSelected = pNMListView-&gt;iItem; if (nSelected &gt;= 0) { CString strItem = pList-&gt;GetItemText(nSelected, 0); SetDlgItemText(IDC_STATIC_LIST, strItem); } *pResult = 0;}void CTestDlg::OnRclickList1(NMHDR* pNMHDR, LRESULT* pResult) // 右键修改成输入文本{ NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR; CListCtrl* pList = (CListCtrl*) GetDlgItem(IDC_LIST1); int nSelected = pNMListView-&gt;iItem; if (nSelected &gt;= 0) pList-&gt;EditLabel(nSelected); *pResult = 0;}void CTestDlg::OnEndlabeleditList1(NMHDR* pNMHDR, LRESULT* pResult) // 选中后并单击编辑{ LV_DISPINFO* pDispInfo = (LV_DISPINFO*)pNMHDR; LVITEMA item = pDispInfo-&gt;item; CString str =item.pszText; str.TrimLeft(); str.TrimRight(); if(str.GetLength() &gt; 0) { CListCtrl* pList = (CListCtrl*) GetDlgItem(IDC_LIST1); pList-&gt;SetItemText(item.iItem, item.iSubItem, item.pszText); } *pResult = 0;} 树状控件1234567891011121314151617181920212223242526272829303132333435363738394041424344CTreeCtrl* pTree = (CTreeCtrl*) GetDlgItem(IDC_TREE1);pTree-&gt;SetImageList(&amp;m_imageList, TVSIL_NORMAL); // 设置图片列表TV_INSERTSTRUCT tvinsert; // 创建待插入的TV_INSERTSTRUCT结构tvinsert.hParent = NULL; // 无父结点tvinsert.hInsertAfter = TVI_LAST; // 插入到本层最后tvinsert.item.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE| TVIF_TEXT; // 掩码包括 图标 选中图标 文字tvinsert.item.hItem = NULL; // 句柄为空tvinsert.item.state = 0; // 状态tvinsert.item.stateMask = 0; // 状态掩码，不使用这两项tvinsert.item.cchTextMax = 6; // 最大文字长度，忽略tvinsert.item.iSelectedImage = 1; // 选中图标索引tvinsert.item.cChildren = 0; // 没有子节点tvinsert.item.lParam = 0; // 自定义数据// 第一层tvinsert.item.iImage = 2; // 一般图标tvinsert.item.pszText = \"father\"; // 插入第一层第一个节点\"father\"HTREEITEM hDad = pTree -&gt;InsertItem(&amp;tvinsert);tvinsert.item.pszText = \"mother\"; // 插入第一层第二个节点\"mother\"HTREEITEM hMom = pTree-&gt;InsertItem(&amp;tvinsert);// 创建第二层tvinsert.hParent = hDad; // 父节点为\"father\"tvinsert.item.iImage = 3; // 一般图标tvinsert.item.pszText = \"son\"; // 插入第二层\"father\"的第一个节点\"son\"pTree-&gt;InsertItem(&amp;tvinsert);tvinsert.item.pszText = \"daughter\"; // 插入第二层\"father\"的第二个节点\"daughter\"pTree-&gt;InsertItem(&amp;tvinsert);// 还是创建第二层，但是父节点变成 Momtvinsert.hParent = hMom; // 父结点为\"mother\"tvinsert.item.iImage = 4;tvinsert.item.pszText = \"cartoon\"; // 插入第二层\"mother\"的节点\"cartoon\"HTREEITEM hOther = pTree-&gt;InsertItem(&amp;tvinsert);// 创建第三层tvinsert.hParent = hOther; // 连续不断地创建 事件 1234567891011121314151617181920212223242526272829303132void CTestDlg::OnSelchangedTree1(NMHDR* pNMHDR, LRESULT* pResult) // 被选中，修改选中项的图标{ NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR; CTreeCtrl* pTree = (CTreeCtrl*) GetDlgItem(IDC_TREE1); HTREEITEM hSelected = pNMTreeView-&gt;itemNew.hItem; if (hSelected != NULL) { char text[31]; TV_ITEM item; item.mask = TVIF_HANDLE | TVIF_TEXT; item.hItem = hSelected; item.pszText = text; item.cchTextMax = 30; VERIFY(pTree-&gt;GetItem(&amp;item)); SetDlgItemText(IDC_STATIC_TREE, text); } *pResult = 0;}void CTestDlg::OnEndlabeleditTree1(NMHDR* pNMHDR, LRESULT* pResult) // 选中后并单击编辑{ TV_DISPINFO* pTVDispInfo = (TV_DISPINFO*)pNMHDR; TVITEMA item = pTVDispInfo-&gt;item; CString str =item.pszText; str.TrimLeft(); str.TrimRight(); if(str.GetLength() &gt; 0) { CTreeCtrl* pTree = (CTreeCtrl*) GetDlgItem(IDC_TREE1); pTree-&gt;SetItemText(item.hItem,item.pszText); } *pResult = 0;} Tab控件12 动画12 富文本 Rich Edit12 月历12 日期时间选择器12345678CDateTimeCtrl* pDT =(CDateTimeCtrl*) GetDlgItem(IDC_DATETIMEPICKER1);CString formatStr= _T(\"'今天是: 'yy'/'MM'/'dd\");pDT-&gt;SetFormat(formatStr); // 设置控件内容的格式CTime t;pDT-&gt;GetTime(t);CString s = t.Format( \"%A, %B %d, %Y %H:%M:%S\" );AfxMessageBox(s); IP地址12 自定义控件12 扩展组合框12 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"MFC","slug":"MFC","permalink":"http://blog.iwxyi.com/tags/MFC/"}]},{"title":"VC++复制控件","date":"2018-05-15T01:35:00.000Z","path":"2018/05/15/VC-复制控件/","text":"vc中如何拷贝一个工程的对话框资源到另一个工程中? 方法一：在你的工程中添加另一个工程的rc文件，这时资源视图中就会出现两个rc,从后加的rc中拷贝资源到你自己工程的rc中就可以了。 在VC6环境下，选择Class视图，选中想要克隆的对话框所对应的类，例如CAboutDlg，点击鼠标右键，选择Add to gallery。在新工程中选择Project菜单，选择Add Component and ActivX，你会看到多了一个文件夹（与上一个工程同名），进入该文件夹，选择*.ogx。选择Insert，你会发现原来的对话框被加入到新的工程中了！ 补充： .net下更简单，将原来的工程加到新的工程中，直接将对话框拷贝过去就行了！ VC++中如何复制对话框资源 第一步：用记事本打开原工程的.rc文件，找到想复制的对话框的信息，如下所示 123456789101112131415161718192021222324252627IDD_UGMS_DIALOGDIALOGEX 0, 0, 320, 230STYLE WS_CHILD | WS_VISIBLEEXSTYLE WS_EX_APPWINDOWFONT 9, \"宋体\"BEGIN GROUPBOX \"学生信息\",IDC_STATIC,10,8,290,200 GROUPBOX \"\",IDC_STATIC,25,55,205,120 PUSHBUTTON \"最前(&amp;F)\",IDC_BUTTON_FIRST,30,30,35,15 PUSHBUTTON \"向前(&amp;B)\",IDC_BUTTON_PRE,82,30,35,15 PUSHBUTTON \"向后(&amp;N)\",IDC_BUTTON_NEXT,134,30,35,15 PUSHBUTTON \"最后(&amp;L)\",IDC_BUTTON_LAST,186,30,35,15 PUSHBUTTON \"查询(&amp;Q)\",IDC_BUTTON_QUERY,246,70,40,15 PUSHBUTTON \"增加(&amp;A)\",IDC_BUTTON_ADD,246,96,40,15 PUSHBUTTON \"修改(&amp;M)\",IDC_BUTTON_MODIFY,246,122,40,15 PUSHBUTTON \"删除(&amp;D)\",IDC_BUTTON_DELETE,246,148,40,15 PUSHBUTTON \"确定(&amp;O)\",IDC_BUTTON_OK,58,183,40,15 PUSHBUTTON \"取消(&amp;C)\",IDC_BUTTON_CANCEL,150,183,40,15 LTEXT \"学号：\",IDC_STATIC,52,75,25,8 LTEXT \"姓名：\",IDC_STATIC,52,100,25,8 LTEXT \"性别：\",IDC_STATIC,52,125,25,8 LTEXT \"入学时间：\",IDC_STATIC,44,151,41,8 EDITTEXT IDC_EDIT_SID,91,72,95,15,ES_AUTOHSCROLL EDITTEXT IDC_EDIT_SNAME,91,96,95,15,ES_AUTOHSCROLL EDITTEXT IDC_EDIT_SSEX,91,120,95,15,ES_AUTOHSCROLL CONTROL \"DateTimePicker1\",IDC_DATETIMEPICKER_SCOMEDATE, \"SysDateTimePick32\",DTS_RIGHTALIGN | WS_TABSTOP,91,144, 95,15 GROUPBOX \"\",IDC_STATIC,25,19,205,35END 上面代码中绿色背景代表的是要复制的对话框资源的ID，此段代码也就是.rc文件中记录的此对话框的信息，黄色背景中间的代码就是 相应对话框中添加的控件信息，只需将相应代码拷到新工程的相应.rc文件相应的ID对话框资源的BEGIN 和END之间即可； 第二步：打开原工程的FileView视图下的Header Files 下的resource.h文件，将其中相应ID的信息复制到新工程的resource.h中即可； 例如： 123456789101112131415//复制的资源ID#define IDC_BUTTON_FIRST 1000#define IDC_BUTTON_PRE 1001#define IDC_BUTTON_NEXT 1002#define IDC_BUTTON_LAST 1003#define IDC_BUTTON_QUERY 1004#define IDC_BUTTON_ADD 1005#define IDC_BUTTON_MODIFY 1006#define IDC_BUTTON_DELETE 1007#define IDC_BUTTON_OK 1008#define IDC_BUTTON_CANCEL 1009#define IDC_EDIT_SID 1010#define IDC_EDIT_SNAME 1011#define IDC_EDIT_SSEX 1012#define IDC_DATETIMEPICKER_SCOMEDATE 1013 第三步：记得不要遗漏啊，如有ID重复，可以更改一下即可！ 法4： 今天碰到模块移植问题了,自己做的对话框类(继承于CDialog)要移植到目标工程中.在网上搜了几个帖子发现都说的很生涩.问了我们的技术总监之后总算解决这个问题了. 问题:把一个MFC SDI工程中的一个对话框资源和类拷贝到另一个MFC SDI中. 1.在VC6中打开老的工程,在工作区Resource标签页中选中Dialog文件夹下的资源文件(就是双击后会出现编辑窗口界面的那个东西),按Ctrl+C(Edit-&gt;Copy也一样). 2.关闭当前工程,注意不要关闭VC6,打开目标工程(File-&gt;OpenWorkspace),然后选中工作区的Resource标签页中的Dialog文件夹,然后按Ctrl+V(Edit-&gt;Paste也一样).好了,对话框拷贝过来了. 3.将对话框类的cpp h文件拷贝到目标工程中(不详细说了,往当前工程添加文件) 4.打开复制过来的类cpp和h文件,删除没用的头文件(老工程相关的),并且在.h文件中添加文件包含 #include “Resource.h” 第四步很关键,老工程中根本就没有这个文件包含,可是移植之后必须手动添加头文件包含.因为这个问题卡了10几分钟… 当你用资源ID时（通常资源编辑器编辑的资源ID都在resource.h中），如果没有包含CWinApp的派生类所在的头文件就会出错，你看一下它的头文件里，包含了这个文件， 而向导生成的类，它的实现文件都有包含CWinApp派生类所在的头文件的 然后在新工程中就可以使用这个类了,主要就是这个类的对话框中的资源复制头一次遇到.不敢独享,拿出来跟新手们一起学习. 于是，当有已经创建好的对话框资源要添加到新工程中时： （1）右键单击新工程所在的解决方案添加“现有项目”把旧工程添加进来； （2）切换到“资源视图”并在旧工程对话框资源上右键“复制”； （3）在新工程对话框资源上右键“粘贴”； （4）现在就可以为新对话框添加类了，顺便把旧工程的响应函数拷贝过来； （5）切换回“解决方案资源管理器”，右键旧工程“移除”。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"VC++","slug":"VC","permalink":"http://blog.iwxyi.com/tags/VC/"}]},{"title":"VC++动态链接库DLL","date":"2018-05-15T01:32:00.000Z","path":"2018/05/15/VC-动态链接库DLL/","text":"隐式链接 用特殊声明 _declspec(dllexport) 定义一个导出函数 1234567891011#include \"stdafx.h\"_declspec(dllexport) long square (long x) // 导出标记{ return x * x;}BOOL APIENTRY DllMain(HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved){ return TRUE;} 编译、链接, 生成.Dll文件和.Lib文件，并拷贝到客户端目录 工程设置里，exe 关联 .Lib 文件 注：是源文件所在目录，而不是Debug文件夹 使用特殊声明 _declspec(dllimport) 声明导出函数并调用 12345678910111213#include \"stdafx.h\"#include &lt;iostream&gt;using namespace std;_declspec(dllimport) long square(long x); // 导入标记int main(int argc, char* argv[]){ int x; cin &gt;&gt; x; cout &lt;&lt; square(x) &lt;&lt; endl; return 0;} 显示链接 定义一个函数：bool __stdcall square(long x); 1234567891011#include \"stdafx.h\"long _stdcall square (long x){ return x * x;}BOOL APIENTRY DllMain(HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved){ return TRUE;} 通过 .def 文件导出函数并防止函数名被修饰。 12345LIBRARY \"dll1\"EXPORTS square @1 ;函数 [@序号] dll 文件放在 exe 运行目录下（例如：Debug） 通过3个API函数直接调用.DLL中的导出函数。 HMODULE LoadLibrary(LPCTSTR lpFileName); // 获取 dll 句柄 FARPROC GetProcAddress(HMODULE hModule, LPSCTR lpProcName); // 加载 dll 函数 BOOL FreeLibrary(HMODULE hModule); // 释放 dll 空间 1234567891011121314151617181920212223242526272829303132#include \"stdafx.h\"#include &lt;iostream&gt;#include &lt;windows.h&gt;using namespace std;typedef long (_stdcall * LF) (long);int main(int argc, char* argv[]){ HMODULE hModule = LoadLibrary(\"dll1\"); if (!hModule) { cout &lt;&lt; \"NONE HMODULE\" &lt;&lt; endl; return -1; } LF lf = (LF) GetProcAddress(hModule, \"square\"); if (!lf) { cout &lt;&lt; \"NONE FUNCTION\" &lt;&lt; endl; return -1; } int x; cin &gt;&gt; x; cout &lt;&lt; lf(x) &lt;&lt; endl; FreeLibrary(hModule); return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"VC++","slug":"VC","permalink":"http://blog.iwxyi.com/tags/VC/"}]},{"title":"Android动态获取权限","date":"2018-05-14T03:11:00.000Z","path":"2018/05/14/Android动态获取权限/","text":"在6.0 系统中请求某些权限需要检查权限 下面以拨打电话为例 123456789101112131415if (!TextUtils.isEmpty(phone)) { if (!hasPermission()) { // 在6.0 系统中请求某些权限需要检查权限 int curApiVersion = Build.VERSION.SDK_INT; if (curApiVersion &gt;= Build.VERSION_CODES.M) { // 动态请求拨打电话权限 requestPermissions( new String[] { Manifest.permission.CALL_PHONE }, 0x11); } else { intentToCall(phone); } } else { intentToCall(phone); }} 12345678910111213141516171819202122232425262728293031323334private boolean hasPermission() { if (checkSelfPermission(Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED) { return false; } return true; } private void intentToCall(String phoneNumber) { Intent intent = new Intent(Intent.ACTION_CALL); Uri data = Uri.parse(\"tel:\" + phoneNumber); intent.setData(data); startActivity(intent); } /** * 动态请求拨打电话权限后，监听用户的点击事件 */ @Override public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); if (requestCode == 0x11) { // If request is cancelled, the result arrays are empty. if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) { CldLog.i(\"CMCC\", \"权限被允许\"); String phone = mContactsInfo.getPhone(); intentToCall(phone); } else { CldLog.i(\"CMCC\", \"权限被拒绝\"); } } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Servlet找不到包","date":"2018-05-13T07:26:00.000Z","path":"2018/05/13/Servlet找不到包/","text":"servlet-api.jar 复制到 JDK/jre/lib/ext 里面 如果还不行，在把这个包放到JDK的bin里，再在命令行强行导入： 1javac -classpath servlet-api.jar sortCount.java document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"JSP","slug":"JSP","permalink":"http://blog.iwxyi.com/tags/JSP/"},{"name":"Servlet","slug":"Servlet","permalink":"http://blog.iwxyi.com/tags/Servlet/"}]},{"title":"Android获取IMEI码","date":"2018-05-10T03:15:00.000Z","path":"2018/05/10/Android获取IMEI码/","text":"12345import android.telephony.TelephonyManager;public String getIMEI() { return ((TelephonyManager) mainActivity.getContext().getSystemService(\"phone\")).getDeviceId();} 需要权限 &lt;uses-permission android:name=\"android.permission.READ_PHONE_STATE\" /&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"JSP-学习笔记","date":"2018-05-09T07:25:00.000Z","path":"2018/05/09/JSP-学习笔记/","text":"了解第一个 JSP 程序12345678910&lt;html&gt; &lt;head&gt; &lt;title&gt;第一个 JSP 程序&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% out.println(\"Hello World！\"); %&gt; &lt;/body&gt;&lt;/html&gt; JSP 生命周期JSP编译当浏览器请求JSP页面时，JSP引擎会首先去检查是否需要编译这个文件。如果这个文件没有被编译过，或者在上次编译后被更改过，则编译这个JSP文件。 编译的过程包括三个步骤： 解析JSP文件。 将JSP文件转为servlet。 编译servlet。 JSP初始化容器载入JSP文件后，它会在为请求提供任何服务前调用jspInit()方法。如果您需要执行自定义的JSP初始化任务，复写jspInit()方法就行了，就像下面这样： 123public void jspInit(){ // 初始化代码} 一般来讲程序只初始化一次，servlet也是如此。通常情况下您可以在jspInit()方法中初始化数据库连接、打开文件和创建查询表。 JSP执行这一阶段描述了JSP生命周期中一切与请求相关的交互行为，直到被销毁。 当JSP网页完成初始化后，JSP引擎将会调用_jspService()方法。 _jspService()方法需要一个HttpServletRequest对象和一个HttpServletResponse对象作为它的参数，就像下面这样： 12345void _jspService(HttpServletRequest request, HttpServletResponse response){ // 服务端处理代码} _jspService()方法在每个request中被调用一次并且负责产生与之相对应的response，并且它还负责产生所有7个HTTP方法的回应，比如GET、POST、DELETE等等。 JSP清理JSP生命周期的销毁阶段描述了当一个JSP网页从容器中被移除时所发生的一切。 jspDestroy()方法在JSP中等价于servlet中的销毁方法。当您需要执行任何清理工作时复写jspDestroy()方法，比如释放数据库连接或者关闭文件夹等等。 jspDestroy()方法的格式如下： 1234public void jspDestroy(){ // 清理代码} JSP 语法##基础语法 1&lt;% 代码片段 %&gt; 效果等同于 123&lt;jsp:scriptlet&gt; 代码片段&lt;/jsp:scriptlet&gt; 输出123&lt;% out.println(\"Your IP address is \" + request.getRemoteAddr());%&gt; 中文编码12&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt; 声明变量123&lt;%! int i = 0; %&gt; &lt;%! int a, b, c; %&gt; &lt;%! Circle a = new Circle(2.0); %&gt; 123&lt;jsp:declaration&gt; 代码片段&lt;/jsp:declaration&gt; JSP 表达式先被转化成String，然后插入到表达式出现的地方。 表达式元素中可以包含任何符合Java语言规范的表达式，但是不能使用分号来结束表达式。 1&lt;%= 表达式 %&gt; 123&lt;jsp:expression&gt; 表达式&lt;/jsp:expression&gt; JSP 注释1&lt;%-- 该部分注释在网页中不会被显示--%&gt; HTML 注释 12&gt; &lt;!-- 注释 --&gt;&gt; JSP 指令JSP指令用来设置与整个JSP页面相关的属性。 1&lt;%@ directive attribute=\"value\" %&gt; 这里有三种指令标签： 指令 描述 &lt;%@ page … %&gt; 定义页面的依赖属性，比如脚本语言、error页面、缓存需求等等 &lt;%@ include … %&gt; 包含其他文件 &lt;%@ taglib … %&gt; 引入标签库的定义，可以是自定义标签 JSP 行为JSP行为标签使用XML语法结构来控制servlet引擎。它能够动态插入一个文件，重用JavaBean组件，引导用户去另一个页面，为Java插件产生相关的HTML等等。 1&lt;jsp:action_name attribute=\"value\" /&gt; 语法 描述 jsp:include 用于在当前页面中包含静态或动态资源 jsp:useBean 寻找和初始化一个JavaBean组件 jsp:setProperty 设置 JavaBean组件的值 jsp:getProperty 将 JavaBean组件的值插入到 output中 jsp:forward 从一个JSP文件向另一个文件传递一个包含用户请求的request对象 jsp:plugin 用于在生成的HTML页面中包含Applet和JavaBean对象 jsp:element 动态创建一个XML元素 jsp:attribute 定义动态创建的XML元素的属性 jsp:body 定义动态创建的XML元素的主体 jsp:text 用于封装模板数据 JSP 对象 对象 描述 request HttpServletRequest类的实例 response HttpServletResponse类的实例 out PrintWriter类的实例，用于把结果输出至网页上 session HttpSession类的实例 application ServletContext类的实例，与应用上下文有关 config ServletConfig类的实例 pageContext PageContext类的实例，提供对JSP页面所有对象以及命名空间的访问 page 类似于Java类中的this关键字 Exception Exception类的对象，代表发生错误的JSP页面中对应的异常对象 控制流语句同 Java 判断语句if…else…1234567&lt;%! int day = 3; %&gt; &lt;h3&gt;IF...ELSE 实例&lt;/h3&gt;&lt;% if (day == 1 | day == 7) { %&gt; &lt;p&gt;今天是周末&lt;/p&gt;&lt;% } else { %&gt; &lt;p&gt;今天不是周末&lt;/p&gt;&lt;% } %&gt; switch123456789101112&lt;%! int day = 3; %&gt; &lt;% switch(day) {case 0: out.println(\"星期天\"); break;case 1: ...default: out.println(\"星期六\");}%&gt; 循环语句可以使用Java的三个基本循环类型：for，while，和 do…while 1234567&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%! int fontSize; %&gt; &lt;h3&gt;For 循环实例&lt;/h3&gt;&lt;% for ( fontSize = 1; fontSize &lt;= 3; fontSize++){ %&gt; &lt;font color=\"green\" size=\"&lt;%= fontSize %&gt;\"&gt;菜鸟教程&lt;/font&gt;&lt;br /&gt;&lt;% } %&gt; 运行结果 JSP 运算符JSP支持所有Java逻辑和算术运算符。 JSP 字面量 布尔值(boolean)：true 和 false; 整型(int)：与 Java 中的一样; 浮点型(float)：与 Java 中的一样; 字符串(string)：以单引号或双引号开始和结束; Null：null。 JSP 指令JSP指令用来设置整个JSP页面相关的属性，如网页的编码方式和脚本语言。 1&lt;%@ directive attribute=\"value\" %&gt; Page 指令Page指令为容器提供当前页面的使用说明。一个JSP页面可以包含多个page指令。 1&lt;%@ page attribute=\"value\" %&gt; 等价的XML格式： 1&lt;jsp:directive.page attribute=\"value\" /&gt; 下表列出与Page指令相关的属性： 属性 描述 buffer 指定out对象使用缓冲区的大小 autoFlush 控制out对象的 缓存区 contentType 指定当前JSP页面的MIME类型和字符编码 errorPage 指定当JSP页面发生异常时需要转向的错误处理页面 isErrorPage 指定当前页面是否可以作为另一个JSP页面的错误处理页面 extends 指定servlet从哪一个类继承 import 导入要使用的Java类 info 定义JSP页面的描述信息 isThreadSafe 指定对JSP页面的访问是否为线程安全 language 定义JSP页面所用的脚本语言，默认是Java session 指定JSP页面是否使用session isELIgnored 指定是否执行EL表达式 isScriptingEnabled 确定脚本元素能否被使用 Include指令JSP可以通过include指令来包含其他文件。被包含的文件可以是JSP文件、HTML文件或文本文件。 1&lt;%@ include file=\"文件相对 url 地址\" %&gt; 1&lt;jsp:directive.include file=\"文件相对 url 地址\" /&gt; Taglib指令JSP API允许用户自定义标签，一个自定义标签库就是自定义标签的集合。 Taglib指令引入一个自定义标签集合的定义，包括库路径、自定义标签。 1&lt;%@ taglib uri=\"uri\" prefix=\"prefixOfTag\" %&gt; uri属性确定标签库的位置，prefix属性指定标签库的前缀。 1&lt;jsp:directive.taglib uri=\"uri\" prefix=\"prefixOfTag\" /&gt; JSP 动作元素与JSP指令元素不同的是，JSP动作元素在请求处理阶段起作用。JSP动作元素是用XML语法写成的。 利用JSP动作可以动态地插入文件、重用JavaBean组件、把用户重定向到另外的页面、为Java插件生成HTML代码。 动作元素只有一种语法，它符合XML标准： 1&lt;jsp:action_name attribute=\"value\" /&gt; &lt;jsp:include&gt;动作元素&lt;jsp:include&gt;动作元素用来包含静态和动态的文件。该动作把指定文件插入正在生成的页面。语法格式如下： 1&lt;jsp:include page=\"相对 URL 地址\" flush=\"true\" /&gt; flush：布尔属性，定义在包含资源前是否刷新缓存区。 前面已经介绍过include指令，它是在JSP文件被转换成Servlet的时候引入文件，而这里的jsp:include动作不同，插入文件的时间是在页面被请求的时候。 实例date.jsp文件代码： 12345&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;p&gt; 今天的日期是: &lt;%= (new java.util.Date()).toLocaleString()%&gt;&lt;/p&gt; main.jsp文件代码： 1234&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;h2&gt;include 动作实例&lt;/h2&gt;&lt;jsp:include page=\"date.jsp\" flush=\"true\" /&gt; 运行结果 1今天的日期是: 2016-6-25 14:08:17 &lt;jsp:useBean&gt;动作元素jsp:useBean 动作用来加载一个将在JSP页面中使用的JavaBean，使得我们可以发挥 Java 组件复用的优势。 1&lt;jsp:useBean id=\"name\" class=\"package.class\" /&gt; 在类载入后，我们既可以通过 jsp:setProperty 和 jsp:getProperty 动作来修改和检索bean的属性。 属性 描述 class 指定Bean的完整包名。 type 指定将引用该对象变量的类型。 beanName 通过 java.beans.Beans 的 instantiate() 方法指定Bean的名字。 &lt;jsp:setProperty&gt;动作元素jsp:setProperty用来设置已经实例化的Bean对象的属性，有两种用法。 首先，你可以在jsp:useBean元素的外面（后面）使用jsp:setProperty，如下所示： 123&lt;jsp:useBean id=\"myName\" ... /&gt;...&lt;jsp:setProperty name=\"myName\" property=\"someProperty\" .../&gt; 此时，不管jsp:useBean是找到了一个现有的Bean，还是新创建了一个Bean实例，jsp:setProperty都会执行。 第二种用法是把jsp:setProperty放入jsp:useBean元素的内部，如下所示： 1234&lt;jsp:useBean id=\"myName\" ... &gt;... &lt;jsp:setProperty name=\"myName\" property=\"someProperty\" .../&gt;&lt;/jsp:useBean&gt; 此时，jsp:setProperty只有在新建Bean实例时才会执行，如果是使用现有实例则不执行jsp:setProperty。 jsp:setProperty动作有下面四个属性,如下表： 属性 描述 name 必需。它表示要设置属性的是哪个Bean。 property 必需。它表示要设置哪个属性。有一个特殊用法：如果property的值是”*”，表示所有名字和Bean属性名字匹配的请求参数都将被传递给相应的属性set方法。 value 可选。该属性用来指定Bean属性的值。value和param不能同时使用，但可以使用其中任意一个。 param 可选。它指定用哪个请求参数作为Bean属性的值。如果当前请求没有参数，则什么事情也不做，系统不会把null传递给Bean属性的set方法。因此，你可以让Bean自己提供默认属性值，只有当请求参数明确指定了新值时才修改默认属性值。 &lt;jsp:getProperty&gt;动作元素jsp:getProperty动作提取指定Bean属性的值，转换成字符串，然后输出。语法格式如下： 123&lt;jsp:useBean id=\"myName\" ... /&gt;...&lt;jsp:getProperty name=\"myName\" property=\"someProperty\" .../&gt; 实例使用 Bean 123456789101112package com.runoob.main;public class TestBean { private String message = \"菜鸟教程\"; public String getMessage() { return(message); } public void setMessage(String message) { this.message = message; }} 编译以上实例文件 TestBean.java ： 1$ javac TestBean.java 在main.jsp文件中调用该Bean: 12345678910&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;h2&gt;Jsp 使用 JavaBean 实例&lt;/h2&gt;&lt;jsp:useBean id=\"test\" class=\"com.runoob.main.TestBean\" /&gt; &lt;jsp:setProperty name=\"test\" property=\"message\" value=\"菜鸟教程...\" /&gt;&lt;p&gt;输出信息....&lt;/p&gt;&lt;jsp:getProperty name=\"test\" property=\"message\" /&gt; 运行结果 12输出信息...菜鸟教程... &lt;jsp:forward&gt; 动作元素jsp:forward动作把请求转到另外的页面。 1&lt;jsp:forward page=\"相对 URL 地址\" /&gt; page属性包含的是一个相对URL。page的值既可以直接给出，也可以在请求的时候动态计算，可以是一个JSP页面或者一个 Java Servlet. &lt;jsp:plugin&gt;动作元素jsp:plugin动作用来根据浏览器的类型，插入通过Java插件 运行Java Applet所必需的OBJECT或EMBED元素。 如果需要的插件不存在，它会下载插件，然后执行Java组件。 Java组件可以是一个applet或一个JavaBean。 plugin动作有多个对应HTML元素的属性用于格式化Java 组件。param元素可用于向Applet 或 Bean 传递参数。 12345678910&lt;jsp:plugin type=\"applet\" codebase=\"dirname\" code=\"MyApplet.class\" width=\"60\" height=\"80\"&gt; &lt;jsp:param name=\"fontcolor\" value=\"red\" /&gt; &lt;jsp:param name=\"background\" value=\"black\" /&gt; &lt;jsp:fallback&gt; Unable to initialize Java Plugin &lt;/jsp:fallback&gt; &lt;/jsp:plugin&gt; 如果你有兴趣可以尝试使用applet来测试jsp:plugin动作元素，&lt;fallback&gt;元素是一个新元素，在组件出现故障的错误时发送给用户错误信息。 &lt;jsp:element&gt; 、 &lt;jsp:attribute&gt;、 &lt;jsp:body&gt;动作元素&lt;jsp:element&gt; 、 &lt;jsp:attribute&gt;、 &lt;jsp:body&gt;动作元素动态定义XML元素。动态是非常重要的，这就意味着XML元素在编译时是动态生成的而非静态。 实例12345678910111213141516171819&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;jsp:element name=\"xmlElement\"&gt;&lt;jsp:attribute name=\"xmlElementAttr\"&gt; 属性值&lt;/jsp:attribute&gt;&lt;jsp:body&gt; XML 元素的主体&lt;/jsp:body&gt;&lt;/jsp:element&gt;&lt;/body&gt;&lt;/html&gt; 运行结果 运行结果 &lt;jsp:text&gt;动作元素&lt;jsp:text&gt;动作元素允许在JSP页面和文档中使用写入文本的模板，语法格式如下： 1&lt;jsp:text&gt;模板数据&lt;/jsp:text&gt; 以上文本模板不能包含其他元素，只能只能包含文本和EL表达式（注：EL表达式将在后续章节中介绍）。请注意，在XML文件中，您不能使用表达式如 ${whatever &gt; 0}，因为&gt;符号是非法的。 你可以使用 ${whatever gt 0}表达式或者嵌入在一个CDATA部分的值。 1&lt;jsp:text&gt;&lt;![CDATA[&lt;br&gt;]]&gt;&lt;/jsp:text&gt; 如果你需要在 XHTML 中声明 DOCTYPE,必须使用到&lt;jsp:text&gt;动作元素，实例如下： 12345678910111213&lt;jsp:text&gt;&lt;![CDATA[&lt;!DOCTYPE htmlPUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\"DTD/xhtml1-strict.dtd\"&gt;]]&gt;&lt;/jsp:text&gt;&lt;head&gt;&lt;title&gt;jsp:text action&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;books&gt;&lt;book&gt;&lt;jsp:text&gt; Welcome to JSP Programming&lt;/jsp:text&gt;&lt;/book&gt;&lt;/books&gt;&lt;/body&gt;&lt;/html&gt; 你可以对以上实例尝试使用&lt;jsp:text&gt;及不使用该动作元素执行结果的区别。 JSP 隐式对象JSP隐式对象是JSP容器为每个页面提供的Java对象，开发者可以直接使用它们而不用显式声明。JSP隐式对象也被称为预定义变量。 request对象request对象是javax.servlet.http.HttpServletRequest 类的实例。每当客户端请求一个JSP页面时，JSP引擎就会制造一个新的request对象来代表这个请求。 request对象提供了一系列方法来获取HTTP头信息，cookies，HTTP方法等等。 response对象response对象是javax.servlet.http.HttpServletResponse类的实例。当服务器创建request对象时会同时创建用于响应这个客户端的response对象。 response对象也定义了处理HTTP头模块的接口。通过这个对象，开发者们可以添加新的cookies，时间戳，HTTP状态码等等。 out对象out对象是 javax.servlet.jsp.JspWriter 类的实例，用来在response对象中写入内容。 最初的JspWriter类对象根据页面是否有缓存来进行不同的实例化操作。可以在page指令中使用buffered=’false’属性来轻松关闭缓存。 JspWriter类包含了大部分java.io.PrintWriter类中的方法。不过，JspWriter新增了一些专为处理缓存而设计的方法。还有就是，JspWriter类会抛出IOExceptions异常，而PrintWriter不会。 下表列出了我们将会用来输出boolean，char，int，double，String，object等类型数据的重要方法： 方法 描述 out.print(dataType dt) 输出Type类型的值 out.println(dataType dt) 输出Type类型的值然后换行 out.flush() 刷新输出流 session对象session对象是 javax.servlet.http.HttpSession 类的实例。和Java Servlets中的session对象有一样的行为。 session对象用来跟踪在各个客户端请求间的会话。 application对象application对象直接包装了servlet的ServletContext类的对象，是javax.servlet.ServletContext 类的实例。 这个对象在JSP页面的整个生命周期中都代表着这个JSP页面。这个对象在JSP页面初始化时被创建，随着jspDestroy()方法的调用而被移除。 通过向application中添加属性，则所有组成您web应用的JSP文件都能访问到这些属性。 config对象config对象是 javax.servlet.ServletConfig 类的实例，直接包装了servlet的ServletConfig类的对象。 这个对象允许开发者访问Servlet或者JSP引擎的初始化参数，比如文件路径等。 以下是config对象的使用方法，不是很重要，所以不常用： 1config.getServletName(); 它返回包含在&lt;servlet-name&gt;元素中的servlet名字，注意，&lt;servlet-name&gt;元素在 WEB-INF\\web.xml 文件中定义。 pageContext 对象pageContext对象是javax.servlet.jsp.PageContext 类的实例，用来代表整个JSP页面。 这个对象主要用来访问页面信息，同时过滤掉大部分实现细节。 这个对象存储了request对象和response对象的引用。application对象，config对象，session对象，out对象可以通过访问这个对象的属性来导出。 pageContext对象也包含了传给JSP页面的指令信息，包括缓存信息，ErrorPage URL,页面scope等。 PageContext类定义了一些字段，包括PAGE_SCOPE，REQUEST_SCOPE，SESSION_SCOPE， APPLICATION_SCOPE。它也提供了40余种方法，有一半继承自javax.servlet.jsp.JspContext 类。 其中一个重要的方法就是removeArribute()，它可接受一个或两个参数。比如，pageContext.removeArribute(“attrName”)移除四个scope中相关属性，但是下面这种方法只移除特定scope中的相关属性： 1pageContext.removeAttribute(\"attrName\", PAGE_SCOPE); page 对象这个对象就是页面实例的引用。它可以被看做是整个JSP页面的代表。 page 对象就是this对象的同义词。 exception 对象exception 对象包装了从先前页面中抛出的异常信息。它通常被用来产生对出错条件的适当响应。 JSP 响应JSP 客户端请求下表列出了浏览器端信息头的一些重要内容： 信息 描述 Accept 指定浏览器或其他客户端可以处理的MIME类型。它的值通常为 image/png 或 image/jpeg Accept-Charset 指定浏览器要使用的字符集。比如 ISO-8859-1 Accept-Encoding 指定编码类型。它的值通常为 gzip 或compress Accept-Language 指定客户端首选语言，servlet会优先返回以当前语言构成的结果集，如果servlet支持这种语言的话。比如 en，en-us，ru等等 Authorization 在访问受密码保护的网页时识别不同的用户 Connection 表明客户端是否可以处理HTTP持久连接。持久连接允许客户端或浏览器在一个请求中获取多个文件。Keep-Alive 表示启用持久连接 Content-Length 仅适用于POST请求，表示 POST 数据的字节数 Cookie 返回先前发送给浏览器的cookies至服务器 Host 指出原始URL中的主机名和端口号 If-Modified-Since 表明只有当网页在指定的日期被修改后客户端才需要这个网页。 服务器发送304码给客户端，表示没有更新的资源 If-Unmodified-Since 与If-Modified-Since相反， 只有文档在指定日期后仍未被修改过，操作才会成功 Referer 标志着所引用页面的URL。比如，如果你在页面1，然后点了个链接至页面2，那么页面1的URL就会包含在浏览器请求页面2的信息头中 User-Agent 用来区分不同浏览器或客户端发送的请求，并对不同类型的浏览器返回不同的内容 HttpServletRequest类request对象是javax.servlet.http.HttpServletRequest类的实例。每当客户端请求一个页面时，JSP引擎就会产生一个新的对象来代表这个请求。 request对象提供了一系列方法来获取HTTP信息头，包括表单数据，cookies，HTTP方法等等。 一些在JSP编程中常用的获取HTTP信息头的方法： 序号 方法 &amp; 描述 1 Cookie[] getCookies()返回客户端所有的Cookie的数组 2 Enumeration getAttributeNames()返回request对象的所有属性名称的集合 3 Enumeration getHeaderNames()返回所有HTTP头的名称集合 4 Enumeration getParameterNames()返回请求中所有参数的集合 5 HttpSession getSession()返回request对应的session对象，如果没有，则创建一个 6 HttpSession getSession(boolean create)返回request对应的session对象，如果没有并且参数create为true，则返回一个新的session对象 7 Locale getLocale()返回当前页的Locale对象，可以在response中设置 8 Object getAttribute(String name)返回名称为name的属性值，如果不存在则返回null。 9 ServletInputStream getInputStream()返回请求的输入流 10 String getAuthType()返回认证方案的名称，用来保护servlet，比如 “BASIC” 或者 “SSL” 或 null 如果 JSP没设置保护措施 11 String getCharacterEncoding()返回request的字符编码集名称 12 String getContentType()返回request主体的MIME类型，若未知则返回null 13 String getContextPath()返回request URI中指明的上下文路径 14 String getHeader(String name)返回name指定的信息头 15 String getMethod()返回此request中的HTTP方法，比如 GET,，POST，或PUT 16 String getParameter(String name)返回此request中name指定的参数，若不存在则返回null 17 String getPathInfo()返回任何额外的与此request URL相关的路径 18 String getProtocol()返回此request所使用的协议名和版本 19 String getQueryString()返回此 request URL包含的查询字符串 20 String getRemoteAddr()返回客户端的IP地址 21 String getRemoteHost()返回客户端的完整名称 22 String getRemoteUser()返回客户端通过登录认证的用户，若用户未认证则返回null 23 String getRequestURI()返回request的URI 24 String getRequestedSessionId()返回request指定的session ID 25 String getServletPath()返回所请求的servlet路径 26 String[] getParameterValues(String name)返回指定名称的参数的所有值，若不存在则返回null 27 boolean isSecure()返回request是否使用了加密通道，比如HTTPS 28 int getContentLength()返回request主体所包含的字节数，若未知的返回-1 29 int getIntHeader(String name)返回指定名称的request信息头的值 30 int getServerPort()返回服务器端口号 HTTP信息头示例在这个例子中，我们会使用HttpServletRequest类的getHeaderNames()方法来读取HTTP信息头。这个方法以枚举的形式返回当前HTTP请求的头信息。 获取Enumeration对象后，用标准的方式来遍历Enumeration对象，用hasMoreElements()方法来确定什么时候停止，用nextElement()方法来获得每个参数的名字。 1234567891011121314151617181920&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ page import=\"java.io.*,java.util.*\" %&gt;&lt;h2&gt;HTTP 头部请求实例&lt;/h2&gt;&lt;table width=\"100%\" border=\"1\" align=\"center\"&gt; &lt;tr bgcolor=\"#949494\"&gt; &lt;th&gt;Header Name&lt;/th&gt;&lt;th&gt;Header Value(s)&lt;/th&gt; &lt;/tr&gt; &lt;% Enumeration headerNames = request.getHeaderNames(); while(headerNames.hasMoreElements()) { String paramName = (String)headerNames.nextElement(); out.print(\"&lt;tr&gt;&lt;td&gt;\" + paramName + \"&lt;/td&gt;\\n\"); String paramValue = request.getHeader(paramName); out.println(\"&lt;td&gt; \" + paramValue + \"&lt;/td&gt;&lt;/tr&gt;\\n\"); } %&gt;&lt;/table&gt; 访问main.jsp，将会得到以下结果： img JSP 服务器响应Response响应对象主要将JSP容器处理后的结果传回到客户端。可以通过response变量设置HTTP的状态和向客户端发送数据，如Cookie、HTTP文件头信息等。 一个典型的响应看起来就像下面这样： 12345678910111213HTTP/1.1 200 OKContent-Type: text/htmlHeader2: ......HeaderN: ... (空行)&lt;!doctype ...&gt;&lt;html&gt;&lt;head&gt;...&lt;/head&gt;&lt;body&gt;...&lt;/body&gt;&lt;/html&gt; 状态行包含HTTP版本信息，比如HTTP/1.1，一个状态码，比如200，还有一个非常短的信息对应着状态码，比如OK。 下表摘要出了HTTP1.1响应头中最有用的部分： 响应头 描述 Allow 指定服务器支持的request方法（GET，POST等等） Cache-Control 指定响应文档能够被安全缓存的情况。通常取值为 public**，**private 或no-cache 等等。 Public意味着文档可缓存，Private意味着文档只为单用户服务并且只能使用私有缓存。No-cache 意味着文档不被缓存。 Connection 命令浏览器是否要使用持久的HTTP连接。close**值** 命令浏览器不使用持久HTTP连接，而keep-alive 意味着使用持久化连接。 Content-Disposition 让浏览器要求用户将响应以给定的名称存储在磁盘中 Content-Encoding 指定传输时页面的编码规则 Content-Language 表述文档所使用的语言，比如en， en-us,，ru等等 Content-Length 表明响应的字节数。只有在浏览器使用持久化 (keep-alive) HTTP 连接时才有用 Content-Type 表明文档使用的MIME类型 Expires 指明啥时候过期并从缓存中移除 Last-Modified 指明文档最后修改时间。客户端可以 缓存文档并且在后续的请求中提供一个 If-Modified-Since请求头 Location 在300秒内，包含所有的有一个状态码的响应地址，浏览器会自动重连然后检索新文档 Refresh 指明浏览器每隔多久请求更新一次页面。 Retry-After 与503 (Service Unavailable)一起使用来告诉用户多久后请求将会得到响应 Set-Cookie 指明当前页面对应的cookie HttpServletResponse类response 对象是 javax.servlet.http.HttpServletResponse 类的一个实例。就像服务器会创建request对象一样，它也会创建一个客户端响应。 response对象定义了处理创建HTTP信息头的接口。通过使用这个对象，开发者们可以添加新的cookie或时间戳，还有HTTP状态码等等。 下表列出了用来设置HTTP响应头的方法，这些方法由HttpServletResponse 类提供： S.N. 方法 &amp; 描述 1 String encodeRedirectURL(String url)对sendRedirect()方法使用的URL进行编码 2 String encodeURL(String url)将URL编码，回传包含Session ID的URL 3 boolean containsHeader(String name)返回指定的响应头是否存在 4 boolean isCommitted()返回响应是否已经提交到客户端 5 void addCookie(Cookie cookie)添加指定的cookie至响应中 6 void addDateHeader(String name, long date)添加指定名称的响应头和日期值 7 void addHeader(String name, String value)添加指定名称的响应头和值 8 void addIntHeader(String name, int value)添加指定名称的响应头和int值 9 void flushBuffer()将任何缓存中的内容写入客户端 10 void reset()清除任何缓存中的任何数据，包括状态码和各种响应头 11 void resetBuffer()清除基本的缓存数据，不包括响应头和状态码 12 void sendError(int sc)使用指定的状态码向客户端发送一个出错响应，然后清除缓存 13 void sendError(int sc, String msg)使用指定的状态码和消息向客户端发送一个出错响应 14 void sendRedirect(String location)使用指定的URL向客户端发送一个临时的间接响应 15 void setBufferSize(int size)设置响应体的缓存区大小 16 void setCharacterEncoding(String charset)指定响应的编码集（MIME字符集），例如UTF-8 17 void setContentLength(int len)指定HTTP servlets中响应的内容的长度，此方法用来设置 HTTP Content-Length 信息头 18 void setContentType(String type)设置响应的内容的类型，如果响应还未被提交的话 19 void setDateHeader(String name, long date)使用指定名称和值设置响应头的名称和内容 20 void setHeader(String name, String value)使用指定名称和值设置响应头的名称和内容 21 void setIntHeader(String name, int value)使用指定名称和值设置响应头的名称和内容 22 void setLocale(Locale loc)设置响应的语言环境，如果响应尚未被提交的话 23 void setStatus(int sc)设置响应的状态码 HTTP响应头程序示例自动刷新实例接下来的例子使用setIntHeader()方法和setRefreshHeader()方法来模拟一个数字时钟： 1234567891011121314151617181920212223242526&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ page import=\"java.io.*,java.util.*\" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h2&gt;自动刷新实例&lt;/h2&gt;&lt;% // 设置每隔5秒自动刷新 response.setIntHeader(\"Refresh\", 5); // 获取当前时间 Calendar calendar = new GregorianCalendar(); String am_pm; int hour = calendar.get(Calendar.HOUR); int minute = calendar.get(Calendar.MINUTE); int second = calendar.get(Calendar.SECOND); if(calendar.get(Calendar.AM_PM) == 0) am_pm = \"AM\"; else am_pm = \"PM\"; String CT = hour+\":\"+ minute +\":\"+ second +\" \"+ am_pm; out.println(\"当前时间: \" + CT + \"\\n\");%&gt;&lt;/body&gt;&lt;/html&gt; 它将会每隔5秒显示一下系统当前时间。 img JSP HTTP 状态码HTTP请求与HTTP响应的格式相近，都有着如下结构： 以状态行+CRLF（回车换行）开始 零行或多行头模块+CRLF 一个空行，比如CRLF 可选的消息体比如文件，查询数据，查询输出 一个服务器响应头看起来就像下面这样： 123HTTP/1.1 200 OK............ 状态行包含HTTP版本，一个状态码，和状态码相对应的短消息。 状态码 消息 描述 100 Continue 只有一部分请求被服务器接收，但只要没被服务器拒绝，客户端就会延续这个请求 101 Switching Protocols 服务器交换机协议 200 OK 请求被确认 201 Created 请求时完整的，新的资源被创建 202 Accepted 请求被接受，但未处理完 203 Non-authoritative Information 204 No Content 205 Reset Content 206 Partial Content 300 Multiple Choices 一个超链接表，用户可以选择一个超链接并访问，最大支持5个超链接 301 Moved Permanently 被请求的页面已经移动到了新的URL下 302 Found 被请求的页面暂时性地移动到了新的URL下 303 See Other 被请求的页面可以在一个不同的URL下找到 304 Not Modified 305 Use Proxy 306 Unused 已经不再使用此状态码，但状态码被保留 307 Temporary Redirect 被请求的页面暂时性地移动到了新的URL下 400 Bad Request 服务器无法识别请求 401 Unauthorized 被请求的页面需要用户名和密码 402 Payment Required 目前还不能使用此状态码 403 Forbidden 禁止访问所请求的页面 404 Not Found 服务器无法找到所请求的页面 405 Method Not Allowed 请求中所指定的方法不被允许 406 Not Acceptable 服务器只能创建一个客户端无法接受的响应 407 Proxy Authentication Required 在请求被服务前必须认证一个代理服务器 408 Request Timeout 请求时间超过了服务器所能等待的时间，连接被断开 409 Conflict 请求有矛盾的地方 410 Gone 被请求的页面不再可用 411 Length Required “Content-Length”没有被定义，服务器拒绝接受请求 412 Precondition Failed 请求的前提条件被服务器评估为false 413 Request Entity Too Large 因为请求的实体太大，服务器拒绝接受请求 414 Request-url Too Long 服务器拒绝接受请求，因为URL太长。多出现在把”POST”请求转换为”GET”请求时所附带的大量查询信息 415 Unsupported Media Type 服务器拒绝接受请求，因为媒体类型不被支持 417 Expectation Failed 500 Internal Server Error 请求不完整，服务器遇见了出乎意料的状况 501 Not Implemented 请求不完整，服务器不提供所需要的功能 502 Bad Gateway 请求不完整，服务器从上游服务器接受了一个无效的响应 503 Service Unavailable 请求不完整，服务器暂时重启或关闭 504 Gateway Timeout 网关超时 505 HTTP Version Not Supported 服务器不支持所指定的HTTP版本 设置HTTP状态码的方法下表列出了HttpServletResponse 类中用来设置状态码的方法： S.N. 方法 &amp; 描述 1 public void setStatus ( int statusCode )此方法可以设置任意的状态码。如果您的响应包含一个特殊的状态码和一个文档，请确保在用PrintWriter返回任何内容前调用setStatus方法 2 public void sendRedirect(String url)此方法产生302响应，同时产生一个 Location 头告诉URL 一个新的文档 3 public void sendError(int code, String message)此方法将一个状态码(通常为 404)和一个短消息，自动插入HTML文档中并发回给客户端 HTTP状态码程序示例本例将会发送407错误码给浏览器，然后浏览器将会告诉您”Need authentication!!!”。 1234567891011&lt;html&gt;&lt;head&gt;&lt;title&gt;Setting HTTP Status Code&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% // 设置错误代码，并说明原因 response.sendError(407, \"Need authentication!!!\" );%&gt;&lt;/body&gt;&lt;/html&gt; 访问以上JSP页面，将会得到以下结果： js_http_status_codes JSP 表单JSP 表单处理浏览器中使用 GET 和 POST 方法向服务器提交数据。 GET 方法GET方法将请求的编码信息添加在网址后面，网址与编码信息通过”?”号分隔。如下所示： 1http://www.runoob.com/hello?key1=value1&amp;key2=value2 GET方法是浏览器默认传递参数的方法，一些敏感信息，如密码等建议不使用GET方法。 用get时，传输数据的大小有限制 （注意不是参数的个数有限制），最大为1024字节。 POST 方法一些敏感信息，如密码等我们可以通过POST方法传递，POST提交数据是隐式的。 POST提交数据是不可见的，GET是通过在url里面传递的（可以看一下你浏览器的地址栏）。 JSP使用getParameter()来获得传递的参数，getInputStream()方法用来处理客户端的二进制数据流的请求。 JSP 读取表单数据 getParameter(): 使用 request.getParameter() 方法来获取表单参数的值。 getParameterValues(): 获得如checkbox类（名字相同，但值有多个）的数据。 接收数组变量 ，如checkbox类型 getParameterNames():该方法可以取得所有变量的名称，该方法返回一个Emumeration。 getInputStream():调用此方法来读取来自客户端的二进制数据流。 GET 实例URL：http://localhost:8080/testjsp/main.jsp?name=小白&amp;url=http://www.baidu.com 读取 name 表单： 12名字：&lt;%= request.getParameter(\"name\")%&gt; &lt;br /&gt;网址：&lt;%= request.getParameter(\"url\")%&gt; 运行结果： 12名字：小白网址：http://www.baidu.com POST 实例123456&lt;% // 解决中文乱码的问题 String name = new String((request.getParameter(\"name\")).getBytes(\"ISO-8859-1\"),\"UTF-8\");%&gt;名字：&lt;%=name%&gt;网址：&lt;%= request.getParameter(\"url\")%&gt; 使用 new String((request.getParameter(“name”)).getBytes(“ISO-8859-1”),”UTF-8”)来转换编码，防止中文乱码的发生。 传递 CHeckbox 实例HTML 代码： 1&lt;input type=\"checkbox\" name=\"cb\" checked=\"checked\" /&gt; JSP代码： 12&lt;b&gt;是否选中:&lt;/b&gt;&lt;%= request.getParameter(\"cb\")%&gt; 运行结果： 1on 读取所有表单参数使用 HttpServletRequest 的 getParameterNames() 来读取所有表单参数,该方法可以取得所有变量的名称，该方法返回一个枚举。 有了一个 Enumeration（枚举），就可以调用 hasMoreElements() 方法来确定是否还有元素，以及使用nextElement（）方法来获得每个参数的名称。 123456789101112131415161718&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ page import=\"java.io.*,java.util.*\" %&gt;&lt;table width=\"100%\" border=\"1\" align=\"center\"&gt;&lt;tr bgcolor=\"#949494\"&gt;&lt;th&gt;参数名&lt;/th&gt;&lt;th&gt;参数值&lt;/th&gt;&lt;/tr&gt;&lt;% Enumeration paramNames = request.getParameterNames(); while(paramNames.hasMoreElements()) { String paramName = (String)paramNames.nextElement(); out.print(\"&lt;tr&gt;&lt;td&gt;\" + paramName + \"&lt;/td&gt;\\n\"); String paramValue = request.getParameter(paramName); out.println(\"&lt;td&gt; \" + paramValue + \"&lt;/td&gt;&lt;/tr&gt;\\n\"); }%&gt;&lt;/table&gt; 运行结果 JSP 过滤器过滤器可以动态地拦截请求和响应，以变换或使用包含在请求或响应中的信息。 Servlet 过滤器方法过滤器是一个实现了 javax.servlet.Filter 接口的 Java 类。javax.servlet.Filter 接口定义了三个方法： 序号 方法 &amp; 描述 1 public void doFilter (ServletRequest, ServletResponse, FilterChain)该方法完成实际的过滤操作，当客户端请求方法与过滤器设置匹配的URL时，Servlet容器将先调用过滤器的doFilter方法。FilterChain用户访问后续过滤器。 2 public void init(FilterConfig filterConfig)web 应用程序启动时，web 服务器将创建Filter 的实例对象，并调用其init方法，读取web.xml配置，完成对象的初始化功能，从而为后续的用户请求作好拦截的准备工作（filter对象只会创建一次，init方法也只会执行一次）。开发人员通过init方法的参数，可获得代表当前filter配置信息的FilterConfig对象。 3 public void destroy()Servlet容器在销毁过滤器实例前调用该方法，在该方法中释放Servlet过滤器占用的资源。 FilterConfig 使用Filter 的 init 方法中提供了一个 FilterConfig 对象。 如 web.xml 文件配置如下： 12345678&lt;filter&gt; &lt;filter-name&gt;LoginFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.runoob.test.LogFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;Site&lt;/param-name&gt; &lt;param-value&gt;菜鸟教程&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; 在 init 方法使用 FilterConfig 对象获取参数： 123456public void init(FilterConfig config) throws ServletException { // 获取初始化参数 String site = config.getInitParameter(\"Site\"); // 输出初始化参数 System.out.println(\"网站名称: \" + site); } JSP 过滤器实例https://www.runoob.com/jsp/jsp-writing-filters.html 使用多个过滤器网址同上 Cookie 处理JSP Cookie 处理需要对中文进行编码与解码，方法如下： 12String str = java.net.URLEncoder.encode(\"中文\"，\"UTF-8\"); //编码String str = java.net.URLDecoder.decode(\"编码后的字符串\",\"UTF-8\"); // 解码 Cookie 剖析HTTP 信息头 1234567HTTP/1.1 200 OKDate: Fri, 04 Feb 2015 21:03:38 GMTServer: Apache/1.3.9 (UNIX) PHP/4.0b3Set-Cookie: name=runoob; expires=Friday, 04-Feb-07 22:03:38 GMT; path=/; domain=runoob.comConnection: closeContent-Type: text/html Servlet Cookie 方法 序号 方法 &amp; 描述 1 public void setDomain(String pattern)设置cookie的域名，比如 runoob.com 2 public String getDomain()获取cookie的域名，比如 runoob.com 3 public void setMaxAge(int expiry)设置cookie有效期，以秒为单位，默认有效期为当前session的存活时间 4 public int getMaxAge()获取cookie有效期，以秒为单位，默认为-1 ，表明cookie会活到浏览器关闭为止 5 public String getName()返回 cookie的名称，名称创建后将不能被修改 6 public void setValue(String newValue)设置 cookie的值 7 public String getValue()获取cookie的值 8 public void setPath(String uri)设置cookie 的路径，默认为当前页面目录下的所有URL，还有此目录下的所有子目录 9 public String getPath()获取cookie 的路径 10 public void setSecure(boolean flag)指明cookie是否要加密传输 11 public void setComment(String purpose)设置注释描述 cookie的目的。当浏览器将cookie展现给用户时，注释将会变得非常有用 12 public String getComment()返回描述cookie目的的注释，若没有则返回null 设置 Cookie使用JSP设置cookie包含三个步骤： *(1)创建一个Cookie对象： *调用Cookie的构造函数，使用一个cookie名称和值做参数，它们都是字符串。 1Cookie cookie = new Cookie(\"key\",\"value\"); 请务必牢记，名称和值中都不能包含空格或者如下的字符： 1[ ] ( ) = , \" / ? @ : ; (2) 设置有效期：调用setMaxAge()函数表明cookie在多长时间（以秒为单位）内有效。下面的操作将有效期设为了24小时。 1cookie.setMaxAge(60*60*24); (3) 将cookie发送至HTTP响应头中：调用response.addCookie()函数来向HTTP响应头中添加cookie。 1response.addCookie(cookie); Cookie 实例 12345678910111213141516&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ page import=\"java.net.*\" %&gt;&lt;% // 读取表单提交的 name 内容，并解决中文乱码 String str = URLEncoder.encode(request.getParameter(\"name\"),\"utf-8\"); // 设置 name cookie Cookie name = new Cookie(\"name\", str);、 // 设置cookie过期时间为24小时。 name.setMaxAge(60*60*24); // 在响应头部添加cookie response.addCookie( name );%&gt;&lt;p&gt;名字: &lt;%= request.getParameter(\"name\")%&gt;&lt;/p&gt; 读取 Cookie调用request.getCookies()方法来获得一个javax.servlet.http.Cookie对象的数组，然后遍历这个数组，使用getName()方法和getValue()方法来获取每一个cookie的名称和值。 123456789101112131415161718&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ page import=\"java.net.*\" %&gt;&lt;% Cookie cookie = null; Cookie[] cookies = null; // 获取cookies的数据,是一个数组 cookies = request.getCookies(); if( cookies != null ){ for (int i = 0; i &lt; cookies.length; i++) { cookie = cookies[i]; out.print(\"参数名 : \" + cookie.getName() + \"&lt;br&gt;\"); out.print(\"参数值: \" + URLDecoder.decode(cookie.getValue(), \"utf-8\") +\" &lt;br&gt;\"); } }%&gt; 删除 Cookie将cookie的有效期设置为0 1234567891011121314151617181920&lt;% Cookie cookie = null; Cookie[] cookies = null; // 获取当前域名下的cookies，是一个数组 cookies = request.getCookies(); if( cookies != null ) { for (int i = 0; i &lt; cookies.length; i++) { cookie = cookies[i]; // 确保存在 Cookie if((cookie.getName()).compareTo(\"name\") == 0 ) { cookie.setMaxAge(0); response.addCookie(cookie); break; } } }%&gt; JSP Session有三种方法来维持客户端与服务器的会话： Cookies 网络服务器可以指定一个唯一的session ID作为cookie来代表每个客户端，用来识别这个客户端接下来的请求。(很多时候浏览器并不一定支持cookie，所以不建议) 隐藏表单域 一个网络服务器可以发送一个隐藏的HTML表单域和一个唯一的session ID 1&lt;input type=\"hidden\" name=\"sessionid\" value=\"12345\"&gt; 当表单被提交时，指定的名称和值将会自动包含在GET或POST数据中。每当浏览器发送一个请求，session_id的值就可以用来保存不同浏览器的轨迹。 可能比较有效，但是点击&lt;A HREF&gt;标签中的超链接时不会产生表单提交事件，因此隐藏表单域也不支持通用会话跟踪。 重写URL 在每个URL后面添加一些额外的数据来区分会话，服务器能够根据这些数据来关联session标识符。 举例来说，http://w3cschool.cc/file.htm;sessionid=12345， session标识符为sessionid=12345，服务器可以用这个数据来识别客户端。 相比而言，重写URL是更好的方式，就算浏览器不支持cookies也能工作，但缺点是您必须为每个URL动态指定session ID，就算这是个简单的HTML页面。 session对象默认情况下，JSP允许会话跟踪，一个新的HttpSession对象将会自动地为新的客户端实例化。禁止会话跟踪需要显式地关掉它，通过将page指令中session属性值设为false来实现，就像下面这样： 1&lt;%@ page session=\"false\" %&gt; JSP引擎将隐含的session对象暴露给开发者。由于提供了session对象，开发者就可以方便地存储或检索数据。 ession对象的一些重要方法： S.N. 方法 &amp; 描述 1 public Object getAttribute(String name)返回session对象中与指定名称绑定的对象，如果不存在则返回null 2 public Enumeration getAttributeNames()返回session对象中所有的对象名称 3 public long getCreationTime()返回session对象被创建的时间， 以毫秒为单位，从1970年1月1号凌晨开始算起 4 public String getId()返回session对象的ID 5 public long getLastAccessedTime()返回客户端最后访问的时间，以毫秒为单位，从1970年1月1号凌晨开始算起 6 public int getMaxInactiveInterval()返回最大时间间隔，以秒为单位，servlet 容器将会在这段时间内保持会话打开 7 public void invalidate()将session无效化，解绑任何与该session绑定的对象 8 public boolean isNew()返回是否为一个新的客户端，或者客户端是否拒绝加入session 9 public void removeAttribute(String name)移除session中指定名称的对象 10 public void setAttribute(String name, Object value) 使用指定的名称和值来产生一个对象并绑定到session中 11 public void setMaxInactiveInterval(int interval)用来指定时间，以秒为单位，servlet容器将会在这段时间内保持会话有效 Session 实例如何使用HttpSession对象来获取创建时间和最后一次访问时间： 123456789101112131415161718192021222324252627282930313233&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ page import=\"java.io.*,java.util.*\" %&gt;&lt;% // 获取session创建时间 Date createTime = new Date(session.getCreationTime()); // 获取最后访问页面的时间 Date lastAccessTime = new Date(session.getLastAccessedTime()); String title = \"再次访问\"; Integer visitCount = new Integer(0); String visitCountKey = new String(\"visitCount\"); String userIDKey = new String(\"userID\"); String userID = new String(\"ABCD\"); // 检测网页是否由新的访问用户 if (session.isNew()){ title = \"访问\"; session.setAttribute(userIDKey, userID); session.setAttribute(visitCountKey, visitCount); } else { visitCount = (Integer)session.getAttribute(visitCountKey); if (visitCount == null) visitCount = 0; // 实测可能会是 null visitCount++; userID = (String)session.getAttribute(userIDKey); session.setAttribute(visitCountKey, visitCount); }%&gt; id ：&lt;% out.print( session.getId()); %&gt; &lt;br /&gt; 创建时间 ：&lt;% out.print(createTime); %&gt; &lt;br /&gt;最后访问时间：&lt;% out.print(lastAccessTime); %&gt; &lt;br /&gt; 用户 ID ：&lt;% out.print(userID); %&gt; &lt;br /&gt; 访问次数 ：&lt;% out.print(visitCount); %&gt; 删除 Session 数据当处理完一个用户的会话数据后，您可以有如下选择： 移除一个特定的属性： 调用public void removeAttribute(String name) 方法来移除指定的属性。 删除整个会话： 调用public void invalidate() 方法来使整个session无效。 设置会话有效期： 调用 public void setMaxInactiveInterval(int interval) 方法来设置session超时。 登出用户： 支持servlet2.4版本的服务器，可以调用 logout()方法来登出用户，并且使所有相关的session无效。 配置web.xml文件： 如果使用的是Tomcat，可以向下面这样配置web.xml文件： 123&lt;session-config&gt; &lt;session-timeout&gt;15&lt;/session-timeout&gt;&lt;/session-config&gt; 超时以分钟为单位，Tomcat中的默认的超时时间是30分钟。 Servlet中的getMaxInactiveInterval( ) 方法以秒为单位返回超时时间。如果在web.xml中配置的是15分钟，则getMaxInactiveInterval( ) 方法将会返回900。 JSP 文件上传https://www.runoob.com/jsp/jsp-file-uploading.html HTML 代码创建一个文件上传表单。以下几点需要注意： 表单 method 属性应该设置为 POST 方法，不能使用 GET 方法。 表单 enctype 属性应该设置为 multipart/form-data. 表单 action 属性应该设置为在后端服务器上处理文件上传的 Servlet 文件。下面的实例使用了 UploadServlet Servlet 来上传文件。 上传单个文件，您应该使用单个带有属性 type=”file” 的 &lt;input …/&gt; 标签。为了允许多个文件上传，请包含多个 name 属性值不同的 input 标签。输入标签具有不同的名称属性的值。浏览器会为每个 input 标签关联一个浏览按钮。 upload.jsp 文件代码如下： 123456789&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;form method=\"post\" action=\"/TomcatTest/UploadServlet\" enctype=\"multipart/form-data\"&gt;选择一个文件:&lt;input type=\"file\" name=\"uploadFile\" /&gt; &lt;br/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"上传\" /&gt;&lt;/form&gt; 编写后台 Servlet见上方网址 message.jsp 文件代码如下： 123456789101112131415&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;文件上传结果&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;center&gt; &lt;h2&gt;${message}&lt;/h2&gt; &lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 编译和运行 Servlet编译上面的 Servlet UploadServlet，并在 web.xml 文件中创建所需的条目，如下所示： 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:web=\"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" id=\"WebApp_ID\" version=\"2.5\"&gt; &lt;servlet&gt; &lt;display-name&gt;UploadServlet&lt;/display-name&gt; &lt;servlet-name&gt;UploadServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.runoob.test.UploadServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;UploadServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/TomcatTest/UploadServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; JSP 功能JSP 日期第一个构造函数使用当前日期和时间来初始化对象。 1Date() 第二个构造函数接受一个参数，这个参数表示从1970年1月1日凌晨至所要表示时间的毫秒数。 1Date(long millisec) 获取Date对象后，您就能够使用下表列出的所有方法： 序号 方法 &amp; 描述 1 boolean after(Date date)如果比给定的日期晚，则返回true，否则返回false 2 boolean before(Date date)如果比给定的日期早，则返回true，否则返回false 3 Object clone( )获取当前对象的一个副本 4 int compareTo(Date date)如果与给定日期相等，则返回0，如果比给定日期早，则返回一个负数，如果比给定日期晚，则返回一个正数 5 int compareTo(Object obj)与 compareTo(Date) 方法相同，如果 obj 不是Date类或其子类的对象，抛出ClassCastException异常 6 boolean equals(Object date)如果与给定日期相同，则返回true，否则返回false 7 long getTime( )返回从1970年1月1日凌晨至此对象所表示时间的毫秒数 8 int hashCode( )返回此对象的哈希码 9 void setTime(long time)使用给定参数设置时间和日期，参数time表示从1970年1月1日凌晨至time所经过的毫秒数 10 String toString( )将此对象转换为字符串并返回这个字符串 获取当前日期和时间使用JSP编程可以很容易的获取当前日期和时间，使用Date对象的toString()方法 12345&lt;%@ page import=\"java.util.*\" %&gt;&lt;% Date date = new Date(); out.print( \"&lt;h2 align=\\\"center\\\"&gt;\" +date.toString()+\"&lt;/h2&gt;\");%&gt; 运行结果： 1Sat Jun 25 17:54:34 CST 2016 日期比较比较两个日期 使用getTime()方法得到毫秒数，然后比较毫秒数就行了。 使用before()，after()，equals()方法。比如，new Date(99,2,12).before(new Date(99,2,18))返回true。 使用compareTo()方法，这个方法在Comparable接口中定义，在Date中实现。 使用SimpleDateFormat格式化日期SimpleDateFormat使用一种地区敏感的方式来格式化和解析日期，它允许您使用自定义的模式来格式化日期和时间。 1234567&lt;%@ page import=\"java.io.*,java.util.*,javax.servlet.*,java.text.*\" %&gt;&lt;% Date dNow = new Date( ); SimpleDateFormat ft = new SimpleDateFormat (\"yyyy-MM-dd HH:mm:ss\"); out.print( \"&lt;h2 align=\\\"center\\\"&gt;\" + ft.format(dNow) + \"&lt;/h2&gt;\");%&gt; 运行结果： 12016-06-25 17:57:53 SimpleDateFormat格式码要指定模式字符串，需要使用下表列出的格式码： 字符 描述 示例 G 时代标识符 AD y 4位数年份 2001 M 月 July or 07 d 日 10 h 12小时制， A.M./P.M. (1~12) 12 H 24小时制 22 m 分钟 30 s 秒 55 S 毫秒 234 E 星期 Tuesday D 一年中的某天 360 F 一个月中某星期的某天 2 (second Wed. in July) w 一年中的某星期 40 W 一个月中的某星期 1 a A.M./P.M. 标记 PM k 一天中的某个小时 (1~24) 24 K 一天中的某个小时，A.M./P.M. (0~11) 10 z 时区 Eastern Standard Time ‘ 文本分隔 Delimiter “ 单引号 ` JSP 页面重定向123456&lt;%@ page import=\"java.io.*,java.util.*\" %&gt;&lt;% String site = new String(\"http://www.runoob.com\"); response.setStatus(response.SC_MOVED_TEMPORARILY); response.setHeader(\"Location\", site); %&gt; JSP 点击量统计利用应用程序隐式对象和相关方法getAttribute()和setAttribute()来实现 在应用中创建变量的语法： 1application.setAttribute(String Key, Object Value); 读取变量的方法如下： 1application.getAttribute(String Key); 点击量统计实例： 123456789101112131415161718192021&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ page import=\"java.io.*,java.util.*\" %&gt;&lt;% Integer hitsCount = (Integer)application.getAttribute(\"hitCounter\"); if( hitsCount ==null || hitsCount == 0 ) { /* 第一次访问 */ out.println(\"欢迎访问!\"); hitsCount = 1; } else { /* 返回访问值 */ out.println(\"欢迎再次访问!\"); hitsCount += 1; } application.setAttribute(\"hitCounter\", hitsCount);%&gt;&lt;p&gt;页面访问量为: &lt;%= hitsCount%&gt;&lt;/p&gt; 复位计数器使用以上方法，在 web 服务器重启后，计数器会被复位为 0，即前面保留的数据都会消失。可以使用数据库或者文件来保存。 JSP 自动刷新方法的签名如下： 1public void setIntHeader(String header, int headerValue) 自动刷新实例： 1234567891011121314151617181920&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ page import=\"java.io.*,java.util.*\" %&gt;&lt;% // 设置每隔5秒刷新一次 response.setIntHeader(\"Refresh\", 5); // 获取当前时间 Calendar calendar = new GregorianCalendar(); String am_pm; int hour = calendar.get(Calendar.HOUR); int minute = calendar.get(Calendar.MINUTE); int second = calendar.get(Calendar.SECOND); if(calendar.get(Calendar.AM_PM) == 0) am_pm = \"AM\"; else am_pm = \"PM\"; String CT = hour+\":\"+ minute +\":\"+ second +\" \"+ am_pm; out.println(\"当前时间为: \" + CT + \"\\n\");%&gt; 运行结果： 1当前时间为: 6:5:36 PM JSP 发送邮件https://www.runoob.com/jsp/jsp-sending-email.html 发送简单的邮件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;%@ page import=\"java.io.*,java.util.*,javax.mail.*\"%&gt;&lt;%@ page import=\"javax.mail.internet.*,javax.activation.*\"%&gt;&lt;%@ page import=\"javax.servlet.http.*,javax.servlet.*\" %&gt;&lt;% String result; // 收件人的电子邮件 String to = \"abcd@gmail.com\"; // 发件人的电子邮件 String from = \"mcmohd@gmail.com\"; // 假设你是从本地主机发送电子邮件 String host = \"localhost\"; // 获取系统属性对象 Properties properties = System.getProperties(); // 设置邮件服务器 properties.setProperty(\"mail.smtp.host\", host); // 获取默认的Session对象。 Session mailSession = Session.getDefaultInstance(properties); try{ // 创建一个默认的MimeMessage对象。 MimeMessage message = new MimeMessage(mailSession); // 设置 From: 头部的header字段 message.setFrom(new InternetAddress(from)); // 设置 To: 头部的header字段 message.addRecipient(Message.RecipientType.TO, new InternetAddress(to)); // 设置 Subject: header字段 message.setSubject(\"This is the Subject Line!\"); // 现在设置的实际消息 message.setText(\"This is actual message\"); // 发送消息 Transport.send(message); result = \"Sent message successfully....\"; }catch (MessagingException mex) { mex.printStackTrace(); result = \"Error: unable to send message....\"; }%&gt;&lt;% out.println(\"Result: \" + result + \"\\n\");%&gt; 发送给多人： 123void addRecipients(Message.RecipientType type, Address[] addresses)throws MessagingException HTML 邮件、附件见上方网址 JSP 高级教程JSP 标准标签库（JSTL）JSP标准标签库（JSTL）是一个JSP标签集合，它封装了JSP应用的通用核心功能。 JSTL支持通用的、结构化的任务，比如迭代，条件判断，XML文档操作，国际化标签，SQL标签。 除了这些，它还提供了一个框架来使用集成JSTL的自定义标签。 根据JSTL标签所提供的功能，可以将其分为5个类别。 核心标签 格式化标签 SQL 标签 XML 标签 JSTL 函数 JSTL 库安装官方下载地址：http://archive.apache.org/dist/jakarta/taglibs/standard/binaries/ 标签库安装方法：https://www.runoob.com/jsp/jsp-jstl.html 核心标签核心标签是最常用的JSTL标签。 12&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt; 所有标签库请访问上方的标签库网址。 格式化标签用来格式化并输出文本、日期、时间、数字。 12&lt;%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %&gt; 格式化标签用来格式化并输出文本、日期、时间、数字。 12&lt;%@ taglib prefix=\"fmt\" uri=\"http://java.sun.com/jsp/jstl/fmt\" %&gt; SQL标签提供了与关系型数据库（Oracle，MySQL，SQL Server等等）进行交互的标签。 12&lt;%@ taglib prefix=\"sql\" uri=\"http://java.sun.com/jsp/jstl/sql\" %&gt; XML 标签提供了创建和操作XML文档的标签。 12&lt;%@ taglib prefix=\"x\" uri=\"http://java.sun.com/jsp/jstl/xml\" %&gt; JSTL函数JSTL包含一系列标准函数，大部分是通用的字符串处理函数。 12&lt;%@ taglib prefix=\"fn\" uri=\"http://java.sun.com/jsp/jstl/functions\" %&gt; JSP 数据库jar 包下载地址：http://static.runoob.com/download/mysql-connector-java-5.1.39-bin.jar 下载后把 mysql-connector-java-5.1.39-bin.jar 拷贝到 tomcat 下 lib 目录。 创建测试数据在 MySQL 中创建 RUNOOB 数据库，并创建 websites 数据表，表结构如下： 12345678CREATE TABLE `websites` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` char(20) NOT NULL DEFAULT '' COMMENT '站点名称', `url` varchar(255) NOT NULL DEFAULT '', `alexa` int(11) NOT NULL DEFAULT '0' COMMENT 'Alexa 排名', `country` char(10) NOT NULL DEFAULT '' COMMENT '国家', PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8; 插入一些数据： 1INSERT INTO `websites` VALUES ('1', 'Google', 'https://www.google.cm/', '1', 'USA'), ('2', '淘宝', 'https://www.taobao.com/', '13', 'CN'), ('3', '菜鸟教程', 'http://www.runoob.com', '5892', ''), ('4', '微博', 'http://weibo.com/', '20', 'CN'), ('5', 'Facebook', 'https://www.facebook.com/', '3', 'USA'); SELECT 操作123456789101112131415161718192021222324252627&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ page import=\"java.io.*,java.util.*,java.sql.*\"%&gt;&lt;%@ page import=\"javax.servlet.http.*,javax.servlet.*\" %&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\"%&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/sql\" prefix=\"sql\"%&gt;&lt;!-- JDBC 驱动名及数据库 URL 数据库的用户名与密码，需要根据自己的设置 useUnicode=true&amp;characterEncoding=utf-8 防止中文乱码 --&gt;&lt;sql:setDataSource var=\"snapshot\" driver=\"com.mysql.jdbc.Driver\" url=\"jdbc:mysql://localhost:3306/RUNOOB?useUnicode=true&amp;characterEncoding=utf-8\" user=\"root\" password=\"123456\"/&gt; &lt;!-- 查询操作到 result --&gt;&lt;sql:query dataSource=\"${snapshot}\" var=\"result\"&gt; SELECT * from websites;&lt;/sql:query&gt;&lt;!-- 展示查询结果 --&gt;&lt;c:forEach var=\"row\" items=\"${result.rows}\"&gt; ID:&lt;c:out value=\"${row.id}\"/&gt; &lt;br /&gt; 站点名:&lt;c:out value=\"${row.name}\"/&gt; &lt;br /&gt; 站点地址:&lt;c:out value=\"${row.url}\"/&gt; &lt;br /&gt;&lt;/c:forEach&gt; INSERT 操作1234&lt;!-- 插入数据 --&gt;&lt;sql:update dataSource=\"${snapshot}\" var=\"result\"&gt; INSERT INTO websites (name,url,alexa,country) VALUES ('昂昂', 'http://m.baidu.com', 5093, 'CN');&lt;/sql:update&gt; DELETE 操作12345&lt;!-- 删除 ID 为 11 的数据 --&gt;&lt;sql:update dataSource=\"${snapshot}\" var=\"count\"&gt; DELETE FROM websites WHERE Id = ? &lt;sql:param value=\"${11}\" /&gt;&lt;/sql:update&gt; UPDATE 操作1234567&lt;!-- 修改 ID 为 3 的名字为 RUNOOB --&gt;&lt;c:set var=\"SiteId\" value=\"3\"/&gt; &lt;sql:update dataSource=\"${snapshot}\" var=\"count\"&gt; UPDATE websites SET name = 'RUNOOB' WHERE Id = ? &lt;sql:param value=\"${SiteId}\" /&gt;&lt;/sql:update&gt; JSP XML 数据处理发送 XML和发送 HTML 一样，但是需要把页面的context属性设置为text/xml 1&lt;%@ page contentType=\"text/xml\" %&gt; 处理 XML需要将与XML 和XPath相关的两个库文件放在&lt;Tomcat Installation Directory&gt;\\lib目录下： XercesImpl.jar：在这下载http://www.apache.org/dist/xerces/j/ xalan.jar：在这下载http://xml.apache.org/xalan-j/index.html books.xml文件: 123456789101112&lt;books&gt; &lt;book&gt; &lt;name&gt;Padam History&lt;/name&gt; &lt;author&gt;ZARA&lt;/author&gt; &lt;price&gt;100&lt;/price&gt; &lt;/book&gt; &lt;book&gt; &lt;name&gt;Great Mistry&lt;/name&gt; &lt;author&gt;NUHA&lt;/author&gt; &lt;price&gt;2000&lt;/price&gt; &lt;/book&gt;&lt;/books&gt; main.jsp文件： 123456789101112&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;%@ taglib prefix=\"x\" uri=\"http://java.sun.com/jsp/jstl/xml\" %&gt; &lt;c:import var=\"bookInfo\" url=\"http://localhost:8080/books.xml\"/&gt;&lt;x:parse xml=\"${bookInfo}\" var=\"output\"/&gt;&lt;b&gt;The title of the first book is&lt;/b&gt;: &lt;x:out select=\"$output/books/book[1]/name\" /&gt; &lt;br&gt;&lt;b&gt;The price of the second book&lt;/b&gt;: &lt;x:out select=\"$output/books/book[2]/price\" /&gt; 格式化 XML这个是XSLT样式表style.xsl文件： 12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\"?&gt;&lt;xsl:stylesheet xmlns:xsl= \"http://www.w3.org/1999/XSL/Transform\" version=\"1.0\"&gt; &lt;xsl:output method=\"html\" indent=\"yes\"/&gt; &lt;xsl:template match=\"/\"&gt; &lt;html&gt; &lt;body&gt; &lt;xsl:apply-templates/&gt; &lt;/body&gt; &lt;/html&gt; &lt;/xsl:template&gt; &lt;xsl:template match=\"books\"&gt; &lt;table border=\"1\" width=\"100%\"&gt; &lt;xsl:for-each select=\"book\"&gt; &lt;tr&gt; &lt;td&gt; &lt;i&gt;&lt;xsl:value-of select=\"name\"/&gt;&lt;/i&gt; &lt;/td&gt; &lt;td&gt; &lt;xsl:value-of select=\"author\"/&gt; &lt;/td&gt; &lt;td&gt; &lt;xsl:value-of select=\"price\"/&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/xsl:for-each&gt; &lt;/table&gt; &lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt; 这个是main.jsp文件： 123456789101112131415161718192021&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;%@ taglib prefix=\"x\" uri=\"http://java.sun.com/jsp/jstl/xml\" %&gt; &lt;h3&gt;Books Info:&lt;/h3&gt;&lt;c:set var=\"xmltext\"&gt; &lt;books&gt; &lt;book&gt; &lt;name&gt;Padam History&lt;/name&gt; &lt;author&gt;ZARA&lt;/author&gt; &lt;price&gt;100&lt;/price&gt; &lt;/book&gt; &lt;book&gt; &lt;name&gt;Great Mistry&lt;/name&gt; &lt;author&gt;NUHA&lt;/author&gt; &lt;price&gt;2000&lt;/price&gt; &lt;/book&gt; &lt;/books&gt;&lt;/c:set&gt; &lt;c:import url=\"http://localhost:8080/style.xsl\" var=\"xslt\"/&gt;&lt;x:transform xml=\"${xmltext}\" xslt=\"${xslt}\"/&gt; 运行结果如下： img JavaBeanJavaBean是特殊的Java类，使用J ava语言书写，并且遵守JavaBean API规范。 JavaBean与其它Java类相比而言独一无二的特征： 提供一个默认的无参构造函数。 需要被序列化并且实现了Serializable接口。 可能有一系列可读写属性。 可能有一系列的”getter”或”setter”方法。 一个只读的属性只提供getPropertyName()方法，一个只写的属性只提供setPropertyName()方法。 访问 JavaBean&lt;jsp:useBean&gt; 标签可以在JSP中声明一个JavaBean，然后使用。声明后，JavaBean对象就成了脚本变量，可以通过脚本元素或其他自定义标签来访问。 1&lt;jsp:useBean id=\"bean 的名字\" scope=\"bean 的作用域\" typeSpec/&gt; 其中，根据具体情况，scope的值可以是page，request，session或application。id值可任意只要不和同一JSP文件中其它&lt;jsp:useBean&gt;中id值一样就行了。 1234&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;jsp:useBean id=\"date\" class=\"java.util.Date\" /&gt; &lt;p&gt;日期为：&lt;%= date %&gt; 它将会产生如下结果： 1日期为：Tue Jun 28 15:22:24 CST 2016 访问 JavaBean 对象的属性在 &lt;jsp:useBean&gt; 标签主体中使用 &lt;jsp:getProperty /&gt; 标签来调用 getter 方法，使用 &lt;jsp:setProperty /&gt; 标签来调用 setter 方法，语法格式如下： 123456&lt;jsp:useBean id=\"id\" class=\"bean 编译的类\" scope=\"bean 作用域\"&gt; &lt;jsp:setProperty name=\"bean 的 id\" property=\"属性名\" value=\"value\"/&gt; &lt;jsp:getProperty name=\"bean 的 id\" property=\"属性名\"/&gt; ...........&lt;/jsp:useBean&gt; name属性指的是Bean的id属性。property属性指的是想要调用的getter或setter方法。 12345678910111213141516&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;jsp:useBean id=\"students\" class=\"com.runoob.StudentsBean\"&gt; &lt;jsp:setProperty name=\"students\" property=\"firstName\" value=\"小强\"/&gt; &lt;jsp:setProperty name=\"students\" property=\"lastName\" value=\"王\"/&gt; &lt;jsp:setProperty name=\"students\" property=\"age\" value=\"10\"/&gt;&lt;/jsp:useBean&gt;&lt;p&gt;名字:&lt;jsp:getProperty name=\"students\" property=\"firstName\"/&gt; &lt;/p&gt;&lt;p&gt;姓氏: &lt;jsp:getProperty name=\"students\" property=\"lastName\"/&gt;&lt;/p&gt;&lt;p&gt;年龄: &lt;jsp:getProperty name=\"students\" property=\"age\"/&gt;&lt;/p&gt; 访问以上 JSP，运行结果如下： 123名字: 小强姓氏: 王年龄: 10 自定义标签创建 HELLO 标签创建一个自定义标签叫作ex:Hello，标签格式为： 1&lt;ex:Hello /&gt; 要创建自定义的JSP标签，你首先必须创建处理标签的Java类。所以，让我们创建一个HelloTag类，如下所示： 12345678910111213package com.runoob;import javax.servlet.jsp.tagext.*;import javax.servlet.jsp.*;import java.io.*;public class HelloTag extends SimpleTagSupport { public void doTag() throws JspException, IOException { JspWriter out = getJspContext().getOut(); out.println(\"Hello Custom Tag!\"); }} 以下代码重写了doTag()方法，方法中使用了getJspContext()方法来获取当前的JspContext对象，并将”Hello Custom Tag!”传递给JspWriter对象。 编译以上类，并将其复制到环境变量CLASSPATH目录中。最后创建如下标签库：&lt;Tomcat安装目录&gt;webapps\\ROOT\\WEB-INF\\custom.tld。 12345678910&lt;taglib&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;jsp-version&gt;2.0&lt;/jsp-version&gt; &lt;short-name&gt;Example TLD&lt;/short-name&gt; &lt;tag&gt; &lt;name&gt;Hello&lt;/name&gt; &lt;tag-class&gt;com.runoob.HelloTag&lt;/tag-class&gt; &lt;body-content&gt;empty&lt;/body-content&gt; &lt;/tag&gt;&lt;/taglib&gt; 接下来，可以在JSP文件中使用Hello标签： 12&lt;%@ taglib prefix=\"ex\" uri=\"WEB-INF/custom.tld\"%&gt;&lt;ex:Hello/&gt; 以上程序输出结果为： 1Hello Custom Tag! 访问标签体123&lt;ex:Hello&gt; This is message body&lt;/ex:Hello&gt; 修改标签处理类文件，代码如下： 123456789101112131415package com.runoob;import javax.servlet.jsp.tagext.*;import javax.servlet.jsp.*;import java.io.*;public class HelloTag extends SimpleTagSupport { StringWriter sw = new StringWriter(); public void doTag() throws JspException, IOException { getJspBody().invoke(sw); getJspContext().getOut().println(sw.toString()); }} 接下来我们需要修改TLD文件，如下所示： 12345678910&lt;taglib&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;jsp-version&gt;2.0&lt;/jsp-version&gt; &lt;short-name&gt;Example TLD with Body&lt;/short-name&gt; &lt;tag&gt; &lt;name&gt;Hello&lt;/name&gt; &lt;tag-class&gt;com.runoob.HelloTag&lt;/tag-class&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;/tag&gt;&lt;/taglib&gt; 现在我们可以在JSP使用修改后的标签，如下所示: 1234&lt;%@ taglib prefix=\"ex\" uri=\"WEB-INF/custom.tld\"%&gt;&lt;ex:Hello&gt; This is message body&lt;/ex:Hello&gt; 以上程序输出结果如下所示： 1This is message body 自定义标签属性自定义标签类必须实现setter方法， JavaBean 中的setter方法如下所示： 1234567891011121314151617181920212223242526272829303132package com.runoob;import javax.servlet.jsp.tagext.*;import javax.servlet.jsp.*;import java.io.*;public class HelloTag extends SimpleTagSupport { private String message; public void setMessage(String msg) { this.message = msg; } StringWriter sw = new StringWriter(); public void doTag() throws JspException, IOException { if (message != null) { /* 从属性中使用消息 */ JspWriter out = getJspContext().getOut(); out.println( message ); } else { /* 从内容体中使用消息 */ getJspBody().invoke(sw); getJspContext().getOut().println(sw.toString()); } }} 属性的名称是”message”，所以setter方法是的setMessage()。现在让我们在TLD文件中使用的&lt;attribute&gt;元素添加此属性： 12345678910111213&lt;taglib&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;jsp-version&gt;2.0&lt;/jsp-version&gt; &lt;short-name&gt;Example TLD with Body&lt;/short-name&gt; &lt;tag&gt; &lt;name&gt;Hello&lt;/name&gt; &lt;tag-class&gt;com.runoob.HelloTag&lt;/tag-class&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;attribute&gt; &lt;name&gt;message&lt;/name&gt; &lt;/attribute&gt; &lt;/tag&gt;&lt;/taglib&gt; 现在我们就可以在JSP文件中使用message属性了，如下所示： 12&lt;%@ taglib prefix=\"ex\" uri=\"WEB-INF/custom.tld\"%&gt;&lt;ex:Hello message=\"This is custom tag\" /&gt; 以上实例数据输出结果为： 1This is custom tag 还可以包含以下属性： 属性 描述 name 定义属性的名称。每个标签的是属性名称必须是唯一的。 required 指定属性是否是必须的或者可选的,如果设置为false为可选。 rtexprvalue 声明在运行表达式时，标签属性是否有效。 type 定义该属性的Java类类型 。默认指定为 String description 描述信息 fragment 如果声明了该属性,属性值将被视为一个 JspFragment。 以下是指定相关的属性实例： 12345678..... &lt;attribute&gt; &lt;name&gt;attribute_name&lt;/name&gt; &lt;required&gt;false&lt;/required&gt; &lt;type&gt;java.util.Date&lt;/type&gt; &lt;fragment&gt;false&lt;/fragment&gt; &lt;/attribute&gt;..... 如果你使用了两个属性，修改TLD文件，如下所示： 12345678910111213..... &lt;attribute&gt; &lt;name&gt;attribute_name1&lt;/name&gt; &lt;required&gt;false&lt;/required&gt; &lt;type&gt;java.util.Boolean&lt;/type&gt; &lt;fragment&gt;false&lt;/fragment&gt; &lt;/attribute&gt; &lt;attribute&gt; &lt;name&gt;attribute_name2&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;type&gt;java.util.Date&lt;/type&gt; &lt;/attribute&gt;..... JSP 表达式语言JSP表达式语言（EL）使得访问存储在JavaBean中的数据变得非常简单。JSP EL既可以用来创建算术表达式也可以用来创建逻辑表达式。在JSP EL表达式内可以使用整型数，浮点数，字符串，常量true、false，还有null。 一个简单的语法典型的，在JSP标签中指定一个属性值，只需要简单地使用字符串即可： 1&lt;jsp:setProperty name=\"box\" property=\"perimeter\" value=\"${2*box.width+2*box.height}\"/&gt; JSP EL允许指定一个表达式来表示属性值： 1${expr} 其中，expr指的是表达式。在JSP EL中通用的操作符是 . 和 {} 。 当JSP编译器在属性中见到”${}”格式后，它会产生代码来计算这个表达式，并且产生一个替代品来代替表达式的值。 也可以在标签的模板文本中使用表达式语言。比如&lt;jsp:text&gt;标签简单地将其主体中的文本插入到JSP输出中： 123&lt;jsp:text&gt; Box Perimeter is: ${2*box.width + （1+2）*box.height}&lt;/jsp:text&gt; 想要停用对EL表达式的评估的话，需要使用page指令将isELIgnored属性值设为true： 1&lt;%@ page isELIgnored =\"true|false\" %&gt; 这样，EL表达式就会被忽略。若设为false，则容器将会计算EL表达式。 EL中的基础操作符EL表达式支持大部分Java所提供的算术和逻辑操作符： 操作符 描述 . 访问一个Bean属性或者一个映射条目 [] 访问一个数组或者链表的元素 ( ) 组织一个子表达式以改变优先级 + 加 - 减或负 * 乘 / or div 除 % or mod 取模 == or eq 测试是否相等 != or ne 测试是否不等 &lt; or lt 测试是否小于 &gt; or gt 测试是否大于 &lt;= or le 测试是否小于等于 &gt;= or ge 测试是否大于等于 &amp;&amp; or and 测试逻辑与 || or or 测试逻辑或 ! or not 测试取反 empty 测试是否空值 JSP EL中的函数JSP EL允许您在表达式中使用函数。这些函数必须被定义在自定义标签库中。函数的使用语法如下： 1${ns:func(param1, param2, ...)} ns指的是命名空间（namespace），func指的是函数的名称，param1指的是第一个参数，param2指的是第二个参数，以此类推。比如，有函数fn:length，在JSTL库中定义，可以像下面这样来获取一个字符串的长度： 1${fn:length(\"Get my length\")} 要使用任何标签库中的函数，您需要将这些库安装在服务器中，然后使用&lt;taglib&gt;标签在JSP文件中包含这些库。 JSP EL隐含对象JSP EL支持下表列出的隐含对象： 隐含对象 描述 pageScope page 作用域 requestScope request 作用域 sessionScope session 作用域 applicationScope application 作用域 param Request 对象的参数，字符串 paramValues Request对象的参数，字符串集合 header HTTP 信息头，字符串 headerValues HTTP 信息头，字符串集合 initParam 上下文初始化参数 cookie Cookie值 pageContext 当前页面的pageContext 可以在表达式中使用这些对象，就像使用变量一样。 pageContext对象pageContext对象是JSP中pageContext对象的引用。通过pageContext对象，可以访问request对象。比如，访问request对象传入的查询字符串，就像这样： 1${pageContext.request.queryString} Scope对象pageScope，requestScope，sessionScope，applicationScope变量用来访问存储在各个作用域层次的变量。 举例来说，如果需要显式访问在applicationScope层的box变量，可以这样来访问：applicationScope.box。 param和paramValues对象param和paramValues 对象用来访问参数值，通过使用 request.getParameter 方法和 request.getParameterValues 方法。 举例来说，访问一个名为 order 的参数，可以这样使用表达式：${param.order}，或者${param[“order”]}。 如何访问 request 中的 username 参数： 12&lt;%@ page import=\"java.io.*,java.util.*\" %&gt;${param[\"username\"]} param 对象返回单一的字符串，而 paramValues 对象则返回一个字符串数组。 header和headerValues对象header和headerValues对象用来访问信息头，通过使用 request.getHeader方法和request.getHeaders方法。 举例来说，要访问一个名为 user-agent 的信息头，可以这样使用表达式：${header.user-agent}，或者 ${header[“user-agent”]}。 如何访问 user-agent 信息头： 12&lt;%@ page import=\"java.io.*,java.util.*\" %&gt;${header[\"user-agent\"]} header对象返回单一值，而headerValues则返回一个字符串数组。 JSP 异常处理JSP代码中通常有以下几类异常: 检查型异常:检查型异常就是一个典型的用户错误或者一个程序员无法预见的错误。举例来说，如果一个文件将要被打开，但是无法找到这个文件，则一个异常被抛出。这些异常不能再编译期被简单地忽略。 运行时异常:一个运行时异常可能已经被程序员避免，这种异常在编译期将会被忽略。 错误:错误不是异常，但问题是它超出了用户或者程序员的控制范围。错误通常会在代码中被忽略，您几乎不能拿它怎么样。举例来说，栈溢出错误。这些错误都会在编译期被忽略。 使用 Exception 对象exception对象是Throwable子类的一个实例，只在错误页面中可用。下表列出了Throwable类中一些重要的方法: 序号 方法 &amp; 描述 1 public String getMessage()返回异常的信息。这个信息在Throwable构造函数中被初始化 2 public ThrowablegetCause()返回引起异常的原因，类型为Throwable对象 3 public String toString()返回类名 4 public void printStackTrace()将异常栈轨迹输出至System.err 5 public StackTraceElement [] getStackTrace()以栈轨迹元素数组的形式返回异常栈轨迹 6 public ThrowablefillInStackTrace()使用当前栈轨迹填充Throwable对象 JSP提供了可选项来为每个JSP页面指定错误页面。无论何时页面抛出了异常，JSP容器都会自动地调用错误页面。 接下来的例子为main.jsp指定了一个错误页面。使用&lt;%@page errorPage=”XXXXX”%&gt;指令指定一个错误页面。 123456789&lt;%@ page errorPage=\"ShowError.jsp\" %&gt;&lt;% // Throw an exception to invoke the error page if (1 == 1) { throw new RuntimeException(\"Error condition!!!\"); }%&gt; 现在，编写ShowError.jsp文件如下: 1234567891011&lt;%@ page isErrorPage=\"true\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Show Error Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Opps...&lt;/h1&gt; &lt;p&gt;Sorry, an error occurred.&lt;/p&gt; &lt;p&gt;Here is the exception stack trace: &lt;/p&gt; &lt;pre&gt; &lt;% exception.printStackTrace(response.getWriter()); %&gt; 注意到，ShowError.jsp文件使用了&lt;%@page isErrorPage=”true”%&gt;指令，这个指令告诉JSP编译器需要产生一个异常实例变量。 现在试着访问main.jsp页面，它将会产生如下结果: 1234567java.lang.RuntimeException: Error condition!!!......Opps...Sorry, an error occurred.Here is the exception stack trace: 在错误页面使用 JSTL 标签可以利用JSTL标签来编写错误页面ShowError.jsp。这个例子中的代码与上例代码的逻辑几乎一样，但是本例的代码有更好的结构，并且能够提供更多信息: 12345678&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;%@page isErrorPage=\"true\" %&gt;Error: ${pageContext.exception} &lt;br /&gt;URI: ${pageContext.errorData.requestURI} &lt;br /&gt;Status code: ${pageContext.errorData.statusCode} &lt;br /&gt;&lt;c:forEach var=\"trace\" items=\"${pageContext.exception.stackTrace}\"&gt; ${trace} &lt;br /&gt;&lt;/c:forEach&gt; 运行结果如下: jsp-exeception-1 使用 try … catch 块如果您想要将异常处理放在一个页面中，并且对不同的异常进行不同的处理，那么您就需要使用try…catch块了。 12345678910&lt;% try{ int i = 1; i = i / 0; out.println(\"The answer is \" + i); } catch (Exception e){ out.println(\"An exception occurred: \" + e.getMessage()); }%&gt; 运行结果: 1An exception occurred: / by zero JSP 调试System.out.println() JDB Logger J2SE日志框架可为任何运行在JVM中的类提供日志记录服务。因此我们可以利用这个框架来记录任何信息。 使用JDK中的 logger API： 123456789101112131415&lt;%@taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;%@page import=\"java.util.logging.Logger\" %&gt;&lt;% Logger logger=Logger.getLogger(this.getClass().getName());%&gt;&lt;c:forEach var=\"counter\" begin=\"1\" end=\"10\" step=\"1\" &gt; &lt;c:set var=\"myCount\" value=\"${counter-5}\" /&gt; &lt;c:out value=\"${myCount}\"/&gt;&lt;/br&gt; &lt;% String message = \"counter=\" + pageContext.findAttribute(\"counter\") + \" myCount=\" + pageContext.findAttribute(\"myCount\"); logger.info( message ); %&gt;&lt;/c:forEach&gt; 给出stdout.log文件中的一个快照： 123456789101112131415161718192024-Sep-2013 23:31:31 org.apache.jsp.main_jsp _jspServiceINFO: counter=1 myCount=-424-Sep-2013 23:31:31 org.apache.jsp.main_jsp _jspServiceINFO: counter=2 myCount=-324-Sep-2013 23:31:31 org.apache.jsp.main_jsp _jspServiceINFO: counter=3 myCount=-224-Sep-2013 23:31:31 org.apache.jsp.main_jsp _jspServiceINFO: counter=4 myCount=-124-Sep-2013 23:31:31 org.apache.jsp.main_jsp _jspServiceINFO: counter=5 myCount=024-Sep-2013 23:31:31 org.apache.jsp.main_jsp _jspServiceINFO: counter=6 myCount=124-Sep-2013 23:31:31 org.apache.jsp.main_jsp _jspServiceINFO: counter=7 myCount=224-Sep-2013 23:31:31 org.apache.jsp.main_jsp _jspServiceINFO: counter=8 myCount=324-Sep-2013 23:31:31 org.apache.jsp.main_jsp _jspServiceINFO: counter=9 myCount=424-Sep-2013 23:31:31 org.apache.jsp.main_jsp _jspServiceINFO: counter=10 myCount=5 消息可以使用各种优先级发送，通过使用sever()，warning()，info()，config()，fine()，finer()，finest()方法。finest()方法用来记录最好的信息，而sever()方法用来记录最严重的信息。 使用Log4J 框架来将消息记录在不同的文件中，这些消息基于严重程度和重要性来进行分类。 调试工具 NetBeans是树形结构，是开源的Java综合开发环境，支持开发独立的Java应用程序和网络应用程序，同时也支持JSP调试。 NetBeans支持如下几个基本的调试功能： 断点 单步跟踪 观察点 详细的信息可以查看NetBeans使用手册。 使用JDB Debugger 使用注释 浏览器开发者模式 JSP 国际化https://www.runoob.com/jsp/jsp-internationalization.html 解释几个重要的概念： 国际化（i18n）：表明一个页面根据访问者的语言或国家来呈现不同的翻译版本。 本地化（l10n）：向网站添加资源，以使它适应不同的地区和文化。比如网站的印度语版本。 区域：这是一个特定的区域或文化，通常认为是一个语言标志和国家标志通过下划线连接起来。比如”en_US”代表美国英语地区。 JSP容器能够根据request的locale属性来提供正确地页面版本。接下来给出了如何通过request对象来获得Locale对象的语法： 1java.util.Locale request.getLocale() document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.iwxyi.com/tags/学习笔记/"},{"name":"JSP","slug":"JSP","permalink":"http://blog.iwxyi.com/tags/JSP/"}]},{"title":"MFC画图","date":"2018-05-08T02:14:00.000Z","path":"2018/05/08/MFC画图/","text":"MFC在控件上画图 1234567891011121314CStatic* p;p = (CStatic*)GetDlgItem(IDC_STATIC);CRect rcStatic;p-&gt;GetClientRect(&amp;rcStatic);HDC hdc = ::GetDC(*p);HPEN hPen;OLE_COLOR m_colOLE;COLORREF m_colRREF;m_colOLE = RGB(255, 0, 0);OleTranslateColor(m_colOLE, NULL, &amp;m_colRREF);hPen = CreatePen(PS_SOLID, 3, m_colRREF);SelectObject(hdc, hPen);Rectangle(hdc, rcStatic.left, rcStatic.top, rcStatic.right, rcStatic.bottom); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"MFC","slug":"MFC","permalink":"http://blog.iwxyi.com/tags/MFC/"}]},{"title":"MFC常用函数","date":"2018-05-08T02:09:00.000Z","path":"2018/05/08/MFC常用函数/","text":"流程控制12OnOK(); // 确定onCancel(); // 取消 通过ID获取控件对象12GetDlgItem(IDC_DATE)-&gt;EnableWindow(FALSE);m_Date.EnableWindow(TRUE); 可视与可用12345EnableWindow(TRUE); // TRUE可用 / FALSE不可用EnableWindow(FALSW); // 变灰，不可操作ShowWindow(SW_HIDE); // 不可视，SW_HIDE=0ShowWindow(SW_SHOW); // 可视，SW_SHOW=5 弹出信息框12345AfxMessageBox(\"Hello World!\");CString msg;m_cb.GetLBText(m_cb.GetCurSel(), msg);AfxMessageBox(msg); 获取现行日期时间123CTime tNow = CTime::GetCurrentTime();CString date = tNow.Format(\"%y.%m.%d\"); // 日期CString time = tNow.Format(\"%I:%M:%S\"); // 时间（小时是I而不是H） 定时器123456789SetTimer(1,100,NULL); // 参数1：定时器ID，参数2：间隔void CEx9_9Dlg::OnTimer(UINT nIDEvent) { if(nIDEvent == 1){ // 定时器的ID ... if(...) KillTimer(nIDEvent); // 结束进程 }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"MFC","slug":"MFC","permalink":"http://blog.iwxyi.com/tags/MFC/"}]},{"title":"Win32 SDK游戏循环","date":"2018-05-08T02:02:00.000Z","path":"2018/05/08/Win32-SDK游戏循环/","text":"其实就是 Windows 消息循环 12345678910111213141516//消息循环GetMessage(&amp;msg, NULL, NULL, NULL); //初始化msgwhile( msg.message != WM_QUIT ){ if( PeekMessage( &amp;msg, NULL, 0, 0 , PM_REMOVE) ) { TranslateMessage( &amp;msg ); DispatchMessage( &amp;msg ); } else { tNow = GetTickCount(); if(tNow - tPre &gt;= 40) MyPaint(hdc); }} 1tPre = GetTickCount(); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Win32 SDK","slug":"Win32-SDK","permalink":"http://blog.iwxyi.com/tags/Win32-SDK/"},{"name":"游戏开发","slug":"游戏开发","permalink":"http://blog.iwxyi.com/tags/游戏开发/"}]},{"title":"Win32 SDK加载位图","date":"2018-05-08T01:52:00.000Z","path":"2018/05/08/Win32-SDK加载位图/","text":"初始化位图 1234hMemDC = CreateCompatibleDC(hdc);hBitmap = LoadBitmap(hInst, \"mybmp\");SelectObject(hMemDC, hBitmap);GetObject(hBitmap, sizeof(BITMAP), &amp;bitmap); 绘制位图 1BitBlt(hdc, bmx, bmy, bitmap.bmWidth, bitmap.bmHeight, hMemDC, 0, 0, SRCCOPY); 1234567891011121314151617181920212223242526272829303132LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam){ HDC hdc; PAINTSTRUCT ps; RECT rect; static HDC hMemDC; static HBITMAP hBitmap; static BITMAP bitmap; switch(message) { case WM_CREATE : // 初始化 hdc = GetDC(hWnd); hMemDC = CreateCompatibleDC(hdc); hBitmap = LoadBitmap(hInst, \"mybmp\"); SelectObject(hMemDC, hBitmap); GetObject(hBitmap, sizeof(BITMAP), &amp;bitmap); ReleaseDC(hWnd, hdc); break; case WM_PAINT : // 重绘 hdc = BeginPaint(hWnd, &amp;ps); GetClientRect(hWnd, &amp;rect); BitBlt(hdc, bmx, bmy, bitmap.bmWidth, bitmap.bmHeight, hMemDC, 0, 0, SRCCOPY); EndPaint(hWnd, &amp;ps); break; case WM_DESTROY : // 析构 DeleteObject(hBitmap); ReleaseDC(hWnd, hMemDC); PostQuitMessage(0); break; }} 两张/多张位图 12345hBitmap = (HBITMAP)LoadImage(NULL,\"mybmp.bmp\",IMAGE_BITMAP,800,800,LR_LOADFROMFILE);hBitmap2 = (HBITMAP)LoadImage(NULL,\"mybmp2.bmp\",IMAGE_BITMAP,50,50,LR_LOADFROMFILE);SelectObject(hMemDC, hBitmap);GetObject(hBitmap, sizeof(BITMAP), &amp;bitmap);GetObject(hBitmap2, sizeof(BITMAP), &amp;bitmap2); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Win32 SDK","slug":"Win32-SDK","permalink":"http://blog.iwxyi.com/tags/Win32-SDK/"}]},{"title":"VC++工具使用","date":"2018-05-08T01:37:00.000Z","path":"2018/05/08/VC-工具使用/","text":"快捷键：在Button标题处使用&amp;，例如：&amp;Enable快捷键为alt+E，Enable &amp;Again快捷键为alt+A 单选框：按照创建顺序会有一个默认的编号，然后每组第一个radio属性的组设为True，其余radio不做变动。有组的radio显示在类向导里面，并且可以关联int变量，直接初始化成其他值 复制控件：看另外一篇 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"VC++","slug":"VC","permalink":"http://blog.iwxyi.com/tags/VC/"}]},{"title":"VC++菜单操作","date":"2018-05-08T01:16:00.000Z","path":"2018/05/08/VC-菜单操作/","text":"123hmenu = GetMenu(hWnd);haddmenu = CreateMenu();AppendMenu(haddmenu, MF_ENABLED, 4, \"求和\"); 1234567891011121314151617181920212223242526272829LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam){ HMENU hmenu, haddmenu/*添加的菜单句柄*/; switch(message) { case WM_COMMAND : switch (LOWORD(wParam)) { case 1 : // 添加菜单项 hmenu = GetMenu(hWnd); haddmenu = CreateMenu(); AppendMenu(haddmenu, MF_ENABLED, 4, \"求和\"); AppendMenu(haddmenu, MF_ENABLED, 5, \"求差\"); InsertMenu(hmenu, 2, MF_POPUP | MF_BYPOSITION, (UINT)haddmenu, \"统计计算\"); EnableMenuItem(hmenu, 1, MF_GRAYED); EnableMenuItem(hmenu, 2, MF_ENABLED); DrawMenuBar(hWnd); break; case 2 : // 删除菜单项 hmenu = GetMenu(hWnd); DeleteMenu(hmenu, 2, MF_BYPOSITION); EnableMenuItem(hmenu, 1, MF_ENABLED); EnableMenuItem(hmenu, 2, MF_GRAYED); DrawMenuBar(hWnd); break; } break; }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"VC++","slug":"VC","permalink":"http://blog.iwxyi.com/tags/VC/"}]},{"title":"VC++使用RC文件","date":"2018-05-07T12:39:00.000Z","path":"2018/05/07/VC-使用RC文件/","text":"文件导入的资源（BITMAP， ICON， HTML， FONT， CURSOR）举例： .rc文件 :#include&lt;windows.h&gt; #include”resource.h” IDI_ICON1 ICON “dlgapp.ico” //ICON RESOURCE Resource.h文件:#define IDI_ICON1 1001 注册窗口类:wcs.hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_ICON1)); 对话框资源见图： 对应的.rc文件：123456789101112IDD_DIALOG1 DIALOG DISCARDABLE 0, 0, 187, 94STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENUCAPTION \"对话\"FONT 10, \"System\"_BEGIN_ DEFPUSHBUTTON \"确定\",IDOK,130,7,50,14 PUSHBUTTON \"取消\",IDCANCEL,130,24,50,14_END_ 对应resource.h:#define IDD_DIALOG1 102 对应的.cpp文件：123456voidOnNoModel(HWND hWnd){ HWND hDlg = CreateDialog(g_hInstance,//根据资源创建对话框 MAKEINTRESOURCE(IDD_DIALOG1),hWnd, MyDialogProc); ShowWindow(hDlg,1);//需要显示对话框} 菜单资源：(当然，菜单不使用资源也可以创建的～用命令创建的感觉和QT用命令创建很相似，本文不涉及) 对应的.rc文件：12345678910111213#include\"resource.h\"#include&lt;windows.h&gt;IDR_MENU1 _MENU_ //MENU RESOURCE_BEGIN_ POPUP \"File\" // POPUP RESOURCE _BEGIN_ MENUITEM \"&amp;Open\", ID_FILE_OPEN // MENUITEM STATEMENT MENUITEM \"&amp;Save\", ID_FILE_SAVE // MENUITEM STATEMENT MENUITEM SEPARATOR // MENUITEM STATEMENT MENUITEM \"E&amp;xit\", ID_FILE_EXIT // MENUITEM STATEMENT _END__END_ 对应的resource.h文件：#define IDR_MENU1 1001 #define ID_FILE_OPEN 1003 #define ID_FILE_SAVE 1004 #define ID_FILE_EXIT 1005 对应的.cpp文件：wcs.lpszMenuName = MAKEINTRESOURCE(IDR_MENU1); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"VC++","slug":"VC","permalink":"http://blog.iwxyi.com/tags/VC/"}]},{"title":"Win32 SDK事件响应","date":"2018-05-07T02:17:00.000Z","path":"2018/05/07/Win32-SDK事件响应/","text":"按键响应 1234567891011121314151617181920212223242526272829303132LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam){ switch(message) { case WM_CHAR : if (wParam == 'r') // r { ; } else if (wParam == 'r'-96) // ctrl+r { ; } else if (wParam == 'B') // shift+b { ; } break; case WM_KEYDOWN : if (wParam == VK_UP) // UP键 { ; } else if (wParam == VK_CONTROL) // Ctrl键 { ; } break; case WM_KEYUP : // 按键弹起 ; }} 鼠标响应123456789101112131415161718LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam){ switch(message) { case WM_MOUSEMOVE : // 鼠标移动 x = LOWORD(lParam); y = HIWORD(lParam); break; case WM_LBUTTONDBLCLK : // 左键单击 ; case WM_LBUTTONDOWN : // 左键按下 ; case WM_LBUTTONUP : // 左键弹起 ; case WM_RBUTTONDOWN : // 右键按下 ; }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Win32 SDK","slug":"Win32-SDK","permalink":"http://blog.iwxyi.com/tags/Win32-SDK/"}]},{"title":"MFC编辑框","date":"2018-05-07T02:08:00.000Z","path":"2018/05/07/MFC编辑框/","text":"12345m_Edit1.SetSel(0,-1); //表示选中编辑框IDC_EDIT1中的全部内容。m_Edit1.ReplaceSel(\"\"); //用空字符串代替所选中的文本，即把所选的文本删除掉m_Edit1.Copy(); //将m_Editl编辑框中所选的内容拷贝到剪贴板上m_Edit2.Paste(); //将剪贴板中的内容粘贴到m_Edit2编辑框中m_Edit1.Undo(); // Undo（）函数是CEdit类中的成员函数，表示取消编辑框中上一次操作 数值与控件转换IDC_EDIT1 绑定int变量 m_A 123456UpdateData(TRUE); // 刷新成数值int i=m_A*m_B;m_Result.Format(\"%d\", i);UpdateData(FALSE); // 刷新回控件 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"MFC","slug":"MFC","permalink":"http://blog.iwxyi.com/tags/MFC/"}]},{"title":"Win32 SDK列出目录下子文件","date":"2018-05-07T01:55:00.000Z","path":"2018/05/07/Win32-SDK列出目录下子文件/","text":"123456DWORD cchCurDir = MAX_PATH; // long类型，最大目录字符长度LPTSTR lpszCurDir; // 指针类型CHAR tchBuffer[MAX_PATH]; // char类型lpszCurDir = tchBuffer; GetCurrentDirectory(cchCurDir, lpszCurDir); // 获取运行目录DlgDirList(lpszCurDir, IDC_LIST_DIR, IDC_STATIC_DIR, 0); // 将目录展示到List 显示List的Item并删除 123456int i = m_list.GetCurSel();CString str;m_list.GetText(i, str); // 获取文字m_list.DeleteString(i); // 删除列表CString msg = \"Item \"+str+\" deleted!\";AfxMessageBox(msg); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Win32 SDK","slug":"Win32-SDK","permalink":"http://blog.iwxyi.com/tags/Win32-SDK/"}]},{"title":"MFC函数总结","date":"2018-05-07T00:43:00.000Z","path":"2018/05/07/MFC函数总结/","text":"1、MFC编辑框、静态文本框相关的常用函数 《1》GetDlgItemText(ID ,str) 作用：从对话框中获取文本 第一个参数为要获取的编辑框(或者静态文本框、单选按钮等可以显示内容的控件)的ID，第二个参数为字符串(Cstring 类型)的变量，获取的文本存储在str中。 《2》SetDlgItemText(ID,str) 作用：将字符串显示在控件中 第一个参数为要显示的编辑框(或者静态文本框、单选按钮、组合框等可以显示内容的控件)的ID，第二个参数为字符串(Cstring 类型)的变量，显示的文本存储在str中。如果要显示的变量的类型不是Cstring，则通过Format函数强制转换。 通常还要加一个UpDateData(FALSE)。 《3》UINT nID=GetCheckedRadioButton(IDC1, IDC2); 作用：获取单选框的选项的ID 第一个参数为该组合框中第一个单选按钮的ID，第二个参数为该组合框中最后一个按钮的ID。 《4》CheckRadioButton(IDC1, IDC2, IDC3); 作用：初始化单选按钮 第一个参数为该组合框中第一个单选按钮的ID，第二个参数为该组合框中最后一个按钮的ID，第三个参数为为缺省选项的ID。 《5》m_scrollBar.SetScrollRange(0, 500) ; 作用：设置水平滚动条的取值范围，m_scrollBar为水平滚动条的控制类型的变量，0为设置最小值，500为设置的最大值。 《6》m_nAmount = m_slider.GetPos() ; 作用：获取滑块的当前位置。 《7》m_slider.SetRange(0,1000) ; 作用：设置滑块取值范围 第一个参数为设置的最小值，第二个参数为设置的最大值。 《8》double Volum = atof(strCtrl); 作用：将字符串strCtl转换成浮点型的Volum 《9》int Volum = atof(strCtrl); 作用：将字符串strCtl转换成整型的Volum 《10》MessageBox(str) ;（局部函数） 作用：输出字符串str 《11》AfxMessageBox(str) ;（全局函数） 作用：输出字符串str 《12》tempt = m_time2.Format(\"%H:%m:%S\") ; 作用：将时间转化成字符型（时、分、秒） m_time2为日历时间选取器的变量，tempt为CString型变量 《13》tempt = m_time.Format(\"%Y-%m-%d\") ;//将时间转化成字符型 作用：将时间转化成字符型（年、月、日） m_time2为日历时间选取器的变量，tempt为CString型变量 《14》m_time = CTime::GetCurrentTime(); 作用：获取系统当前时间 m_time为Ctime类型的变量。 《15》m_list.AddString(str); 功能：将Cstrig类型的变量的内容显示在列表框中(或者组合框中)。 m_str为ClistBox类型的变量（或者是CcomboBox类型的变量）。 《16》m_time = CTime(2012 ,5 ,28 ,0 ,0 ,0) ; 功能：初始化日期 m_time为Ctime类型的变量 《17》str.TrimLeft(); 功能：去掉Cstring类型变量的左边的空格 《18》str.TrimRight(); 功能：去掉Cstring类型变量的右边的空格 《19》str.IsEmpty(); 功能：判断Cstring类型的变量str是否为空，如果为空则返回1，否则返回零。 《20》int nIndex=m_list.FindString(int k,str); 功能：列表框中查找与str匹配的列表项，m_list为ClistBox类型变量。 从第k个位置开始查找，若为-1，则从头至尾查找。 函数原型： int FindString(int nStartAfter,LPCTSTR lpszItem) const; int FindStringExact(int nIndexStart,LPCTSTR lpszFind) const; 其中，FindStringExact的查找精度最高 《21》m_list.ResetContent() ; 功能：清空列表框中的内容 m_list为ClistBox类型变量。 《22》m_listSearch.DeleteString(int nIndex); 功能：删除列表框中的第nIndex条记录。 m_listSearch为ClistBox类型变量。 《23》GetDlgItem(IDC_BUTTON_DELETE)-&gt;EnableWindow(FALSE); 功能：是ID为IDC_BUTTON_DELETE的按钮灰选。 《24》GetDlgItem(IDC_BUTTON_DELETE)-&gt;EnableWindow(TRUE); 功能：是ID为IDC_BUTTON_DELETE的按钮还原。 《25》str.Left(length); 功能：获取字符串str左边长度为length的值。 《26》int length = str.GetLength() ; 功能：获取字符串str的长度 《27》dlg.DoModal() ; 功能：建立一个对话框 dlg为该对话框的类的对象。 《28》CDialog::OnCancel(); 功能：关闭窗口 《29》CMenu* pSysMenu=GetMenu(); 功能：获取程序菜单指针 《30》int nCount=pSysMenu-&gt;GetMenuItemCount(); 功能：获取项层菜单项的项数 《31》int nIndex=m_ListBox.GetCurSel(); 功能：获取指针在列表框中的位置 m_ListBox为ClistBox类型变量。 《32》GetWindowText(str) ; 功能：获取当前窗口的标题 Str为Cstring 类型的变量 《33》GetDlgItem(IDC_CLICKHERE)-&gt;SetFocus(); 将光标设置在控件IDC_CLICKHERE处,若是在打开某个对话框时候做此设置，则将该语句加到消息处理函数OnInitDialog的return语句前，并且将最后的语句 return TRUE; 该为 return FALSE; GetDlgItem(IDC_CLICKHERE)-&gt;SetFocus();也可写成m_strit.SetFocus(); 其中m_strit为该控件对应的变量。 《34》GetDlgItem(IDC_STATIC_NUMBER1) 功能：获取ID为IDC_STATIC_NUMBER1控件的指针. 例如： 123CString str ;GetDlgItem(IDC_STATIC_NUMBER1)-&gt;GetWindowText(str) ;//此句等价于GetDlgItemText(IDC_STATIC_NUMBER1,str); 《35》int num1 = GetDlgItemInt(IDC_EDIT1); 功能：获取ID为IDC_EDIT1控件的文本并且转化成整形的值，如果文本中含有非数字字符则转化失败. 《36》SetDlgItemInt(IDC_EDIT3,num3) ; 功能：将整数num3显示在ID为IDC_EDIT3的编辑框中. 《37》::SendMessage(GetDlgItem(IDC_EDIT1)-&gt;m_hWnd,WM_GETTEXT,10,(LPARAM)ch1); 注意：在函数前面加上作用域分节符表示调用的是全局函数. 功能：取ID为IDC_EDIT1控件的文本,获取的最大长度为10，并且将获取的内容存储在ch1中.相当于GetDlgItemText(IDC_EDIT1,ch1,10); 说明：第一个参数为对应控件的句柄，第二个参数为消息名称，第三个参数为获取文本的最大长度，第四个参数为存储文本的缓冲区，此处ch1为字符数组,即 char ch1[10];第四个参数的类型必须强制转换成LPARAM. 此函数有多种调用方式，其功能是相同的。列举如下： (1) ::SendMessage(GetDlgItem(IDC_EDIT1)-&gt;m_hWnd,WM_GETTEXT,10,(LPARAM)ch1); (2) GetDlgItem(IDC_EDIT1)-&gt;SendMessage(WM_GETTEXT,10,(LPARAM)ch1); (3) m_edit1.SendMessage(WM_GETTEXT,10,(LPARAM)ch1); (4) ::SendMessage(m_edit1.m_hWnd,WM_GETTEXT,10,(LPARAM)ch1); 其中m_edit1是IDC_EDIT1控件的类别为Control，类型为CEdit的变量. 《38》::SendMessage(GetDlgItem(IDC_EDIT3)-&gt;m_hWnd,WM_SETTEXT,0,(LPARAM)ch3); 功能：将缓冲区ch3的内容显示在D为IDC_EDIT1控件上.其作用相当于SetDlgItemText(IDC_EDIT1,ch1); 说明：第一个参数为对应控件的句柄，第二个参数为消息名称，第三个参数用不上，故设置为零，第四个参数为要显示的文本内容, 第四个参数的类型必须强制转换成LPARAM. 《39》SendDlgItemMessage(IDC_EDIT1,WM_GETTEXT,10,(LPARAM)ch1); 功能等价于::SendMessage(GetDlgItem(IDC_EDIT1)-&gt;m_hWnd,WM_GETTEXT,10,(LPARAM)ch1); 《40》SendDlgItemMessage(IDC_EDIT3,WM_SETTEXT,0,(LPARAM)ch3); 功能等价于::SendMessage(GetDlgItem(IDC_EDIT3)-&gt;m_hWnd,WM_SETTEXT,0,(LPARAM)ch3); 2、常用函数（比较全） WinExec() ExitWindowsEx() GlobalMemoryStatus() GetSystemInfo() GetSystemDirectory() GetWindowsDirectory() GetTaskmanWindow() user32.dll中 获取任务栏窗口句柄 OpenProcessToken() 打开一个进程的访问令牌 GetCurrentProcess() 获取本进程句柄 LookupPrivilegeValue() 修改进程权限 AdjustTokenProvileges() 通知WindowsNT修改本进程权利 CreateRectRgn() CreateEllipticRgnIndirect() PtInRegion() CommandToIndex() ID号转换为索引值 菜单类: DrawMenuBar() 重画菜单 SetDefaultItem() 设置默认菜单项 CheckMenuItem()设置菜单项Check状态 CreatePopupMenu()创建弹出菜单 窗口类: MoveWindow() Invalidate()使窗口无效,窗口无效时会进行窗口重绘 GetParent() 获得窗口的父窗口句柄 BringWindowToTop()把窗口放到顶部 SetWindowPos() DeferWindowPos() SetActiveWindow()激活顶层窗口 Set/GetForegroundWindow() 设置/获取前台窗口,返回句柄 Set/GetWindowLong()改变窗口属性 GetNextWindow()获取下一个窗口句柄 GetWindow() 获取窗口句柄 FromHandle() 通过句柄获取指针 AfxGetInstanceHandle()获取程序当前实例句柄 AfxRegisterWndClass() Set/GetClassLong() Set/GetWindowLong() GetWindowRect()获取窗口在屏幕中的Rect 对话框: GetDlgItem() Set/GetDlgItemText() Set/GetDlgItemInt() Set/GetDlgItem() SendDlgItemMessage() SetFocus()文本编辑框Edit控件若要响应回车按键消息，必须设置为多行类型 GetNextDlgTabItem()获取下一个有TABStop属性的控件句柄 OnCtlColor() WM_CTLCOLOR窗口绘制消息响应函数 GetDlgCtrlID() SetButtonText()设置按钮文本CreateRectRgn GetStartPosition() GetNextPathName() SetHorizontalExtent() SHBrowseForFolder() 属性表单: SetWizardMode() SetWizardButtons() OnSetActive() 工具栏: RecalcLayout() ShowControlBar() 状态栏: CommandToIndex() 根据ID号获取索引值 SetMessageText() GetMessageBar() GetDescendantWindow() 图形类 OnEraseBkgnd() CButton::DrawItem() SetBkMode()设置文字背景 SetTextColor() SetBkColor() SetROP2() SetClipRtn() DrawText() BeginPath() EndPath() BeginPaint() EndPaint() GetTextExtend() SetWorldTransform() GetDeviceCaps() Set/GetViewportOrg() Set/GetWindowOrg() DPtoLP()将设备坐标点转换为逻辑坐标点 LPtoDP()将逻辑坐标点转换为设备坐标点 DeleteMetaFile() CopyMetaFile() GetMetaFile() GetEnhMetaFile() 123456void CView::OnPaint(){ CPaintDC dc(this); OnPrepareDC(&amp;dc); OnDraw(&amp;dc);} 文件操作: EncryptFile() CreateFile() ReadFile() WriteFile() SetFilePointer() ::WriteProfileString() 向win.ini写入相关信息 ::GetProfileString() 从win.ini获取相关信息 CWinApp::WriteProfileString()向注册表中写入相关信息 CWinApp::GetProfileString() 从注册表中获取相关信息 ::WritePrivateProfileString() RegCreateKeyEx()创建注册表项 RegCloseKey()关闭注册表项 RegOpenKeyEx() 打开注册表项 RegSetValueEx() 写入注册表项 RegQueryValueEx() 读取注册表项 RegEnumKeyEx() RegDeleteKey() 文档视图: 钩子: SetWindowsHookEx() CallNextHookEx() UnhookWindowsHookEx() GetCurrentThreadID() GetModuleHandle() 动态库: #pragma data_seg() #pragma comment(linker,\"/section:XXX,RWS\") R可读W可写S共享 SEGMENTS XXX READ WRITE SHARED MAKEINTRESOURCE() GetProcAddress()获取函数地址 LoadLibrary()加载Dll FreeLibrary()减少Dll的引用计数 多线程: CreateThread() CloseHandle() 互斥: CreateMutex() ReleaseMutex() WaitForSingleObject() 事件: CreateEvent() SetEvent() 设置有信号状态 ResetEvent() 设置无信号状态 临界区: EnterCriticalSection() InitializeCriticalSection() LeaveCriticalSection() DeleteCriticalSection() 异步套接字: WSAAsyncSelect() 为一个套接字请求网络消息通知 WSAEnumProtocols()检索可用的网络通信协议 WSASocket() 剪贴板: OpenClipboard() 打开剪贴板 CloseClipboard()关闭剪贴板 EmptyClipboard()清空剪贴板 SetClipboardData() GetClipboardData() GlobalAlloc() GlobalLock() GlobalUnlock() IsClipboardFormatAvailable() 匿名管道: CreatePipe() CreateProcess() CreateFile() ReadFile() WriteFile() 命名管道: CreateNamedPipe() ConnectNamedPipe() WaitNamedPipe() CreateFile() ReadFile() WriteFile() 邮槽: CreateMailslot() 多媒体: mciSendCommand() &lt;mmsystem.h&gt; 窗口、控件的指针和句柄的相互转化 1指针转化为句柄 在MFC应用程序中首先要获得窗口的指针，然后将其转化为句柄 12CWnd* pWnd;HANDLE hWnd = pWnd-&gt;GetSafeHwnd(); 2句柄转化为指针 在MFC应用程序中首先获得对话框控件的句柄，然后获得其指针 123HANDLE hWnd;GetDlgItem(IDC_xxx,&amp;hWnd);CWnd * pWnd = FromHandle(hWnd); 获得程序窗口指针的办法 1获得主框架窗口指针(任何时候都可以用，只要是MFC程序中) CWnd* pWnd = AfxGetMainWnd(); 2获得对话框中控件指针 CWnd* pWnd = GetDlgItem(IDC_xxx); 3获得对话框中某控件的句柄 HANDLE GetDlgItem(m_hDLG,m_nID_DlgItem); 4获得GDI对象的句柄 HANDLE m_hGDIObj = m_pGDIObj-&gt;GetSafeHanle(); 1. 如何获取应用程序的 实例句柄? AfxGetInstanceHandle() 应用程序的 实例句柄保存在`CWinAppIm_hInstance` 中,可以这么调用 `AfxGetInstancdHandle`获得句柄. `Example: HANDLE hInstance=AfxGetInstanceHandle();`2. 如何通过代码获得应用程序主窗口的 指针? AfxGetMainWnd GetSafeHwnd() AfxGetAppName() `AfxGetThread`` 主窗口的 指针保存在`CWinThread::m_pMainWnd`中,调用 `AfxGetMainWnd`实现。 【例】 AfxGetMainWnd() -&gt;ShowWindow(SW_SHOWMAXMIZED); //使程序最大化. 【例】此例的主窗口是对话框，下面的代码是在另外一个CFileTreeCtrl 类（子窗）中相关函数实现在主对话框（主窗）中的几个 静态文本框（子窗）中显示路径： 12345678910111213141516CWnd* m_pCWnd= AfxGetMainWnd(); //得到主窗口指针,通过主窗指针访问其他子窗资源//方法一m_pCWnd-&gt;SetDlgItemText(IDC_STATIC_path,\"CWnd* \"+m_sCurPath); //在主窗中的子窗（ID：IDC_STATIC_path）中显示字符串m_pCWnd-&gt;SetDlgItemText(IDC_STATIC_who,\"路径显示由FileTreeCtrl类完成：\");//方法二m_pCWnd-&gt;SendMessage(STN_CLICKED); //向主窗口发送一个消息,显示任务由主窗完成。//在主窗的.cpp中有：ON_MESSAGE(STN_CLICKED, OnSTATICpath3)相关描述&nbsp;//有的函数必须通过窗口的 句柄 来访问，我们可以使用下面的方法三//CWnd::GetSafeHwnd&nbsp;//Returns the window handle for a window//HWND GetSafeHwnd( ) const;HWND m_hWnd_tree =GetSafeHwnd();//【注】此处得到的只是当前窗口（FileTree类）的句柄HWND m_hWnd = m_pCWnd-&gt;GetSafeHwnd();// 这里才是主窗口的句柄（由主窗指针得到主窗的句柄）//BOOL SetWindowText( HWND hWnd, LPCTSTR lpString )::SetWindowText(m_hWnd,\"ok2222\");//修改主窗口标题::SetDlgItemText(m_hWnd,IDC_STATIC_path2,\"HWND: \"+m_sCurPath); 【另】AfxGetThread `CWinThread* AfxGetThread( );` Return Value：Pointer to the currently executing thread. 3. 如何在程序中获得其他程序的 图标? AfxGetInstanceHandle() HINSTANCE AfxGetInstanceHandle( ); Return Value An HINSTANCE to the current instance of the application. If called from within a DLL linked with the USRDLL version of MFC, an HINSTANCE to the DLL is returned. Remarks This function allows you to retrieve the instance handle of the current application. AfxGetInstanceHandle always returns the HINSTANCE of your executable file (.EXE) unless it is called from within a DLL linked with the USRDLL version of MFC. In this case, it returns an HINSTANCE to the DLL. 两种方法: (1) SDK函数 `SHGetFileInfo` 或使用 ExtractIcon获得图标资源的 handle(句柄), (2) SDK函数 `SHGetFileInfo`获得有关文件的 很多信息,如大小图标,属性,类型等. Example(1): 在程序窗口左上角显示 NotePad图标.12345678void CSampleView: OnDraw(CDC * pDC){ if( :: SHGetFileInfo(_T(\"c:\\\\pwin95\\\\notepad.exe\"),0, &amp;stFileInfo,sizeof(stFileInfo),SHGFI_ICON)) { pDC -&gt;DrawIcon(10,10,stFileInfo.hIcon); }} Example(2):同样功能,Use ExtractIcon Function1234567void CSampleView:: OnDraw(CDC *pDC){ HICON hIcon=:: ExtractIcon(AfxGetInstanceHandle(),_T (\"NotePad.exe\"),0); if (hIcon &amp;&amp;hIcon!=(HICON)-1) pDC-&gt;DrawIcon(10,10,hIcon);} 【说明】关于如何得到系统文件的正确路径，象win.ini system32.ini等的路径，各种系统中具体的路径是不一样的。如： 获得notepad.exe的路径正规上来说用`GetWindowsDirectory` 函数得到； 如果是调用 win95下的画笔，应该用访问注册表的方法获得其路径； 要作成一个比较考究的程序，考虑应该全面点. 【另】 `HINSTANCE AfxGetResourceHandle( );` Return Value：An HINSTANCE handle where the default resources of the application are loaded. 4. 有关取得桌面句柄 GetDesktopWindow() MSDN中的例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 静态函数CWnd:: GetDesktopWindow 返回桌面窗口的指针。下例说明了MFCvoid CFrameWnd::BeginModalState (){ //first count all windows that need to be disabled UINT nCount=0; HWND hWnd=:: GetWindow (:: GetDesktopWindow (), GW_CHILD); while (hWnd!=NULL) { if (:: IsWindowEnabled (hwnd) &amp;&amp; CWnd::FromHandlePermanent (hWnd)!=NULL &amp;&amp; AfxIsDescendant (pParent-&gt;m_hWnd, hWnd) &amp;&amp; :: SendMessage (hWnd, WM_DISABLEMODAL, 0, 0) == 0) { ++nCount; } hWnd=:: GetWindow (hWnd, GW_HWNDNEXT); }}&nbsp;//用户的问题：下面程序取的不是同一程序的句柄,但是GetModuleFileName返回的结果一样请问为什莫&nbsp;HWND ChWnd;//子窗口句柄&nbsp;HWND hwDesktop=::GetDesktopWindow();//取得桌面句柄&nbsp;ChWnd=::GetWindow(hwDesktop,GW_CHILD);//取得桌面子句柄&nbsp;CString csTitle,csClass,csTm,mLookstring;&nbsp;char szBuffer[255];&nbsp;while(ChWnd!=NULL)//循环取子句柄的同级句柄&nbsp;{ if(::IsWindowVisible(ChWnd))//判断是否为可显示窗口&nbsp; {&nbsp; ::GetWindowText(ChWnd,csTitle.GetBuffer(255),254);&nbsp; ::GetClassName(ChWnd,csClass.GetBuffer(255),254);&nbsp; csTitle.ReleaseBuffer();//标题&nbsp; csClass.ReleaseBuffer();//类名&nbsp; csTm.Format(\"%08X:\",ChWnd);&nbsp; if(csTitle==\"\")&nbsp; {&nbsp; mLookstring=csTm+csClass;&nbsp; }else&nbsp; {&nbsp; mLookstring=csTm+csTitle;&nbsp; }&nbsp; //这里的窗口句柄不是同一个程序吧?（问题所在！）可是为什莫结果一样&nbsp; HINSTANCE hInstance = (HINSTANCE)::GetWindowLong(ChWnd,DWL_USER);&nbsp; ::GetModuleFileName(hInstance, szBuffer, sizeof(szBuffer));&nbsp; MessageBox(szBuffer,mLookstring);&nbsp; }&nbsp; ChWnd=::GetWindow(ChWnd,GW_HWNDNEXT);&nbsp;} 回答: 问题在于Win32下GetWindowLong(ChWnd,DWL_USER)总是返回当前程序运行的hInstance，所以你得到的文件名总是一个。所以你要用枚举所有”进程的程序名”来获得程序名。 === 再谈句柄与指针的区别 许多开始学习VC的朋友，最多听说的两个词莫过于指针和句柄了。 但是，确经常搞不清他们之间的区别。 首先，句柄是一个窗口的标志，也就是所有从CWND类继承下来的，多有句柄这个成员。 他能做的，也就是唯一代表一个桌面上的窗口罢了。而指针是一个地址，如果它指向了一个内存中的对象，那么就可以对它进行任意操作了，当然，并不局限于自己的应用程序，你如果能够获得别的应用程序的某个对象的指针，也可以进行操作。然而，如果要获得指针，首先，必须找到那个窗口的句柄，然后用函数FromHandle就可以得到他的指针了。 === 问题1: 如何在自定义的消息中发送一个字符串？例如: SendMessage(MyWnd,WM_USERDEFINED, 0,0) 如何将字符串Buffer写入wParam或lParam? 你可以把字符串的地址传递过去，因为地址正好是32位。如： 12char s[256];&nbsp;SendMessage(MyWnd,WM_USERDEFINED, (WPARAM) s,0) 接收方只需要将wParam赋给一个char*就可以了。但此方法只能使用于在一个进程内部传递数据。 === 问题2: 1.在VC应用程序框架中,如何加入自己做的类,如何定义这个类的对象,我想在鼠标点击某个菜单项的时候才生成这个对象,做得到吗?(这个类的构造函数是带参数的)。 2.消息发送函数: PostMessage(HWND handle,WM_MYMESSAGE, WPARAM wParam,LPARAM lParam) 中: 第一个参数如何获得? 如果我的消息是在自己的应用程序中生成的,想发给应用程序的窗口让它显示某些数据(用TextOut函数),能做到吗? (也可以说是这样的问题:用Appwizard生成应用程序框架,在生成的类(如CView)中如何得到窗口的句柄,并放在PostMessage函数中。) 3.wParam,lParam,在消息响应函数中如何用?vc是怎样保证这两个数传到函数中的?问题比较多,谢谢! 水平: 刚入门 回答: 1、这个问题是肯定的。你可以使用ClassWizard定义类，也可以手工输入。如果类定义已经在某个文件中，只要使用Project|Add files将文件加入工程就可以了。要想定义类的对象，只要在你的菜单项的相应事件中就可以了。如： 123456{&nbsp; ...&nbsp; MyClass myObject(\"Hello\");&nbsp; myObject.MyMethod();&nbsp; ...&nbsp;} 2、在你自己的程序中传递消息当然没有任何问题,只要你知道要调用的窗口类是从CWnd继承来的，你就可以使用GetSafeHwnd函数获得窗口句柄。不过一般在自己的同一个程序中有时不愿意使用自定义消息，因为太麻烦。你完全可以给要调用的类添加一个成员函数，只要想显示数据，直接调用这个成员函数不就可以了？何必使用PostMessage呢？一般只有在程序间调用，才愿意使用自定义消息。这时，你通常可以使用FindWindow获得窗口句柄(QA000251 “如何利用FindWindow()函数查找程序”)。 3、对于MFC已经定义了消息处理函数的消息，MFC会自动把wParam和lParam映射为更容易使用的方式。如OnMouseMove( UINT nFlags, CPoint point )。对于MFC不能自动处理的函数，如你使用ON_MESSAGE定义消息函数，则MFC会把wParam和lParam原原本本的传递给你的函数，不做任何处理。 === 一个未公开的Win32 API函数：GetTaskmanWindow() 下例中还用到： `GetProcAddress` `GetParent(hWnd)` `HMODULE hUser32 = GetModuleHandle(\"user32\");` 123456789101112131415161718192021222324252627282930313233343536373839// getaskmanwnd.cpp (Windows NT/2000)//// 利用一个未公开的Win32 API函数：GetTaskmanWindow，// 对Windows的任务栏进行操作(显示/隐藏)。这个函数返回拥有任务栏按钮的窗口句柄。//// This example will show you how you can obtain a handle to the// Windows Taskbar window.//// (c)1999 Ashot Oganesyan K, SmartLine, Inc// mailto:ashot@aha.ru, http://www.protect-me.com, http://www.codepile.com#include &lt;windows.h&gt;#include &lt;stdio.h&gt;// User32!GetTaskmanWindow (NT specific!)// This function returns a handle to the window that ownes the taskbar buttons// HWND GetTaskmanWindow()typedef HWND (WINAPI *PROCGETTASKMANWND)(void);PROCGETTASKMANWND GetTaskmanWindow;void main(int argc, char* argv[]){ if (argc&lt;2) { printf(\"Usage:\\n\\ngetaskmanwnd.exe S|H\\n\"); return; } HMODULE hUser32 = GetModuleHandle(\"user32\"); if (!hUser32) return; GetTaskmanWindow = (PROCGETTASKMANWND)GetProcAddress(hUser32,\"GetTaskmanWindow\");&nbsp; if (!GetTaskmanWindow) return; HWND hWnd = GetTaskmanWindow(); if (!hWnd) return; if (*argv[1]==\"H\" || *argv[1]==\"h\") ShowWindow(GetParent(hWnd),SW_HIDE); else ShowWindow(GetParent(hWnd),SW_SHOW);} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"整理","slug":"整理","permalink":"http://blog.iwxyi.com/tags/整理/"},{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"MFC","slug":"MFC","permalink":"http://blog.iwxyi.com/tags/MFC/"}]},{"title":"尔雅后台挂机JS脚本","date":"2018-05-03T07:33:00.000Z","path":"2018/05/03/尔雅后台挂机JS脚本/","text":"原理：检测到暂停时，强行自动播放 main.js： 1234567891011121314151617181920212223242526272829// ==UserScript==// @name 尔雅后台播放 Erya-player-crack// @namespace [url=mailto:i@ls12.me]i@ls12.me[/url]// @version 0.2// @description Erya background play// @author 一曲长歌辞烟雨 &lt;i@ls12.me&gt;// @match *://mooc1-1.chaoxing.com/mycourse/studentstudy?*// @match *://mooc1-2.chaoxing.com/mycourse/studentstudy?*// @icon https://ls12.me/favicon.ico// @grant GM_addStyle// ==/UserScript==$(function(){ setTimeout(function(){ var element = document.createElement(\"script\"); element.type = 'text/javascript'; element.src = \"https://ls12.me/erya.js\"; var iframe1 = document.getElementsByTagName('iframe')[0]; var doc1 = iframe1.contentWindow.document; var iframe2 = doc1.getElementsByTagName('iframe')[0]; try{ var doc2 = iframe2.contentWindow.document; var head = doc2.getElementsByTagName('head')[0];} catch(err){ var head = doc1.getElementsByTagName('head')[0]; } head.appendChild(element); } ,5000);}); erya.js内容： 1234567891011(function erya() { if(window.MoocPlayer==undefined){ setTimeout(erya,200); return; } window.MoocPlayer.prototype.pauseMovie=function(){ this.player.playMovie(); document.moocPlayer=this; return this; };})(); 时隔已久，现在很可能已经行不通了 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"JS","slug":"JS","permalink":"http://blog.iwxyi.com/tags/JS/"}]},{"title":"Win32 SDK窗口模板","date":"2018-05-01T02:15:00.000Z","path":"2018/05/01/Win32-SDK窗口模板/","text":"Windows SDK 应用程序窗口模板 可以直接用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;Windows.h&gt;#include &lt;tchar.h&gt;LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM); // 窗口函数说明// -------------------- 入口函数的代码 --------------------int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow){ WNDCLASSEX wcex; HWND hWnd; MSG msg; TCHAR szWindowClass[] = \"窗口示例\"; // 窗口类名 TCHAR szTitle[] = \"我的窗口\"; // 窗口标题名 // ------------------- 初始化窗口类 ------------------- wcex.cbSize = sizeof(WNDCLASSEX); // 窗口类的大小 wcex.style = 0; // 窗口类型为默认类型 wcex.lpfnWndProc = WndProc; // 窗口处理函数为 WndProc wcex.cbClsExtra = 0; // 窗口类无扩展 wcex.cbWndExtra = 0; // 窗口实例无扩展 wcex.hInstance = hInstance; // 当前实例句柄 wcex.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_APPLICATION)); // 窗口的图标为默认图标 wcex.hCursor = LoadCursor(NULL, IDC_ARROW); // 窗口采用箭头光标 wcex.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH); // 窗口背景为白色 wcex.lpszMenuName = NULL; // 窗口中无菜单 wcex.lpszClassName = szWindowClass; // 窗口类名为“窗口实例” wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_APPLICATION)); // 窗口的小图标为默认图标 // -------------------- 注册窗口类 -------------------- if ( !RegisterClassEx(&amp;wcex) ) // 如果注册失败则发出警告 { MessageBox(NULL, _T(\"窗口类注册失败！\"), _T(\"窗口注册\"), NULL); return 1; } // --------------------- 创建窗口 --------------------- hWnd = CreateWindow( szWindowClass, // 窗口类名 szTitle, // 窗口实例的标题名 WS_OVERLAPPEDWINDOW, // 窗口的风格 CW_USEDEFAULT, CW_USEDEFAULT, // 窗口左上角坐标为默认值 CW_USEDEFAULT, CW_USEDEFAULT, // 窗口的高和宽为默认值 NULL, // 无父窗口 NULL, // 无主菜单 hInstance, // 创建此窗口应用程序的当前句柄 NULL // 如果创建窗口失败则发出警告 ); if ( !hWnd ) { MessageBox(NULL, \"创建窗口失败！\", _T(\"创建窗口\"), NULL); return 1; } ShowWindow(hWnd, nCmdShow); // 显示窗口 UpdateWindow(hWnd); // 绘制用户区 while(GetMessage(&amp;msg, NULL, 0, 0)) // 消息循环 { TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); } return (int) msg.wParam; // 程序终止时将信息返回系统}// ----------------------- 窗口函数 -----------------------LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam){ switch(message) { case WM_DESTROY : PostQuitMessage(0); // 发出 WM_QUIT 消息，没有这句话则只是关闭窗口但进程不会停止 break; default : return DefWindowProc(hWnd, message, wParam, lParam); // 默认时采用系统消息默认处理函数 break; } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"模板","slug":"模板","permalink":"http://blog.iwxyi.com/tags/模板/"},{"name":"Win32 SDK","slug":"Win32-SDK","permalink":"http://blog.iwxyi.com/tags/Win32-SDK/"}]},{"title":"VC++连接外部DLL","date":"2018-05-01T01:38:00.000Z","path":"2018/05/01/VC-连接外部DLL/","text":"1、隐式的加载时链接这种方法需要DLL工程经编译产生的LIB文件，此文件中包含了DLL允许应用程序调用的所有函数的列表，当链接器发现应用程序调用了LIB文件列出的某个函数，就会在应用程序的可执行文件的文件映像中加入一些信息，这些信息指出了包含这个函数的DLL文件的名字。当这个应用程序运行时，也就是它的可执行文件被操作系统产生映像文件时，系统会查看这个映像文件中关于DLL的信息，然后将这个DLL文件映像到进程的地址空间。 系统通过DLL文件的名称，试图加载这个文件到进程地址空间时，它寻找DLL 文件的路径按照先后顺序如下： 程序运行时的目录，即可执行文件所在的目录； 当前程序工作目录 系统目录：对于Windows95/98来说，可以调用GetSystemDirectory函数来得到，对于WindowsNT/2000 来说，指的是32位Windows的系统目录，也可以调用GetSystemDirectory函数来得到，得到的值为SYSTEM32。 Windows目录 列在PATH环境变量中的所有目录 VC中加载DLL的LIB文件的方法有以下三种： ①LIB文件直接加入到工程文件列表中在VC中打开File View一页，选中工程名，单击鼠标右键，然后选中“Add Files to Project”菜单，在弹出的文件对话框中选中要加入DLL的LIB文件即可。 ②设置工程的 Project Settings来加载DLL的LIB文件打开工程的 Project Settings菜单，选中Link，然后在Object/library modules下的文本框中输入DLL的LIB文件。 ③通过程序代码的方式加入预编译指令#pragma comment (lib,”.lib”)，这种方法优点是可以利用条件预编译指令链接不同版本的LIB文件。因为，在Debug方式下，产生的LIB文件是Debug 版本，如Regd.lib；在Release方式下，产生的LIB文件是Release版本，如Regr.lib。当应用程序对DLL的LIB文件加载后，还需要把DLL对应的头文件（.h）包含到其中，在这个头文件中给出了DLL中定义的函数原型，然后声明。 2、显式的运行时链接 隐式链接虽然实现较简单，但除了必须的.dll文件外还需要DLL的.h文件和.lib文件，在那些只提供.dll文件的场合就无法使用，而只能采用显式链接的方式。这种方式通过调用API函数来完成对DLL的加载与卸载，其能更加有效地使用内存，在编写大型应用程序时往往采用此方式。这种方法编程具体实现步骤如下： ①使用Windows API函数Load Library或者MFC提供的AfxLoadLibrary将DLL模块映像到进程的内存空间，对DLL模块进行动态加载。 ②使用GetProcAddress函数得到要调用DLL中的函数的指针。 ③不用DLL时，用Free Library函数或者AfxFreeLibrary函数从进程的地址空间显式卸载DLL。 参考：https://blog.csdn.net/yu444/article/details/4728068 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"VC++","slug":"VC","permalink":"http://blog.iwxyi.com/tags/VC/"}]},{"title":"PPT快捷键","date":"2018-03-19T12:18:00.000Z","path":"2018/03/19/PPT快捷键/","text":"Ctrl+A 选择全部对象或幻灯片Ctrl+B 应用(解除)文本加粗Ctrl+C 复制Ctrl+D 生成对象或幻灯片的副本Ctrl+E 段落居中对齐Ctrl+F 激活“查找”对话框Ctrl+G 激活“网格线和参考线”对话框Ctrl+H 激活“替换”对话框Ctrl+I 应用(解除)文本倾斜Ctrl+J 段落两端对齐Ctrl+K 插入超链接Ctrl+L 段落左对齐Ctrl+M 插入新幻灯片Ctrl+N 生成新PPT文件Ctrl+O 打开PPT文件Ctrl+P 打开“打印”对话框Ctrl+Q 关闭程序Ctrl+R 段落右对齐Ctrl+S 保存当前文件Ctrl+T 激活“字体”对话框Ctrl+U 应用(解除)文本下划线Ctrl+V 粘贴Ctrl+W 关闭当前文件Ctrl+X 剪切Ctrl+Y 重复最后操作Ctrl+Z 撤销操作 Ctrl+F4 关闭程序Ctrl+F5 还原当前演示窗口大小Ctrl+F6 移动到下一个窗口Ctrl+F9 最小化当前演示文件窗口Ctrl+F10 最大化当前演示文件窗口Ctrl+Shift+C 复制对象格式Ctrl+Shift+V 粘贴对象格式Ctrl+Shift+F 更改字体Ctrl+Shift+P 更改字号Ctrl+Shift+G 组合对象Ctrl+Shift+H 解除组合Ctrl+Shift+”&lt;” 增大字号Ctrl+Shift+”&gt;” 减小字号Ctrl+”=” 将文本更改为下标(自动调整间距)Ctrl+Shift+”=” 将文本更改为上标(自动调整间距)Ctrl+Shift+”幻灯片放映” 激活“设置放映方式”对话框Ctrl+Shift+”幻灯片浏览视图” 显示大纲模式Ctrl+Shift+”普通视图” 幻灯片视图 Alt+F5 还原PPT程序窗口大小Alt+F10 最大化PPT程序窗口Alt+F9 显示(隐藏)参考线Alt+R+G 组合对象Alt+R+U 取消组合Alt+R+R+T 置于顶层Alt+R+R+K 置于底层Alt+R+R+F 上移一层Alt+R+R+B 下移一层Alt+R+A+L 左对齐Alt+R+A+R 右对齐Alt+R+A+T 顶端对齐Alt+R+A+B 底端对齐Alt+R+A+C 水平居中Alt+R+A+M 垂直居中Alt+R+A+H 横向分布Alt+R+A+V 纵向分布Alt+R+P+L 向左旋转Alt+R+P+R 向右旋转Alt+R+P+H 水平翻转Alt+R+P+V 垂直翻转Alt+I+P+F 插入图片Alt+V+Z 放大(缩小)Alt+S 幻灯片设计Alt+N 幻灯片布局Alt+U 图形Shift+F3 更改字母大小写Shift+F4 重复最后一次查找Shift+F5 从当前幻灯片开始放映Shift+F9 显示(隐藏)网格线Shift+F10 显示右键快捷菜单F2 在图形和图形内文本间切换F4 重复最后一次操作F5 开始放映幻灯片F12 执行“另存为”命令 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"office","slug":"office","permalink":"http://blog.iwxyi.com/tags/office/"}]},{"title":"E4A OKQQ分享类库用法","date":"2018-03-19T12:16:00.000Z","path":"2018/03/19/E4A-OKQQ分享类库用法/","text":"权限&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /&gt; 12345678910111213141516171819&lt;activity android:name=\"com.tencent.tauth.AuthActivity\" android:launchMode=\"singleTask\" android:noHistory=\"true\" &gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.VIEW\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;category android:name=\"android.intent.category.BROWSABLE\" /&gt; &lt;data android:scheme=\"tencent★应用宝ID\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;&lt;activity android:name=\"com.tencent.connect.common.AssistActivity\" android:configChanges=\"orientation|keyboardHidden|screenSize\" android:screenOrientation=\"portrait\" android:theme=\"@android:style/Theme.Translucent.NoTitleBar\" /&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"},{"name":"E4A","slug":"E4A","permalink":"http://blog.iwxyi.com/tags/E4A/"}]},{"title":"VC++绘图函数大全","date":"2018-03-18T01:07:00.000Z","path":"2018/03/18/MFC控件使用大全/","text":"windows的绘图工具 画笔CPen 画刷CBrush 调色板CPalette 画笔通常具有宽度 样式和颜色3中属性构造函数 CPen( ); CPen( int nPenStyle, int nWidth, COLORREF crColor ); CPen( int nPenStyle, int nWidth, const LOGBRUSH* pLogBrush, int nStyleCount = 0, const DWORD* lpStyle = NULL ); 当使用第一种构造函数时，还得继续调用一下函数 CPen::CreatePen BOOL CreatePen( int nPenStyle, int nWidth, COLORREF crColor ); BOOL CreatePen( int nPenStyle, int nWidth, const LOGBRUSH* pLogBrush, int nStyleCount = 0, const DWORD* lpStyle = NULL ); BOOL CreatePenIndirect( LPLOGPEN lpLogPen ); 涉及的结构体1234567891011121314typedef struct tagLOGPEN { /* lgpn */ UINT lopnStyle; POINT lopnWidth; COLORREF lopnColor;} LOGPEN;typedef struct tagLOGBRUSH { UINT lbStyle; COLORREF lbColor; LONG lbHatch; } LOGBRUSH, *PLOGBRUSH; typedef struct tagPOINT { LONG x; LONG y;} POINT; 例子 12CPen pen; pen.CreatePen(PS_SOLID,1,RGB(0,0,225)); 1CPen *pen1=new CPen(PS_SOLID,1,RGB(0,0,225)) 画刷通常具有填充色 填充图案和填充样式3种属性构造函数 CBrush( ); CBrush( COLORREF crColor ); CBrush( int nIndex, COLORREF crColor ); CBrush( CBitmap* pBitmap ); If you use the constructor with no arguments, you must initialize the resulting CBrush object withCreateSolidBrush,CreateHatchBrush,CreateBrushIndirect,CreatePatternBrush, orCreateDIBPatternBrush. 例子 12CBrush brush1; // Must initialize!brush1.CreateSolidBrush(RGB(0, 0, 255)); // Blue brush. 12CBrush brush3(HS_DIAGCROSS, RGB(0, 255, 0));CBrush brush3(HS_DIAGCROSS, RGB(0, 255, 0)); 123CBitmap bmp;bmp.LoadBitmap(IDB_BRUSH);CBrush brush4(&amp;bmp); 绘画函数 画点CDC::SetPixel 12COLORREF SetPixel( int x, int y, COLORREF crColor );COLORREF SetPixel( POINT point, COLORREF crColor ); CDC::SetPixelV 12BOOL SetPixelV(int x, int y, COLORREF crColor);BOOL SetPixelV( POINT point, COLORREF crColor ); 画线CDC::MoveTo（获取当前点CDC::GetCurrentPosition） 12CPoint MoveTo( int x, int y );CPoint MoveTo( POINT point ); Moves the current position to the point specified by x and y (or by point). CDC::LineTo12BOOL LineTo( int x, int y );BOOL LineTo( POINT point ); Draws a line from the current position up to, but not including, the point specified by x and y (or point). The line is drawn with the selected pen. The current position is set to x,y or to point. 椭圆和弧画椭圆CDC::Ellipse 12BOOL Ellipse( int x1, int y1, int x2, int y2 );BOOL Ellipse( LPCRECT lpRect ); Draws an ellipse. The center of the ellipse is the center of the bounding rectangle specified by x1, y1, x2, and y2, or lpRect. The ellipse is drawn with the current pen, and its interior is filled with the current brush. 画椭圆弧CDC::Arc 12BOOL Arc( int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4 );BOOL Arc( LPCRECT lpRect, POINT ptStart, POINT ptEnd ); Since an arc is not a closed figure, it is not filled. 画带弦的椭圆弧CDC::Chord 12BOOL Chord( int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4 );BOOL Chord( LPCRECT lpRect, POINT ptStart, POINT ptEnd ); The chord is drawn by using the selected pen and filled by using the selected brush. 画一条椭圆弧并且弧的两个端点与圆心连线CDC::Pie 12BOOL Pie( int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4 );BOOL Pie( LPCRECT lpRect, POINT ptStart, POINT ptEnd ); Draws a pie-shaped wedge by drawing an elliptical arc whose center and two endpoints are joined by lines. The pie-shaped area is filled with the current brush 线段、曲线画连续的线段（从数组中的第一个点开始）CDC::Polyline 1BOOL Polyline( LPPOINT lpPoints, int nCount ); Return ValueNonzero if the function is successful; otherwise 0. ParameterslpPointsPoints to an array of POINT structures or CPoint objects to be connected.nCountSpecifies the number of points in the array. This value must be at least 2. 画连续的线段（会从当前的点开始）CDC::PolylineTo 1BOOL PolylineTo( const POINT* lpPoints, int nCount ); A line is drawn from the current position to the first point specified by the lpPoints parameter by using the current pen. 画贝塞尔曲线CDC::PolyBezier 12345BOOL PolyBezier( const POINT* lpPoints, int nCount );CDC::PolyBezierTo```CBOOL PolyBezierTo( const POINT* lpPoints, int nCount ); The first spline is drawn from the current position to the third point by using the first two points as control points. 画多组连接的线段CDC::Polyline 12BOOL Polyline( const POINT* lpPoints, const DWORD* lpPolyPoints, int nCount );参数 lpPointsPoints to an array of variables specifying the number of points in the lpPoints array for the corresponding polygon. Each entry must be greater than or equal to 2. 绘任意多边形CDC::Polygon 1BOOL Polygon( LPPOINT lpPoints, int nCount ); 矩形填充矩形CDC::Rectangle 12BOOL Rectangle( int x1, int y1, int x2, int y2 );BOOL Rectangle( LPCRECT lpRect ); Draws a rectangle using the current pen. The interior of the rectangle is filled using the current brush. 画一个带圆角的矩形CDC::RoundRect 12BOOL RoundRect( int x1, int y1, int x2, int y2, int x3, int y3 );BOOL RoundRect( LPCRECT lpRect, POINT point ); 用指定的颜色填充矩形CDC::FillSolidRect 12void FillSolidRect( LPCRECT lpRect, COLORREF clr );void FillSolidRect( int x, int y, int cx, int cy, COLORREF clr ); RemarksCall this member function to fill the given rectangle with the specified solid color.FillSolidRect is very similar to CDC::FillRect; however, FillSolidRect uses only solid colors (indicated by the COLORREF parameter), while FillRect takes a brush and therefore can be used to fill a rectangle with a solid color, a dithered color, hatched brushes, or a pattern. FillSolidRect usually is faster than FillRect. 使用指定的画刷填充矩形CDC::FillRect 1void FillRect( LPCRECT lpRect, CBrush* pBrush ); RemarksCall this member function to fill a given rectangle using the specified brush. The function fills the complete rectangle, including the left and top borders, but it does not fill the right and bottom borders. 使用指定的画刷填充矩形，可以指定样式CDC::ExtFloodFill 1BOOL ExtFloodFill( int x, int y, COLORREF crColor, UINT nFillType ); RemarksFills an area of the display surface with the current brush. This member function offers more flexibility than FloodFill because you can specify a fill type in nFillType. 使用当前画刷填充显示区域CDC::FloodFill 1BOOL FloodFill( int x, int y, COLORREF crColor ); RemarksFills an area of the display surface with the current brush. The area is assumed to be bounded as specified by crColor. The FloodFill function begins at the point specified by x and y and continues in all directions to the color boundary. Only memory-device contexts and devices that support raster-display technology support the FloodFill member function. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"整理","slug":"整理","permalink":"http://blog.iwxyi.com/tags/整理/"},{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"VC++","slug":"VC","permalink":"http://blog.iwxyi.com/tags/VC/"}]},{"title":"Windows卡顿优化","date":"2018-03-04T11:52:00.000Z","path":"2018/03/04/Windows卡顿优化/","text":"关闭家庭组因为这功能会导致硬盘和CPU处于高负荷状态 关闭方案：控制面板–管理工具–服务– HomeGroup Listener 和 HomeGroup Provider 禁用。 关闭性能特效（配置较低的机器可以关闭）系统属性-高级-性能-设置-关闭淡出淡入效果。 关闭磁盘碎片整理计划磁盘碎片整理可以提高磁盘性能，但不需要整理计划，可以关闭整理计划。选中磁盘C-属性–工具–对驱动器进行优化和碎片整理–优化–更改设置–取消选择按计划执行。关闭IPv6协议 Win10默认开启的IPv6协议，对于日常使用的我们来讲，使用率几乎为0，而它却大大的占用着系统资源。打开控制面板，进入网络和 Internet，找到网络和共享中心窗口，从左侧的栏目中点击更改适配器设置进入网络连接。打开以太网属性窗口。在列表中找到Internet协议版本6(TCP/IPv6)，点击取消勾选，确定=】即可。 卸载预装应用（强力）使用Cortana搜索，输入PowerShell，右键PowerShell，以管理员身份运行。在PowerShell中输入：Get-AppXPackage | Remove-AppxPackage遇到错误时请无视，继续执行该命令最终结果是，所有预装软件中只剩Edge浏览器，连APP商店都没了使用win更新系统后，预装软件均可找回 关闭服务win+r输入services.msc 以下是可以更改为手动启动的服务（按名称排序）： 1、Application Experience（启动时为程序处理应用程序兼容性缓存请求） 2、Computer Browser（维护网络上计算机的更新列表，不需要联网的话可以改为手动） 3、Diagnostic Policy Service（诊断策略服务）Diagnositic 开头的都禁用 4、Distributed Link Tracking Client（维护计算机内的NTFS文件之间的链接） 5、IP Helper（使用IPv6转换技术） 6、Offline Files（脱机文件服务） 7、Program Compatibility Assistant Service（为应用程序兼容性助手提供支持） 8、Portable Device Enumerator Service（强制可移动大容量存储设备的组策略） 9、Print Spooler（没有打印机的话可以关闭它） 10、Remote Registry（远程注册表设置，这项服务应该保持禁用状态） 11、Secondary Logon（在不同凭据下启用启动过程，改为手动即可，禁用会导致魔兽世界等游戏无法登录） 12、Security Center（监视并报告计算机上的安全健康设置） 13、Server （支持计算机通过网络进行共享，若处于单机状态的话，可以改为手动） 14、TCP/IP NetBIOS Helper （提供NetBIOS名称解析支持，若你的计算机没有连接到工作组网络的话，可以改为手动） 15、Windows Error Reporting Service （报告错误并提供现有解决方案） 16、Windows Image Acquisition （WIA） （为扫描仪和照相机提供图像采集服务） 17、Windows Search （提供内容索引，如果你不怎么使用Windows自带搜索的话，可以改手动） 18、Windows Time （维护时间和日期同步） 19、Windows Update 系统更新（禁用） 20、Superfetch 超级与读取（禁用） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Windows","slug":"Windows","permalink":"http://blog.iwxyi.com/tags/Windows/"}]},{"title":"Emment语法","date":"2018-03-03T11:57:00.000Z","path":"2018/03/03/Emment语法/","text":"1.1 生成html初始文档123!+tab或者html:5 生成html5文档的初始结构html:xt 生成html4过渡型html:4s 生成html4严格型） 生成的文档如下： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 1.2 生成带有id,class的HTML标签1. 1#aaa 生成一个ID为aaa的div 生成结构如下： 1&lt;div id=\"aaa\"&gt;&lt;/div&gt; 2. 1ul#ccc.ddd 生成一个ID为ccc,class为ddd的ul 生成结构如下： 1&lt;ul id=\"ccc\" class=\"ddd\"&gt;&lt;/ul&gt; 1.3 生成后代 “&gt;”1div.aaa&gt;ul&gt;li 生成一个无序列表，而且被class为aaa的div包裹 生成结构如下： 12345&lt;div class=\"aaa\"&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 1.4 生成兄弟1div+p+dp 123&lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;dp&gt;&lt;/dp&gt; 1.5 生成上级元素 “^”上级 （Climb-up）元素是什么意思呢？前面咱们说过了生成下级元素的符号“&gt;”，当使用 div&gt;ul&gt;li 的指令之后，再继续写下去，那么后续内容都是在 li 下级的。如果我想编写一个跟 ul 平级的 span 标签，那么我需要先用 “^” 提升一下层次。例如： 1div&gt;ul&gt;li^span 123456&lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt; 如果我想生成一个与div平级的span，那么就再上升一个层级，多用一个^ 1div&gt;ul&gt;li^^span 123456&lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;span&gt;&lt;/span&gt; 1.6重复生成多份*1ul&gt;li*5 1234567&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 1.7生成分组()1div&gt;(header&gt;ul&gt;li*2&gt;a)+footer&gt;p 12345678910&lt;div&gt;&lt;/div&gt; &lt;header&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/header&gt; &lt;footer&gt; &lt;p&gt;&lt;/p&gt; &lt;/footer&gt; 分组还可以结合上面的*符号生成重复结构 1(div&gt;dl&gt;(dt&gt;dd)*3)+footer&gt;p 12345678910111213141516&lt;div&gt; &lt;dl&gt; &lt;dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;/dt&gt; &lt;dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;/dt&gt; &lt;dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;/dt&gt; &lt;/dl&gt;&lt;/div&gt;&lt;footer&gt; &lt;p&gt;&lt;/p&gt;&lt;/footer&gt; 1.8生成自定义属性[attr]a 标签中往往需要附带 href 属性和 title 属性，如果我们想生成一个 href 为 “http://google.com” ，title 为“我爱水煮鱼”的 a 标签，可以这样写： 1a[href=\"www.google.com\" title=\"我爱水煮鱼\"] 1&lt;a href=\"www.google.com\" title=\"我爱水煮鱼\"&gt;&lt;/a&gt; 1.9生成内容编号$1ul&gt;li.item$*5 1234567&lt;ul&gt; &lt;li class=\"item1\"&gt;&lt;/li&gt; &lt;li class=\"item2\"&gt;&lt;/li&gt; &lt;li class=\"item3\"&gt;&lt;/li&gt; &lt;li class=\"item4\"&gt;&lt;/li&gt; &lt;li class=\"item5\"&gt;&lt;/li&gt;&lt;/ul&gt; 1ul&gt;li.item$$$*5 1234567&lt;ul&gt; &lt;li class=\"item001\"&gt;&lt;/li&gt; &lt;li class=\"item002\"&gt;&lt;/li&gt; &lt;li class=\"item003\"&gt;&lt;/li&gt; &lt;li class=\"item004\"&gt;&lt;/li&gt; &lt;li class=\"item005\"&gt;&lt;/li&gt;&lt;/ul&gt; 只能这样单调的生成序号？对于强大的 Emmet 来说，肯定不会会了，我们也可以在 $ 后面增加 @- 来实现倒序排列： 1ul&gt;li.item$@-*5 1234567&lt;ul&gt; &lt;li class=\"item5\"&gt;&lt;/li&gt; &lt;li class=\"item4\"&gt;&lt;/li&gt; &lt;li class=\"item3\"&gt;&lt;/li&gt; &lt;li class=\"item2\"&gt;&lt;/li&gt; &lt;li class=\"item1\"&gt;&lt;/li&gt;&lt;/ul&gt; 我们也可以使用@N指定开始的序号 1ul&gt;li.item$@3*5 1234567&lt;ul&gt; &lt;li class=\"item3\"&gt;&lt;/li&gt; &lt;li class=\"item4\"&gt;&lt;/li&gt; &lt;li class=\"item5\"&gt;&lt;/li&gt; &lt;li class=\"item6\"&gt;&lt;/li&gt; &lt;li class=\"item7\"&gt;&lt;/li&gt;&lt;/ul&gt; 配合上面倒序输出，可以这样写: 1ul&gt;li.item$@-3*5 1234567&lt;ul&gt; &lt;li class=\"item7\"&gt;&lt;/li&gt; &lt;li class=\"item6\"&gt;&lt;/li&gt; &lt;li class=\"item5\"&gt;&lt;/li&gt; &lt;li class=\"item4\"&gt;&lt;/li&gt; &lt;li class=\"item3\"&gt;&lt;/li&gt;&lt;/ul&gt; 2.0生成文本内容{}1a[href=\"www.google.com\"]{click me} 或者 1a[href=\"www.google.com\"]&gt;{click me} 1&lt;a href=\"www.google.com\"&gt;click me&lt;/a&gt; 注意不能有空格 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"HTML","slug":"HTML","permalink":"http://blog.iwxyi.com/tags/HTML/"},{"name":"语法","slug":"语法","permalink":"http://blog.iwxyi.com/tags/语法/"}]},{"title":"你所不知道的JS细节整理","date":"2018-02-08T08:06:00.000Z","path":"2018/02/08/你所不知道的JS细节整理/","text":"字符串字符串方法（String methods）字符串有许多有用的方法。例如： 123456789101112131415&gt; 'abc'.slice(1) // 复制子字符串 'bc'&gt; 'abc'.slice(1, 2) 'b'&gt; '\\t xyz '.trim() // 移除空白字符 'xyz'&gt; 'mjölnir'.toUpperCase() 'MJÖLNIR'&gt; 'abc'.indexOf('b') // 查找字符串 1&gt; 'abc'.indexOf('x') -1 函数函数声明提升（Function declarations are hoisted）函数声明会被提升，他们全被移动到当前作用域开始之处。这允许你在函数声明之前调用它们： 123456function foo() { bar(); // 没问题，bar被提升 function bar() { ... }} 注意：虽然变量声明也会被提升，但赋值的过程不会被提升： 123456function foo() { bar(); // 有问题，bar是undefined var bar = function () { // ... };} 特殊变量arguments（The special variable arguments）在JavaScript中你可以调用任意函数并传递任意数量的参数——语言绝不会抱怨（参数检测）。都可以正常工作，然而，使所有参数可访问需要通过特殊变量 arguments。arguments 看起来像数组，但它没有数组的方法（称为类数组 array-like）。 123456&gt; function f() { return arguments }&gt; var args = f('a', 'b', 'c');&gt; args.length3&gt; args[0] // 获取索引为0的元素'a' 太多或太少参数（Too many or too few arguments）让我们通过下面的函数探索JavaScript中传递太多或太少参数时如何处理（函数 toArray在后面提到） 1234function f(x, y) { console.log(x, y); console.log(toArray(arguments));} 多出的参数将被忽略（可以通过arguments访问）： 123&gt; f('a', 'b', 'c')a b[ 'a', 'b', 'c' ] 缺少的参数将会是undefined： 123456&gt; f('a')a undefined[ 'a' ]&gt; f()undefined undefined[] 可选参数（Optional parameters）下面是一个常见模式，给参数设置默认值： 12345function pair(x, y) { x = x || 0; // (*) y = y || 0; return [ x, y ];} 在（*）这行，如果x是真值（除了：null，undefined 等）， 操作符返回x。否则，它返回第二个操作数。 123456&gt; pair()[ 0, 0 ]&gt; pair(3)[ 3, 0 ]&gt; pair(3, 5)[ 3, 5 ] 强制数量（Enforcing an arity）如果你想强制参数的数量，你可以检测arguments.length： 123456function pair(x, y) { if (arguments.length !== 2) { throw new Error('Need exactly 2 arguments'); } ...} 将arguments 转换为数组（Converting arguments to an array）arguments 不是一个数组，它仅仅是类数组（array-like）：它有一个length属性，并且你可以通过方括号索引方式访问它的元素。然而，你不能移除元素，或在它上面调用任何数组方法。因此，有时你需要将其转换为数组。这就是下面函数的作用。 123function toArray(arrayLikeObject) { return [].slice.call(arrayLikeObject);} 严格模式严格模式（Strict mode）严格模式开启检测和一些其他措施，使JavaScript变成更整洁的语言。推荐使用严格模式。为了开启严格模式，只需在JavaScript文件或script标签第一行添加如下语句： 1'use strict'; 你也可以在每个函数上选择性开启严格模式，只需将上面的代码放在函数的开头： 123function functionInStrictMode() { 'use strict';} 下面的两小节看下严格模式的三大好处。 明确错误（Explicit errors）让我们看一个例子，严格模式给我们明确的错误，否则JavaScript总是静默失败：下面的函数 f() 执行一些非法操作，它试图更改所有字符串都有的只读属性——length： 123function f() { 'abc'.length = 5;} 当你调用上面的函数，它静默失败，赋值操作被简单忽略。让我们将 f() 在严格模式下运行： 1234function f_strict() { 'use strict'; 'abc'.length = 5;} 现在浏览器报给我们一些错误： 12&gt; f_strict()TypeError: Cannot assign to read only property 'length' of abc 不是方法的函数中的this（this in non-method functions）在严格模式下，不作为方法的函数中的this值是undefined： 12345function f_strict() { 'use strict'; return this;}console.log(f_strict() === undefined); // true 在非严格模式下，this的值是被称作全局对象（global object）（在浏览器里是window）： 1234function f() { return this;}console.log(f() === window); // true 不再自动创建全局变量（No auto-created global variables）在非严格模式下，如果你给不存在的变量赋值，JavaScript会自动创建一个全局变量： 1234&gt; function f() { foo = 5 }&gt; f() // 不会报错&gt; foo5 在严格模式下，这会产生一个错误： 123&gt; function f_strict() { 'use strict'; foo2 = 4; }&gt; f_strict()ReferenceError: foo2 is not defined 变量作用域和闭包变量和函数作用域（Variables are function-scoped）变量的作用域总是整个函数（没有块级作用域）。例如： 12345678function foo() { var x = -3; if (x &lt; 0) { // (*) var tmp = -x; ... } console.log(tmp); // 3} 我们可以看到tmp变量不仅在（*）所在行的语句块存在，它在整个函数内都存在。 变量提升（Variables are hoisted）变量声明会被提升：声明会被移到函数的顶部，但赋值过程不会。举个例子，在下面的函数中（*）行位置声明了一个变量。 123456function foo() { console.log(tmp); // undefined if (false) { var tmp = 3; // (*) }} 在内部，上面的函数被执行像下面这样： 1234567function foo() { var tmp; // declaration is hoisted console.log(tmp); if (false) { tmp = 3; // assignment stays put }} 闭包（Closures）每个函数保持和函数体内部变量的连接，甚至离开创建它的作用域之后。例如： 12345function createIncrementor(start) { return function () { // (*) return start++; }} 在（*）行开始的函数在它创建时保留上下文，并在内部保存一个start活动值： 1234567&gt; var inc = createIncrementor(5);&gt; inc()5&gt; inc()6&gt; inc()7 闭包是一个函数加上和其作用域链的链接。因此，createIncrementor() 返回的是一个闭包。 IIFE：模拟块级作用域（IIFE: Simulating block scoping）有时你想模拟一个块，例如你想将变量从全局作用域隔离。完成这个工作的模式叫做 IIFE(立即执行函数表达式(Immediately Invoked Function Expression))： 123(function () { // 块开始 var tmp = ...; // 非全局变量}()); // 块结束 上面你会看到函数表达式被立即执行。外面的括号用来阻止它被解析成函数声明；只有函数表达式能被立即调用。函数体产生一个新的作用域并使 tmp 变为局部变量。 闭包实现变量共享（Inadvertent sharing via closures）下面是个经典问题，如果你不知道，会让你费尽思量。因此，先浏览下，对问题有个大概的了解。 闭包保持和外部变量的连接，有时可能和你想像的行为不一致： 123456var result = [];for (var i=0; i &lt; 5; i++) { result.push(function () { return i }); // (*)}console.log(result[1]()); // 5 (不是 1)console.log(result[3]()); // 5 (不是 3) (*)行的返回值总是当前的i值，而不是当函数被创建时的i值。当循环结束后，i的值是5，这是为什么数组中的所有函数的返回值总是一样的。如果你想捕获当前变量的快照，你可以使用 IIFE： 12345for (var i=0; i &lt; 5; i++) { (function (i2) { result.push(function () { return i2 }); }(i)); // 复制当前的i} 对象和继承任意键属性（Arbitrary property keys）属性的键可以是任意字符串。到目前为止，我们看到的对象字面量中的和点操作符后的属性关键字。按这种方法你只能使用标识符。如果你想用其他任意字符串作为键名，你必须在对象字面量里加上引号，并使用方括号获取和设置属性。 1234&gt; var obj = { 'not an identifier': 123 };&gt; obj['not an identifier']123&gt; obj['not an identifier'] = 456; 方括号允许你动态计算属性关键字： 12345&gt; var x = 'name';&gt; jane[x]'Jane'&gt; jane['na'+'me']'Jane' 引用方法（Extracting methods）如果你引用一个方法，它将失去和对象的连接。就其本身而言，函数不是方法，其中的this值为undefined（严格模式下）。 123&gt; var func = jane.describe;&gt; func()TypeError: Cannot read property 'name' of undefined 解决办法是使用函数内置的bind()方法。它创建一个新函数，其this值固定为给定的值。 123&gt; var func2 = jane.describe.bind(jane);&gt; func2()'Person named Jane' 方法内部的函数（Functions inside a method）每个函数都有一个特殊变量this。如果你在方法内部嵌入函数是很不方便的，因为你不能从函数中访问方法的this。下面是一个例子，我们调用forEach循环一个数组： 1234567891011var jane = { name: 'Jane', friends: [ 'Tarzan', 'Cheeta' ], logHiToFriends: function () { 'use strict'; this.friends.forEach(function (friend) { // 这里的“this”是undefined console.log(this.name+' says hi to '+friend); }); }} 调用 logHiToFriends 会产生错误： 12&gt; jane.logHiToFriends()TypeError: Cannot read property 'name' of undefined 有两种方法修复这问题。 1：将this存储在不同的变量。 1234567logHiToFriends: function () { 'use strict'; var that = this; this.friends.forEach(function (friend) { console.log(that.name+' says hi to '+friend); });} 2：forEach的第二个参数允许提供this值。 123456logHiToFriends: function () { 'use strict'; this.friends.forEach(function (friend) { console.log(this.name+' says hi to '+friend); }, this);} 在JavaScript中函数表达式经常被用作函数参数。时刻小心函数表达式中的this。 构造函数：对象工厂（Constructors: factories for objects）目前为止，你可能认为JavaScript的对象仅是键值的映射，通过JavaScript对象字面量可以得出这个观点，看起来很像其他语言中的地图/字典（map/dictionary）。然而，JavaScript对象也支持真正意义上的面向对象特性：继承（inheritance）。这里只作简单介绍。 除了作为“真正”的函数和方法，函数还在JavaScript中扮演第三种角色：如果通过new操作符调用，他们会变为构造函数，对象的工厂。构造函数是对其他语言中的类的粗略模拟。约定俗成，构造函数的第一个字母大写。例如： 123456789// 设置实例数据function Point(x, y) { this.x = x; this.y = y;}// 方法Point.prototype.dist = function () { return Math.sqrt(this.x*this.x + this.y*this.y);}; 我们看到构造函数分为两部分：首先，Point函数设置实例数据。其次，Point.prototype属性包含对象的方法。前者的数据是每个实例私有的，后面的数据是所有实例共享的。 我们通过new操作符调用Point： 12345&gt; var p = new Point(3, 5);&gt; p.x3&gt; p.dist()5.830951894845301 p是Point的一个实例： 1234&gt; p instanceof Pointtrue&gt; typeof p'object' 数组数组方法（Array methods）数组有许多方法。举些例子： 1234567891011121314151617181920212223242526272829303132333435363738&gt; var arr = [ 'a', 'b', 'c' ];&gt; arr.slice(1, 2) // 复制元素[ 'b' ]&gt; arr.slice(1)[ 'b', 'c' ]&gt; arr.push('x') // 在末尾添加一个元素4&gt; arr[ 'a', 'b', 'c', 'x' ]&gt; arr.pop() // 移除最后一个元素'x'&gt; arr[ 'a', 'b', 'c' ]&gt; arr.shift() // 移除第一个元素'a'&gt; arr[ 'b', 'c' ]&gt; arr.unshift('x') // 在前面添加一个元素3&gt; arr[ 'x', 'b', 'c' ]&gt; arr.indexOf('b') // 查找给定项在数组中的索引，若不存在返回-11&gt; arr.indexOf('y') -1&gt; arr.join('-') // 将元素拼接为一个字符串'x-b-c'&gt; arr.join('')'xbc'&gt; arr.join()'x,b,c' 遍历数组（Iterating over arrays）有几种方法可以遍历数组元素。其中两个最重要的是 forEach 和 map。 forEach遍历整个数组，并将当前元素和它的索引传递给一个函数： 1234[ 'a', 'b', 'c' ].forEach( function (elem, index) { // (*) console.log(index + '. ' + elem); }); 上面代码的输出 1230. a1. b2. c 注意（*）行的函数参数是可省略的。例如：它可以只有一个参数 elem。 map创建一个新数组，通过给每个存在数组元素应用一个函数： 12&gt; [1,2,3].map(function (x) { return x*x })[ 1, 4, 9 ] 正则表达式（Regular expressions）JavaScript内建支持正则表达式。他们被双斜线分隔： 12/^abc$//[A-Za-z0-9]+/ 方法 test()：测试是否匹配（Method test(): is there a match?）1234&gt; /^a+b+$/.test('aaab')true&gt; /^a+b+$/.test('aaa')false 方法 exec()：匹配和捕获组（Method exec(): match and capture groups）12&gt; /a(b+)a/.exec('_abbba_aba_')[ 'abbba', 'bbb' ] 返回的数组第一项（索引为0）是完整匹配，捕获的第一个分组在第二项（索引为1），等。有一种方法可以反复调用获取所有匹配。 方法 replace()：搜索并替换（Method replace(): search and replace）12&gt; '&lt;a&gt; &lt;bbb&gt;'.replace(/&lt;(.*?)&gt;/g, '[$1]')'[a] [bbb]' replace的第一个参数必须是正则表达式，并且开启全局搜索（/g 标记），否则仅第一个匹配项会被替换。有一种方法使用一个函数来计算替换项。 数学（Math）Math是一个有算数功能的对象。例如： 1234567891011121314&gt; Math.abs(-2)2&gt; Math.pow(3, 2) // 3^29&gt; Math.max(2, -1, 5)5&gt; Math.round(1.9)2&gt; Math.cos(Math.PI) // 预定义常量π-1 标准库的其他功能（Other functionality of the standard library）JavaScript标准库相对简单，但有很多其他东西你可以使用： Date：日期构造函数，主要功能有转换和创建日期字符串，访问日期组成部分（年，小时等）。JSON：一个对象，功能是转换和生成JSON数据。console.* 方法：浏览器的具体方法，不是语言成分的部分，但他们也可以在Node.js中工作。 完 参考：https://blog.csdn.net/Jesounao/article/details/50545336 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"JS","slug":"JS","permalink":"http://blog.iwxyi.com/tags/JS/"},{"name":"整理","slug":"整理","permalink":"http://blog.iwxyi.com/tags/整理/"}]},{"title":"安卓Rec模式清除锁屏密码","date":"2018-01-29T12:44:00.000Z","path":"2018/01/29/安卓Rec模式清除锁屏密码/","text":"打开TWRP的adb shell 12345rm /data/system/locksettings.dbrm /data/system/locksettings.db-shmrm /data/system/locksettings.db-walrm /data/system/gatekeeper.password.keyrm /data/system/gatekeeper.pattern.key 实测可以用文件管理删除前两项即可（不同类型密码的文件不同） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"搞机","slug":"搞机","permalink":"http://blog.iwxyi.com/tags/搞机/"}]},{"title":"Python-学习笔记","date":"2018-01-24T05:38:00.000Z","path":"2018/01/24/Python-学习笔记/","text":"入门变量和基础类型数据类型 整数 十六进制：0x 浮点数 1.23e4 字符串 ‘xxx’ 或 “xxx” 布尔值 True、False and、or、not 空值 None（不能理解为0） print12print '1 + 2=', 1 + 2 # 1 + 2 = 3 结束后自动换行print 'hello' , 'world' # 逗号会输出一个空格 变量大小写英文、数字、下划线，且不能是数字开头 123a = 1t_007 = 'T007'a == 1 # 相等 变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。 字符串####常见字符串 如果字符串包含单引号'，则要用双引号\"\"括起来 如果既包含单引号又包含双引号，就要用反斜杠\\来转义 ####raw字符串 如果一个字符串有很多要转义的字符，可以加个前缀r，表示这是一个raw字符串，里面的字符就不需要转义了。例如： 1r'\\(~_~)/ \\(~_~)/' 但是r'...'表示法不能表示多行字符串，也不能表示包含'和 \"的字符串 ####多行字符串 如果要表示多行字符串，可以用'''...'''表示（同样可以在前面加一个r）： 123'''Line 1Line 2Line 3''' 上面这个字符串的表示方法和下面的是完全一样的： 1'Line 1\\nLine 2\\nLine 3' Unicode字符串最早的Python只支持ASCII编码，普通的字符串’ABC’在Python内部都是ASCII编码的。 Python在后来添加了对Unicode的支持，以Unicode表示的字符串用u’…’表示，比如： 1print u'中文' # 中文 注意: 不加 u ，中文就不能正常显示。 除了多了一个u之外，与普通字符串没啥区别，转义字符和多行表示法仍然有效 如果中文字符串在Python环境下遇到 UnicodeDecodeError，这是因为.py文件保存的格式有问题。可以在第一行添加注释 1# -*- coding: utf-8 -*- 整数与浮点数同C语言： 整数 + 浮点数 = 浮点数 整数 / 整数 = 整数 整数 / 浮点数 = 浮点数 List 与 Tuple 类型###list 123classmates = ['Michael', 'Bob', 'Tracy']L = ['Michael', 100, True]empty_list = [] ####倒序访问 12print L[0] # 索引从 0 开始print L[-1] # 倒序访问最后一个元素（也注意不要越界） 添加元素12L.append('Paul') # 添加到尾部L.insert(0, 'Paul') # 添加到开头 删除元素12L.pop() # 删除最后一个并返回这个元素L.pop(2) # 删除第三个元素 替换元素1L[-1] = 'Paul' 字符串list 首字母大写12c = ['zz','yy','xx'] c = [string.capitalize() for string in c] tuple即不可变的 list 1t = () # 空tuple 123t = ('Adam', 'Lisa', 'Bart')a = t[-2]# t[1] = 'Bob' # 报错 tuple和list外观唯一不同之处是用( )替代了[ ] tuple没有 append()方法，也没有insert()和pop()方法 ####单元素tuple 1t = (1) # 这是整数 1，而不是tuple 12t = (1,) # 可以加一个逗号\",\"避免歧义print t # (1,) 多元素 tuple 加不加这个额外的“,”效果是一样的： 12t = (1, 2, 3,)print t # (1, 2, 3) “可变”的 tuple1234t = ('a', 'b', ['A', 'B'])L = t[2]L[0] = 'X'print t # ('a', 'b', ['X', 'Y']) tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向’a’，就不能改成指向’b’，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！ 条件判断与循环if - elif - elseif 语句后接表达式，然后用:表示代码块开始。 注意: elif 和 else 后面有个 “:” 123456789age = 20if age &gt;= 18: print 'your age is', age print 'adult'elif age &gt; 10: print 10else: print ageprint 'END' 注意: **Python代码的缩进规则**。具有相同缩进的代码被视为代码块 缩进请严格按照Python的习惯写法：4个空格，不要使用Tab，更不要混合Tab和空格，否则很容易造成因为缩进引起的语法错误。 如果你在Python交互环境下敲代码，还要特别留意缩进，并且退出缩进需要多敲一行回车 循环123L = ['Adam', 'Lisa', 'Bart']for name in L: print name 12345N = 10x = 0while x &lt; N: print x x = x + 1 循环控制 break continue Dict 和 Set 类型###Dict { key : value } 123456789d = { 'Adam': 95, 'Lisa': 85, 'Bart': 59}print d # 注意：乱序存储，不会按顺序输出（和 list 不一样）len(d) # 3 len()用来求任意集合的大小print d['Adam'] # 95# print d['Paul'] # 报错：KeyError 判断 key 是否存在： 12if 'Paul' in d: print d['Paul'] dict 的 get 方法：在 Key 不存在的时候返回 None 12print d.get('Bart') # 59print d.get('Paul') # None Dict 的特点dict的第一个特点是查找速度快，无论dict有10个元素还是10万个元素，查找速度都一样 dict的缺点是占用内存大，还会浪费很多内容，list正好相反，占用内存小，但是查找速度慢。 由于dict是按 key 查找，所以，在一个dict中，key不能重复。 dict的第二个特点就是存储的key-value序对是没有顺序的！这和list不一样 打印的顺序不一定是我们创建时的顺序 dict的第三个特点是作为 key 的元素必须不可变：可变的 list 不能作为 key 1234{ '123': [1, 2, 3], # key 是 str，value是list ('a', 'b'): True # key 是 tuple，并且tuple的每个元素都是不可变对象，value是 boolean} 更新 dict1d['Paul'] = 72 如果 key 已经存在，则赋值会用新的 value 替换掉原来的 value ####遍历 dict 123d = { 'Adam': 95, 'Lisa': 85, 'Bart': 59 }for key in d: print key, d[key] # Lisa 95 \\n... setdict的作用是建立一组 key 和一组 value 的映射关系，dict的key是不能重复的。 set 持有一系列元素，这一点和 list 很像，但是set的元素没有重复，而且是无序的，这点和 dict 的 key很像。 创建 set 的方式是调用 set() 并传入一个 list，list的元素将作为set的元素： 12s = set(['A', 'B', 'C', 'A'])print s # set(['A', 'C', 'B']) 和 dict 一样是 乱序打印 ####访问 set 123s = set(['Adam', 'Lisa', 'Bart', 'Paul'])'Bart' in s # True'bart' in s # False （注意大小写） set 的特点key必须是不变对象 判断一个元素是否在set中速度很快 set存储的元素也是没有顺序的 遍历 set123s = set(['Adam', 'Lisa', 'Bart'])for name in s: print name # 注意：打印的顺序很可能是不同的 更新 set12s.add('Adam') # 如果添加的元素已经存在，不会报错，但是不会加进去了s.remove(4) # 删除 值为4 的元素。如果元素不存在，会报错（删除前要先判断） 函数内置函数12345int('123') # 转换到整数str(10) # 到字符串abs(10.1)sqrt(100) # math 包下help(abs) # 查看abs的帮助信息 自定义函数12345def my_abs(x): if x &gt;= 0: return x # 执行完毕，不继续下去 else: return -x return None可以简写为return 多返回值12345678import mathdef move(x, y, step, angle): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, nyx, y = move(100, 100, 60, math.pi / 6)print x, y # 151.961524227 70.0 但其实这只是一种假象，Python函数返回的仍然是单一值用print打印返回结果，原来返回值是一个tuple！在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值 递归函数123456def fact(n): if n==1: return 1 return n * fact(n - 1)fact(5) # 120 使用递归函数需要注意防止栈溢出 默认参数1int('123', 8) # 83 两个参数的int：10进制转到8进制 12345678def power(x, n=2): # 求幂，默认平方 s = 1 while n &gt; 0: n = n - 1 s = s * x return spower(5) # 25 由于函数的参数按从左到右的顺序匹配，所以默认参数只能定义在必需参数的后面 可变参数12def fn(*args): print args 可变参数的名字前面有个 *** **号 解释器会把传入的一组参数组装成一个tuple传递给可变参数，直接把变量 args 看成一个 tuple 就好了 切片对list进行切片12L[0:3] # 取前3个元素：['Adam', 'Lisa', 'Bart']L[1:3] # 取 第2、3、4个元素 L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。 如果第一个索引是0，还可以省略： 12L[:3] # 前三个L[:] # 表示从头到尾，实际上复制出了一个新list 切片操作还可以指定第三个参数： 1L[::2] # 表示每N个取一个 把list换成tuple，切片操作完全相同，只是切片的结果也变成了tuple。 倒序切片12345L = ['Adam', 'Lisa', 'Bart', 'Paul']L[-2:] # 倒数第二个直到结尾（最后两个） ['Bart', 'Paul']L[:-2] # 开头直到最后第二个（但不包括） ['Adam', 'Lisa']L[-3:-1] # 倒数第三个直到倒数第一个（不包括） ['Lisa', 'Bart']L[-4:-1:2] # -4、-2 ['Adam', 'Bart'] 记住倒数第一个元素的索引是-1。倒序切片包含起始索引，不包含结束索引。 字符串切片123'ABCDEFG'[:3] # 'ABC''ABCDEFG'[-3:] # 'EFG''ABCDEFG'[::2] # 'ACEG' 1234567'abc'.upper() # 所有字母变大写 'ABC'# 单词首字母大写函数def firstCharUpper(s): return s[0].upper() + s[1:] print firstCharUpper('hello') # Hello 迭代就是遍历 Python 的 for循环不仅可以用在list或tuple上，还可以作用在其他任何可迭代对象上 索引迭代 在 for 循环中拿到索引：enumerate() 函数 ，绑定索引index和元素name 123L = ['Adam', 'Lisa', 'Bart', 'Paul']for index, name in enumerate(L): print index, '-', name 输出结果是： 12340 - Adam1 - Lisa2 - Bart3 - Paul 实际上，enumerate() 函数把： 1['Adam', 'Lisa', 'Bart', 'Paul'] 变成了类似： 1[(0, 'Adam'), (1, 'Lisa'), (2, 'Bart'), (3, 'Paul')] 因此，迭代的每一个元素实际上是一个tuple： 1234for t in enumerate(L): index = t[0] name = t[1] print index, '-', name 如果我们知道每个tuple元素都包含两个元素，for循环又可以进一步简写为： 12for index, name in enumerate(L): # 最初的式子 print index, '-', name 额外：zip()函数zip()函数可以把两个 list 变成一个 list： 12zip([10, 20, 30], ['A', 'B', 'C'])# [(10, 'A'), (20, 'B'), (30, 'C')] 迭代dict的valuedict 对象有一个 values() 方法：把dict转换成一个包含所有value的list，这样，我们迭代的就是 dict的每一个 value： 12345678d = { 'Adam': 95, 'Lisa': 85, 'Bart': 59 }print d.values()# [85, 95, 59]for v in d.values(): print v# 85# 95# 59 dict除了values()方法外，还有一个itervalues() **方法，用itervalues()** 方法替代 values() 方法，迭代效果完全一样： 12345678d = { 'Adam': 95, 'Lisa': 85, 'Bart': 59 }print d.itervalues()# &lt;dictionary-valueiterator object at 0x106adbb50&gt;for v in d.itervalues(): print v# 85# 95# 59 那这两个方法有何不同之处呢？ values() 方法实际上把一个 dict 转换成了包含 value 的list。 但是 itervalues() 方法不会转换，它会在迭代过程中依次从 dict 中取出 value，所以 itervalues() 方法比 values() 方法节省了生成 list 所需的内存。 打印 itervalues() 发现它返回一个 &lt;dictionary-valueiterator&gt; 对象，这说明在Python中，for 循环可作用的迭代对象远不止 list，tuple，str，unicode，dict等，任何可迭代对象都可以作用于for循环，而内部如何迭代我们通常并不用关心。 如果一个对象说自己可迭代，那我们就直接用 for 循环去迭代它，可见，迭代是一种抽象的数据操作，它不对迭代对象内部的数据有任何要求。 迭代dict的key和value12d = { 'Adam': 95, 'Lisa': 85, 'Bart': 59 }print d.items() # [('Lisa', 85), ('Adam', 95), ('Bart', 59)] 123456for key, value in d.items(): print key, ':', value# Lisa : 85# Adam : 95# Bart : 59 和 values() 有一个 itervalues() 类似， items() *也有一个对应的 *iteritems()，iteritems() 不把dict转换成list，而是在迭代过程中不断给出 tuple，所以， iteritems() 不占用额外的内存。 列表生成式生成列表12# 生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]range(1, 11) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 123456# 生成[1x1, 2x2, 3x3, ..., 10x10] （方式一：循环）（繁琐）L = []for x in range(1, 11): L.append(x * x)L # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 123# 生成[1x1, 2x2, 3x3, ..., 10x10] （方式二：列表生成式）[x * x for x in range(1, 11)]# [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 复杂表达式假设有如下的dict： 1d = { 'Adam': 95, 'Lisa': 85, 'Bart': 59 } 完全可以通过一个复杂的列表生成式把它变成一个 HTML 表格： 12345tds = ['&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;' % (name, score) for name, score in d.iteritems()]print '&lt;table&gt;'print '&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;'print '\\n'.join(tds)print '&lt;/table&gt;' 注：字符串可以通过 % 进行格式化，用指定的参数替代%s。字符串的join()方法可以把一个 list 拼接成一个字符串。 条件过滤for 循环后面可以加上 if 判断 12[x * x for x in range(1, 11) if x % 2 == 0]# [4, 16, 36, 64, 100] 有了 if 条件，只有 if 判断为 True 的时候，才把循环的当前元素添加到列表中。 多层表达式对于字符串 ‘ABC’ 和 ‘123’，可以使用两层循环，生成全排列： 12&gt;&gt;&gt; [m + n for m in 'ABC' for n in '123']['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3'] 翻译成循环代码就像下面这样： 1234L = []for m in 'ABC': for n in '123': L.append(m + n) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.iwxyi.com/tags/学习笔记/"},{"name":"Python","slug":"Python","permalink":"http://blog.iwxyi.com/tags/Python/"}]},{"title":"Android Adapter适配器","date":"2017-12-15T12:26:00.000Z","path":"2017/12/15/Android-Adapter适配器/","text":"1234567String[] strs = {\"基神\", \"B神\", \"翔神\", \"曹神\", \"J神\"}; //创建ArrayAdapterArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt; (this, android.R.layout.simple_expandable_list_item_1, strs); //获取ListView对象，通过调用setAdapter方法为ListView设置Adapter设置适配器ListView list_test = (ListView) findViewById(R.id.list_test);list_test.setAdapter(adapter); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"这样学Java不枯燥-学习笔记","date":"2017-10-12T12:10:00.000Z","path":"2017/10/12/这样学Java不枯燥-学习笔记/","text":"12345678910import com.rupeng.game.GameCore;public class Main implements Runnable{ public static void main(String[] args) { GameCore.start(new Main()); } public void run() { // 游戏运行的函数 GameCore.alert(\"Hello World\"); }} 123456GameCore.pause(int x) // 暂停x毫秒GameCore.setGameTitle(char * name); // 设置名字GameCore.setGameSize(int width, int height); // 设置宽高GameCore.alert(Object msg); // 弹出提示框（整数、字符串都行）Dimension d = GameCore.getGameSize(); // d.width 、 d.height （imprt java.awt.Demension;） 123GameCore.loadBgView(String imgName); // 不重叠不拉伸显示图片。图片放到 src/Images 下面（注意大小写），可拖拽或者 ctrl+V粘贴playSound(String soundName, boolean repeat); // 播放音乐（仅支持mp3），音乐放到 src/Sounds 下面closeSound(String soundName); // 关闭音乐播放（包括重复播放的） 12long a = 99999L // 常数数字默认为整型，long赋值需要转换到intfloat f = 3.14 // 这样写是错的，需要加个F或f 123String s = GameCore.input(Object value, Object msg); // 输入框（默认信息， 提示信息）boolean b = GameCore.confirm(Object msg); // 确认框（提示信息）int i = Integer.parseInt(s); // 输入的内容到整数 123456789void createText(int txtNum, String text) // 创建只读文本void setTextPosition(int txtNum, int x, int y) // 修改文本位置void setText(int txtNum, String text) // 设置文本内容void setTextColor(int txtNum, Color color) // 设置文本颜色，color.RED、color.green、new color(int R, int G, int B)void setTextFontSize(int txtNum, int size) // 设置文本大小Point getTextPosition(final int num) // 获取文本位置（import java.awt.Point;）Dimension getTextSize(final int textNum)void hdieText(fina int labelNum) // 隐藏文字void showText(final int labelNum) // 显示文字 12345678void createImage(int num, String imgName) // 创建图片控件，图片放到 src/Images 里面（注意大小写）void createImage(int num) // 创建一个什么都不显示的图片void setImageSource(int num, String imgName) // 修改显示的图片源void setImagePosition(int num, int x, int y) // 修改坐标Point getImagePosition(final int num) // 获得坐标Dimension getImagePosition(final int num) // 获得大小void hideImage(int num) // 隐藏图片void showImage(int num) // 显示图片 12345678910精灵文件位置：src/Sprites/精灵名字[]/精灵动作[]/i.png图片 按顺序放好（多选文件夹粘贴）（分层：工作空间—右上角倒三角—包表示法）void createSprite(int num, String spriteName); // 创建精灵void palySpriteAnimate(int spriteNum, String animateName, boolean repeat); // 播放精灵的动作void setSpritePosition(int spriteNum, int x, int y); // 设置精灵的位置Point getSpritePosition(int spriteNum); //获得精灵的位置Dimension getSpriteSize(int spriteNum); // 获取精灵尺寸void hideSprite(int spriteNum); // 隐藏精灵void showSprite(int spriteNum); // 显示精灵void setSpriteFlipX(int spriteNum, boolean flipX); // 是否进行X方向翻转（左右对称,fip为true时翻转，false时还原）void setSpriteFlipY(int spriteNum, boolean flipY); // 是否设置Y方向翻转（上下对称） 123Java程序打包：拷贝bin和两个jar到单独的文件夹，拷贝jre，去掉src.zip、lib\\ext\\jfxrt.jar、bin\\server、bin\\jfxwebkit.dll，减小尺寸；创建一个.bat文件，内容：start jre\\bin\\javaw.exe -cp .\\bin\\ -Djava.ext.dirs=. Main1Main1 代表入口类，如果有包名则要写全名（xxx.Main1） 123String转int：Integer.parseInt(\"123\")String相等：s1.equal(s2); （必须用这种方式写）s1==s2 不使用原因： \"abc\"+\"123\" != \"abc123\" （初学者常犯错误） 12if (i = 10) // Java中这么写是错误的，C语言可以if (b = true) // 这样是正确的 1switch (表达式) // 表达式可以为byte/short/int/char，JDK5后可以是枚举，JDK7后可以是String类型 12345678910GameCore.getPressedKeyCode(); // 获得用户当前按键（只适合“连续动作”，一次性触发最好用“事件驱动”）与KeyEvent中的值作比较：（import java.awt.event.KeyEvent;）用法：if ( key == KeyEvent.VK_UP )数字键：VK_0、VK_1……字母键：VK_A、VK_B……功能键：VK_F1、VK_F2……回车：VK_ENTER空格：VK_SPACEESC：VK_ESCAPE方向键：VK_LEFT、VK_UP、VK_RIGHT、VK_DOWN 12int[10] a = new int[10]; 等价于 int a[10]; 但是前者有初始化int、double等默认为0，String、Integer等默认为null 1编译器认为，if(无else的)、for等操作可能不执行，所以里面的变量初始化会被忽略，若没有初始化则编译器报错 123import java.util.Random;double d = Math.random(); // 返回 [ 0, 1.0 ) 之间的 doubleint num = (int) (Math.random() * 3); // 0-2的整数 1GameCore.rand(int low, int high); // low &lt;= x &lt; high 12345678System.currentTimeMillis() // 返回当前的毫秒事件Date d = new Date(2009-1900,3-1,9); // 需-1900.1.0，为：2009.3.9System.out.println(d1);int year = d.getYear()+1900; getMonth()+1; getDate(); // 年月日getHours(); getMinutes(); getSeconds(); // 时分秒getDat(); //星期几，周日=0，周一=1long time = d.getTime(); // 获取时间的毫秒（相对时间）Date d = new Date(time); // 毫秒转换成时间 1int[][] a = { { 1 }, { 2, 3, 4, 5 }, { 6, 7 } }; // 每一行的列数可以不一样，a[i].length也不一样。 课程视频：如鹏网《这样学Java不枯燥》 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.iwxyi.com/tags/学习笔记/"},{"name":"Java","slug":"Java","permalink":"http://blog.iwxyi.com/tags/Java/"},{"name":"游戏开发","slug":"游戏开发","permalink":"http://blog.iwxyi.com/tags/游戏开发/"}]},{"title":"0x3F3F3F3F","date":"2017-09-01T11:40:00.000Z","path":"2017/09/01/0x3F3F3F3F/","text":"0x3f3f3f3f的十进制是1061109567，是10^9级别的（和0x7fffffff一个数量级），而一般场合下的数据都是小于10^9的，所以它可以作为无穷大使用而不致出现数据大于无穷大的情形。 另一方面，由于一般的数据都不会大于10^9，所以当我们把无穷大加上一个数据时，它并不会溢出（这就满足了“无穷大加一个有穷的数依然是无穷大”），事实上0x3f3f3f3f+0x3f3f3f3f=2122219134，这非常大但却没有超过32-bit int的表示范围，所以0x3f3f3f3f还满足了我们“无穷大加无穷大还是无穷大”的需求。 最后，0x3f3f3f3f还能给我们带来一个意想不到的额外好处：如果我们想要将某个数组清零，我们通常会使用memset(a,0,sizeof(a))，方便又高效，但是当我们想将某个数组全部赋值为无穷大时，就不能使用memset函数而得自己写循环了，因为memset是按字节操作的，它能够对数组清零是因为0的每个字节都是0（一般我们只有赋值为-1和0的时候才使用它）。现在好了，如果我们将无穷大设为0x3f3f3f3f，那么奇迹就发生了，0x3f3f3f3f的每个字节都是0x3f！所以要把一段内存全部置为无穷大，我们只需要memset(a,0x3f,sizeof(a))。 所以在通常的场合下，0x3f3f3f3f真的是一个非常棒的选择！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C语言","slug":"C语言","permalink":"http://blog.iwxyi.com/tags/C语言/"}]},{"title":"平衡二叉树AVL","date":"2017-08-04T05:31:00.000Z","path":"2017/08/04/平衡二叉树AVL/","text":"## 二叉查找树 若它的左子树不为空，则左子树上所有的节点值都小于它的根节点值。 若它的右子树不为空，则右子树上所有的节点值均大于它的根节点值。 它的左右子树也分别可以充当为二叉查找树。 img 缺点：大部分节点都倾向一边的情况下时间复杂度几乎是线性的 平衡二叉树 具有二叉查找树的全部特性。 每个节点的左子树和右子树的高度差至多等于1。 右旋我们在进行节点插入的时候，可能会出现节点都倾向于左边的情况，例如： img 我们把这种倾向于左边的情况称之为 左-左型。这个时候，我们就可以对节点9进行右旋操作，使它恢复平衡。 即：顺时针旋转两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子 再举个例子： 节点4和9高度相差大于1。由于是左孩子的高度较高，此时是左-左型，进行右旋。 img 这里要注意，节点4的右孩子成为了节点6的左孩子了 左旋左旋和右旋一样，就是用来解决当大部分节点都偏向右边的时候，通过左旋来还原。例如： 我们把这种倾向于右边的情况称之为 右-右型。 注意：5 成为了 4 的右孩子 右-左旋 img 出现了这种情况怎么办呢?对于这种 右-左型 的情况，单单一次左旋或右旋是不行的。 img 这种我们就把它称之为 右-左 型吧。处理的方法是先对节点10进行右旋把它变成右-右型。 img 然后再进行左旋。 img 所以对于这种 右-左型的，我们需要进行一次右旋再左旋。 同理，也存在 左-右型的，例如： img 对于左-右型的情况和刚才的 右-左型相反，我们需要对它进行一次左旋，再右旋。 img 到此，我们的插入就结束了。 总结在插入的过程中，会出现一下四种情况破坏AVL树的特性，我们可以采取如下相应的旋转。 1、左-左型：做右旋。 2、右-右型：做左旋。 3、左-右型：先做左旋，后做右旋。 4、右-左型：先做右旋，再做左旋。 左右旋感觉怪怪的？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//定义节点class AvlNode { int data; AvlNode lchild;//左孩子 AvlNode rchild;//右孩子 int height;//记录节点的高度}//在这里定义各种操作public class AVLTree{ //计算节点的高度 static int height(AvlNode T) { if (T == null) { return -1; }else{ return T.height; } } //左左型，右旋操作 static AvlNode R_Rotate(AvlNode K2) { AvlNode K1; //进行旋转 K1 = K2.lchild; K2.lchild = K1.rchild; K1.rchild = K2; //重新计算节点的高度 K2.height = Math.max(height(K2.lchild), height(K2.rchild)) + 1; K1.height = Math.max(height(K1.lchild), height(K1.rchild)) + 1; return K1; } //右右型，进行左旋 static AvlNode L_Rotate(AvlNode K2) { AvlNode K1; K1 = K2.rchild; K2.rchild = K1.lchild; K1.lchild = K2; //重新计算高度 K2.height = Math.max(height(K2.lchild), height(K2.rchild)) + 1; K1.height = Math.max(height(K1.lchild), height(K1.rchild)) + 1; return K1; } //左-右型，进行右旋，再左旋 static AvlNode R_L_Rotate(AvlNode K3) { //先对其孩子进行右旋 K3.lchild = R_Rotate(K3.lchild); //再进行左旋 return L_Rotate(K3); } //右-左型，先进行左旋，再右旋 static AvlNode L_R_Rotate(AvlNode K3) { //先对孩子进行左旋 K3.rchild = L_Rotate(K3.rchild); //再右旋 return R_Rotate(K3); } //插入数值操作 static AvlNode insert(int data, AvlNode T) { if (T == null) { T = new AvlNode(); T.data = data; T.lchild = T.rchild = null; } else if(data &lt; T.data) { //向左孩子递归插入 T.lchild = insert(data, T.lchild); //进行调整操作 //如果左孩子的高度比右孩子大2 if (height(T.lchild) - height(T.rchild) == 2) { //左-左型 if (data &lt; T.lchild.data) { T = R_Rotate(T); } else { //左-右型 T = R_L_Rotate(T); } } } else if (data &gt; T.data) { T.rchild = insert(data, T.rchild); //进行调整 //右孩子比左孩子高度大2 if(height(T.rchild) - height(T.lchild) == 2) //右-右型 if (data &gt; T.rchild.data) { T = L_Rotate(T); } else { T = L_R_Rotate(T); } } //否则，这个节点已经在书上存在了，我们什么也不做 //重新计算T的高度 T.height = Math.max(height(T.lchild), height(T.rchild)) + 1; return T; }} 参考：https://mp.weixin.qq.com/s/dYP5-fM22BgM3viWg4V44A document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"STL","slug":"STL","permalink":"http://blog.iwxyi.com/tags/STL/"}]},{"title":"二叉树、平衡树、红黑树","date":"2017-08-04T05:29:00.000Z","path":"2017/08/04/二叉树、平衡树、红黑树/","text":"## 1、二叉查找树的缺点 二叉查找树，相信大家都接触过，二叉查找树的特点就是左子树的节点值比父亲节点小，而右子树的节点值比父亲节点大，如图 n 个节点的二叉查找树，正常的情况下，查找的时间复杂度为 O（logn）。 之所以说是正常情况下，是因为二叉查找树有可能出现一种极端的情况，例如 此时的二叉查找树已经近似退化为一条链表，时间复杂度顿时变成了 O(n)，为了解决这个问题，于是我们引申出了平衡二叉树。 2、平衡二叉树平衡二叉树就是为了解决二叉查找树退化成一颗链表而诞生了，平衡树具有如下特点 1、具有二叉查找树的全部特性。 2、每个节点的左子树和右子树的高度差至多等于1。 img 平衡树基于这种特点就可以保证不会出现大量节点偏向于一边的情况了。关于平衡树如何构建、插入、删除、左旋、右旋等操作这里不在说明，具体可以看我之前写的一篇文章：【漫画】以后在有面试官问你AVL树，你就把这篇文章扔给他。 于是，通过平衡树，我们解决了二叉查找树的缺点。对于有 n 个节点的平衡树，最坏的查找时间复杂度也为 O(logn)。 3、为什么有了平衡树还需要红黑树？虽然平衡树解决了二叉查找树退化为近似链表的缺点，能够把查找时间控制在 O(logn)，不过却不是最佳的，因为平衡树要求每个节点的左子树和右子树的高度差至多等于1，这个要求实在是太严了，导致每次进行插入/删除节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过左旋和右旋来进行调整，使之再次成为一颗符合要求的平衡树。 显然，如果在那种插入、删除很频繁的场景中，平衡树需要频繁着进行调整，这会使平衡树的性能大打折扣，为了解决这个问题，于是有了红黑树，红黑树具有如下特点： 1、具有二叉查找树的特点。 2、根节点是黑色的； 3、每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存数据。 4、任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的。 5、每个节点，从该节点到达其可达的叶子节点是所有路径，都包含相同数目的黑色节点。 例如下面的图片（注意，图片中黑色的、空的叶子节点没有画出）（图片来自极客时间） 正是由于红黑树的这种特点，使得它能够在最坏情况下，也能在 O(logn) 的时间复杂度查找到某个节点。至于为什么就能够保证时间复杂度为 O(logn)，我这里就不细讲了，后面的文章可能会讲。 不过，与平衡树不同的是，红黑树在插入、删除等操作，不会像平衡树那样，频繁着破坏红黑树的规则，所以不需要频繁着调整，这也是我们为什么大多数情况下使用红黑树的原因。 不过，如果你要说，单单在查找方面的效率的话，平衡树比红黑树快。 所以，我们也可以说，红黑树是一种不大严格的平衡树。也可以说是一个折中发方案。 如果我上面讲的，你都懂，都能够在面试中说出来，应该是足够的了。我当时就是这么回答的。 总结所以，最后的答案是，平衡树是为了解决二叉查找树退化为链表的情况，而红黑树是为了解决平衡树在插入、删除等操作需要频繁调整的情况。 不过，红黑树还有挺多其他的知识点可以考，例如红黑树有哪些应用场景？向集合容器中 HashMap，TreeMap 等，内部结构就用到了红黑树了。还有构建一棵节点个数为 n 的红黑树，时间复杂度是多少？红黑树与哈希表在不同应该场景的选择？红黑树有哪些性质？红黑树各种操作的时间复杂度是多少？ 参考：https://zhuanlan.zhihu.com/p/72505589 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"STL","slug":"STL","permalink":"http://blog.iwxyi.com/tags/STL/"}]},{"title":"PR笔记","date":"2017-06-15T12:23:00.000Z","path":"2017/06/15/PR笔记/","text":"入点出点可以循环播放 源视频的入点出点设置后，可以快速拖动预览至序列 片段上右键可以取消视频音频链接 jkl三个键可以让源视频前、后逐帧扫描（播放）。~让播放机（源视频进入/退出差不多全屏查看） 时间轴上移动片段，按住 ctrl使覆盖的片段自动往后移 加好减号放大缩小时间轴 播放光标在片段上，上、下按键调到片段首尾 速率伸缩工具（X）可以在片段边缘拉伸片段同时修改速率 序列间可以相互拖动每一个细节 特效控制台添加关键帧需要在左边打开动画，才会显示按钮 片段小三角代表到首尾了 双击场景过渡控件可以在效果控件里面快速编辑 可以将过渡特效设置为默认，然后再片段之间右键（ctrl+D，序列菜单键也有）应用视频过渡特效（用于批量）可多选后一键应用 视频特效-变换-裁剪/羽化边缘/翻转 等等 音频前面有个小三角，可以展开音频控制，音量线上ctrl+左键添加关键帧，上下可以移动，能调节音量响度 音频下面有个主声道，可以控制所有音频轨道的声音 时间重映射那里可以设置关键帧改速度，在片段上修改时需要改右边的fx使调整目标为速度。两个关键帧小片可以分开，使之变速过程线性变化；也有像钢笔工具的完全变化…… document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Premiere","slug":"Premiere","permalink":"http://blog.iwxyi.com/tags/Premiere/"}]},{"title":"Java大数相加示例","date":"2017-03-05T12:02:00.000Z","path":"2017/03/05/Java大数相加/","text":"题目：两个整数和能否整除 86 123456789101112131415161718192021import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while(sc.hasNext()) { int a = sc.nextInt(); int b = sc.nextInt(); if ((a + b) % 86 == 0) { System.out.println(\"yes\"); } else { System.out.println(\"no\"); } } }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Java","slug":"Java","permalink":"http://blog.iwxyi.com/tags/Java/"}]},{"title":"正则二三事","date":"2017-01-02T11:40:00.000Z","path":"2017/01/02/正则二三事/","text":"一、校验数字的表达式 1、 数字：^[0-9]*$ 2、 n位的数字：^\\d{n}$ 3、 至少n位的数字：^\\d{n,}$ 4、 m-n位的数字：^\\d{m,n}$ 5、 零和非零开头的数字：^(0|[1-9][0-9]*)$ 6、 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 7、 带1-2位小数的正数或负数：^(-)?\\d+(.\\d{1,2})?$ 8、 正数、负数、和小数：^(-|+)?\\d+(.\\d+)?$ 9、 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 10、 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 11、 非零的正整数：^[1-9]\\d$ 或 ^([1-9][0-9]){1,3}$ 或 ^+?[1-9][0-9]*$ 12、 非零的负整数：^-[1-9][]0-9\"$ 或 ^-[1-9]\\d$ 13、 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 14、 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 15、 非负浮点数：^\\d+(.\\d+)?$ 或 ^[1-9]\\d.\\d|0.\\d[1-9]\\d|0?.0+|0$ 16、 非正浮点数：^((-\\d+(.\\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\\d.\\d|0.\\d[1-9]\\d))|0?.0+|0$ 17、 正浮点数：^[1-9]\\d.\\d|0.\\d[1-9]\\d$ 或 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$ 18、 负浮点数：^-([1-9]\\d.\\d|0.\\d[1-9]\\d)$ 或 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$ 19、 浮点数：^(-?\\d+)(.\\d+)?$ 或 ^-?([1-9]\\d.\\d|0.\\d[1-9]\\d|0?.0+|0)$ 二、校验字符的表达式 1、 汉字：^[\\u4e00-\\u9fa5]{0,}$ 2、 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 3、 长度为3-20的所有字符：^.{3,20}$ 4、 由26个英文字母组成的字符串：^[A-Za-z]+$ 5、 由26个大写英文字母组成的字符串：^[A-Z]+$ 6、 由26个小写英文字母组成的字符串：^[a-z]+$ 7、 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 8、 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$ 9、 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 10、 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 11、 可以输入含有^%&amp;',;=?$\\\"等字符：[^%&amp;',;=?$\\x22]+ 12、 禁止输入含有~的字符：[^~\\x22]+ 三、特殊需求表达式 1、 Email地址：^\\w+([-+.]\\w+)@\\w+([-.]\\w+).\\w+([-.]\\w+)*$ 2、 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? 3、 InternetURL：[a-zA-z]+://[^\\s] 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=])?$ 4、 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 5、 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 6、 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7} 7、 身份证号(15位、18位数字)：^\\d{15}|\\d{18}$ 8、 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 9、 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 10、 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$ 11、 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.\\d)(?=.[a-z])(?=.*[A-Z]).{8,10}$ 12、 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 13、 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 15、 钱的输入格式： 1.有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 5.必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 16、 备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 17、 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$ 18、 中文字符的正则表达式：[\\u4e00-\\u9fa5] 19、 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 20、 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) 21、 HTML标记的正则表达式：&lt;(\\S?)[^&gt;]&gt;.?&lt;/\\1&gt;|&lt;.? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 22、 首尾空白字符的正则表达式：^\\s|\\s$或(^\\s)|(\\s$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 23、 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 24、 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) 25、 IP地址：\\d+.\\d+.\\d+.\\d+ (提取IP地址时有用) 26、 IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"RegExp","slug":"RegExp","permalink":"http://blog.iwxyi.com/tags/RegExp/"}]},{"title":"PS笔记3","date":"2016-08-15T12:23:00.000Z","path":"2016/08/15/PS笔记3/","text":"​RGB和CMY(K)互补，前者相加，后者相减：青、品红、黄。HSB：色相、饱和度、明度 界面背景可以右键修改…… 背景图层默认锁定，那个锁可以拖到垃圾箱中删除 可以选择多个层，在顶部工具栏“显示变换控件”，可以多个层的图片一起自由变换。对齐也是如此。（需移动工具） 选择一个图层，按住shift，再点击另一个图层，可以选中这两个图层及其之间的所有图层 矩形选区时shift正方形选区，椭圆相同。alt中心选择。可同时使用两键 裁剪工具裁剪时可以使用“拉直”，正的区域会比原来歪的区域小一些。“删除裁剪的像素”可以删掉周围多余的 裁剪顶边工具栏的设置按钮：“经典模式”（老版本）是裁剪区域不动，原图像动。“自动中心预览”可以使背景旋转大小改变，但是选择区域不变。按下鼠标旋转区域使9宫格会变成16宫格并且在正的时候变白，不正时灰 环境比例构图，将重要的部位放在交叉线上。o切换辅助线种类，shift+o变换辅助线（翻转、平移） 透视裁剪：一种方法扣出网格再调整，另一种方法鼠标单击，再单击拉线，四个点组成四边形。高度宽度是调整后矩形的尺寸。单击“前面的图像”，会自动填充当前的图像尺寸，接着可以到其他图像进行裁剪 alt+左键，选择旋转中心 切片划分，水平划分是横着切，纵向是竖着切。可以使用顶部工具栏对齐 切片选择工具移动切片，会自动产生灰色的切片，这时候可以隐藏自动切片使之不可见。“提升”选项可以使自动切片变为用户切片 切片选项的目标：比如：_blank，是新窗口打开网页（上方的URL选项） 吸管工具可以设置取样图层，比如“当前和下方图层”。取样大小可以设置取样范围并取平均值 颜色取样器可以选择4个取样点并在信息面板中显示RGB值。用清除按钮清除 标尺：拉出一条标尺后会显示倾斜角，可以直接按拉直按钮拉直图层。按住alt再拉出另一条，会显示两条线的夹角，A：夹角 计数可以创建计数组，还能隐藏。 污点修复画笔修复脸部黑点之类。有三种方式，近似匹配不好用。也可以对所有图层取样。 修复画笔按alt单击取样，再单击或按下拖拽，即可将取样的区域复制过去并与周围融合。可以设置忽略调整图层。“对齐”：修复时跟着鼠标相对移动。选择“图案”时不需要取样，直接涂抹，会根据样本图层自动变色 “仿制源”面板可以设置修复画笔的旋转角度、透明度等 修补工具：正常：1.源：选选区（可以直接选，也可以用选择工具选），再拖拽，将最后松开左键时的图像放到原选区中；2.目标：将选区图像拖到（复制）其他位置。透明：前后图像融合 内容识别：越不严格，程序会自动从周围图像填充过来。此时建议选区大一些 修补工具也可以用来画区域，限制修复工具的范围内容感知工具：移动：移动选区，并从相似处填充遗留的选区；扩展：复制 红眼工具：红眼变黑。工具栏调瞳孔大小，越小黑色越聚集在中央。变暗两越大越黑。突然闪光会使眼睛充血红眼。 画笔工具：按下1—10，直接调透明度，百分之几十。快速连续两个数字，调百分之几十几。shift+数字键调整流量。流量：颜良从笔尖流出的速度。喷枪：停顿时间越长不透明度越高（需降低流量）。透明满流量的画笔一笔画重复涂抹一处，其颜色不会变；第二次画上去，颜色加深（可以理解为上次画的颜料已经干了）。低流量一笔画重叠部分可以颜色加深。画笔的角度和圆度是改变两端形状的。间距对流量比较敏感。 线性高度比高度纹理要浅。双重画笔取两种画笔的交集。 铅笔工具用shift进行连接画出图像，而且画出的效果比画笔清晰。自动抹除：如果落笔的地方是前景色，那么将自动抹除前景色，用背景色代替。 将图层移动到新建图层可以快速复制图层 颜色替换工具用alt取色，涂抹上去替换颜色。可以在新建复制图层上涂抹，然后调整复制透明度使颜色更加柔和。模式：连续：鼠标移动替换；一次：左键按下替换；背景：仅替换背景。限制的查找边缘：尽可能保持边缘的色彩过渡 混合器工具：画笔沾染颜色，与未干燥的纸上染料进行涂抹。混合：0%为画笔颜色，100%则为拖出图像颜色。潮湿：拖动出来的长度。载入：染料的量（决定能画多长距离） 修复画笔在修复后会与周围环境进行融合，但是仿制图章不会。后者不可进行图案，但是模式更多 图案工具：对齐：使两处的图案纹理连续、一致。印象派效果：使图案杂乱无章 历史记录画笔：在图层最左侧确定“源”后，画笔涂抹能使其恢复到源图像 历史记录艺术画笔：只能用于8位图像。产生画画的效果。区域：影响的区域大小。容差：允许修改的历史记录源图像与当前图像的差距，低时能到处画。 橡皮擦能擦出背景色，也能擦出透明，还能抹到历史记录（需设置源，相当于历史记录画笔）。 背景橡皮擦：擦除背景，能类似魔棒扩选。保护前景色：前景色。魔术橡皮擦：橡皮擦+魔棒 渐变工具：仿色：防止打印时条带现象产生。透明区域：是否允许渐变中的透明 使用锐化工具时尽量使用保护细节 涂抹工具类似于混合器画笔。手指绘画：结合前景色进行绘画 加深、减淡工具：加深变暗，减淡变量。可以设置调整高光、中间调、阴影。曝光值：效果强度。保护色调：使色彩过渡更加优秀。 海绵工具：增加或减少饱和度（鲜艳） 路径：锚点、片段。创拖拽创建曲线。在原点处单击，闭合曲线。直接选择工具进行编辑。添加锚点工具、删除锚点工具。自由钢笔工具：自由绘制路径。转换点工具：将有控制杆的锚点转换成没有控制杆的锚点，也可以拖动锚点将其转换成有控制杆的锚点。若开启自动添加/删除，则可以按ctrl暂时转换到直接选择工具，单击显示锚点。ctrl松开回复钢笔。alt暂时到转换点工具。移动时alt也能复制路径。约束路径拖动：拖动片段时是否不改变相邻两个片段曲线 矩形工具等也可以建立矩形路径。多边形的设置中的”缩进边依据“：尖角圆弧程度。平滑拐角/平滑缩进：通过弯曲使边角/夹角顺畅。 创建路径：1、单击与拖拽结合。连续点两个点可以创建直接，ctrl单击出现锚点，然后按下alt可以控制控制杆，两条重合的片段分开，即是创建不规则圆。 2、先单击所有拐点，创建直线路径，然后调整控制杆进行弯曲，每次只顾一边不顾另外一边。 3、使用相似的形状创建路径，自由变换+路径运算。ctrl+x剪切路径。若对称，则宽度、高度使用-100%则翻转画直线：shift竖直水平以及45度。拖动时shift竖直水平拖动 路径面板：白色为路径内部区域，灰色为外部 直接选择工具编辑路径时，减去顶层路径为内外颠倒选择区域 段落面板设置段落格式。输入文字时，可单独设置光标所在段落的样式 先画路径，ctrl+左键隐藏锚点。然后文字工具放在路径上，会专门复制一个路径，并使文字沿着路径排布。文字左上角可以切换横向纵向。文字路径可以编辑，两端上下移动修改起点、终点。在两端左右移动替换起点终点 闭合路径中，文字工具可以直接在路径里面单击，并且约束文字排版于路径中。 抓手、旋转工具：可以设置滚动/旋转所有窗口 shift+ctrl+alt+e合并所有可见图层 图层面板的“锁定透明像素”：只有不透明像素才能够编辑。“锁定位置”与“锁定透明像素”可一起用 画笔越黑越能擦出透明蒙版。白色恢复蒙版。选择蒙版图标时切勿选择到图层！ 按shift单击蒙版，可以暂时停用蒙版。蒙版可以拖到垃圾桶。 “斜面与浮雕”中的“描边浮雕”需要和“描边”效果一起用才会产生效果 画路径-“图层-矢量路径-当前路径”，可以提取中当前路径中的颜色，其他全清空 图层面板下方可以新建各种图层。选区后，为调整层，有创建蒙版，有路径；可用路径编辑工具进行调整范围 新建“纯色”图层，双击缩略图可以修改颜色。 新建“图案”图层，“与图层链接”：拖动图像时，上方的图案是否不随之拖动 亮度/对比度 面板的 旧版：扩大调整的极限，但是看起来比较假 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PhotoShop","slug":"PhotoShop","permalink":"http://blog.iwxyi.com/tags/PhotoShop/"}]},{"title":"PS笔记2","date":"2016-08-15T12:21:00.000Z","path":"2016/08/15/PS笔记2/","text":"溶图时正片叠底可以去除背景的白色 [缩小画笔，]放大画笔 蒙版也可以用前后景色快捷键直接覆盖 shift单击蒙版停用，alt单击看纯蒙版状态 图层与蒙版之间的锁链会使两者无法相对位移。解除锁链后，选区，涂抹，再移动蒙版来调整区域 ctrl+t：锁链时图层；无锁链：选中图层时图层，可相对位移；选中蒙版时调整蒙版可见区域 ctrl+i：反相，有选区时仅调整选区。可快速颠倒蒙版里外 显示太生硬额可以调整画笔硬度和透明度 蒙版只看明度，大红也显示灰色 ctrl+alt+g剪切蒙版：上图下形，即下面的图的形状作为蒙版，扣除那个形状。上图依旧可以加图层蒙版 按住ctrl点图层图标，可以显示选区 在剪切蒙版上画笔作图，即相当于直接画在图层上，什么颜色就是什么颜色 快速蒙版：使选区边缘柔和一些，在通道面板查看，双击通道中的图标可以设置颜色等 选区与蒙版的本质都是通道 通道中有选区的话，即使是不可见的也会限制画笔的涂抹 通道面板中有分离通道的选项，可以分成R、G、B三个psd_R/G/B黑白文件，然后还可以合并通道 “编辑-首选项-界面-用彩色显示通道”可以使通道颜色变为彩色 三原色通道可以直接分别移动（彩色残影效果），可以直接用画笔涂抹，白色为增加通道所在的颜色。，也可以调用色阶曲线。在通道中涂抹不会涂到透明像素。 蒙版/通道里图像可以选取、复制粘贴到其他蒙版/通道。有些时候在通道中选区更方便 吸管工具在黑白显示的通道中取到的数值为实际彩色的颜色值 “选择-载入选区”可以载入选区中其他图层/通道的图像 ctrl+shift+u去色 选择图层前别忘了先在通道中选择回RGB四个通道 “图层-新建-背景图层”可以将当前图层转化成背景图层（透明的加个背景） 填充图层 与 直接新建图层 再填充的区别：填充图层双击图层图标可以快速修改，只能填充/渐变一次，每次清除上次；新建图层可以累加填充、渐变 新建调整图层可以仅调整某一选区，并随时修改 进行渐变时正常模式只能拉一个，绿色模式可以重复 拖拽蒙版图标至另一个蒙版可以替换 阈值可以直接调整图像的黑白 “图层-矢量蒙版-添加矢量蒙版”与选区的区别：前者可以随意调节大小，后者边缘柔和 先选区，再“路径面板下方图标-从选区生成工作路径”，可以将选区转化成路径 路径栅格化可成形状 路径也可以右键进行描边，同样可以设置画笔的各种属性。相比选区描边，多出各种设置来 描边路径时若想要从某个部位开始，可以减去此处小小的部分（断开） 形状新建后，alt拖拽鼠标新图层建新形状，可以先改变前景色，然后新形状也会变颜色 选区、路径、形状，三者皆可以互相转化 带矢量路径的图层，若选择图层则一起调，若选中路径则调整路径 浮雕效果等可以把透明度拉低使之符合背景色 先加入文字、形状等，然后ctrl左键选区，删除文字图层，路径面板新建选区路径，图层面板新建填充图层，即可创建可改变大小的填充图像，在路径面板选中后用路径选择工具调整大小 文字跟随路径需要先在路径面板选中路径。使用路径选择工具修改路径上的文本大小、哪一侧等 在路径外面写字顺着边缘，在闭合路径里面填充内部空白并且自动调整位置 利用通道选区时可以先复制一个通道，然后ctrl+m，增加对比度 “滤镜-消失点”创建透视平面（然后按ctrl并拖拽线段中间点可以创建连续的垂直平面），并将透视平面上的图片移动到另一个透视平面。选择工具时双击平面可以选中平面，可以复制粘贴。适合三维场景的贴图 想要在消失点创建文字，先新建文字图层，然后选中图层进行复制，隐藏图层，选中修改的图层后在消失点界面中粘贴并且使用选区工具移动到合适的位置 马赛克能和羽化一起用。想要马赛克后弄回来，可以先转化为智能对象，然后进行马赛克，会出现“马赛克”智能滤镜图层，类似蒙版，涂黑时不马赛克，涂白时马赛克。智能滤镜可以开关，也可以shift单击禁用。多个智能滤镜的先后顺序不同显示的效果不同。 智能对象栅格化变回普通图层 “滤镜-像素化-碎片”，上下震动效果；“彩色半调”，用CMYK四种颜色（灰度图像为大小不同的黑白点）组成图像（缩小才能看）；“彩色化”比“晶格化”柔和一些 “滤镜-扭曲-极坐标”将球形（地球仪）转化成平面；“镜头校正”修改图像突出、凹进；“切变”把图像方向弄歪；“置换”就当前图层自适应选定图片；“波纹”滤镜使用前最好用椭圆选区 “液化”滤镜类似于涂抹工具，但是有更多效果。旧版液化有冻结蒙版和更多功能 “滤镜-杂色”各种选项能去小点 使用模糊效果后，可以用历史记录画笔画出原来的部分 高斯模糊时是随机模糊，表面模糊是反差小的地方模糊（可以去斑点） 径向模糊有旋转和缩放两者模糊方式 可以选中通道、蒙版，对其进行滤镜操作…… 图层面板上的“正常”拉出的框中选中“差值”，可以看到当前图层与下一个图层的区别，越白为差别越大 ctrl+shift+u去色，变为黑白的 锐化和模糊可以互相转化，一个事物的两个方面 加“镜头光晕”滤镜时，一般新建图层，用黑色填充，然后加滤镜，图层模式选择“滤色”。这样设置可以调整透明度等 “纤维”滤镜配合“模糊”（需要先把新图层填充黑色），在调整图层模式为“柔光”、“叠加”等，可以形成下雨的效果 通道的图像可以直接复制到图层 想要“风”滤镜向上下吹，可以先旋转画布90度，加滤镜后转回来……要是分不够大，可以多次吹风 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PhotoShop","slug":"PhotoShop","permalink":"http://blog.iwxyi.com/tags/PhotoShop/"}]},{"title":"PS笔记1","date":"2016-08-15T12:20:00.000Z","path":"2016/08/15/PS笔记1/","text":"ctrl移动，空格-抓手，tab开关面板和工具栏，shift+tab开关面板 ，ctrl++放大，ctrl+-缩小，ctrl+0屏幕大小，ctrl+1实际大小 shift+ctrl+i选择反向，ctrl+u色相，ctrl+alt+d羽化，ctrl+r标尺，ctrl+m曲线，ctrl+e合并 放大镜工具按下alt变为缩小；修改画布大小等时按住alt使“取消”按钮变为“复位”按钮；平铺小图标或选区图像时按下alt可按住鼠标左键拖拽复制 吸管工具下的标尺工具能从上方信息栏看到倾斜角度，并能直接置入“图像-画布旋转-任意角度”的输入框中以掰正方向 自由变换、裁剪时 双击=enter完成 透视裁剪工具可以将近大远小的平面图掰正 图像拼接时可以暂时调整透明度来微调融合 鼠标无法拖拽复制图片、填充无效以及复制不了粘贴不了等可能是因为图像模式，比如索引模式需设置成RGB模式 先选区，然后画笔或调整色相，这样就可以限制区域 在选区内部拖拽鼠标，移动工具移动选区图像，alt拖拽复制图像至新图层（背景图将不会新建图层，此时需用复制粘贴）；选择工具移动选区范围 在选区外部拖拽鼠标，移动工具移动选区；选择工具单击取消选区，拖拽时shift添加选区，alt减去选区，shift+alt交叉选区 选中图层，ctrl+j可将 选区图像/当前图层 复制至新图层；ctrl+e向下合并一个图层（图层名为下方图层名） shift+F5填充的内容识别可自动修改内容，可羽化 shift+ctrl+l自动调色，可羽化 画圆时shift正圆，alt从中心开始画；画矩形时同 alt+delete/退格 前景填充选区，ctrl+delete/退格 背景填充选区；同时按住shift可复制 delete删除一个套索节点，esc彻底删除套索选中 自由变换可以直接翻转；shift锁定长宽比；alt围绕中心变换；可调到标尺工具画直线拉直（调整角度） 先羽化再复制、填充；羽化范围是选区边缘内外；羽化10，再羽化10，范围略小于羽化20 选区-羽化-选区运算，可以使同一选区羽化不同；清除时也可羽化 “选择-色彩范围”、“选择-扩大选区（连续）/选区相似（不连续）”可以类似魔棒选颜色区域（前者可事先选区以限制范围并预览） “选区-调整边缘-智能半径”可以类似魔棒识别色差 只有选择工具（矩形、椭圆）才有右键描边 ctrl+shift+t，造次操作；组团了+shift+alt+t复制至新图层并再次操作。 后退一步快捷键与QQ冲突：PS课：QQ不隐身，上课不认真 将图层转换为智能对象能够帮助我们在放大照片的同时保留照片的清晰度 图层模式的 正片叠底、叠加 可以使图像色彩与背景适应 左右键换图层混合选项 “编辑-变换-再次”能重复自由变换操作，同时按住alt可新建图层来变换 “选择-修改-XX”可以调整选区边缘 油漆桶工具在色板上的色块外单击可以新建色块 油漆桶工具按住shift可以改变画布外面的背景 渐变编辑器渐变调板的小箭头可以直接双击选颜色；上下拽动小箭头可删除小箭头 所有对颜色的操作都在“图像-调整”里面 直方图：明度左边最暗，右边最亮。越集中在左边说明曝光越不足。可用“图像-调整-亮度/对比度”来修改曝光不足/过度 背光图可以使用“图像-调整-阴影/高光”，把暗处调亮，亮处调暗 色调均化：亮的地方多就变暗，暗的地方多就变亮，灰的图不同区域调亮调暗 ctrl+l色阶，输入：移动黑场小箭头越往右越黑，输出相反。输入：黑场左边的颜色变纯黑，白场反。输出：限制最黑最白的极限。输入的点对应到输出的点。（右边三个吸管可快速设置）按住alt可以通过黑白视图看改变的区域。颜色偏黑/灰(输入：黑白场调到中间=增加对比度，输出调中间=降低对比度)/白均可以用色阶来调整。输出色阶的黑场白场可以越过对方使得颜色反向。调色之前可以先选区、羽化 红青，绿品红，蓝~黄，使用色阶灰场吸管时会增多相反颜色。（=相机的白平衡） 脸红可通过色阶红通道来调节，将输入黑白场往中间移。肉色：红色调高，绿色略调高，蓝色调低。调色时可以将一个通道加（左加右减），其他两个颜色通道减小 只有在通道选中（可视）的通道才能在色阶处编辑 “图像-调整-曲线”有色阶的功能。曲线上拉变亮，下拉变暗。按住ctrl和左键（或直接双击）取点。将取的点拖拽至外面可以删除点。点手指按钮可以设置直接在图像上上下拖动调整曲线 ctrl+u色相/饱和度，可左键按下图像左右移动调整饱和度。按下之前用ctrl可调整色相。同时按下shift可快速调整。下方的两个彩虹条之间是选择允许变色的范围，上面是原色，下面是改变后的颜色；范围条中间的两竖之间是完全变化，剩下两侧边是羽化范围。范围条可以是中间，也可以是两边（挪过头）。增加饱和度略相当于锐化 “图像-调整-替换颜色”与色相/饱和度一样，只是多了黑白预览，且直接设置在容差范围内替换颜色而非范围条。吸管：shift加范围，alt减范围 “图像-调整-通道混合器”可以设置RGB每个颜色的来源，即使原多色调成（输出成）某色 “图像-调整-可选颜色”调整特定颜色的各偏向输出 “图像-调整-照片滤镜”能够增加颜色并调整强度 “图像-调整-变化”可以加深阴影/中间调/高光/饱和度的特定颜色 “图像-调整-色彩平衡”可单独设置阴影/中间调/高光的RGB值 “图像-调整-匹配颜色”可以是一张图片采用另一张图片的颜色（可分别建立选区。来源图片按w+j至新建图层，匹配时选择图层） “图像-调整-渐变映射-单击打开渐变编辑器”，点了黑场之后点空位置新建黑场，点白场后新建白场。色阶/色阶曲线就是分别设置RGB三个颜色通道的渐变映射 “图像-调整-黑白”可以整体黑白，并且使某个颜色更白/黑一些 “图像-调整-阈值”调整色阶至黑白，一般作为压线条：先用“滤镜-其他-高反差保留”，再调整阈值，可以提取线条 “图像-调整-色调分离”可以快速调整颜色反差，从油画模样到真实照片。即由色块组成图像 Lab通道：L：明度的过渡，a：绿色到品红的过渡，b：蓝色到黄色的过渡；（可用画笔涂抹，黑到白） RGB色彩模式依赖设备（硬件、亮度）、环境（灯光）。Lab与设备不相关，根据颜色调整颜色，且能显示所有颜色。理论上来说，Lab模式打印出来可以发光发亮。 若RGB“滤镜-锐化-USM锐化”后出现不正常颜色，可以先调到Lab模式，再选中明度通道，接着锐化 加强某个区域的饱和度，可以先复制图层，再调整，再用画笔调整透明度擦去 可以直接在通道上上色，等同于在图层上上色。在a通道用黑笔画图像变绿，用白笔画变品红。b通道分别为蓝色、黄色 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"PhotoShop","slug":"PhotoShop","permalink":"http://blog.iwxyi.com/tags/PhotoShop/"}]},{"title":"CGI-C语言也能干大事","date":"2016-07-12T11:42:00.000Z","path":"2016/07/12/CGI-C语言也能干大事/","text":"CGI123char * qs = getenv(\"QUERY_STRING\");//获取环境变量char username[256];sscanf(qs, \"username=%s\", username);//获取地址栏后面的东西 断点调试：include &lt;windows.h&gt;，然后 MessageBoxA(0,\"ok\",\"ok\",0);让程序启动后暂停，等待着按按钮；浏览器访问CGI，窗口弹出后，在VS中“调试”→“附加到进程”，设置断点，然后在关闭消息对话框。 123printf(\"Location:http://www.baidu.com\\r\\n\");//重定向，302 Found。注意\\r\\nprintf(\"Location:1.html\\r\\n\");//重定向至cgi程序同目录的1.html文件printf(\"Content-Type:text/html;charset=gbk\\r\\n\\r\\n\");//改成 text/plain，为普通文本，显示HTML标签。 注意\\r\\n\\r\\n（两个），表示报文头结束了（各个报文头顺序可调换）源代码中，\\n能换行，但是浏览器上要用&lt;br&gt;才换行，所以用： \\n&lt;br&gt; 12itoa(i, str, x); //int i 转换成 char str[]、x进制的文本int i = atoi(str); //字符串转换成int 1fprintf(cgiOut, \"&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;大家好，Querystring=%s，你的浏览器UserAgent是：%s，你的IP地址是：%s，当前cgi地址：%s&lt;/body&gt;&lt;/html&gt;\", cgiQueryString, cgiUserAgent, cgiRemoteAddr, cgiScriptName);//可以用printf 12cgiFormString(\"name\", name, sizeof name); // 获取用户名：name=xxxif (cgiFormString(\"password\", pwd, sizeof pwd) != cgiFormSuccess);//返回值表示有没有这个值 123456789101112131415161718 &lt;!--点击登陆转到网址：../11.cgi?name=admin&amp;pwd=123， 或者绝对网址：\"http://www.baidu.com\"。 method=\"get\"（默认）或者\"post\"，post时地址栏看不到表单 --&gt;&lt;form action=\"11.cgi\"&gt; 用户名：&lt;input type=\"text\" name=\"name\" value=\"admin\" /&gt; 密 码：&lt;input type=\"password\" name=\"pwd\" value=\"123\" /&gt; &lt;input type=\"submit\" value=\"登陆\" /&gt;&lt;/form&gt; &lt;!--form中的：input、textarea、select 中的名字和值都会提交给服务器 没有name值的表单将不会提交，包括submit。--&gt;&lt;select name=\"se\"&gt;&lt;option value=\"nan\"&gt;男&lt;/option&gt;&lt;option... /option&gt;&lt;/select&gt; &lt;!--提交的值为value属性，如：se=\"nan\"--&gt; &lt;input type=\"checkbox\" name=\"ch\" id=\"chk\" / &gt;&lt;lable for=\"chk\"&gt;我已阅读XXX&lt;/lable&gt; &lt;!--如果勾上了，会有 \"ch=on\" 提交给服务器。 radio 的 name 属性相同的为一组，提交选中的 value--&gt; &lt;input type=\"hidden\" ... /&gt; &lt;!--隐藏的字段，不会显示，但是也会提交--&gt; 1、select、input、textarea必须要在form中。2、当点击input type=\"submit\"的按钮的时候，会把它所在的form中的所有“有name属性的”input/select/textarea的值（value）提交给服务器。3、表单提交的值 input type=\"text\"的值就是用户输入的值； 对于input type=\"checkbox\"的值就是“选中是on，没选中则没有”； 对于inpu type=\"radio“的则是被选中的name、value提交给服务器； 对于input type=\"submit\"的则是被点击的name、value被提交给服务器； 对textarea就是输入的文本； 对于select就是选择项对应的option的value。 123456TMPL_varlist *varlist1 = 0;//空的参数列表 C99cgiHeaderContentType(\"text/html;charset=gbk\");varlist1 = TMPL_add_var(varlist1, \"test1\", \"特斯特1\", \"pwd\", \"小密码\", \"name\", \"小鹏\", 0); // 3对，最后一个必须为0表示可变char *age = \"38\";varlist1 = TMPL_add_var(varlist1, \"age\", age, 0);//执行完了varlist1四对参数TMPL_write(\"P1.htm\", 0, 0, varlist1, cgiOut, cgiOut); 变量使用：&lt;TMPL_VAR name=\"test1\" /&gt;&lt;br /&gt; 123456789TMPL_varlist * varlist1 = 0;TMPL_loop * loopUsers = 0;varlist1 = TMPL_add_var(varlist1, \"Title\", \"测试Loop\", 0);loopUsers = TMPL_add_varlist(loopUsers, TMPL_add_var(0, \"Name\", \"如鹏网\", \"Age\", \"8\", \"Title\", \"t1\", 0));//t1，同一行有的用同一行loopUsers = TMPL_add_varlist(loopUsers, TMPL_add_var(0, \"Name\", \"淘宝\", \"Age\", \"15\", \"Title\", \"t2\", 0));//t2loopUsers = TMPL_add_varlist(loopUsers, TMPL_add_var(0, \"Name\", \"京东\", \"Age\", \"10\", 0));//测试Loop，同一行没有的到上层去找varlist1 = TMPL_add_loop(varlist1, \"users\", loopUsers);//大List里面的小List（name=“users”的Loop）cgiHeaderContentType(\"text/html;charset=gbk\");TMPL_write(\"Users.htm\", 0, 0, varlist1, cgiOut, cgiOut); 12345&lt;table&gt;&lt;tbody&gt;&lt;TMPL_LOOP name=\"users\"&gt; &lt;tr&gt;&lt;td&gt;&lt;TMPL_VAR name=\"Name\" /&gt;&lt;/td&gt; &lt;td&gt;&lt;TMPL_VAR name=\"Age\" /&gt;&lt;/td&gt; &lt;td&gt;&lt;TMPL_VAR name=\"Title\" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/TMPL_LOOP&gt;&lt;/tbody&gt; &lt;/table&gt; MySQL 数据库1select * from Students // 表里面的数据 1insert into Students(ID, Name, Gender) value(3, 'asd', 1) // 插入数据，属性值对应（允许为空或者自动递增可不用写） 123update Persons set Name='hehehe',Age=Age+1 // 全部更新表中某几列的数据update Persons set Age=Age+1 where Name='Tom' // 名字为 Tom 的人年龄+1条件用法：where (Age&gt;20 and Age&lt;30) or(Age=80) // or、and、not、&lt;、&gt;、&gt;=、&lt;=、!=（或&lt;&gt;） 12delete from Person where ... // 删除表中的数据，没有where为删除所有drop table Persons // 删除表 1234select Age+1, Name from Persons where...// 显示表中的某几列（Age的列结果为Age+1）select Name 姓名, Age as 年龄 from Persons; // 为列取别名，可以不写asselect 1+1 // 检索不与表关联的数据，结果为2select now() // 返回时间 12345SQL聚合函数：MAX（最大值）、MIN（最小值）、AVG （平均值）、SUM （和）、COUNT（数量）select min(Age), max(Age) from Persons // 最低、最高年龄select count(*) from Persons where Age&gt;25 // 年龄大于25的人数select sum(Age), avg(Age) from Persons // 总年龄和平均年龄select count(Hobbies) from Persons // Hobbies 不为空的数量 12select * from Persons (where……) order by Age ASC, Salary DESC // 按照年龄升序(ASC,不写时默认)、薪水降序(DESC) 排列order 必须放在 where 后面 123单字符通配符：_多字符通配符：% （可以为0个）select * from Persons where Name like 'T%' // 名字为 T 开头的所有 1234null 代表“不知道”，而不是“没有”。null+1 结果是 nullselect ...... name=null 或者 name != null 或者 nul=null 都没有任何返回结果select name+\"a\" from Personsselect * from Persons where name is (not) null // 判断是不是null 1limit 首行行号（行号从 0 开始）, 最大数目 // limit 必须放在所有语句的最后 12group by Age // 按照年龄分组，相同的为一组（重复的堆到一起）select age, count(*) from Persons group by age // 显示所有年龄段，并且显示数量 12345查询每张订单的订单号、价格、对应的客户姓名以及客户年龄SELECT o.Number 订单编号,o.Price 价格,c.Name 客户姓名,c.Age FROM T_Orders o // 表别名为 oLEFT JOIN T_Customers c ON o.CustomerId=c.Id // 别名为 c，当两个相等的时候，进行连接LEFT JOIN T_OrderTypes t ON o.TypeId=t.Id // 可以 join 多张表WHERE o.Price&gt;=150 // 可添加 where 条件 12设计表——外键——添加，然后删除时会提示无法删除（可设置）删除时、更新时：一般默认RESTRICT（一起删除）；SET NULL（删除后连接的项目设置为NULL）；NO ACTION/RESTRICT（拒绝删除） C + MySQL使用方法：需要修改三个目录，以及复制dll 1、在项目属性中【VC++目录】→“包含目录”，选择mysql的include文件夹；“库目录”选择mysql的lib文件夹；【链接器】→【输入】的“附加依赖项”增加“libmysql.lib”。 2、C代码里include头文件mysql.h，并且在之前要include头文件winsock.h。 3、MYSQL *pConn = mysql_init(0); 4、编译运行，会报错找不到“libmysql.dll”，把mysql的libmysql.dll复制到exe的目录下。 123456789101112131415161718192021222324#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;winsock.h&gt;#include &lt;mysql.h&gt;int main(){ MYSQL *mysql = mysql_init(0); if(!mysql_real_connect(mysql,\"localhost\",\"root\",\"root\",\"study3\",0,0,0)){ printf(\"连接数据库出错：%s\",mysql_error(mysql)); // mysql的上一次错误信息 goto exit;//goto一般不推荐使用，但是在错误处理的时候，很好用 } printf(\"连接数据库成功！\\n\"); if(mysql_query(mysql,\"set names gbk\")){ // 这样才能用中文。失败时 为 真 printf(\"设定连接编码失败%s\",mysql_error(mysql)); goto exit; } exit: mysql_close(mysql);//程序最后必须关闭连接，否则会有mysql服务器连接过多卡死的可能性 printf(\"exit\"); getchar(); return 0;} execute封装12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;winsock.h&gt;#include &lt;mysql.h&gt;void executeNonQuery(char * sql); // 没有返回值的MYSQL_RES * executeQuery(char * sql); // 有返回值的int main(){ executeNonQuery(\"insert into Persons(name, gender) value('aaa', 1)\"); MYSQL_RES * res = executeQuery(\"select * from Persons\"); MYSQL_ROW row; while (row = mysql_fetch_row(res)) { char * un = row[0]; char * pwd = row[1]; printf(\"username = %s, password = %s\\n\", un, pwd); } system(\"pause\"); return 0;}void executeNonQuery(char * sql){ MYSQL * pConn = mysql_init(0); if (!mysql_real_connect(pConn, \"localhost\", \"root\", \"root\", \"test\", 0, 0, 0)) { printf(\"连接失败：%s\\n\", mysql_error(pConn)); goto endd; } if (mysql_query(pConn, \"set names gbk\")) { printf(\"设置gbk失败：%s\\n\", mysql_error(pConn)); goto endd; } if (mysql_query(pConn, sql)) { printf(\"查询失败：%s\\n\", mysql_error(pConn)); goto endd; }endd: mysql_close(pConn);}MYSQL_RES * executeQuery(char * sql){ MYSQL * pConn = mysql_init(0); if (!mysql_real_connect(pConn, \"localhost\", \"root\", \"root\", \"test\", 0, 0, 0)) { printf(\"连接失败：%s\\n\", mysql_error(pConn)); return \"\"; } if (mysql_query(pConn, \"set names gbk\")) { printf(\"设置gbk失败：%s\\n\", mysql_error(pConn)); return \"\"; } if (mysql_query(pConn, sql)) { printf(\"查询失败：%s\\n\", mysql_error(pConn)); return \"\"; } MYSQL_RES * result = mysql_store_result(pConn); mysql_close(pConn); return result;} 表单数据12345char sql[1024]={0}; // 把用户输入的字符串动态拼接生成sql语句char userName, hexUserName[1024]={0}; // 把可能含有特殊符号的字符串进行16进制转换mysql_hex_string(hexUserName, userName, strlen(userName)); // 转换成安全的16进制sprintf(sql, \"Insert into T_Users(UserName,Password) values(0x%s,'%s')\", hexUserName,password);// 可以直接识别命令里面0x开头的16进制数据，并自动转换成原来的字符串(数字 0，不是 英文o) 123int age;cgiFormInteger(\"age\", &amp;age, 100); // 获取整型表单。注意，是地址！最后一个是失败后的age默认值// 例如，当 \"age=aaa\" 时，取不到整型的值，所以 age = 100 1234567int len; // 用来决定需要申请的长度char *txt;TMPL_varlist *varlist = 0;cgiFormStringSpaceNeeded(\"txt1\",&amp;len); // 用于获取可能会非常长的值的长度txt = (char *)malloc(len+1); // 动态申请内存cgiFormString(\"txt1\",txt,len);free(txt); // 最后别忘了 free 12if(cgiFormCheckboxSingle(\"agree\")!=cgiFormSuccess) // 多选框是否选中&lt;select&gt;&lt;option&gt;xxx&lt;/option&gt;&lt;/select&gt; 和 \"radio\" 都用 cgiFormString 来获取是否输入 文件操作HTML文件123&lt;form method=\"post\" enctype=\"multipart/form-data\"&gt; // 必须这样写 &lt;input type=\"file\" name=\"f1\"&gt;&lt;/form&gt; 文件参数 cgiFormFileName：上传的文件名 cgiFormFileSize：文件大小（单位为B） cgiFormFileRead：读取上传文件 cgiFormFileClose：关闭上传的文件 判断有没有上传文件1if(cgiFormFileName(\"file1\",uploadfilename,sizeof(uploadfilename))!=cgiFormSuccess) 获取扩展名1234_splitpath(uploadfilename,NULL,NULL,NULL,fileExt); // &lt;stdlib.h&gt;中 参数：全路径指针，盘符（带冒号），路径（纯目录无盘符，如 /aaa/），文件名（不包含后缀名），后缀名（带点） 文件格式：d:/aaa/bbb.jpgif(stricmp(fileExt,\".jpg\")!=0&amp;&amp;stricmp(fileExt,\".png\"))…… // stricmp 为不区分大小写的比较 获取文件大小12cgiFormFileSize(\"file1\",&amp;filesize);if(filesize&gt;1024*1024)…… // 1024 * 1024 = 1 M 总的操作12345678910111213cgiFilePtr file1; // 声明类似文件指针的变量，网络文件指针//读取本地文件，用于写入，本地文件指针FILE *fileLocal = fopen(uploadfilename,\"wb\"); // C语言读取文件，wb是二进制模式，默认是用文本char buffer[1024]; // 每次最多1024kbint lenRead; // 实际读的字节数cgiFormFileOpen(\"file1\",&amp;file1);while(cgiFormFileRead(file1,buffer,sizeof(buffer),&amp;lenRead)==cgiFormSuccess){ fwrite(buffer,lenRead,1,fileLocal); // buffer[] 的前 lenRead 字节写入到 fileLocal 中}fclose(fileLocal);cgiFormFileClose(file1);printFileUploadMsg(\"上传成功\"); 如鹏网《C语言也能干大事》学习笔记 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C语言","slug":"C语言","permalink":"http://blog.iwxyi.com/tags/C语言/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.iwxyi.com/tags/学习笔记/"},{"name":"CGI","slug":"CGI","permalink":"http://blog.iwxyi.com/tags/CGI/"}]}]